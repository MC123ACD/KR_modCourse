<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[王国保卫战修改教程]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://github.io/</link><image><url>.\https:\\github.io\lib\media\favicon.png</url><title>王国保卫战修改教程</title><link>https://github.io/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 29 Jul 2025 01:26:54 GMT</lastBuildDate><atom:link href=".\https:\\github.io\lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 29 Jul 2025 01:26:41 GMT</pubDate><copyright><![CDATA[138]]></copyright><ttl>60</ttl><dc:creator>138</dc:creator><item><title><![CDATA[(一) 修改英雄的等级属性]]></title><description><![CDATA[ 
 <br><br><br><br>首先使用搜索功能在 kr/game_templates 任意找到一个英雄模板<br>模板定义见 <a data-href="1.1 实体#模板" href=".\https:\\github.io\第-1-章、基础\1.1-实体.html#模板" class="internal-link" target="_self" rel="noopener nofollow">1.1 实体 &gt; 模板</a><br>
模板名见 <a data-href="详细数据#壹、模板" href=".\https:\\github.io\详细数据.html#壹、模板" class="internal-link" target="_self" rel="noopener nofollow">详细数据 &gt; 壹、模板</a><br><br>如图以小公主为例：<br>
<img alt="Pasted image 20250626164940.png" src=".\https:\\github.io\lib\media\pasted-image-20250626164940.png" style="width: 800px; max-width: 100%;"><br>可以看到有很多 tt...，tt 指的是对应英雄，然后第一个键指来源于哪个组件，例如 tt.hero.hp_max 指对应英雄的 hero 组件的最大血量<br>我们先看 level_stats 等级属性，就是英雄升到对应等级时变化的属性<br>如图（已折叠）：<br>
<img alt="Pasted image 20250626190509.png" src=".\https:\\github.io\lib\media\pasted-image-20250626190509.png" style="width: 450px; max-width: 100%;"><br>
<br>第一行：armor 物理护甲
<br>第二行：hp_max 最大血量
<br>还有近战普攻、远程普攻的最大最小伤害等
<br><img alt="Pasted image 20250626191037.png" src=".\https:\\github.io\lib\media\pasted-image-20250626191037.png" style="width: 352px; max-width: 100%;"><br>
如图假如我们要修改的是最大血量<br>
<br>展开我们发现有 10 行数字，其实这是行数对应等级的血量<br>
例如：修改第十行为 233，那么英雄 10 级时血量为 233 点<br>
其他等级属性同理
<br><br>我们将第十行血量修改为 666，然后运行游戏（确保已配置环境）<br>
<img alt="Pasted image 20250626192149.png" src=".\https:\\github.io\lib\media\pasted-image-20250626192149.png" style="width: 377px; max-width: 100%;"><br>
<img alt="Pasted image 20250626191819.png" src=".\https:\\github.io\lib\media\pasted-image-20250626191819.png" style="width: 541px; max-width: 100%;"><br>
如图血量变为 666 成功<br>
<br>若未成功可以检查一下英雄等级是否到 10 级，当然也可以修改其他行只要英雄到达这个等级
<br>还要检查出战的英雄是不是你改的英雄
<br><br>五代的键值是这样的：<br>
<img alt="Pasted image 20250630133711.png" src=".\https:\\github.io\lib\media\pasted-image-20250630133711.png" style="width: 625px; max-width: 100%;"><br>通过查看模板的定义知道：等级属性的存储位置在 balance<br>
<img alt="Pasted image 20250630134949.png" src=".\https:\\github.io\lib\media\pasted-image-20250630134949.png" style="width: 245px; max-width: 100%;"><br>
如图在 balance 搜索要改的英雄，同样可以找到等级属性，修改 hp_max 即可<br><br>
<br>Q：程序是如何知道我们在修改哪个英雄？换句话说 tt 指的是什么
<br>A：因为 E:register_t 函数会返回创建的模板的引用，也就是说此时 tt 就是 E.entities.hero_alleria<br>
除非重新给 tt 赋值（比如创建另一个英雄模板，然后 tt 就直接指向新模板了，也就是说此后修改的血量等都是修改新模板的）
<br>E:register_t 函数见 <a data-href="1.1 实体#1 创建模板" href=".\https:\\github.io\第-1-章、基础\1.1-实体.html#1_创建模板" class="internal-link" target="_self" rel="noopener nofollow">1.1 实体 &gt; 1 创建模板</a><br><br>下面来看 skills 技能的等级属性，就是技能到达对应等级的属性（夹杂一些基础属性，这里值的是非基础属性）<br>
<img alt="Pasted image 20250627155614.png" src=".\https:\\github.io\lib\media\pasted-image-20250627155614.png" style="width: 525px; max-width: 100%;"><br>
如图以艾莉丹为例，我们发现有很多技能<br>
<br>可以通过查资料来找要改的技能的名称，见 <a data-href="详细数据" href=".\https:\\github.io\详细数据.html" class="internal-link" target="_self" rel="noopener nofollow">详细数据</a>
<br>技能的属性键自行翻译，不进行赘叙<br>
<img alt="Pasted image 20250627185432.png" src=".\https:\\github.io\lib\media\pasted-image-20250627185432.png" style="width: 500px; max-width: 100%;"><br>
如图假设我们要修改艾莉丹的四技能；双刀跳斩的伤害
<br>查资料（代码名称大全）我们发现四技能的名称是 double_strike<br>五代还是一样在 balance<br>
<br>3 行数字意义同上<br>
例如：修改第三行最大伤害为 233 则双刀跳斩三级时最大伤害为 233 点
<br>修改后同上运行游戏测试就行，不再赘叙<br><br>
<br>Q：如果我想修改冷却时间等不会随等级变化的属性，这里怎么没有
<br>A：因为这里只有随等级变化的属性，想修改请往下看
<br>Q：有些英雄的技能的等级属性找不到怎么办
<br>A：有些技能直接用的乘数，也就是每次到达对应等级，技能的属性会 = 技能等级 × 这个乘数<br>
可以重点找找带 inc 的属性
<br>下面还有一些移动速度，拦截范围什么的属性感兴趣的可以自己改下<br>tt.melee.range 拦截范围，tt.motion.max_speed 移动速度<br><br><br>然后继续往下，有一些近战攻击（melee）与远程攻击（ranged）的组件<br><br>首先需要先明白一些组件的用途<br><br>近战攻击与远程攻击统称为攻击，防御塔攻击不包含在内<br>拦截可以进行的远程攻击称为特殊远程攻击<br><br><img alt="Pasted image 20250630143223.png" src=".\https:\\github.io\lib\media\pasted-image-20250630143223.png" style="width: 500px; max-width: 100%;"><br>
如图，一般第一个近战与远程攻击（attacks[1]）为普通攻击，其他都是相同行为的技能<br>会随等级变化的属性在之前的等级属性(1)(2)那里，这里都是不会随等级变化的属性<br><br>
<br>Q：怎么知道我修改的是哪个攻击
<br>A：可以查资料找这个攻击的键对应哪个攻击<br>
ps：有的攻击可能会占有多个攻击，可以通过 table.deepclone 复制的攻击来分辨<br>
用于播放不同动画，与增加额外效果
<br><br>本质：远程攻击本质是召唤子弹，让子弹造成伤害<br>
所以修改远程攻击只能修改远程攻击召唤的速度（攻击速度）、召唤范围（攻击范围）等<br>所以远程攻击的伤害和伤害类型等都是写在子弹上的，可以通过搜索子弹键（bullet）的键值对应的模板来找到子弹的一些键<br>
<img alt="Pasted image 20250630184001.png" src=".\https:\\github.io\lib\media\pasted-image-20250630184001.png" style="width: 850px; max-width: 100%;"><br>
<img alt="Pasted image 20250630184104.png" src=".\https:\\github.io\lib\media\pasted-image-20250630184104.png" style="width: 725px; max-width: 100%;"><br>
<br>有些子弹的伤害可能是 nil 甚至没有
<br>没有基本就是用默认值了，还是用上面的搜索方法（搜索 E:clone_c 的 bullet_attack）
<br>nil 则是伤害大概率写在技能等级属性上了，找到直接改技能等级属性
<br>其他键同理
<br>ps：bullet 组件来自 E:register_t 的底模板，没有 E:add_comps 不知道组件怎么加上的就可以看看 E:register_t 的底模板<br>修改就不赘叙了，和上面一样修改键值<br><br>修改方法不进行赘叙<br><br>找不到想修改的属性的位置，可以通过查看技能的实现方法来找到属性的位置<br>示例：E:clone_c("spawn_attack") 召唤实体，实现方法就是召唤实体，和远程攻击的子弹一样；搜索 entity 键的键值的模板来找到想修改的属性<br>tt.timed_attacks.list[1] = E:clone_c("spawn_attack")
--小公主技能 1
tt.timed_attacks.list[1].entity = "soldier_alleria_wildcat"	--搜索 soldier_alleria_wildcat 模板，可以找到野猫的属性
<br>还有光环、效果、子弹都是搜索对应键的键值的模板来找到想修改的属性<br>注意：这些模板内可能会多次套娃套其他的模板，只要记住重点找效果、光环、子弹、实体这些就行<br><br><br>我们在攻击键可能找不到伤害类型，那伤害类型是哪来的？我们可以搜索 E:add_comps 的 melee 组件看看有没有默认值<br>在 components 搜索 melee 组件<br><img alt="Pasted image 20250630155536.png" src=".\https:\\github.io\lib\media\pasted-image-20250630155536.png" style="width: 775px; max-width: 100%;"><br>
如图发现没有伤害类型，继续往下在 E:clone_c 发现攻击 1 来自 melee_attack，继续搜索 melee_attack<br>
<img alt="Pasted image 20250630160301.png" src=".\https:\\github.io\lib\media\pasted-image-20250630160301.png" style="width: 825px; max-width: 100%;"><br>
如图我们发现近战攻击是有伤害类型的，默认是物伤，也就是说英雄的近战攻击如果不填伤害类型，那么伤害类型就是物伤<br><br>由此可以这样改：<br>--英雄模板内
tt.melee.attacks[1].damage_type = DAMAGE_TRUE	--手动加上伤害类型键，然后键值写伤害类型就行
<br>伤害类型见 <a data-href="详细数据#一、伤害类型" href=".\https:\\github.io\详细数据.html#一、伤害类型" class="internal-link" target="_self" rel="noopener nofollow">详细数据 &gt; 一、伤害类型</a><br>
<br>其他比如魔抗等同理，可以通过以上方法改（看看有没有默认值）
<br>重点搜索 E:register_t / E:add_comps / E:clone_c 的组件或模板
<br><br>主要目的：让单位攻击造成减速效果、中毒、燃烧等<br><br>**近战攻击直接在后面增加 mod 键，键值为效果模板名<br>远程攻击增加到子弹的模板的 bullet 键上，个别远程攻击无效<br>技能能不能增加，增加到哪里取决于函数，后面修改函数再解释<br>示例：<br>--英雄模板内
tt.melee.attacks[1].mod = "mod_lava"	--普通近战攻击造成燃烧效果，此燃烧来自模板可自行搜索

--子弹模板内
tt.bullet.mod = "mod_lava"	--子弹造成燃烧效果
<br><br>
<br>注意：五代所有新加的键必须写在 game_templates 内，写在 balance 是不会生效的<br>
不嫌麻烦可以让新键的键值也读取 balance，才能生效
<br>示例（让维斯珀普通近战攻击造成燃烧效果）：<br>--balance 模块内
hero_spider = {
	basic_melee = {	--普通近战攻击
		mod = "mod_lava",	--效果
		...	--其他键值对，攻击速度等
	}
}

--game_templates 模块内
b = balance.heroes.hero_spider
tt.melee.attacks[1].mod = b.basic_melee.mod	--读取 balance 内的表
<br>不推荐这种方法，如果你不想改 game_templates 也不行，因为后面基本都要改，一些东西也不在 balance 内<br><br>
<br>Q：为什么攻击可以直接增加效果，而技能不行
<br>A：因为近战攻击与远程攻击用的对应函数都有造成效果，而技能是单独的逻辑不一定有
<br>Q：如何造成多个效果
<br>A：只有光环和远程攻击可以造成多个效果，并且方法还不一样（铁皮逆天代码发力了）后面函数篇再讲怎么让近战攻击等造成多个效果<br>
具体方法：
<br>--子弹
tt.bullet.mod = {	--注意是 mod，不是 mods
	效果 1,
	效果 2
	...
}

--光环
tt.aura.mods = {	--注意是 mods，不是 mod，找不到光环可以先不管，知道怎么加就行
	效果 1,
	效果 2
	...
}
<br><br>手动创建一个效果模板，以原效果为底表，然后修改键，增加这个效果即可<br>注意：不建议直接修改基础效果（例如 all/templates 内的），因为其他实体可能也在使用这个效果，如果修改则会影响其他实体<br>
想直接修改效果必须保证这个效果没有其他实体使用或作为底模板使用<br>
<br>一般英雄特有的效果基本可以随便改，不要死脑筋都创建一个新效果
<br>示例：<br>--模板
--原tt.melee.attacks[1].mod = "mod_lava"
tt.melee.attacks[1].mod = "mod_lava_2"	--仅存储模板名，所以创建与增加 mod 无先后顺序

--子弹
--原tt.bullet.mod = "mod_lava"
tt.bullet.mod = "mod_lava_2"

lava_2 = E:register_t("mod_lava_2", "mod_lava")	--创建 mod_lava_2 模板以 mod_lava 为底模板
--接收返回值的变量不建议使用 tt，因为会修改 tt 的引用，导致之后增加的键增加到效果里，与预期的位置不符导致错误

lava_2.dps.damage_inc = 6	--inc 倍数，也就是伤害倍数 6 倍（原燃烧伤害倍数 3）
lava_2.dps.damage_every = 0.1	--伤害间隔，每 0.1 秒造成一次伤害
<br>自行搜索 mod_lava 模板查看有哪些键<br><br>主要目的：实现两个不同效果不可共存<br>效果模板使用 modifier.bans 键，键值为效果表，即可让两个不相同效果单向不可叠加<br>
注意这里是单向，双向需要互相增加对方效果<br>
即 A ban B，有 A 不能有 B，有 B 可以有 A。AB 互相 ban，有 A 不能有 B，有 B 不能有 A<br>modifier.ban_types 键则是抵消一个效果类型（类似于 flag 标签，后面会讲）<br>
例如：mod_freeze 冻结效果就是典型 MOD_TYPE_FREEZE 类型，mod_elora_bolt_freeze 冰女的冻结也是这个类型<br>效果类型见 <a data-href="详细数据#三、效果类型" href=".\https:\\github.io\详细数据.html#三、效果类型" class="internal-link" target="_self" rel="noopener nofollow">详细数据 &gt; 三、效果类型</a><br><br>--燃烧效果模板内
tt.modifier.bans = {
	"mod_freeze",	--指定具体效果，如果目标上有燃烧效果，目标将不会被冻结
	...	--可指定多个
}
tt.modifier.ban_types = {	--可选
	MOD_TYPE_FREEZE,	--指定一个效果类型，如果目标上有燃烧效果，目标将不会被冻结类型的所有效果冻结
	...
}
<br><br>主要目的：实现类似于两个效果之间元素的克制关系，让两个效果互斥，例如冻结与燃烧，如果目标上有冻结，此时给目标造成燃烧效果，主动移除冻结效果<br>在之前的基础上给效果模板增加 modifier.remove_banned 键，键值为 true，即可<br>注意：<br>
<br>
还是单向，双向方法同上

<br>
与上面的不可共存共用同一个键，并且是复合含义所以易混淆<br>
需要明确含义：一个是被动无法与对应效果共存 A ← B，一个是主动移除对应效果 A → B

<br>
被动优先级高于主动，如果对方效果被动与当前效果无法共存，当前效果主动移除对方效果，因为被动优先级高所以当前效果将不会被造成

<br><br>--燃烧效果模板内
tt.modifier.remove_banned = true
tt.modifier.bans = {
	"mod_freeze",	--指定具体效果，如果目标上有冻结效果，主动移除冻结效果，并且被动无法与冻结共存
	...
} 
tt.modifier.ban_types = {	--可选
	MOD_TYPE_FREEZE,	--指定一个效果类型，如果目标上有冻结类型的效果，主动移除冻结类型的效果，并且被动无法与冻结共存
	...
}
<br><br>相同效果就是模板名称相同的效果，效果等级就是 modifier.level 键<br>给效果模板加上 modifier.allows_duplicates 键，键值为 true，即可允许叠加多个相同等级的相同效果<br>modifier.replaces_lower 键为替换不相同等级的相同效果<br>
modifier.resets_same 键为重置相同等级的相同效果的持续时间<br>注意等级问题<br><br><br>使攻击 E:clone_c("aura_attack")，然后加上伤害范围等即可<br>示例：<br>tt.melee.attacks[1] = E:clone_c("area_attack")
tt.melee.attacks[1].damage_radius = 25	--伤害范围 25 码，必须要加否则不会生效
tt.melee.attacks[1].count = 3	--最多对三名敌人造成伤害，可选
tt.melee.attacks[1].min_count = 2	--需要两名敌人才能进行这个攻击，可选
<br><br>只要给攻击加上 loops 键并在键值设置次数，设置播放的动画，即可实现每次攻击时攻击多次<br>
hit_times 或 shoot_times 则是一次攻击的次数<br>注意：loops 键的键值必须要有值， hit_times 和 shoot_times 才会生效<br>
<br>可以理解成乘算：攻击次数 = loops × hit_times/shoot_times
<br><br>tt.melee/ranged.attacks[1].animations = {
	nil,
	"attack/shoot",	--近战攻击填 "attack"，远程攻击填 "shoot"，借用普通攻击动画
	nil
}
<br><br>根据数字决定攻击次数<br>示例：<br>tt.melee.attaks[1].loops = 2	--攻击 2 次
<br><br>根据表的键数决定近战攻击一次攻击的次数<br>示例：<br>tt.melee.attacks[1].animations = {
	nil,
	"attack",	--近战攻击填 "attack"
	nil
}
tt.melee.attaks[1].loops = 1	--不想每次攻击多次填 1 就行
tt.melee.attaks[1].hit_times = {n, fts(1)}	--一次攻击 2 次，n 为秒，1 fts = 1 ÷ 30
<br><br>根据表的键数决定远程攻击一次攻击的次数<br>示例：<br>tt.ranged.attacks[1].animations = {
	nil,
	"shoot",	--远程攻击填 "shoot"
	nil
}
tt.ranged.attaks[1].loops = 1
tt.ranged.attaks[1].shoot_times = {n, fts(1)}	--一次性攻击 2 次
<br><br>只需要给实体增加闪避组件即可<br>示例：<br>E:add_comps(tt, "dodge", ...)	--增加闪避组件
tt.dodge.chance = 0.25	--闪避概率 25 %
tt.dodge.silent = true	--true 表示无动画
<br>挖坑：动画、条件闪避、闪避造成伤害<br><br>主要目的：对特定目标不释放某个攻击，或释放技能<br>当然也可以通过 flags 标签来实现对特定单位、攻击以及技能的特定行为<br>攻击的标签与过滤标签写在 vis_flags 和 vis_bans 键上，而单位则是 vis 键的 flags 和 bans 键上<br><br>简单来说就是每次索敌时与攻击时通过按位与运算<br>
首先判断攻击标签 vis_flags 有没有被目标 vis.bans 过滤，然后再判断目标标签 vis.flags 有没有被攻击 vis_bans 过滤<br>
即：攻击过滤 → 目标标签，目标过滤 → 攻击标签<br>
如果任意一方被过滤，则不选择这个目标<br>参考 SU.soldier_pick_melee_attack 代码片段：<br>
band(a.vis_flags, t.vis.bans) == 0 and band(a.vis_bans, t.vis.flags) == 0<br>可以通过位运算来增加多个标签，位运算见 <a data-href="1.3 常量#位运算" href=".\https:\\github.io\第-1-章、基础\1.3-常量.html#位运算" class="internal-link" target="_self" rel="noopener nofollow">1.3 常量 &gt; 位运算</a><br>
所有标签见 <a data-href="详细数据#二、标签" href=".\https:\\github.io\详细数据.html#二、标签" class="internal-link" target="_self" rel="noopener nofollow">详细数据 &gt; 二、标签</a><br><br>--某个英雄模板
tt.vis.bans = F_RANGED	--不会被远程攻击

tt.ranged.attacks[1].vis_bans = bor(F_BOSS, F_FLYING)	--远程攻击不攻击 boss 与飞行敌人
tt.ranged.attacks[1].vis_flags = F_RANGED	--远程攻击标签

--某个敌人模板
tt.vis.bans = F_DRILL	--不会被钻头攻击，就是二代的地震的钻头
<br>
<br>支持在效果、光环上增加
<br>可以自己在 constants 写个标签
<br>参考资料：<br><a class="auto-card-link-card" href="https://tieba.baidu.com/p/9839262014"><div class="auto-card-link-main"><div class="auto-card-link-title"></div><div class="auto-card-link-description"></div><div class="auto-card-link-host"></div></div></a>标签与技能的释放机制 by发的gtr让他发 -百度贴吧技能的释放与否由双方的 bans 和 flags 决定，两者的具体含义为：flags：标签我方bans：不会对有XX标签的敌人释放敌方bans：有XX标签的技能不会对它释放，即具有XX抗性。判定机制为：【只要有一方的 bans 与对方的 flags 配对，该技能就不会释放】，以下截取代码片段来分析几个具体例子（以秒杀技为例）。]]></description><link>.\https:\\github.io\第-1-章、基础\1.-修改教程\1-模板.html</link><guid isPermaLink="false">第 1 章、基础/1. 修改教程/1 模板.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Sun, 27 Jul 2025 10:03:49 GMT</pubDate><enclosure url=".\https:\\github.io\lib\media\pasted-image-20250626164940.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=".\https:\\github.io\lib\media\pasted-image-20250626164940.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(一) 修改主插入函数]]></title><description><![CDATA[ 
 <br><br>主插入函数就是创建实体后会调用一遍的函数，见 <a data-href="1.4 函数#(4) 实体正式创建" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#(4)_实体正式创建" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; (4) 实体正式创建</a><br>有些技能就是通过主插入函数来实现的；<br>
典型代表就是二代女巫的 1 伤害的光环，原理就是调用主插入函数 → 判断技能等级 → 创建光环<br><br>直接搜索对应英雄的模板，在 kr/game_scripts 就可以找到函数了（如图为艾莉丹）<br>
<img alt="Pasted image 20250701213229.png" src=".\https:\\github.io\lib\media\pasted-image-20250701213229.png" style="width: 825px; max-width: 100%;"><br>
ps：VS Code 可以直接跳转到对应函数的定义，可以不用搜索，直接在对应英雄模板右键插入函数转到定义即可<br>
<img alt="Pasted image 20250705190320.png" src=".\https:\\github.io\lib\media\pasted-image-20250705190320.png" style="width: 725px; max-width: 100%;"><br>function scripts.hero_elves_archer.insert(this, store)
--this 表示调用插入主函数的完全独立的实体，store 就是存储实体的表
	...	--其他可以先不用管
	
	local d = E:create_entity("damage")	--造成伤害
	d.value = 233666	--伤害
	d.target_id = this.id	--目标的 id 设置为当前英雄 id
	queue_damage(store, d)	--插入伤害队列
	
    return true
end
<br>使用修改的英雄进入关卡，发现英雄直接死亡了，不用之意这个，重点知道怎么造成伤害就行<br>
<img alt="Pasted image 20250716185606.png" src=".\https:\\github.io\lib\media\pasted-image-20250716185606.png" style="width: 194px; max-width: 100%;"><br>造成效果同理，只不过要插入实体队列，而不是伤害队列<br>local mod = E:create_entity(效果模板名)	--造成效果
mod.modifier.target_id = this.id	--目标
queue_insert(store, mod)	--插入实体队列
<br><br>
<br>Q：怎么修改伤害类型
<br>A：增加 d.damage_type = 伤害类型 即可
<br>Q：怎么对敌人造成伤害
<br>A：这个更新主函数再说，需要索敌
<br><br><br>以给沙王增加死亡骑士光环为例<br>function scripts.hero_alric.insert(this, store, script)
--hero_alric 为沙王模板名，this 就是通过模板创建的沙王实体
	... --其他先不用管，就看下面这几行
	if this.hero.skills.toughness.level &gt; 0 then	--若坚韧技能等级大于 0，可选
		local e = E:create_entity("death_rider_aura")	--创建死亡骑士光环
		e.aura.source_id = this.id	--来源设置为沙王

		queue_insert(store, e)	--创建光环 e，也就是死亡骑士光环
	end
	--表示若沙王坚韧技能等级大于 0 则给沙王创建死亡骑士光环

	return true	--注意：不要写到返回值后面了
end
<br>E:create_entity 与 queue_insert 作用见 <a data-href="1.4 函数#二、实体创建流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#二、实体创建流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 二、实体创建流程</a><br>注意：this 指的不是模板，而是通过模板创建出来的完全独立的实体<br>然后我们发现光环会显示在脸上，而不是脚下，这是因为默认光环显示位置有偏移<br>我们只需要移除偏移就行了，修改光环的方法同修改效果<br><br>--game_templates 模块内
--创建新模板，底表为原死亡骑士光环，变量为缩写，用于区分模板
araa = E:register_t("death_rider_aura_alric", "death_rider_aura")

araa.aura.use_mod_offset = nil	--移除偏移
...	--其他属性同理，比如作用范围，护甲或伤害加成等

--插入主函数内
local e = E:create_entity("death_rider_aura_alric")	--修改创建的实体表为新模板即可
<br><br>注意：修改函数还是同修改效果，如果一个函数有多个效果在用，修改函数需要复制这个函数，然后重新命名，然后让对应效果使用这个函数，最后再修改复制出来的函数<br>
示例：<br>--某个效果模板
--原 tt.main_script.insert = scripts.mod_dps.insert
tt.main_script.insert = scripts.mod_dps_2.insert

--修改函数
scripts.mod_dps_2 = {}	--需要注意，避免索引问题
function scripts.mod_dps_2.insert()
	... --mod_dps 主插入函数的代码，修改即可
end
<br><br>删除主插入函数的排序函数，直接在模板手动写优先级即可（写攻击的序号，例如攻击 1 就是 1）<br>攻击流程见 <a data-href="1.4 函数#攻击流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#攻击流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 攻击流程</a><br><br>以雷格森为例<br>--game_templates 模块内
tt.melee/ranged.order = {	--自行选择远程攻击或近战攻击
	2,	--优先释放攻击 2
	1,	--之后释放攻击 1
	...	--注意：必须填写所有的攻击，没填写的将不会被释放
}
<br>在 game_scripts 找到对应的实体插入主函数<br>删除下划线的代码即可，远程攻击则删除 ranged.order<br>
<img alt="Pasted image 20250701134555.png" src=".\https:\\github.io\lib\media\pasted-image-20250701134555.png" style="width: 575px; max-width: 100%;"><br>注意：仅能修改攻击，技能请在更新主函数修改代码顺序<br><br><br><br>还是以艾莉丹的四技能，双刀跳斩为例<br>tt.hero.skills.double_strike = E:clone_c("hero_skill")
tt.hero.skills.double_strike.cooldown = {	--假设要让双刀跳斩的冷却时间随等级变化（原版 12 秒）
	12,	--一级 12 秒
	10,	--二级 10 秒
	8	--三级 8 秒
}
<br><br>搜索方法同插入主函数<br>
<img alt="Pasted image 20250705182915.png" src=".\https:\\github.io\lib\media\pasted-image-20250705182915.png" style="width: 600px; max-width: 100%;"><br>
这里就是每次升级时都会调用的函数，所有等级属性会在这里转化为具体属性<br>你可能已经注意到了插入主函数会调用一次这个函数 （this.hero.fn_level_up(this, store, true)）<br>
这是因为升级函数只有升级时才会调用，所以需要在插入时调用一次进行初始化来保证等级属性正常转化<br>找到双刀跳斩对应的转化代码块，后面加上 a.cooldown = s.cooldown[s.level]：<br>
<img alt="Pasted image 20250705184937.png" src=".\https:\\github.io\lib\media\pasted-image-20250705184937.png" style="width: 450px; max-width: 100%;"><br>
没错最后还是赋值到攻击的冷却时间上了，s.level 就是技能等级<br><br>调用流程见 <a data-href="1.4 函数#三、调用更新函数流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#三、调用更新函数流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 三、调用更新函数流程</a><br>更新主函数与插入主函数寻找方法相同。光环、效果、召唤物这些也是有更新主函数的<br><br><br>计算时间常用到 store.tick_ts 与 ts（时间戳）<br>示例：<br>a = this.timed_attacks.list[1]	--某个技能

if store.tick_ts - a.ts &gt; a.cooldown then
	a.ts = store.tick_ts	--表示已释放技能，刷新 a 的时间戳
	-- 造成伤害等逻辑
...
<br>表示如果当前时间与上次释放技能 a 的时间戳 之差大于冷却时间，则执行条件代码块<br>
换句话说就是上次释放技能过去的时间大于冷却时间<br>持续时间等同理<br>注意：通常时间运算都在 while true 死循环内<br><br>targets = U.find_enemies_in_range，U.find_xxx 这种都是索敌<br>使用方法详细见 <a data-href="详细数据#一、索敌" href=".\https:\\github.io\详细数据.html#一、索敌" class="internal-link" target="_self" rel="noopener nofollow">详细数据 &gt; 一、索敌</a><br><br>SU.y_soldier_melee_block_and_attacks(store, this) 近战攻击函数<br>y_soldier_ranged_attacks 远程攻击函数<br>无目标返回 A_NO_TARGET<br>
无可用攻击返回 A_IN_COOLDOWN 攻击完毕 A_DONE`<br>可以通过返回值判断攻击的状态，来执行某些代码块<br>SU.y_soldier_ranged_attacks(store, this) 远程攻击函数<br>详细见 <a data-href="1.4 函数#攻击流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#攻击流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 攻击流程</a><br><br>coroutine.yield() 循环末尾必须挂起协程，否则会卡死程序<br><br>流程见 <a data-href="1.4 函数#五、造成伤害流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#五、造成伤害流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 五、造成伤害流程</a>  <a data-href="1.4 函数#六、造成效果流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#六、造成效果流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 六、造成效果流程</a>  <a data-href="1.4 函数#二、实体创建流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#二、实体创建流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 二、实体创建流程</a><br>通过查看流程我们知道：造成伤害、效果，以及召唤实体用的都是 E:create_entity 函数<br>然后再加上具体目标，以及所有者的 id，具体属性等<br>最后插入队列即可<br><br>有些技能是支持造成效果的，但是有些则不能，我们可以通过以下方法来做到造成效果：<br>找到技能造成伤害的代码块，在后面加上造成效果就行<br><br>以给火男烈焰冲击增加燃烧效果为例（需要注意一下变量不要用错）<br>--更新主函数内
a = this.timed_attacks.list[1]	--看到这个就说明下面是对应技能的释放函数了
skill = this.hero.skills.flaming_frenzy

if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts &gt;= a.cooldown then	--冷却时间的计算
...
	targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags,
	a.vis_bans)	--索敌

	if targets then	--如果找到敌人
		for _, t in pairs(targets) do	--因为是范围伤害所以要遍历找到的所有敌人，单体没有遍历这一步
			local d = E:create_entity("damage")	--造成伤害
			d.damage_type = a.damage_type	--伤害类型
			d.source_id = this.id	--所有者 id
			d.target_id = t.id	--目标 id
			d.value = math.random(a.damage_min, a.damage_max)	--具体伤害

			queue_damage(store, d)	--插入伤害队列

			--后面写上造成效果
			if a.mod then	--避免没有 mod 导致的一些问题
				local mod = E:create_entity(a.mod)	--也就是 this.timed_attacks.list[1].mod
				mod.modifier.target_id = t.id	--目标 id，再次注意：变量不要用错，是一个目标，而不是多个目标
				--因为索敌是找范围内的所有敌人所以是遍历出来的单体 t，如果索敌找的是单体敌人，则直接用索敌找到的敌人 					target 这些
				mod.modifier.source_id = this.id	--可选，有些效果需要来源，推荐加上
				...	--后面一些可以按需求加

				queue_insert(store, mod)	--插入实体队列
			end
		end
	end
...

--英雄模板内
tt.timed_attacks.list[1].mod = "mod_lava_ignus"	--造成这个效果

local mod_lava = E:register_t("mod_lava_ignus", "mod_lava")
mod_lava.dps.damage_inc = 2	--修改伤害
<br>通过上面的教程，个别子弹的效果无效也可以加上造成效果的代码块来解决，方法就不赘叙了，还是顺着 E:register_t 和 E:add_comps 找更新主函数就行<br><br>只需要在模板增加一个效果表（mods），然后在更新主函数遍历这个表然后造成效果就行了<br><br>还是以给火男烈焰冲击增加燃烧效果为例（需要注意一下变量不要用错）<br>--更新主函数内
a = this.timed_attacks.list[1]
skill = this.hero.skills.flaming_frenzy

if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts &gt;= a.cooldown then
...
	targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags,
	a.vis_bans)

	if targets then
		for _, t in pairs(targets) do
			local d = E:create_entity("damage")
			d.damage_type = a.damage_type
			d.source_id = this.id
			d.target_id = t.id
			d.value = math.random(a.damage_min, a.damage_max)
			
			queue_damage(store, d)
		
			--修改造成效果的代码块
			if a.mod or a.mods then	--避免没有 mod 导致的一些问题
				local mods = a.mods or {	--没有 mods 则创建一个包含 mod 的表，然后赋值
					a.mod
				}
				for _, mod_name in pairs(mods) do	--遍历效果表
					local new_mod = E:create_entity(mod_name)	
					new_mod.modifier.target_id = t.id
					new_mod.modifier.source_id = this.id

					queue_insert(store, new_mod)
					--每个效果都遍历出来给个目标，然后插入实体队列
				end
			end
		end
	end
...

--英雄模板内
tt.timed_attacks.list[1].mods = {
	效果 1,	--因为 mod 会被覆盖，所以需要注意一下如果原本就有效果，需要加上之前的效果，否则技能将不会造成之前的效果
	效果 2
	...
}

<br><br>所有索敌函数见 <a data-href="详细数据#一、索敌" href=".\https:\\github.io\详细数据.html#一、索敌" class="internal-link" target="_self" rel="noopener nofollow">详细数据 &gt; 一、索敌</a><br><br><br>target = find_foremost_enemy(..., function(v，origin)	--其他传递的参数省略，v 会传递实体表，origin 会传递圆心
	...	--函数体
	return v.health.hp &gt;= 1000	--寻找血量大于等于 1000 的敌人
end, ...)	
<br><br>函数见 <a data-href="详细数据#二、判断拥有效果" href=".\https:\\github.io\详细数据.html#二、判断拥有效果" class="internal-link" target="_self" rel="noopener nofollow">详细数据 &gt; 二、判断拥有效果</a><br><br>target = find_foremost_enemy(..., function(v，origin)
	...
	return v.health.hp &gt;= 1000 and U.has_modifiers(store, v, "mod_lava")
	--寻找血量大于等于 1000，并且处于燃烧效果的敌人
end, ...)	
<br><br>因为基本所有索敌都是从范围索敌改来的，由此我们可以通过范围索敌找到目标，然后排序血量最高的敌人即可<br><br>local targets = U.find_enemies_in_range(store.entities, hero.pos, 0, a.radius, a.vis_flags, a.vis_bans)
--索敌

if targets then
	table.sort(targets, function(e1, e2)	--排序函数
		return e1.health.hp &gt; e2.health.hp	--根据血量排序，最终血量最高的会排序在最前
	end)
	
	local target = targets[1]	--取第一个目标
	...	--后面造成伤害，造成效果，目标都传 target 目标即可
<br>大于号是降序排序（大在前），小于号是升序（小在前）<br>当然你也可以根据伤害、速度、护甲大小排序，表示选择伤害最高或最低、速度最快或最慢、护甲最高或最低的目标<br><br><br>主要目的：给实体释放某个近战攻击增加条件，满足条件才释放这个攻击<br>注意：仅支持实体的近战攻击，技能与远程不支持，防御塔的攻击也不支持<br>只需要给实体的模板的近战攻击增加 fn_can 键，键值为函数即可<br><br>以给一代死侍二技能灭魂斩增加血量释放条件为例<br>--死侍模板内
tt.melee.attacks[3].trigger_min_hp = 150	--释放条件：目标血量大于等于 150，键自己编一个就行，仅用于后续方便修改，你直接写到函数也是没问题的
tt.melee.attacks[3].fn_can = scripts.hero_oni.fn_can_death_strike	--函数名自己编一个

--game_scripts 模块内，最好和更新主函数，插入主函数写在一个地方
function scripts.hero_oni.update(this, store)
... end

function scripts.hero_oni.fn_can_death_strike(this, store, a, target)
	return target.health.hp &gt;= a.trigger_min_hp	--目标血量大于等于设定的血量时返回 true，表示可以释放
end
<br>
<br>fn_can 函数会传递调用这个函数的实体，以及 store、攻击、目标
<br>见 <a data-href="1.4 函数#攻击流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#攻击流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 攻击流程</a>
<br><br>只需要给实体模板的远程攻击增加 filter_fn 键，键值为函数即可<br>和索敌的过滤函数写法相同<br><br>--模板内
tt.ranged.attacks[2].trigger_min_hp = 150	
tt.ranged.attacks[2].filter_fn = scripts.xxx.filter_fn_xxx

--game_scripts 模块内，还是最好和更新主函数，插入主函数写在一个地方
function scripts.xxx.filter_fn_xxx(v, origin)
	return v.health.hp &gt; trigger_min_hp	-- 寻找低于阈值的敌人
end
<br>本质还是索敌的过滤函数，过滤某些条件的目标<br><br>主要目的：让实体释放近战攻击概率，根据不同条件动态变化，例如对处于流血效果的目标造成百分百概率秒杀<br>注意：还是仅支持实体的近战攻击，技能与远程不支持，防御塔的攻击也不支持<br>只需要给实体的模板的攻击增加 fn_chance 键，键值为函数即可<br><br>以给一代死侍二技能灭魂斩百分百秒杀处于流血状态为例<br>--死侍模板内
--死侍近战攻击 2 是灭魂斩的秒杀，3 则是不秒杀的真伤
tt.melee.attacks[2].instakill_mod_type = MOD_TYPE_BLEED	--效果：流血类型的效果，键自己编一个就行
tt.melee.attacks[2].fn_chance = scripts.hero_oni.fn_chance_death_strike	--函数名自己编一个

--game_scripts 模块内，最好和死侍更新主函数，插入主函数写在一个地方
function scripts.hero_oni.update(this, store)
... end

function scripts.hero_oni.fn_chance_death_strike(this, store, a, target)
	return U.has_modifier_types(store, target, a.instakill_mod) or math.random() &lt; attack.chance
	--目标拥有流血类型效果时返回 true，表示百分百概率，or 后面是原始计算概率逻辑
end
<br>效果类型见 <a data-href="详细数据#三、效果类型" href=".\https:\\github.io\详细数据.html#三、效果类型" class="internal-link" target="_self" rel="noopener nofollow">详细数据 &gt; 三、效果类型</a><br><br>
<br>Q：为什么 fn_chance 函数后面要加原始计算概率逻辑
<br>A：这是因为计算概率时会判断攻击有没有 fn_chance 函数，有则用 fn_chance 函数，没有则用这个原始计算概率逻辑，两个不能同时存在，所以需要单独增加
<br><br>特殊远程攻击就是近战时进行的远程攻击<br>--某个可以远程攻击单位的更新主函数内
...
if this.unit.is_stunned then	--处于眩晕状态原地待机
	SU.soldier_idle(store, this)
else
	brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)	--调用近战攻击函数
	--brk 就是跳出 break 缩写，sta 就是状态 status
	
	if brk or sta ~= A_NO_TARGET then	--近战攻击跳出，或近战攻击有目标，跳过远程攻击
		-- block empty
	else	--近战攻击未跳出，无目标
		brk, sta = SU.y_soldier_ranged_attacks(store, this)	--调用远程攻击函数
		if brk then	--远程攻击跳出，跳过
			-- block empty
		elseif SU.soldier_go_back_step(store, this) then	--正在返回集结点，跳过
			-- block empty
		else	--远程攻击成功，脱战
			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end
	end
end

::label_43_0::	--标志，用于代码之间的跳转
coroutine.yield()
<br>通过观察函数发现一般远程攻击和近战攻击一次只能触发一个，并且远程攻击优先级低于近战攻击，由此我们可以通过修改代码让远程和近战攻击同时都可以触发，来将远程攻击改为特殊远程攻击<br>将以上代码修改为以下即可：<br>...
if this.unit.is_stunned then
	SU.soldier_idle(store, this)
else
	if this.melee then
		brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

		if brk then	--近战攻击跳出
			goto 挂起协程	--直接跳到挂起协程部分
		end
	end

	if this.ranged then
		brk, sta = SU.y_soldier_ranged_attacks(store, this)

		if brk or sta == A_DONE then	--远程攻击跳出，或攻击完毕
			goto 挂起协程	--直接跳到挂起协程部分
		elseif sta == A_IN_COOLDOWN then	--远程攻击未跳出，并且在冷却
			goto 脱战	--直接跳到脱战部分
		end
	end

	if SU.soldier_go_back_step(store, this) then
		goto 挂起协程	--直接跳到挂起协程部分
	end

	::脱战::	--可以自己改个标志
	SU.soldier_idle(store, this)
	SU.soldier_regen(store, this)
end

::挂起协程::
coroutine.yield()
<br>注意跳转的标志位置<br><br><br>主要目的：概率造成效果、概率暴击等<br>在模板增加一个新攻击，复制要概率造成效果的攻击，增加效果和概率即可<br><br>tt.melee.attacks[3] = table.deepclone(tt.melee.attacks[1])	--如果你想让普通攻击概率造成效果，可以直接复制普通攻击
tt.melee.attacks[3].chance = 0.33	--概率
tt.melee.attacks[3].mod = xxx	--效果
<br>值得注意的是，原版一个攻击的多个不同动画也是这样实现的，所以有些攻击可能有两三个，看着是不同的攻击，实际就是相同的只不过动画不同<br>
可以通过这个攻击是复制谁的和之后修改的键来判断<br><br>tt.melee.attacks[2] = table.deepclone(tt.melee.attacks[1])
tt.melee.attacks[2].chance = 0.5
tt.melee.attacks[2].animation = "attack2"	
--近战攻击 2 就是近战攻击 1 的另一个动画
--如果此时想修改攻击 1，那么就需要增加两个攻击 3 和 4，并且要分别复制攻击 1 和 2
tt.melee.attacks[3] = table.deepclone(tt.melee.attacks[1])
...	--增加一些效果等
tt.melee.attacks[4] = table.deepclone(tt.melee.attacks[2])
...	--增加一些效果等
<br>需要重点关注攻击顺序对概率的影响，见 <a data-href="1.4 函数#攻击流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#攻击流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 攻击流程</a><br><br>只有英雄以及能升级有升级函数的单位（例如召唤物）需要修改，其他单位不需要<br>通过上面的修改升级函数，知道等级属性最后会赋值到对应攻击或技能的对应键上，也就是说直接复制攻击是得不到等级属性的属性的<br>
此时我们需要修改一下升级函数，让等级属性最后也会赋值到新攻击上，方法如下：<br>以莉恩为例，增加了攻击 4 与攻击 5，都是概率让普通近战攻击造成效果，然后运行发现攻击 4 与攻击 5 没有伤害<br>
<img alt="Pasted image 20250708092738.png" src=".\https:\\github.io\lib\media\pasted-image-20250708092738.png" style="width: 550px; max-width: 100%;"><br>
如图攻击 2 为普通近战攻击的另一个动画<br>赋值时给攻击 4 和 5 也赋值即可<br><br>
<br>Q：为什么可以通过增加另一个攻击来让一个攻击概率造成效果
<br>A：这是因为攻击顺序是概率低的优先，所以可行，具体见 <a data-href="1.4 函数#攻击流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#攻击流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 攻击流程</a><br>
本质还是增加了一个新攻击，看似原攻击概率造成效果，实则不然，只是使新攻击复制（深拷贝）原攻击，给这个攻击增加了效果而已，也就是说复制后两个攻击之间其实已经没有什么关联了
<br><br>主要目的：增加一个较为独立的技能<br><br>以给尼鲁增加一个技能：每 275 秒增加 1 生命（升级二技能翠绿迸发解锁）为例<br>--尼鲁英雄模板内
tt.hero.skills.heal_live = E:clone_c("hero_skill")	--复制英雄技能组件，防御塔与其他单位技能组件是 power
tt.hero.skills.heal_live.cooldown = {	--增加等级属性：冷却时间
	275,	--一级冷却时间 210 秒
	245,	--三级冷却时间 210 秒
	210		--三级冷却时间 210 秒
}

tt.timed_attacks.list[5] = E:clone_c("custom_attack")	--复制自定义技能组件，尼鲁只有四个技能所以序号是 5
tt.timed_attacks.list[5].animation = "fairy_dust"	--动画套用四技能衰弱咒语，当然也可以套用其他技能，注意：只能用当前实体有的动画，否则将会报错
tt.timed_attacks.list[5].sound = "HeroNyruFairyDustCast"	--音效，也是借用衰弱咒语
tt.timed_attacks.list[5].cooldown = nil		--默认冷却时间，因为等级属性已经有了所以不需要，其他属性键处理方法相同
tt.timed_attacks.list[5].disabled = true	--默认禁用	
tt.timed_attacks.list[5].heal_live = 1		--默认增加生命数量

--尼鲁升级函数
s = this.hero.skills.verdant_blast	--目前不能做到增加 UI，但是可以先借用其他技能，当然你也可以直接根据等级来实现
sl = s.level

if sl &gt; 0 and initial then
	...
	local a = this.timed_attacks.list[5]
	a.cooldown = this.hero.skills.heal_live.cooldown[sl]	--根据翠绿迸发技能等级决定冷却时间，对应等级属性
	a.disabled = nil	--解除禁用
end

--尼鲁更新主函数内
while true do
	...
	if h.dead then
		SU.y_hero_death_and_respawn(store, this)
	end
	if this.unit.is_stunned then
		SU.soldier_idle(store, this)
	else
		a = this.timed_attacks.list[5]
		skill = this.hero.skills.heal_live

		if not a.disabled and store.tick_ts - a.ts &gt; a.cooldown then	--计算冷却时间
			a.ts = store.tick_ts	--刷新时间戳
			U.animation_start(this, a.animation, nil, store.tick_ts)	--播放动画
			S:queue(a.sound)	--播放音效
			
			store.lives = store.lives + a.heal_live	--增加生命，ps：生命，金币都存在 store

			SU.y_hero_animation_wait(this)	--等待动画完成
		end
		...
	end
	...
end
<br><br>主要目的：使闪避或格挡时进行反击<br>流程见：<a data-href="1.4 函数#八、闪避流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#八、闪避流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 八、闪避流程</a><br>通过查看流程知道：主要是通过 dodge.active 键来判断是否闪避 ，以及 dodge.counter_attack_pending 键来判断是否进行闪避攻击的<br>所以我们可以在单位的更新主函数判断闪避，然后将 dodge.counter_attack_pending 键的键值改为 true，在模板 dodge.counter_attack 键写上攻击即可<br><br>--某个实体的更新主函数内
while true do
	if h.dead then
		SU.y_hero_death_and_respawn(store, this)
	end

	if this.unit.is_stunned then
		SU.soldier_idle(store, this)
	else	--通常不会在死亡或眩晕时闪避
		if this.dodge and this.dodge.active then	--判断闪避
			this.dodge.active = false	--重置状态
			this.dodge.counter_attack_pending = true
			...	--ps：后面可以增加其他逻辑
		end
	end
	...
end

-- 模板内
tt.dodge.counter_attack = E:clone_c("melee_attack")
tt.dodge.counter_attack.animation = "attack"
tt.dodge.counter_attack.sound = "MeleeSword"	--动画和音效可以先借用普通攻击的
...	--增加伤害类型，伤害这些，与攻击同理
<br><br><br>上次在增加效果时我们说到：近战攻击不能增加多个效果<br>通过上面的教程我们知道造成多个效果需要有效果表，最后还要遍历效果表<br>
所以近战攻击不能造成多个效果的原因如下：造成效果时只造成单一的 mod 效果<br>我们只需要将近战攻击函数的造成效果的代码块修改一下即可：<br><br>首先找到近战攻击函数<br>
参考 <a data-href="1.4 函数#攻击流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#攻击流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 攻击流程</a> 直接在 script_utils 搜索 y_soldier_melee_block_and_attacks 函数，即可找到近战攻击函数<br>然后修改近战攻击函数 y_soldier_do_loopable_melee_attack，y_soldier_do_single_area_attack，y_soldier_do_single_melee_attack，多次攻击、范围攻击、单次攻击这三个函数<br>可以直接搜索也可以直接转到定义<br>
右键函数点击转到定义跳转到这个函数的定义<br>
<img alt="Pasted image 20250705131059.png" src=".\https:\\github.io\lib\media\pasted-image-20250705131059.png" style="width: 600px; max-width: 100%;"><br><br>往下找造成伤害的代码块<br>
<img alt="Pasted image 20250705131332.png" src=".\https:\\github.io\lib\media\pasted-image-20250705131332.png" style="width: 525px; max-width: 100%;"><br>
同上修改造成效果的代码块即可<br>if attack.mod or attack.mods then
	local mods = attack.mods or {
		attack.mod
	}
	for _, mod_name in pairs(mods) do	--遍历效果表
		local new_mod = E:create_entity(mod_name)
		new_mod.modifier.target_id = e.id
		new_mod.modifier.source_id = this.id
		new_mod.modifier.ts = store.tick_ts	--加上原有的避免兼容性问题
		new_mod.modifier.level = attack.level
		
		queue_insert(store, new_mod)
	end
end

--模板内直接把效果写在 mods 键上即可
tt.melee.attacks[1].mods = {
	效果 1,
	效果 2
	...
}
<br>三个函数都改一遍即可]]></description><link>.\https:\\github.io\第-1-章、基础\1.-修改教程\2-函数.html</link><guid isPermaLink="false">第 1 章、基础/1. 修改教程/2 函数.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Sun, 27 Jul 2025 10:33:48 GMT</pubDate><enclosure url=".\https:\\github.io\lib\media\pasted-image-20250701213229.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=".\https:\\github.io\lib\media\pasted-image-20250701213229.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1.1 实体]]></title><description><![CDATA[ 
 <br>使用模板（template）创建的单位、贴图、精灵等称为实体（entities）<br>单位特指英雄、士兵、敌人、防御塔<br>实体创建流程见 <a data-href="1.4 函数#二、实体创建流程" href=".\https:\\github.io\第-1-章、基础\1.4-函数.html#二、实体创建流程" class="internal-link" target="_self" rel="noopener nofollow">1.4 函数 &gt; 二、实体创建流程</a><br>用途：balance → 模板 → 实体 → 函数<br><br>在&nbsp;all/entity_db（简称 E）返回的表中：<br><br>
<br>用于创建各种实体
<br>支持模板之间的深拷贝
<br>默认为空，后面会通过 kr/game_templates 和 all/templates 模块动态增加模板
<br>game_templates 创建模板时会读取 kr/balance/balance 内的数据
<br><br>
<br>用于为模板增加组件
<br>默认为空，后面会通过 all/components 模块动态增加组件
<br>组件与模板都是表，这里仅为了区分两个表<br>E = {
    components = { },  -- 组件（如血量、技能）
    entities = { },    -- 实体模板（如英雄、敌人）
    -- ... 其他函数
}
<br><br><br>tt = E:register_t(模板, 底模板)
<br>
<br>作用：模板会派生于底模板生成新模板，也就是拥有底模板的所有键值对<br>
给模板增加 template_name 键，键值为模板名称
<br>返回值：新模板的引用（可直接操作）
<br>原理：E.entities.模板 = table.deepclone(E.entities.底模板)
<br>示例：  <br>tt = E:register_t("hero_gerald", "hero")  -- tt 等价于 E:get_template("hero_gerald") 即 E.entities.hero_gerald
<br><br>E:add_comps(模板, 组件， ...)
<br>
<br>作用：向模板增加多个 components 中的组件
<br>原理：E.entities.模板.组件 = table.deepclone(组件)
<br>示例：  <br>E:add_comps("hero_gerald", "melee", "health")	--向 hero_gerald 模板增加 melee 和 health 组件
<br><br>E:get_template(模板)
<br>
<br>原理：t = E.entities.模板
<br>注意：需确保模板已存在（通过 E:register_t 创建）<br>示例：<br>E:get_template.health.hp = 666	--给 hero_gerald 模板设置血量
<br><br>key = E:clone_c(组件)
<br>
<br>作用：将对应键设置为对应组件，用于初始化
<br>原理：key = table.deepclone(组件)
<br>示例：<br>tt.melee.attacks[1] = E:clone_c("aura_attack")	--给近战攻击 1 设置范围攻击组件 
<br><br>E:filter(表, 键, ...)	--可以传任意数量
<br>
<br>作用：返回一个表，表内具有包含指定键的表
<br>示例：<br>T = E:filter(store.entities, "tower")	--此时 T 是一个表，内有所有包含 tower 键的实体（所有防御塔）

for _, t in pairs(T) do	--遍历所有具有 tower 键的实体，使其攻击速度改为 1（使所有已建造的防御塔攻击速度改为 1 秒/次）
	t.attacks.list[1].cooldown = 1
end
<br><br>E:filter_templates(键, ...)	--可以传任意数量
<br>
<br>作用：返回一个表，表内具有包含指定键的模板
<br>原理：E:filter(E.entities, ...)
<br>示例：<br>T = E:filter_templates("tower")	--此时 T 是一个表，内有所有具有 tower 键的模板（所有防御塔）

for _, t in pairs(T) do	--遍历所有具有 tower 键的模板，使其降价 10（使所有防御塔价格降低 10 块）
	t.tower.price = t.tower.price - 10
end
]]></description><link>.\https:\\github.io\第-1-章、基础\1.1-实体.html</link><guid isPermaLink="false">第 1 章、基础/1.1 实体.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Thu, 24 Jul 2025 07:25:24 GMT</pubDate></item><item><title><![CDATA[<strong>错误排查指南</strong>]]></title><description><![CDATA[ 
 <br><br><br>示例（以<a data-tooltip-position="top" aria-label="注意事项 > 表的索引" data-href="注意事项#表的索引" href=".\https:\\github.io\第-1-章、基础\注意事项.html#表的索引" class="internal-link" target="_self" rel="noopener nofollow">索引空值错误</a>为例）：<br>tt = E:register_t("hero_gerald", "hero")
E:add_comps(tt, "melee", "timed_attacks", "dodge")
tt.melee.error.n = 666  -- 错误源头
<br>报错：<br>
<img alt="Pasted image 20250624161626.png" src=".\https:\\github.io\lib\media\pasted-image-20250624161626.png" style="width: 500px; max-width: 100%;"><br><br>
<br>
attempt to index a nil value → 尝试索引不存在的键（melee 组件无 error 字段）

<br>
第一行：错误文件与行号（kr3/game_templates-1.lua:2770）  

<br>
Traceback：错误前的执行的代码与调用的函数（用于逆向分析根本原因）

<br><br>控制台报错常见于实体逻辑错误，实体卡死（无法攻击/移动）<br>
<img alt="Pasted image 20250625102924.png" src=".\https:\\github.io\lib\media\pasted-image-20250625102924.png" style="width: 141px; max-width: 100%;"><br>示例（还是以索引空值错误为例）：<br>function scripts.hero_alleria.update(this, store)
    local error = this.melee.error.n  -- 错误源头
...
<br>报错：<br>
<img alt="Pasted image 20250625103109.png" src=".\https:\\github.io\lib\media\pasted-image-20250625103109.png" style="width: 1175px; max-width: 100%;">  <br><br>
<br>
attempt to index field 'error' (a nil value) → 尝试索引不存在的键

<br>
错误文件与行号：kr3/game_scripts-1.lua:1890

<br>
Traceback：显示错误前的调用链（有可能什么都没有）

]]></description><link>.\https:\\github.io\第-1-章、基础\1.2-错误.html</link><guid isPermaLink="false">第 1 章、基础/1.2 错误.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Wed, 16 Jul 2025 01:11:43 GMT</pubDate><enclosure url=".\https:\\github.io\lib\media\pasted-image-20250624161626.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=".\https:\\github.io\lib\media\pasted-image-20250624161626.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1.3 常量]]></title><description><![CDATA[ 
 <br>all/constants 内的所有变量名义上称为 “常量”（constants）<br>
<br>名义常量：<br>
虽叫常量，实际为可修改的变量，但强制约定：

<br>允许读取引用
<br>禁止直接修改（破坏位运算逻辑）


<br>具体常量见 <a data-href="详细数据#贰、常量" href=".\https:\\github.io\详细数据.html#贰、常量" class="internal-link" target="_self" rel="noopener nofollow">详细数据 &gt; 贰、常量</a><br><br>constants 内的常量最终基本都会转换为二进制进行位运算<br><br>二进制结果已换行处理，便于查看<br>建议使用 win 自带的计算器的程序员模式输入十进制然后选择按位来计算结果，看二进制效率较低<br>]]></description><link>.\https:\\github.io\第-1-章、基础\1.3-常量.html</link><guid isPermaLink="false">第 1 章、基础/1.3 常量.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Tue, 08 Jul 2025 01:03:44 GMT</pubDate><enclosure url=".\https:\\github.io\lib\media\pasted-image-20250705082808.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=".\https:\\github.io\lib\media\pasted-image-20250705082808.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1.4 函数]]></title><description><![CDATA[ 
 <br><br>所有基础函数都存储在 all/scripts 模块<br>
<br>后续会通过 kr/game_scripts 模块动态向 scripts 模块增加实体的各种函数
<br>all/script_utils（简称 SU）用于存储实体各种行为的函数（如近战攻击，远程攻击，技能则是直接写到实体的更新函数上）
<br>all/utils（简称 U）用于存储通用工具函数（索敌等）
<br><br><br>all/simulation 简称为 S<br><br>
<br>更新逻辑时间（store.tick_ts += 1）
<br>处理实体插入与移除
<br>调用各种更新函数<br>
-i. 包括调用更新主函数（main_script.update），血量更新函数等<br>
-具体请在 all/systems（简称 sys）搜索 on_update 参考
<br><br>所有实体最终都会创建到 all/game.store.entities 表中（game.store 简称 store）<br><br>
<br>调用 E:create_entity(模板) 函数：

<br>深拷贝模板，生成独立实体表（存储实体的各种数据）
<br>分配唯一 ID
<br>返回该实体表引用<br>
-i. 此后可以通过这个引用直接修改创建的实体表（使用 ID 不好索引），比如增加目标、来源等


<br><br>
<br>调用 S.queue_insert_entity 函数：

<br>将实体表增加到 store.pending_inserts（待插入队列）中<br>
-i. 通常使用 queue_insert(store, e) 函数包装


<br><br>
<br>通过驱动函数逐帧检测&nbsp;pending_inserts：

<br>如果队列非空，取出实体表（移除队列中的引用）
<br>调用&nbsp;S:insert_entity&nbsp;函数创建实体


<br><br>
<br>调用 S:insert_entity&nbsp;函数：

<br>调用各种插入函数

<br>会给插入函数传递两个参数：对应实体（this）、store<br>
-i. 包括主插入函数（main_script.insert），血量插入函数<br>
-具体请在 sys 搜索 on_insert 参考<br>
-若插入主函数返回 false （通常表示创建失败）则调用 dequeue 主函数


<br>以实体表唯一 ID 为键，实体表为键值以键值对形式&nbsp;[ID] = 实体表&nbsp;插入&nbsp;store.entities


<br>注意：从创建实体表到创建实体从始至终都只是在操作引用，也就是同一实体表<br><br><br>
<br>调用各种更新函数<br>
-i. 包括更新主函数<br>
-具体请在 sys 搜索 on_update 参考
<br><br>
<br>调用 sys.main_script:on_update 函数调度协程：

<br>遍历所有实体，使其中有更新主函数的实体进行下一步
<br>若实体主函数没有运行过且更新主函数没有协程，则创建更新主函数的协程<br>
-i. 创建后首次会调用一遍更新主函数
<br>若更新主函数有协程则重启协程（也就是调用更新主函数的 while）
<br>给更新主函数传递四个参数：对应协程、对应实体（this）、store、主函数表的引用


<br>注意：更新主函数内最后必须挂起协程，若没有挂起则会卡死程序<br><br>同创建实体，移除时调用各种移除函数，具体见 sys 的 on_remove<br>不同的是：<br>
<br>无第一步，创建实体表
<br>最后会将对应 ID 键的键值设置为 nil
<br><br><br>
<br>调用 E:create_entity("damage") 创建伤害实体表：

<br>返回伤害实体表引用<br>
-i. 此后可以通过这个引用直接修改创建的实体表（使用 ID 不好索引），比如增加目标等


<br><br>
<br>调用 table.insert(store.damage_queue, 伤害) 函数：

<br>将伤害插入 store.damage_queue 伤害队列<br>
-i. 通常使用 queue_damage(store, damage) 函数包装


<br><br>d = E:create_entity("damage")	--创建伤害实体
d.damage_type = DAMAGE_TRUE	--伤害类型设置为真伤，注意：修改的是创建的完全独立的伤害实体表

queue_damage(store, d)	--正式插入伤害，等价于 table.insert(store.damage_queue, d)
<br><br>
<br>调用血量更新函数 sys.health:on_update：

<br>若伤害队列非空，遍历伤害队列，使其中没有造成伤害的伤害，进行下一步
<br>在 store 索引目标的 ID（target_id）
<br>调用 U.predict_damage 函数计算伤害大小（计算护甲与伤害类型的影响）
<br>造成伤害


<br><br>与创建实体相同，只不过在效果的更新主函数增加条件：如果持续时间到了则移除效果（实体）<br><br>
<br>
判断实体有没有 modifier 键，如果没有则表示此实体不是效果，直接返回 true

<br>
筛选所有具有相同目标的效果

<br>
判断当前效果有没有被其他相同目标的效果抵消掉，如果被抵消直接返回 false

<br>
判断当前效果的 modifier.remove_banned 键的键值，若为 true 则移除被抵消的其他相同目标的效果

<br>
移除后 modifier.removed_by_ban 键改为 true

<br>
判断 modifier.allows_duplicates 键的键值是否允许叠加多个相同等级的相同效果

<br>
判断 modifier.replaces_lower 键的键值是否仅替换不同等级的相同效果

<br>
判断 modifier.resets_same 键的键值是否仅重置相同等级的相同效果的持续时间，返回 false

<br>
完毕后最终返回 true

<br><br><br>
<br>调用 U.attack_order 函数排序攻击：<br>
- 遍历实体对应的攻击表（melee.attacks 或 ranged.attacks）<br>
- 根据以下条件排序攻击表<br>
- 返回到实体  melee.order 或 ranged.order 表（攻击优先级）<br>
示例：this.melee/ranged.order = U.attack_order(this.melee/ranged.attacks)
<br><br>都不相等时优先考虑根据概率排序<br>-i. 因为 melee.order 或 ranged.order 默认值只有攻击 1，所以如果没有排序则只能使用普通攻击<br>
-可以删除主插入函数对应攻击的排序函数，直接在模板写攻击优先级（详细见 <a data-href="1 模板#二、修改攻击优先级" href=".\https:\\github.io\第-1-章、基础\1.-修改教程\1-模板.html#二、修改攻击优先级" class="internal-link" target="_self" rel="noopener nofollow">1 模板 &gt; 二、修改攻击优先级</a>）<br><br>
<br>调用 SU.y_soldier_melee_block_and_attacks 近战攻击函数：

<br>调用 SU.soldier_pick_melee_target 函数寻找拦截范围内的目标：

<br>返回目标


<br>无目标返回 A_NO_TARGET
<br>调用 SU.soldier_pick_melee_attack 函数遍历实体的 melee.order 表（排序在前的优先）：

<br>闪避攻击优先级最高
<br>判断攻击是否可用：没有禁用、冷却完毕、标签没有被过滤、fn_can 函数返回 true、计算概率或调用  fn_chance 函数计算概率，返回可用攻击
<br>fn_can 函数会传递：调用这个函数的实体、store、攻击、目标
<br>fn_chance 函数传递内容同上


<br>无可用攻击返回 A_IN_COOLDOWN
<br>判断攻击类型：单体攻击、多次攻击、近战范围攻击，调用对应攻击类型的函数<br>
-i. 支持同时多次范围攻击<br>
-单体攻击会调用 SU.unit_dodges 函数判断与计算目标是否闪避此次攻击
<br>攻击完毕返回 A_DONE


<br>攻击函数就是最基础的造成伤害与造成效果、播放动画、判断有没有闪避、处理共享冷却等，不进行赘叙<br>注意步骤内的缩进，返回值是上一层级的函数返回<br><br>
<br>调用 SU.soldier_pick_ranged_target_and_attack 函数：

<br>寻找攻击范围内的目标
<br>遍历实体的 ranged.order 表（排序在前的优先）
<br>判断攻击是否可用：没有禁用、冷却完毕、标签没有被过滤、没有被筛选函数 filter_fn 过滤<br>
-i. 传递的参数同索敌的筛选函数（v，origin，实体表与圆心位置）
<br>同时返回目标和可用攻击
<br>无目标返回 A_NO_TARGET
<br>无可用攻击返回 A_IN_COOLDOWN


<br>判断攻击类型：单体攻击、多次攻击，调用对应攻击类型的函数
<br>创建子弹实体
<br>攻击完毕返回 A_DONE
<br><br>
<br>调用子弹的主函数：

<br>计算子弹飞行轨迹，抛物线（箭矢），直线追踪（魔法弹）等
<br>造成伤害与造成效果


<br><br><br>
<br>判断目标有没有闪避此次攻击（是否可用）：
<br>有 dodge 键、没有被眩晕、冷却完毕、攻击的伤害类型没有 DAMAGE_NO_DODGE、计算概率、can_dodge 函数返回 true
<br>可用返回 true，不可用 false
<br>目标的 dodge.active 键的键值设为 true<br>
-i. 通常返回 true 后不应造成伤害
<br><br>
<br>判断 dodge.active 是否闪避上次攻击
<br>条件代码块内执行其他闪避相关的代码<br>
-i. 比如闪避后造成效果 
<br><br>
<br>判断 dodge.counter_attack_pending 是否进行闪避攻击
<br>进行则 soldier_pick_melee_attack 函数返回 dodge.counter_attack 攻击
<br>dodge.counter_attack_pending 键的键值改为 false
<br>注意：是否进行闪避是攻击者在判断，而不是目标<br>
攻击者 → 目标，目标闪避攻击 → 攻击者<br><br><br>注意：闪避优先级较高，如果有闪避动画，则会打断优先级低的行为<br>流程就是简单的按照顺序判断然后调用对应行为的函数，不进行赘叙了，自行见 all/scripts.soldier_barrack.update 函数<br>参考资料：<br><a class="auto-card-link-card" href="https://tieba.baidu.com/p/9764441850"><div class="auto-card-link-main"><div class="auto-card-link-title"></div><div class="auto-card-link-description"></div><div class="auto-card-link-host"></div></div></a>关于士兵是如何攻击的讨论 by天玑布可 -百度贴吧事情是这样的，因为今天lz很闲，偶然看到一个吧友问和刺客秒杀相关的事情，然后就真的写了很多东西和数学计算，结果最后翻开底层代码仔细看了一下发现全错!)  所以单独开一个贴，写一下士兵究竟是怎么一个攻击逻辑。也望各位引以为戒，对斩钉截铁说出的话要进行查证]]></description><link>.\https:\\github.io\第-1-章、基础\1.4-函数.html</link><guid isPermaLink="false">第 1 章、基础/1.4 函数.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Fri, 25 Jul 2025 12:02:01 GMT</pubDate></item><item><title><![CDATA[1.5 存档]]></title><description><![CDATA[ 
 <br>存档用于存储各种英雄等级，加点，完成的成就、星星以及升级、关卡完成情况等<br>存档位置：C:\Users\你的用户名\AppData\Roaming\kingdom_rush_xxx<br>
使用 VSCode 调试则在 C:\Users\你的用户名称\AppData\Roaming\LOVE\kingdom_rush_xxx 里面<br>
<br>也可以点击工作区文件夹内的存档位置快捷方式进行跳转
<br>存档内就是一些简单的表，不进行赘叙<br><br><br>slot = storage:load_slot()	-- slot 就是存档的表了
<br><br>storage:save_slot(slot)
<br>强制约定：保存前要先读取存档<br>
因为这个函数会将存档直接完全替换为保存的表，所以刚开始必须先读取存档，否则存档会丢失此前保存的内容，仅有保存的内容<br>示例：<br>slot = storage:load_slot()	-- slot 接收存档的表，如果你要修改存档必须首先加载存档

slot.heroes.status.hero_gerald.xp = 2333	-- 将爵士的经验设置为 2333 点

storage:save_slot(slot) -- 保存到存档里
]]></description><link>.\https:\\github.io\第-1-章、基础\1.5-存档.html</link><guid isPermaLink="false">第 1 章、基础/1.5 存档.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Thu, 24 Jul 2025 07:20:24 GMT</pubDate></item><item><title><![CDATA[拷贝的区别]]></title><description><![CDATA[ 
 <br><br>给一个变量赋值表，就是复制其引用（内存地址），除非显式（深拷贝）复制它<br><br>
<br>因为变量只相当于指针，所以无法通过直接通过修改变量来修改表
<br>例如：<br>a = {1 , 2 , 3}
a = {"a", "b", "c"}	-- 123 表不变，只是从引用 123 表改为引用 abc 表
<br><br><br>可以在方括号内填写变量，或者数字、字符串<br>
<br>示例：table[1]、table["str"]、table[a]
<br><br>
<br>仅能索引字符串
<br>示例：table.str
<br>Warning
注意：如果 str 键不存在，尝试索引子键 x 会引发索引 nil 值错误<br>
示例：table.str.x
因为表内不存在的键都是 nil ，nil 不是一个表所以不存在子键，无法索引
但是如果只是给不存在的 str 赋值，那么将会自动创建 str 键然后接收这个值
<br><br>调用函数和定义函数时的冒号，其主要作用如下<br><br>
<br>
调用时将冒号前的一个表隐式传递

<br>调用时：E:register_t(模板, 组件) 
<br>等价于 E.register_t(E, 模板, 组件)


<br>
定义时隐式定义一个形式参数 self

<br>定义时：function entity_db:register_t(name, base) 
<br>等价于 function entity_db.register_t(self, name, base)


<br>综上使用冒号与点的区别仅在于隐式传递与隐式定义 self<br>注意：self 形式参数名一般不可修改，除非镶套一下函数<br>
示例：<br>a = {}
function a:f()	--用 冒号 定义
	function a:print(this)
		print(this)	--此时 this 就是 self
	end
end

a.f("self")	--用 点 调用
]]></description><link>.\https:\\github.io\第-1-章、基础\注意事项.html</link><guid isPermaLink="false">第 1 章、基础/注意事项.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Mon, 28 Jul 2025 11:41:15 GMT</pubDate></item><item><title><![CDATA[0.1 配置环境]]></title><description><![CDATA[ 
 <br>游戏引擎版本：Lua_v5.1 + Love 2d_v10.2 + LuaJIT_v2.0.4<br>（通过 print 版本信息得到）<br>本篇教程参考自狂神的教程，进行再次简洁、整理，无用设置均已剔除，当然也有自创内容<br><br>开始修改前建议先观看两门教程（至少需要两个小时）<br>
<br>
<a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1vf4y1L7Rb/" rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV1vf4y1L7Rb/" target="_blank">Lua教程-入门—哔哩哔哩</a>

<br>
<a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1WR4y1E7ud/" rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV1WR4y1E7ud/" target="_blank">Lua教程-进阶—哔哩哔哩</a>

<br><br><br><a class="auto-card-link-card" href="https://code.visualstudio.com/"><div class="auto-card-link-main"><div class="auto-card-link-title"></div><div class="auto-card-link-description"></div><div class="auto-card-link-host"><span></span></div></div></a>Visual Studio Code - Code Editing. RedefinedVisual Studio Code redefines AI-powered coding with GitHub Copilot for building and debugging modern web and cloud applications. Visual Studio Code is free and available on your favorite platform - Linux, macOS, and Windows.code.visualstudio.com<img class="auto-card-link-thumbnail" src="https://code.visualstudio.com/opengraphimg/opengraph-home.png" draggable="false"><br><br>
<br>将网盘的整合包下载并解压<br>
解压工具见 <a data-href="0.2 工具#压缩软件" href=".\https:\\github.io\0.2-工具.html#压缩软件" class="internal-link" target="_self" rel="noopener nofollow">0.2 工具 &gt; 压缩软件</a>
<br>链接：<br><a class="auto-card-link-card" href="https://pan.baidu.com/s/1FNmzdCuilWbFg5sFR0AO5w?pwd=2333#list/path=%2F%E8%8B%B1%E9%9B%84%E8%A1%A5%E5%BC%BA%2F%E5%B7%A5%E5%85%B7"><div class="auto-card-link-main"><div class="auto-card-link-title"></div><div class="auto-card-link-description"></div><div class="auto-card-link-host"><span></span></div></div></a>工具 -百度网盘百度网盘为您提供文件的网络备份、同步和分享服务。空间大、速度快、安全稳固，支持教育网加速，支持手机端。注册使用百度网盘即可享受免费存储空间pan.baidu.com<br><img alt="Pasted image 20250710100316.png" src=".\https:\\github.io\lib\media\pasted-image-20250710100316.png" style="width: 347px; max-width: 100%;"><br>
2. 将 VScode_KR_workspace 文件夹放到 D 盘<br>
可以放到其他地方，但要保证没有中文路径，也可以重命名，请改一个便于找到的位置与名字<br>
<img alt="Pasted image 20250706200745.png" src=".\https:\\github.io\lib\media\pasted-image-20250706200745.png" style="width: 395px; max-width: 100%;"><br>
<br>此文件夹包含配置文件，用于推荐插件与使用预先修改的设置，还包括 Love 2d 引擎
<br><br>
<br>打开 VSCode → 安装所有建议的扩展<br>
位于右下角<br>
<img alt="Pasted image 20250710092722.png" src=".\https:\\github.io\lib\media\pasted-image-20250710092722.png" style="width: 525px; max-width: 100%;">
<br>
<br>包含 Lua 代码补全、诊断、格式化、用于调试的扩展
<br>所有插件均配置完毕，无需自行配置
<br><br>
<br>将要修改的游戏本体 exe 复制到工作区文件夹内的 src 文件夹内
<br>将游戏本体解压到当前位置，注意不是直接解压，而是解压到当前位置
<br><br>
<br>通过 VSCode 打开文件夹<br>
双击 VScode_KR_workspace 文件即可<br>
<img alt="Pasted image 20250716131909.png" src=".\https:\\github.io\lib\media\pasted-image-20250716131909.png" style="width: 325px; max-width: 100%;"><br>
注：此后修改的文件将会存在这个文件夹内
<br>
<br>设置与配置均已在 .vscode 内设置完毕，为了性能部分游戏资源文件已被排除（图片等）
<br>参考资料：<br><a class="auto-card-link-card" href="https://www.cnblogs.com/linxiaoxu/p/17653162.html"><div class="auto-card-link-main"><div class="auto-card-link-title"></div><div class="auto-card-link-description"></div><div class="auto-card-link-host"><span></span></div></div></a>[Love] VSCODE 调试 LOVE 引擎游戏 - 小能日记 - 博客园VSCODE调试LOVE引擎游戏 按 CTRL + SHIFT + P，打开 Preferences: Open User Settings (JSON)，为settings.json 添加如下代码<img class="auto-card-link-favicon" src="https://assets.cnblogs.com/favicon_v3_2.ico">www.cnblogs.com<br><br>
<br>安装 Python<br>
由于国内在官网下载较慢，所以提供镜像网站下载：
<br><a class="auto-card-link-card" href="https://mirrors.huaweicloud.com/python/3.13.5/python-3.13.5-amd64.exe"><div class="auto-card-link-main"><div class="auto-card-link-title"></div><div class="auto-card-link-host"></div></div></a>python-3.13.5 - 华为云<br>
<br>
打开 luajit-decompiler-v2/无错误弹窗反编译

<br>
浏览选择工作区文件夹的 src，进行反编译<br>
可能会未响应几分钟，这是正常现象，耐心等待完成即可<br>
<img alt="Pasted image 20250727204353.png" src=".\https:\\github.io\lib\media\pasted-image-20250727204353.png" style="width: 875px; max-width: 100%;">

<br>
替换原文件<br>
反编译后将 output 文件夹内的所有文件拖入 src 全部替换即可<br>
<img alt="Pasted image 20250727205026.png" src=".\https:\\github.io\lib\media\pasted-image-20250727205026.png" style="width: 850px; max-width: 100%;">

<br><br>
<br>打开 src/version
<br>将 build 键键值改为 "DEBUG"<br>
<img alt="Pasted image 20250706170225.png" src=".\https:\\github.io\lib\media\pasted-image-20250706170225.png" style="width: 650px; max-width: 100%;">
<br><br>
<br>
运行游戏<br>
点击运行与调试 → 选择模式：Debug → 运行<br>
Debug 为调试模式，会对性能造成较大影响<br>
Release 则为正常模式<br>
<img alt="Pasted image 20250706203549.png" src=".\https:\\github.io\lib\media\pasted-image-20250706203549.png" style="width: 371px; max-width: 100%;">

<br>
打一些断点<br>
尽量打到会立刻执行的代码上，比如 kr/game_templates 内<br>
<img alt="Pasted image 20250618143505.png" src=".\https:\\github.io\lib\media\pasted-image-20250618143505.png" style="width: 625px; max-width: 100%;">

<br>
一切正常下游戏会在断点处暂停，同时可以看到变量、堆栈<br>
<img alt="Pasted image 20250618143251.png" src=".\https:\\github.io\lib\media\pasted-image-20250618143251.png" style="width: 800px; max-width: 100%;"><br>
完成后注意一下存档位置会在 C:\Users\你的用户名称\AppData\Roaming\LOVE\kingdom_rush_xxx 里面

<br>
<br>也可以点击工作区文件夹内的存档位置快捷方式进行跳转
<br><br><br>在 args 模块的 love.keypressed 函数内打个断点即可<br><img alt="Pasted image 20250707135331.png" src=".\https:\\github.io\lib\media\pasted-image-20250707135331.png" style="width: 500px; max-width: 100%;"><br><br>注意：只有触发断点时监视才可用<br><br><img alt="Pasted image 20250621105918.png" src=".\https:\\github.io\lib\media\pasted-image-20250621105918.png" style="width: 450px; max-width: 100%;"><br><br><br><br><br>
<br>点击左上角金币图标，可以开启有 UI 的控制台（功能与快捷键相同）<br>
<img alt="Pasted image 20250620190901.png" src=".\https:\\github.io\lib\media\pasted-image-20250620190901.png" style="width: 600px; max-width: 100%;">
<br><br><br>调试控制台会显示详细信息，比如加载资源，所有点击事件，操作实体（插入，移除）等<br>可以通过搜索来筛选信息<br><br>待补充...<br><br>在运行过程中的打断点、删除、禁用断点、激活断点操作，只有断点后进行的才会立刻生效<br>
否则不会立刻生效，需要到下次重新启动才会生效<br>也就是说想在运行过程中打断点，必须在断点触发时才能打，否则不会立刻生效<br>
（建议手动触发断点，然后打断点，或者提前打好断点然后禁用，需要使用时手动触发断点，然后启用）<br><br>
<br>取消 screen 与 custom 的注释
<br>custom 输入要编辑的关卡的编号运行即可进入关卡编辑器<br>
<img alt="Pasted image 20250712192159.png" src=".\https:\\github.io\lib\media\pasted-image-20250712192159.png" style="width: 500px; max-width: 100%;"><br>
ps：关卡编辑器bug较多，仅用于修改路径与塔位，部分按钮可能会报错
<br><br><br>关闭输入法即可<br><br>检查 conf 模块关闭游戏自带控制台，将 console 键键值从 true改为 false<br>
<img alt="Pasted image 20250618142239.png" src=".\https:\\github.io\lib\media\pasted-image-20250618142239.png" style="width: 325px; max-width: 100%;"><br><br>在 all/systems 搜索 main_script:on_update<br>--将以下代码修改
--if coroutine.status(s.co) == "dead" or error ~= nil then
	--if error ~= nil then

--修改为
if coroutine.status(s.co) == "dead" or (not success and error ~= nil) then
	if not success and error ~= nil then
<br><img alt="Pasted image 20250717091020.png" src=".\https:\\github.io\lib\media\pasted-image-20250717091020.png" style="width: 975px; max-width: 100%;"><br><br>可将 main 模块的 ppref 设为空字符串<br>
<img alt="Pasted image 20250618161513.png" src=".\https:\\github.io\lib\media\pasted-image-20250618161513.png" style="width: 600px; max-width: 100%;"><br><br>在设置关闭诊断即可<br>
<img alt="Pasted image 20250728093403.png" src=".\https:\\github.io\lib\media\pasted-image-20250728093403.png" style="width: 675px; max-width: 100%;">]]></description><link>.\https:\\github.io\0.1-配置环境.html</link><guid isPermaLink="false">0.1 配置环境.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Mon, 28 Jul 2025 01:38:31 GMT</pubDate><enclosure url="https://code.visualstudio.com/opengraphimg/opengraph-home.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://code.visualstudio.com/opengraphimg/opengraph-home.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[AI]]></title><description><![CDATA[ 
 <br><br>如有任何疑问，强烈建议先问一下 AI，然后再向他人寻求帮助。<br>先推荐一个 deep seek：<br><a class="auto-card-link-card" href="https://www.deepseek.com/"><div class="auto-card-link-main"><div class="auto-card-link-title"></div><div class="auto-card-link-description"></div><div class="auto-card-link-host"><span></span></div></div></a>DeepSeek | 深度求索我是 DeepSeek，很高兴见到你！我可以帮你写代码、读文件、写作各种创意内容，请把你的任务交给我吧~<img class="auto-card-link-favicon" src="https://www.deepseek.com/favicon.ico">www.deepseek.com<img class="auto-card-link-thumbnail" src="https://chat.deepseek.com/deepseek-chat.jpeg" draggable="false"><br>问 AI 最重要的是你想问的问题，需要先明确自己的遇到的问题。然后简单描述环境（或者直接复制上下文给 AI）<br>（不知道问题？建议把 lua 基础学会，了解一些名词）<br><br>推荐 7z<br><a class="auto-card-link-card" href="https://www.7-zip.org/"><div class="auto-card-link-main"><div class="auto-card-link-title"></div><div class="auto-card-link-host"><span></span></div></div></a>7-Zipwww.7-zip.org<img class="auto-card-link-thumbnail" src="https://www.7-zip.org/7ziplogo.png" draggable="false"><br><br>
<br>
打开工作区文件夹

<br>
将需要反编译的 lua 文件拖入 luajit-decompiler.exe<br>
可以拖文件夹，但可能会弹非常多的弹窗<br>
<img alt="Pasted image 20250707141931.png" src=".\https:\\github.io\lib\media\pasted-image-20250707141931.png" style="width: 625px; max-width: 100%;">

<br>
在 output 文件夹找到反编译后的 lua 文件，用其替换掉 src 内的文件<br>
<img alt="Pasted image 20250707144234.png" src=".\https:\\github.io\lib\media\pasted-image-20250707144234.png" style="width: 700px; max-width: 100%;">

<br><br>(1) 这个窗口表示该文件不是 lua 文件或已反编译，点击继续就行<br>
<img alt="Pasted image 20250616103143.png" src=".\https:\\github.io\lib\media\pasted-image-20250616103143.png" style="width: 368px; max-width: 100%;"><br>(2) 这个窗口表示 output 文件夹已有这个文件，自行决定是否替换<br>
<img alt="Pasted image 20250625162357.png" src=".\https:\\github.io\lib\media\pasted-image-20250625162357.png" style="width: 405px; max-width: 100%;">]]></description><link>.\https:\\github.io\0.2-工具.html</link><guid isPermaLink="false">0.2 工具.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Thu, 10 Jul 2025 02:07:45 GMT</pubDate><enclosure url="https://www.deepseek.com/favicon.ico" length="0" type="image/x-icon"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.deepseek.com/favicon.ico"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[发布改版]]></title><description><![CDATA[ 
 <br><br>发布时应该仅发布修改的模块<br><br><img alt="Pasted image 20250626193110.png" src=".\https:\\github.io\lib\media\pasted-image-20250626193110.png" style="width: 235px; max-width: 100%;"><br><br>all，krn，all-desktop，krn-desktop<br>
其中 n 为游戏版本，例如：一代就是 1，五代就是 5<br>
<img alt="Pasted image 20250626193245.png" src=".\https:\\github.io\lib\media\pasted-image-20250626193245.png"><br><br>假设修改了 kr.game_templates 则将修改的 game_templates 放入以上文件夹内对应的文件夹（改版名.krn）<br>
<img alt="Pasted image 20250626193952.png" src=".\https:\\github.io\lib\media\pasted-image-20250626193952.png" style="width: 409px; max-width: 100%;"><br><br>将改版文件夹增加到压缩包打包（任意压缩软件即可），发布即可<br>压缩软件见 <a data-href="0.2 工具#压缩软件" href=".\https:\\github.io\0.2-工具.html#压缩软件" class="internal-link" target="_self" rel="noopener nofollow">0.2 工具 &gt; 压缩软件</a><br><br><br><br><br>找到游戏目录，然后打开游戏 exe 的压缩包<br><br><br><img alt="Pasted image 20250626200756.png" src=".\https:\\github.io\lib\media\pasted-image-20250626200756.png" style="width: 650px; max-width: 100%;"><br><br>]]></description><link>.\https:\\github.io\发布与安装改版.html</link><guid isPermaLink="false">发布与安装改版.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Sat, 28 Jun 2025 08:01:13 GMT</pubDate><enclosure url=".\https:\\github.io\lib\media\pasted-image-20250626193110.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=".\https:\\github.io\lib\media\pasted-image-20250626193110.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[详细数据]]></title><description><![CDATA[ 
 <br>这篇用来总结常用数据<br>更详细的数据请查阅 @杨叔伟大无需多言 的文档：<br><a class="auto-card-link-card" href="https://www.bilibili.com/read/readlist/rl141527"><div class="auto-card-link-main"><div class="auto-card-link-title"></div><div class="auto-card-link-description"></div><div class="auto-card-link-host"><span></span></div></div></a>《王国保卫战》Kingdom Rush 中文百科全集《王国保卫战》百科系列，含有全代防御塔，英雄，敌人，天赋系统，关卡场景，关卡出怪列表等内容的详细数据及作者的解说。<img class="auto-card-link-favicon" src="https://www.bilibili.com/favicon.ico">www.bilibili.com<img class="auto-card-link-thumbnail" src="https://i1.hdslb.com/bfs/article/9f3790a8bc417f97ecf26770bb67d305248602469.jpg@234w_176h_1c.webp" draggable="false"><br>ps：注意分辨直径与半径，文档为直径，代码为半径<br><br><br><br><br>看二进制效率较低，所以直接写 1 所在的位数，例如 1000 则位数为 4<br>仅总结常用的，其他自行见 constants<br><br><br><br><br><br><br><br><br><br><br><br><br>几乎所有索敌本质都是在一定范围索敌<br>
也就是说基本所有索敌都是在范围索敌的基础上增加一些代码而来的（图片是游戏自带调试模式的功能，快捷键 b）<br>
<img alt="Pasted image 20250705124548.png" src=".\https:\\github.io\lib\media\pasted-image-20250705124548.png" style="width: 361px; max-width: 100%;"><br><br>过滤函数 用于筛选目标，筛选出过滤函数返回 true 的实体，false 表示无视这个实体<br>最小范围内标签 用于判断目标标签有没有设定的标签，如果有则无最小范围限制<br>是否仅上游 用于指定是否只筛选位于当前节点的上游（即更靠近路径起点）或下游（即更靠近路径终点）的敌人<br><br><br>效果类型见 <a data-href="详细数据#三、效果类型" href=".\https:\\github.io\详细数据.html#三、效果类型" class="internal-link" target="_self" rel="noopener nofollow">详细数据 &gt; 三、效果类型</a><br>表的形式：<br>{
	"mod_lava",	--效果模板名称
	...
}
<br>通常用于索敌的过滤函数<br>
当然也可以用于技能，对具有特定效果的敌人造成额外效果，典型代表是三代莉恩，对有诅咒效果的敌人造成额外伤害<br><br>]]></description><link>.\https:\\github.io\详细数据.html</link><guid isPermaLink="false">详细数据.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Mon, 28 Jul 2025 03:23:23 GMT</pubDate><enclosure url="https://www.bilibili.com/favicon.ico" length="0" type="image/x-icon"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.bilibili.com/favicon.ico"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[免责声明]]></title><description><![CDATA[ 
 <br><br>该文档仅限学习交流，禁止用于商业用途<br>请购买正版游戏后再进行修改。若修改盗版出现任何问题，均与作者以及文档无关<br><br><a data-tooltip-position="top" aria-label="https://github.com/MC123ACD/KR_modCourse" rel="noopener nofollow" class="external-link" href="https://github.com/MC123ACD/KR_modCourse" target="_blank">Github</a>              <br>本文档适用于电脑版的一、二、三、五代，请注意版本（安卓版部分可用）<br>由于本人正处于学习阶段，所以错误在所难免，欢迎提出意见、提 requests<br><br>鉴于网上对这个游戏的修改教程过于分散以及不系统，特地写此文档<br>本文档的修改教程仅提供基础知识供快速上手与总结，具体修改什么请自便<br><br>开始之前为了阅读体验建议先安装网盘修改教程的所有字体<br>注意：演示时为了方便，通常省略 local，修改时请根据情况自行决定使用全局或局部变量<br>如果嫌网页加载慢可以直接下载网盘的 md 源文件，用 obsidian 软件在本地打开（想编辑文档也可以看一下教程）：<br>
<br>下载安装
<br><a class="auto-card-link-card" href="https://thoughts.teambition.com/share/62a131711a6baa00416a79d3#title=Obsidian_%E5%AE%89%E8%A3%85%E5%8C%85"><div class="auto-card-link-main"><div class="auto-card-link-title"></div><div class="auto-card-link-description"></div><div class="auto-card-link-host"><span></span></div></div></a>Obsidian 安装包官网：https://obsidian.md/<img class="auto-card-link-favicon" src="https://g.alicdn.com/thoughts/thoughts-front/server/favicon.7d745459.png">thoughts.teambition.com<br>下载 md 源文件<br>
<br>打开下载的文件夹
<br><br>
<br>使用阅读模式<br>
点击右下角铅笔，使用阅读模式<br>
<img alt="Pasted image 20250704153432.png" src=".\https:\\github.io\lib\media\pasted-image-20250704153432.png" style="width: 293px; max-width: 100%;">
<br>若想编辑则选择实时阅览模式]]></description><link>.\https:\\github.io\index.html</link><guid isPermaLink="false">index.md</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Mon, 28 Jul 2025 11:44:55 GMT</pubDate><enclosure url="https://g.alicdn.com/thoughts/thoughts-front/server/favicon.7d745459.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://g.alicdn.com/thoughts/thoughts-front/server/favicon.7d745459.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[程序运行逻辑]]></title><description><![CDATA[ 
 函数<br>模板<br>每帧调用 game:update<br>balance<br>E:register_t 创建模板<br>每帧调用 director:update<br>每帧调用 love.update<br>调用 E:create_entity<br>调用 E:load<br>每帧调用 S:do_tick<br>实体表<br>store.entities<br>待插入队列<br>重启协程，没有则创建<br>实体正式创建<br>调用血量更新函数<br>伤害队列<br>实体表完全独立<br>每帧调用 S:update深拷贝模板，分配唯一ID读取插入]]></description><link>.\https:\\github.io\第-1-章、基础\程序运行逻辑.html</link><guid isPermaLink="false">第 1 章、基础/程序运行逻辑.canvas</guid><dc:creator><![CDATA[138]]></dc:creator><pubDate>Sun, 27 Jul 2025 07:31:51 GMT</pubDate></item></channel></rss>