# (一) 拷贝的区别
给一个变量赋值表，就是复制其引用（内存地址），除非显式（深拷贝）复制它

|              | <center>直接赋值</center> | <center>浅拷贝</center> | <center>深拷贝</center>    |
| ------------ | --------------------- | -------------------- | ----------------------- |
| **语法示例**     | `a = b`               | `a = table.clone(b)` | `a = table.deepcopy(b)` |
| **内存对象**     | 共享地址                  | 新建顶层对象               | 新建完整对象树                 |
| **引用关系**     | 完全相同引用                | 仅顶层镶套对象内引用           | 完全独立引用                  |
| **修改顶层字段影响** | 影响原始数据                | **不影响**原始数据          | **不影响**原始数据             |
| **修改嵌套字段影响** | 影响原始数据                | 影响原始数据               | **不影响**原始数据             |
| **内存开销**     | 最小（无新对象）              | 中等（新增顶层对象）           | 最大（完整复制所有对象）            |
| **循环引用处理**   | 无问题                   | 无问题                  | 需要特殊处理                  |
| **性能影响**     | 小                     | 中                    | 大（递归开销较大）               |
- 因为变量只相当于指针，所以无法通过直接通过修改变量来修改表

例如：
```lua
a = {1 , 2 , 3}
a = {"a", "b", "c"}	-- 123 表不变，只是从引用 123 表改为引用 abc 表
```

# (二) 表的索引
## 一、使用方括号 `[ ]`
可以在方括号内填写变量，或者数字、字符串
- 示例：``table[1]、table["str"]、table[a]``

## 二、直接使用 `.`
- 仅能索引字符串键
- 示例：`table.str`

> [!warning]
> 注：**如果 `str` 键不存在**，**尝试索引子键 `x` 会引发索引 `nil` 值错误**<br>
> 示例：`table.str.x`
> 因为**表内不存在的键**都是 `nil` ，`nil` **不是一个表所以不存在子键，无法索引**
> 
> 但是如果**只是给不存在的 `str` 赋值**，那么将会**自动创建 `str` 键然后接收这个值**

#### 冒号与self
调用函数和定义函数时的冒号，其主要作用如下

1. **调用时将冒号前的一个表隐式传递**
	- **调用时：**`E:register_t(模板, 组件)` 
	- 等价于 `E.register_t(E, 模板, 组件)`

2. **定义时隐式定义一个形式参数 `self`**
	- **定义时：**`function entity_db:register_t(name, base)` 
	- 等价于 `function entity_db.register_t(self, name, base)`

综上使用**冒号与点的区别仅在于隐式传递与隐式定义** `self`
