## 6.1 精灵
可在屏幕上移动具有坐标，可变化的图像，称为精灵（**sprite**）

精灵通过前缀与动画名拼接播放动画控制其显示的图像

```lua
tt.render.sprites[1].prefix = "prefix"
tt.render.sprites[1].name = "animation"
tt.render.sprites[1].scale = v(2, 2)	-- 缩放到此前的两倍
```
实际动画名：prefix_animation

### 6.1.1 常用精灵键

| <center>键</center> | <center>作用</center> | <center>键</center> | <center>作用</center> |
| ------------------ | ------------------- | ------------------ | ------------------- |
| `flip_x`           | 是否水平翻转              | `anchor`           | 锚点（%）               |
| `r`                | 旋转弧度                | `offset`           | 位置偏移量               |
| `scale`            | 缩放比例                | `alpha`            | 透明度（0-255）          |
| `prefix`           | 动画前缀                | `hidden`           | 精灵是否隐藏              |
| `name`             | 动画名称，不是动画则可以指定图像名称  | `fps`              | 动画播放帧率              |
| `animated`         | 是否为动画               |                    |                     |

所有键见 [[10. 键#精灵]]

## 6.2 动画
精灵播放动画时通过动画数据指定的帧，与图像名称前缀拼接获取具体显示的图像

所有动画数据都存于 `kr/data/animations` （一代为 `kr1/data/game_animations`）目录中。

### 6.2.1 动画数据结构
```lua
animation_a_name = {		-- 动画名称
	prefix = "image",		-- 图像名称前缀（不带_x序号）
	to = 10,				-- 动画结束帧
	from = 1				-- 动画起始帧
}
```
第一帧时精灵显示 image_1 图像，第二帧显示 image_2 图像，直到 image_10

### 6.2.2 animation_start - 播放动画
```lua
U.animation_start(
	实体: table, 
	动画名: str, 
	是否水平翻转: bool, 
	时间戳: num, 
	是否循环播放: bool, 
	精灵索引?: int, 
	强制重置时间戳: bool
)
```
- 原理是修改精灵的 `name` 后续动画名与精灵前缀拼接
- 精灵索引默认为 1

所有动画函数见 [[11. 工具函数#动画]]

#### 示例
```lua
-- 模板
tt.render.sprites[1].prefix = "hero_muyrn"
tt.melee.attacks[1] = CC("melee_attack")
tt.melee.attacks[1].hit_time = fts(9)
tt.melee.attacks[1].animation = "melee_attack"

-- 更新函数中
local ma = this.melee.attacks[1]
-- 实际播放动画 hero_muyrn .. melee_attack = hero_muyrn_melee_attack
U.animation_start(this, ma.animation, nil, store.tick_ts)
-- 播放后等待攻击前摇的时间（9帧）
U.y_wait(store, ma.hit_time)

-- 也可以使用 U.y_animation_wait(this) 等待动画播放完成
```

### 6.2.3 等待动画的三种方法
#### 1. y_wait - 协程等待
```lua
U.y_wait(store, 等待时间: num, 中断函数?: func) -> 是否被中断: bool
```
- 在指定时间内循环挂起协程
- 中断函数用于提前终止暂停

#### 2. y_animation_wait - 等待动画播放完成
```lua
U.y_animation_wait(实体: table, 精灵索引?: int, 播放次数?: int)
```
- 精灵索引默认为 1
- 播放次数默认为 1

##### 示例
```lua
-- 更新函数中
local ma = this.melee.attacks[1]
U.animation_start(this, ma.animation, nil, store.tick_ts)

-- 播放后等待动画播放完成
U.y_animation_wait(this) 
```

#### 3. y_animation_play - 播放并等待动画完成
```lua
U.y_animation_play(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数?: int, 精灵索引?: int)
```
- 是 `animation_start` 与 `y_animation_wait` 的结合
- 精灵索引默认为 1
- 播放次数默认值为 1

##### 示例
```lua
-- 更新函数中
local ma = this.melee.attacks[1]
U.y_animation_play(this, ma.animation, nil, store.tick_ts)
```

### 6.2.4 修改动画速度
由于原版（fps）不支持单独修改动画速度，所以需要手动扩展一下

修改 `all/animation_db` 的 `fni` 函数
```lua
function animation_db:fni(animation, time_offset, loop, fps, tick_length)
	-- 读取动画数据的 fps
	fps = a.fps or fps or self.fps
end
```

在动画数据增加 `fps` 键输入值即可
```lua
-- 修改 kr1/data/game_animations 中的电塔动画数据
tower_tesla_shoot = {
	prefix = "artillery_lvl4_tesla",
	to = 65,
	from = 1,
	fps = 60	-- 默认 fps 30，60 播放速度翻倍
},
```

## 6.3 图像
所有图像（纹理）都存于 `_assets/kr-desktop/images` （三代为 `kr3-desktop/assets/kr-desktop/images`）目录中，通过图集存储，使用图集数据指定图像位置。

### 6.3.1 图像数据结构
```lua
image_1 = {					-- 图像名称
	a_name = "atlas.dds",	-- 图集名称
	size = {		-- 图像原始大小（未裁剪透明边）
		200,		-- 长度
		100			-- 高度
	},
	trim = {		-- 裁剪的透明边
		10,			-- 左侧裁剪的长度
		20,			-- 上方裁剪的长度
		15,			-- 右侧裁剪的长度
		25			-- 下方裁剪的长度
	},
	a_size = {		-- 图集大小
		2048,		-- 长度
		2048		-- 高度
	},
	f_quad = {		-- 从图集指定位置得到图像
		1000,		-- x
		500,		-- y
		175,		-- 长度
		55			-- 高度
	},
	alias = {		-- 别名
		"image_2"	-- 也可以通过 image_2 索引这个图像
	}
}
```

示意图：
![[Pasted image 20251229202055.png|850]]

### 6.3.2 为什么使用图集？
使用图集（Sprite Atlas）是游戏开发和图形应用中的一项重要优化技术，它通过将多个小纹理（如图片、图标、实体动画帧等）合并到一张大纹理中，带来多方面的性能与效率优势。

1. **减少绘制调用（Draw Call）**：可以在一次绘制调用中批量渲染纹理
2. **优化内存与加载**：多个小纹理单独存储时会有内存对齐浪费，同时大纹理的压缩比更高，加载速度更快
3. **避免纹理切换（Texture Switching）：切**换纹理需要 GPU 状态更新，使用图集后可连续渲染纹理，减少状态切换

### 6.3.3 修改图集
使用 KR_Tools 内的拆分图集工具修改后再使用合并图集工具合并为图集

#### 1. 拆分图集
将图集与数据放入 `input`，运行拆分图集脚本即可
![[Pasted image 20251230094853.png|420]]
在 `output` 即可找到拆出的图集
![[Pasted image 20251230095159.png|550]]

#### 2. 合并图集
修改后将图集文件夹放入 `input` 运行合并图集脚本，同理在 `output` 即可找到图集与图集数据，然后替换原图即可

![[Pasted image 20260105103018.png|425]]

### 6.3.4 锚点
使用 KR_Tools 内的锚点测量工具

打开图像拖动红色十字调整锚点

`ctrl + 拖动` 可以调整参照点，用于计算相对于锚点的偏移（offset）
![[Pasted image 20251230095839.png|700]]

## 6.4 补间动画
根据精灵起点与终点的参数补足中间过渡帧的动画，称为补间动画（**Tween Animation**）
补间动画可当做关键帧，用于过渡，淡出淡入、平滑移动等

### 6.4.1 使用方法
首先增加 `tween` 补间动画组件，在 `keys` 指定关键帧，在 `name` 指定精灵键，在 `sprite_id` 指定目标精灵。

**默认值**：
- `name`：`alpha`
- `sprite_id`：`1`
```lua
-- 透明度
AC(tt, "tween")	-- 增加组件
tt.tween.props[1].keys = {
	{
		0,	
		255	-- 默认不透明
	},
	{
		1,
		0	-- 1 秒时完全透明
	}
}
tt.tween.props[1].sprite_id = 2	-- 补间的精灵，支持数字或表

-- 缩放
tt.tween.props[1].name = "scale"	-- 缩放
tt.tween.props[1].keys = {
	{
		0,
		v(1, 1)
	},
	{
		5,			-- 从 0 秒到 5 秒缓慢放大精灵到此前的两倍
		v(2, 2)
	}
}
```

### 6.4.2 淡出淡入
```lua
AC(tt, "tween")
tt.tween.props[1].keys = {
	{
		0,	-- 默认透明度 0
		255
	},
	{
		1,	-- 1 秒时完全淡出
		0
	},
	{
		2,	-- 2 秒时完全淡入
		255
	}
}
tt.tween.props[1].sprite_id = {	-- 补间的精灵，可以直接用数字或表
	1,
	2,
	...
}
tt.tween.remove = false			-- 禁用播放后移除
tt.tween.props[1].loop = true	-- 循环播放
```

## 6.5 声音
声音资源存储于 `_assets/kr-desktop/sounds` （三代为 `kr3-desktop/assets/kr-desktop/sounds`）目录中。

**其中**：
- `sounds` 为单个声音
- `groups` 为声音组
- `settings` 用于指定声音最大来源
- `files` 声音资源

### 6.5.1 声音数据结构

#### 1. sounds
```lua
声音名称 = {
	loop = 是否循环播放: bool,
	mode = 播放模式: str,
	gain = 声音增益: num,
	source_group = 来源组: str,
	files = {
		声音文件名: str
	}
}
```

#### 2. groups
```lua
组名 = {
	files = {
		声音文件名: str
	}
}
```

### 6.5.2 声音函数
声音模块位于 `all/sound_db` （缩写 S）中

#### 1. 将声音加入播放队列
```lua
S:queue(声音名称: str, 声音参数?: table)
```
- 同样会分配唯一 ID

##### 可选声音参数
```lua
1. gain: 声音大小: num|list{最小范围: num, 最大范围: num}
2. seek: 从指定位置开始播放（秒）: num
3. delay: 延迟（秒）: num
4. chance: 播放概率: num
5. every: 每N次请求播放一次: int
6. ignore: 播放声音间隔: num
7. ref_counted: 是否引用计数: bool
8. mode: 播放模式: 按顺序播放: "sequence"|随机选择一个播放: "random"|同时播放所有: "concurrent"
```
- 引用计数用于管理多个相同声音实例

##### 示例
```lua
-- 模板
tt.melee.attacks[1] = CC("melee_attack")
tt.melee.attacks[1].sound = "HeroNyruBasicAttackMelee"
tt.melee.attacks[1].sound_args = {
	delay = 1	-- 延迟 1 秒播放
}

-- 更新函数中
local ma = this.melee.attacks[1]
S:queue(ma.sound, ma.sound_args)
```

#### 2. 停止播放声音
```lua
S:stop(声音名称: str)
```

## 6.6 加载资源
为了性能游戏通常只会加载 `required_textures` 纹理与 `required_sounds` 声音中指定的资源

### 6.6.1 位置
通常在以下位置指定需要的资源

#### 1. 关卡
在关卡数据与 `all/game` 中指定

```lua
-- level01_data
required_sounds = {
	"music_stage01",
	...
},
required_textures = {
	"go_stage01_bg",
	"go_stage01",
	...
}
```

```lua
-- all/game
game.required_textures = {
	"go_decals",
	"go_enemies_common",
	"go_towers"
}
game.required_sounds = {
	"common"
}
```

#### 2. 其他界面
通常在相应界面的模块内

```lua
-- 关卡界面 game_gui
game_gui.required_textures = {
	"gui_common",
	"gui_portraits",
	...
}
```

```lua
-- 地图界面 screen_map
screen_map.required_sounds = {
	"common",
	"music_screen_map"
}
screen_map.required_textures = {
	"screen_map",
	"screen_map_bg",
	...
}
```

## 6.7 图像格式区别

### 6.7.1 PNG
**质量优先**：无损高质量，读取时**需要解压**，内存占用大，加载速度较慢
**通用性强**：支持多种平台，手机安卓，电脑 Win 等

### 6.7.2 DDS BC
**性能优先**：有损压缩，实时渲染，读取**不需要解压**，内存占用少，加载速度快
**通用性一般**：支持多种平台，部分 CPU 不支持

**BC3**
- 质量较低，支持较旧设备
**BC7**
- 高质量

## 6.8 国际化文本
国际化通常简称为 i18n（**Internationalization**），是指支持多语言的框架和结构，主要是将代码与文本分离，将所有需要翻译的文本从源代码中提取出来，存放在独立的资源文件中。

国际化资源文件存储于 `_assets/kr-desktop/strings` （三代为 `kr3-desktop/assets/kr-desktop/string`）目录中。
模块存储于 `all/i18n`

```lua
tt.info.i18n_key = "ENEMY_GOBLIN"	-- 文本标识 ENEMY_GOBLIN，对应中文文本哥布林，英文文本 goblin
```

### 6.8.1 命名
不同语言的国际化资源文件通过语言标签（Language Tag）命名，这里仅说明常用语言
1. **zh-Hans**：简体中文
2. **zh-Hant**：繁体中文
3. **en**：英文

### 6.8.2 排序文本
由于文本过于混乱可以使用 KR_Tools 中的排序表工具进行排序。

使用方法同上，放入 `input` 运行

### 6.8.3 常用函数

#### 1. 根据当前语言返回相应值
```lua
i18n:cjk(默认: any, 中文: any, 日语: any, 韩语: any) -> 相应语言的值: any
```
- 仅支持中日韩语言

#### 2. 根据文本标识获取相应国际化文本
```lua
_(文本标识: str, 默认值: str) -> 相应国际化文本
```

## 6.9 字体
字体存储位置：`_assets/all-desktop/fonts`（三代为 `all-desktop\assets\fonts`）
模块位置：`lib/klove/font_db`
数据位置：`all-desktop/data/font_subst`

### 6.9.1 字体数据格式
```lua
语言标签 = {
	{
		字体别名: str,
		字体文件名: str,
		{
			size = 1.2: num		-- 字体大小系数
		}
	}
}
```

### 6.9.1 修改字体
将字体文件放入 `_assets/all-desktop/fonts` 中，修改字体数据即可

可以在以下网站下载字体
[字体天下](https://www.fonts.net.cn/)
[猫啃网](https://www.maoken.com/)

以流行点阵体为例：
![[Pasted image 20260104154827.png]]
```lua
-- 修改简体中文语言的主体字体
["zh-Hans"] = {
	{
		"body",		-- 字体别名：主体
		"FashionBitmap16_0.091",	-- 字体文件名
		{
			size = 1.2		-- 字体大小系数
		}
	}
}
```
![[Pasted image 20260104155126.png|424]]
如果出现乱码则表示字体缺少对应文字或游戏不支持，请换个字体

## 6.10 着色器
着色器存储位置：`_assets/all-desktop/shaders` （三代为 `all-desktop\assets\shaders`）
模块位置：`lib/klove/shader_db`

着色器使用 GLSL ES（**OpenGL ES Shading Language**）语言编写

### 6.10.1 p_tint - 色彩
以哥布林精灵改为蓝色为例：
![[Pasted image 20260104162248.png|89]]
```lua
-- 模板
tt = RT("enemy_goblin", "enemy")

-- 着色器名称
tt.render.sprites[1].anchor = v(0.5, anchor_y)
tt.render.sprites[1].prefix = "goblin"
tt.render.sprites[1].shader = "p_tint"
tt.render.sprites[1].shader_args = {
	tint_factor = 0.5,
	tint_color = {
		0,
		0.85,
		1,
		1
	}
}
```

#### 1. 参数
```lua
1. tint_factor = 强度: 0-1,
2. tint_color = 颜色：RGBA（0-1）
```

#### 2. RGBA 颜色
RGB 代表 **红（Red）、绿（Green）、蓝（Blue）**，是一种通过三种基色光混合来呈现各种颜色的模式。 
RGBA 在 RGB 的基础上增加了一个通道（Alpha 通道），用于控制颜色的透明度。

RGBA 的值通常为 0-255 或 0-1，支持互相转换
GLSL ES 使用 0-1 颜色，Love 2D 使用 0-255 颜色

```lua
{
	红色 R: 0-1,
	绿色 G: 0-1,
	蓝色 B: 0-1,
	透明度 A: 0-1,
}
```

推荐使用调色板调整颜色：
[在线调色板，颜色选择器](https://www.sojson.com/web/panel.html)

### 6.10.2 p_outline - 描边
![[Pasted image 20260104162903.png|91]]
```lua
tt.render.sprites[1].shader = "p_outline"
tt.render.sprites[1].shader_args = {
	thickness = 3,
	outline_color = {
		0,
		0.85,
		1,
		1
	},
	samples = 2,
	threshold = 0.2
}
```

#### 参数
```lua
1. thickness = 轮廓厚度: num
2. outline_color = 轮廓颜色: RGBA（0-1）
3. samples = 采样密度: num
4. threshold = 不透明度阈值（0-1）
```

### 6.10.3 p_glow - 外发光
比描边平滑
![[Pasted image 20260104163440.png|89]]
```lua
tt.render.sprites[1].shader = "p_glow"
tt.render.sprites[1].shader_args = {
	thickness = 2,
	glow_color = {
		0,
		0.85,
		1,
		1
	},
	samples = 2
}
```
#### 参数
```lua
1. thickness = 轮廓厚度: num
2. glow_color = 轮廓发光颜色: RGBA（0-1）
3. samples = 采样密度: num
```