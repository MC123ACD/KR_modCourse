## 6.1 精灵
精灵（**sprite**）是游戏中最基本的图形对象，代表可在屏幕上移动、变换和显示动画的图像元素。具有坐标位置、尺寸、旋转角度等属性，并且可以显示动画序列的可视化图像对象
精灵通过前缀与动画名拼接播放动画控制其显示的图像

**核心特性：**
- 位置控制（坐标x, y）
- 尺寸和缩放
- 旋转角度
- 透明度
- 动画播放控制

```lua
tt.render.sprites[1].prefix = "prefix"
tt.render.sprites[1].name = "animation"
tt.render.sprites[1].scale = v(2, 2)	-- 缩放到此前的两倍
```
实际动画名：prefix_animation

### 6.1.1 常用精灵键

| <center>键</center> | 类型      | 描述                                             |
| ------------------ | ------- | ---------------------------------------------- |
| `animated`         | `bool`  | 精灵是否启用动画序列帧                                    |
| `name`             | `str`   | 动画名称（当 animated=true）或静态图像名称（当 animated=false） |
| `prefix`           | `str`   | 动画名称前缀，自动拼接到 name 前                            |
| `anchor`           | `vec2`  | 精灵锚点，控制旋转/缩放的中心点                               |
| `offset`           | `vec2`  | 相对于实体位置的偏移量                                    |
| `loop`             | `bool`  | 动画是否循环播放                                       |
| `scale`            | `vec2`  | 缩放比例                                           |
| `alpha`            | `0-255` | 透明度                                            |
| `r`                | `num`   | 旋转角度（弧度）                                       |
| `fps`              | `int`   | 帧率覆盖（每秒帧数）                                     |
| `hidden`           | `bool`  | 精灵是否隐藏                                         |
| `flip_x`           | `bool`  | 是否水平翻转精灵                                       |
| `flip_y`           | `bool`  | 是否垂直翻转精灵                                       |

所有键见 [[9. 键#精灵]]

## 6.2 动画（animation）
精灵播放动画时通过动画数据指定的帧，与图像名称前缀拼接获取具体显示的图像

所有动画数据都存于 `kr/data/animations` （一代为 `kr1/data/game_animations`）目录中。

### 6.2.1 动画数据结构
```lua
animation_a_name = {		-- 动画名称
	prefix = "image",		-- 图像名称前缀（不带_x序号）
	to = 10,				-- 动画结束帧
	from = 1				-- 动画起始帧
}
```
第一帧时精灵显示 image_1 图像，第二帧显示 image_2 图像，直到 image_10

### 6.2.2 animation_start - 播放动画
```lua
U.animation_start(
	实体: table, 
	动画名: str, 
	是否水平翻转: bool, 
	时间戳: num, 
	是否循环播放: bool, 
	精灵索引?: int, 
	强制重置时间戳: bool
)
```
- 原理是修改精灵的 `name` 后续动画名与精灵前缀拼接
- 精灵索引默认为 1

所有动画函数见 [[10. 工具函数#动画]]

#### 示例
```lua
-- 模板
tt.render.sprites[1].prefix = "hero_muyrn"
tt.melee.attacks[1] = CC("melee_attack")
tt.melee.attacks[1].hit_time = fts(9)
tt.melee.attacks[1].animation = "melee_attack"

-- 更新函数中
local ma = this.melee.attacks[1]
-- 实际播放动画 hero_muyrn .. melee_attack = hero_muyrn_melee_attack
U.animation_start(this, ma.animation, nil, store.tick_ts)
-- 播放后等待攻击前摇的时间（9帧）
U.y_wait(store, ma.hit_time)

-- 也可以使用 U.y_animation_wait(this) 等待动画播放完成
```

### 6.2.3 等待动画的三种方法
#### 1. y_wait - 协程等待
```lua
U.y_wait(store, 等待时间: num, 中断函数?: func) -> 是否被中断: bool
```
- 在指定时间内循环挂起协程
- 中断函数用于提前终止暂停

#### 2. y_animation_wait - 等待动画播放完成
```lua
U.y_animation_wait(实体: table, 精灵索引?: int, 播放次数?: int)
```
- 精灵索引默认为 1
- 播放次数默认为 1

##### 示例
```lua
-- 更新函数中
local ma = this.melee.attacks[1]
U.animation_start(this, ma.animation, nil, store.tick_ts)

-- 播放后等待动画播放完成
U.y_animation_wait(this) 
```

#### 3. y_animation_play - 播放并等待动画完成
```lua
U.y_animation_play(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数?: int, 精灵索引?: int)
```
- 是 `animation_start` 与 `y_animation_wait` 的结合
- 精灵索引默认为 1
- 播放次数默认值为 1

##### 示例
```lua
-- 更新函数中
local ma = this.melee.attacks[1]
U.y_animation_play(this, ma.animation, nil, store.tick_ts)
```

### 6.2.4 修改动画速度
由于原版（fps）不支持单独修改动画速度，所以需要手动扩展一下

修改 `all/animation_db` 的 `fni` 函数
```lua
function animation_db:fni(animation, time_offset, loop, fps, tick_length)
	-- 读取动画数据的 fps
	fps = a.fps or fps or self.fps
end
```

在动画数据增加 `fps` 键输入值即可
```lua
-- 修改 kr1/data/game_animations 中的电塔动画数据
tower_tesla_shoot = {
	prefix = "artillery_lvl4_tesla",
	to = 65,
	from = 1,
	fps = 60	-- 默认 fps 30，60 播放速度翻倍
},
```

## 6.3 图像（image）
图像（纹理）是游戏中所有视觉资源的基础，通过图集（Texture Atlas）系统进行高效管理和渲染。
模块位置：`lib/klove/image_db`
存储位置：`_assets/kr-desktop/images` （三代为 `kr3-desktop/assets/kr-desktop/images`）

### 6.3.1 为什么使用图集？
使用图集是游戏开发和图形应用中的一项重要优化技术，它通过将多个小纹理（如图片、图标、实体动画帧等）合并到一张大纹理中，带来多方面的性能与效率优势。

1. **减少绘制调用（Draw Call）**：可以在一次绘制调用中批量渲染纹理
2. **优化内存与加载**：多个小纹理单独存储时会有内存对齐浪费，同时大纹理的压缩比更高，加载速度更快
3. **避免纹理切换（Texture Switching）：切**换纹理需要 GPU 状态更新，使用图集后可连续渲染纹理，减少状态切换

### 6.3.2 图像数据结构
```lua
image_1 = {					-- 图像名称
	a_name = "atlas.dds",	-- 图集名称
	size = {		-- 图像原始大小（未裁剪透明边）
		200,		-- 长度
		100			-- 高度
	},
	trim = {		-- 裁剪的透明边
		10,			-- 左侧裁剪的长度
		20,			-- 上方裁剪的长度
		15,			-- 右侧裁剪的长度
		25			-- 下方裁剪的长度
	},
	a_size = {		-- 图集大小
		2048,		-- 长度
		2048		-- 高度
	},
	f_quad = {		-- 从图集指定位置得到图像
		1000,		-- x
		500,		-- y
		175,		-- 长度
		55			-- 高度
	},
	alias = {		-- 别名
		"image_2"	-- 也可以通过 image_2 索引这个图像
	}
}
```

示意图：
![[Pasted image 20251229202055.png|850]]

### 6.3.3 修改图集
使用 KR_Tools 内的拆分图集工具修改后再使用合并图集工具合并为图集

#### 1. 拆分图集
将图集与数据放入 `input`，运行拆分图集脚本即可
![[Pasted image 20251230094853.png|420]]
在 `output` 即可找到拆出的图集
![[Pasted image 20251230095159.png|550]]

#### 2. 合并图集
修改后将图集文件夹放入 `input` 运行合并图集脚本，同理在 `output` 即可找到图集与图集数据，然后替换原图即可
![[Pasted image 20260105103018.png|425]]
![[Pasted image 20260105194135.png|111]]
### 6.3.4 锚点（anchor）
使用 KR_Tools 内的锚点测量工具

打开图像拖动红色十字调整锚点

`ctrl + 拖动` 可以调整参照点，用于计算相对于锚点的偏移（offset）
![[Pasted image 20251230095839.png|700]]

## 6.4 补间动画（tween）
根据精灵起点与终点的参数补足中间过渡帧的动画，称为补间动画（**Tween Animation**）
补间动画可当做关键帧，用于过渡，淡出淡入、平滑移动等

### 6.4.1 使用方法
首先增加 `tween` 补间动画组件，在 `keys` 指定关键帧，在 `name` 指定精灵键，在 `sprite_id` 指定目标精灵。

**默认值**：
- `name`：`alpha`
- `sprite_id`：`1`
```lua
-- 透明度
AC(tt, "tween")	-- 增加组件
tt.tween.props[1].keys = {
	{
		0,	
		255	-- 默认不透明
	},
	{
		1,
		0	-- 1 秒时完全透明
	}
}
tt.tween.props[1].sprite_id = 2	-- 补间的精灵，支持数字或表

-- 缩放
tt.tween.props[1].name = "scale"	-- 缩放
tt.tween.props[1].keys = {
	{
		0,
		v(1, 1)
	},
	{
		5,			-- 从 0 秒到 5 秒缓慢放大精灵到此前的两倍
		v(2, 2)
	}
}
```

### 6.4.2 淡出淡入
```lua
AC(tt, "tween")
tt.tween.props[1].keys = {
	{
		0,	-- 默认透明度 0
		255
	},
	{
		1,	-- 1 秒时完全淡出
		0
	},
	{
		2,	-- 2 秒时完全淡入
		255
	}
}
tt.tween.props[1].sprite_id = {	-- 补间的精灵，可以直接用数字或表
	1,
	2,
	...
}
tt.tween.remove = false			-- 禁用播放后移除
tt.tween.props[1].loop = true	-- 循环播放
```

## 6.5 声音（sound）
声音资源存储于 `_assets/kr-desktop/sounds` （三代为 `kr3-desktop/assets/kr-desktop/sounds`）目录中。

**其中**：
- `sounds` 为单个声音
- `groups` 为声音组
- `settings` 用于指定声音最大来源
- `files` 声音资源

### 6.5.1 声音数据结构

#### 1. sounds
```lua
声音名称 = {
	loop = 是否循环播放: bool,
	mode = 播放模式: str,
	gain = 声音增益: num,
	source_group = 来源组: str,
	files = {
		声音文件名: str
	}
}
```

#### 2. groups
```lua
组名 = {
	files = {
		声音文件名: str
	}
}
```

### 6.5.2 声音函数
声音模块位于 `all/sound_db` （缩写 S）中

#### 1. 将声音加入播放队列
```lua
S:queue(声音名称: str, 声音参数?: table)
```
- 同样会分配唯一 ID

##### 可选声音参数
```lua
1. gain: 声音大小: num|list{最小范围: num, 最大范围: num}
2. seek: 从指定位置开始播放（秒）: num
3. delay: 延迟（秒）: num
4. chance: 播放概率: num
5. every: 每N次请求播放一次: int
6. ignore: 播放声音间隔: num
7. ref_counted: 是否引用计数: bool
8. mode: 播放模式: 按顺序播放: "sequence"|随机选择一个播放: "random"|同时播放所有: "concurrent"
```
- 引用计数用于管理多个相同声音实例

##### 示例
```lua
-- 模板
tt.melee.attacks[1] = CC("melee_attack")
tt.melee.attacks[1].sound = "HeroNyruBasicAttackMelee"
tt.melee.attacks[1].sound_args = {
	delay = 1	-- 延迟 1 秒播放
}

-- 更新函数中
local ma = this.melee.attacks[1]
S:queue(ma.sound, ma.sound_args)
```

#### 2. 停止播放声音
```lua
S:stop(声音名称: str)
```

## 6.6 加载资源
为了性能游戏通常只会加载 `required_textures` 纹理与 `required_sounds` 声音中指定的资源

### 6.6.1 位置
通常在以下位置指定需要的资源

#### 1. 关卡
在关卡数据与 `all/game` 中指定

```lua
-- level01_data
required_sounds = {
	"music_stage01",
	...
},
required_textures = {
	"go_stage01_bg",
	"go_stage01",
	...
}
```

```lua
-- all/game
game.required_textures = {
	"go_decals",
	"go_enemies_common",
	"go_towers"
}
game.required_sounds = {
	"common"
}
```

#### 2. 其他界面
通常在相应界面的模块内

```lua
-- 游戏界面 game_gui
game_gui.required_textures = {
	"gui_common",
	"gui_portraits",
	...
}
```

```lua
-- 地图界面 screen_map
screen_map.required_sounds = {
	"common",
	"music_screen_map"
}
screen_map.required_textures = {
	"screen_map",
	"screen_map_bg",
	...
}
```

## 6.7 图像格式区别

### 6.7.1 PNG
**质量优先**：无损高质量，读取时**需要解压**，内存占用大，加载速度较慢
**通用性强**：支持多种平台，手机安卓，电脑 Win 等

### 6.7.2 DDS BC
**性能优先**：有损压缩，实时渲染，读取**不需要解压**，内存占用少，加载速度快
**通用性一般**：支持多种平台，部分 CPU 不支持

**BC3**
- 质量较低，支持较旧设备
**BC7**
- 高质量

## 6.8 国际化文本（i18n）
国际化通常简称为 i18n（**Internationalization**），是指支持多语言的框架和结构，主要是将代码与文本分离，将所有需要翻译的文本从源代码中提取出来，存放在独立的资源文件中。

国际化资源文件存储于 `_assets/kr-desktop/strings` （三代为 `kr3-desktop/assets/kr-desktop/string`）目录中。
模块存储于 `all/i18n`

```lua
tt.info.i18n_key = "ENEMY_GOBLIN"	-- 文本标识 ENEMY_GOBLIN，对应中文文本哥布林，英文文本 goblin
```

### 6.8.1 命名
不同语言的国际化资源文件通过语言标签（Language Tag）命名，这里仅说明常用语言
1. **zh-Hans**：简体中文
2. **zh-Hant**：繁体中文
3. **en**：英文

### 6.8.2 排序文本
由于文本过于混乱可以使用 KR_Tools 中的排序表工具进行排序。

使用方法同上，放入 `input` 运行

### 6.8.3 常用函数

#### 1. 根据当前语言返回相应值
```lua
i18n:cjk(默认: any, 中文: any, 日语: any, 韩语: any) -> 相应语言的值: any
```
- 仅支持中日韩语言

#### 2. 根据文本标识获取相应国际化文本
```lua
_(文本标识: str, 默认值: str) -> 相应国际化文本
```

## 6.9 字体（font）
字体系统用于管理游戏中的文本渲染，支持多语言、自定义字体样式和文本格式化。

字体存储位置：`_assets/all-desktop/fonts`（三代为 `all-desktop\assets\fonts`）
模块位置：`lib/klove/font_db`
数据位置：`all-desktop/data/font_subst`

### 6.9.1 字体数据格式
```lua
语言标签 = {
	{
		字体别名: str,
		字体文件名: str,
		{
			size = 1.2: num		-- 字体大小系数
		}
	}
}
```

### 6.9.1 修改字体
将字体文件放入 `_assets/all-desktop/fonts` 中，修改字体数据即可

可以在以下网站下载字体
[字体天下](https://www.fonts.net.cn/)
[猫啃网](https://www.maoken.com/)

以流行点阵体为例：
![[Pasted image 20260104154827.png]]
```lua
-- 修改简体中文语言的主体字体
["zh-Hans"] = {
	{
		"body",		-- 字体别名：主体
		"FashionBitmap16_0.091",	-- 字体文件名
		{
			size = 1.2		-- 字体大小系数
		}
	}
}
```
![[Pasted image 20260104155126.png|424]]
如果出现乱码则表示字体缺少对应文字或游戏不支持，请换个字体

## 6.10 着色器（shader）
着色器是用于控制图形渲染管线中顶点和像素处理的程序，能够实现高级视觉效果、后处理特效和自定义渲染逻辑。

着色器存储位置：`_assets/all-desktop/shaders` （三代为 `all-desktop\assets\shaders`）
模块位置：`lib/klove/shader_db`

着色器使用 GLSL ES（**OpenGL ES Shading Language**）语言编写

### 6.10.1 p_tint - 色彩
以哥布林精灵改为蓝色为例：
![[Pasted image 20260104162248.png|89]]
```lua
-- 模板
tt = RT("enemy_goblin", "enemy")

-- 着色器名称
tt.render.sprites[1].anchor = v(0.5, anchor_y)
tt.render.sprites[1].prefix = "goblin"
tt.render.sprites[1].shader = "p_tint"
tt.render.sprites[1].shader_args = {
	tint_factor = 0.5,
	tint_color = {
		0,
		0.85,
		1,
		1
	}
}
```

#### 1. 参数
```lua
1. tint_factor = 强度: 0-1,
2. tint_color = 颜色：RGBA（0-1）
```

#### 2. RGBA 颜色
RGB 代表 **红（Red）、绿（Green）、蓝（Blue）**，是一种通过三种基色光混合来呈现各种颜色的模式。 
RGBA 在 RGB 的基础上增加了一个通道（Alpha 通道），用于控制颜色的透明度。

RGBA 的值通常为 0-255 或 0-1，支持互相转换
GLSL ES 使用 0-1 颜色，Love 2D 使用 0-255 颜色

```lua
{
	红色 R: 0-1,
	绿色 G: 0-1,
	蓝色 B: 0-1,
	透明度 A: 0-1,
}
```

推荐使用调色板调整颜色：
[在线调色板，颜色选择器](https://www.sojson.com/web/panel.html)

### 6.10.2 p_outline - 描边
![[Pasted image 20260104162903.png|91]]
```lua
tt.render.sprites[1].shader = "p_outline"
tt.render.sprites[1].shader_args = {
	thickness = 3,
	outline_color = {
		0,
		0.85,
		1,
		1
	},
	samples = 2,
	threshold = 0.2
}
```

#### 参数
```lua
1. thickness = 轮廓厚度: num
2. outline_color = 轮廓颜色: RGBA（0-1）
3. samples = 采样密度: num
4. threshold = 不透明度阈值（0-1）
```

### 6.10.3 p_glow - 外发光
比描边平滑
![[Pasted image 20260104163440.png|89]]
```lua
tt.render.sprites[1].shader = "p_glow"
tt.render.sprites[1].shader_args = {
	thickness = 2,
	glow_color = {
		0,
		0.85,
		1,
		1
	},
	samples = 2
}
```
#### 参数
```lua
1. thickness = 轮廓厚度: num
2. glow_color = 轮廓发光颜色: RGBA（0-1）
3. samples = 采样密度: num
```

## 6.11 粒子（particle）
粒子系统是用于创建动态视觉效果的核心工具，能够模拟火焰、烟雾、魔法、爆炸、闪电、雨雪等复杂特效。通过控制粒子的发射、运动、外观和生命周期，可以创造出丰富多样的动态效果。

### 6.11.1 常用粒子键

| 键                   | 类型              | 描述                                                  |
| ------------------- | --------------- | --------------------------------------------------- |
| `animated`          | `bool`          | 粒子是否使用动画序列（如爆炸序列帧）而非静态图像                            |
| `name`              | `str`           | 粒子图像或动画名称（当没有 `names` 列表时使用）                        |
| `scale_var`         | `list{num...}`  | 缩放变化范围，如 `{0.5, 1.5}` 表示随机缩放0.5-1.5倍                |
| `anchor`            | `vec2`          | 粒子精灵的锚点（中心点），`(0.5, 0.5)` 表示中心，`(0, 0)` 表示左上角       |
| `loop`              | `bool`          | 粒子动画是否循环播放                                          |
| `particle_lifetime` | `list{num...}`  | 粒子生命周期范围（秒），如 `{0.9, 1}` 表示0.9-1秒随机                 |
| `alphas`            | `list{int}`     | 粒子生命周期中透明度变化值，支持插值（如 `{255, 128, 0}` 表示从透明到不透明再到透明） |
| `animation_fps`     | `int`           | 动画播放速度（帧/秒），当 `animated=true` 时生效                   |
| `emission_rate`     | `int`           | 每秒发射粒子数量（发射频率）                                      |
| `emit_area_spread`  | `vec2`          | 发射区域范围（矩形区域），粒子在区域内随机位置生成                           |
| `emit_duration`     | `num`           | 发射持续时间（秒），`nil` 表示无限发射                              |
| `emit_direction`    | `num`           | 发射角度（弧度），0为向右，π/2为向下                                |
| `emit_rotation`     | `num`           | 粒子的初始旋转角度（弧度）                                       |
| `emit_speed`        | `list{num...}`  | 粒子发射速度范围，如 `{100, 200}` 表示速度在100-200之间随机            |
| `emit_spread`       | `num`           | 发射方向的随机变化范围（弧度）                                     |
| `emit_offset`       | `vec2`          | 发射位置相对于实体位置的偏移                                      |
| `spin`              | `table{num...}` | 粒子旋转速度范围（弧度/秒），如 `{-1, 1}` 表示随机旋转方向                 |
| `track_id`          | `int`           | 要跟踪的目标实体ID，粒子系统会跟随该实体                               |
| `track_offset`      | `vec2`          | 相对于跟踪实体的偏移位置                                        |

所有键见 [[9. 键#粒子]]

### 6.11.2 使用
（黄色动态为粒子）
![[Pasted image 20260106162906.png|131]]
```lua
-- 创建模板
tt = RT("ps_bolt_sorcerer", "particle_system")
-- 使用静态图像
tt.particle_system.animated = false
-- 静态图像名
tt.particle_system.name = "sorcererbolt_particle"
-- 发射范围 6x6 矩形
tt.particle_system.emit_area_spread = v(6, 6)
-- 发射频率 60/秒
tt.particle_system.emission_rate = 60
-- 生命周期 2-5 帧
tt.particle_system.particle_lifetime = {
	fts(2),
	fts(5)
}
-- 初始旋转弧度
tt.particle_system.rotation_spread = math.pi
-- 透明度 0-255
tt.particle_system.alphas = {
	255,
	0
}
-- 缩放比例 0.6-0.8
tt.particle_system.scale_var = {
	0.8,
	0.6
}
-- 发射出去后随机变化缩放比例在 0.3-1 范围
tt.particle_system.scales_x = {
	1,
	0.3
}
tt.particle_system.scales_y = {
	1,
	0.3
}

-- 爵士更新函数
function scripts.hero_gerald.update(this, store)
	while true do
		if h.dead then
			-- 死亡时创建粒子
			local ps = E:create_entity("ps_bolt_sorcerer")
			-- 跟踪实体
			ps.particle_system.track_id = this.id

			queue_insert(store, ps)

			SU.y_hero_death_and_respawn(store, this)
		end
		...
	end
	...
end
```