
## 5.1 科技树
模块位置：`kr/upgrades`

科技名称见 [[7. 科技树与能力]]

其整体思路为给模板赋值
```lua
-- 获取指定名称的升级科技（如果该升级已解锁且有效）
function upgrades:get_upgrade(name)
	local u = self.list[name]

	-- 检查升级是否存在且符合解锁条件：
	-- 1. 升级数据存在
	-- 2. 升级等级不超过该科技类别的当前等级
	-- 3. 升级等级不超过最大等级限制（如果存在最大等级限制）
	if not u or u.level > self.levels[u.class] or not self.max_level or u.level > self.max_level then
		return nil
	else
		return u
	end
end

-- 一代箭塔科技：鹰眼（增加射程）
-- 获取鹰眼升级数据（该升级会增加箭塔和相关单位的射程）
u = self:get_upgrade("archer_eagle_eye")

if u then
	-- 对指定箭塔列表中的每个箭塔应用射程加成
	for _, n in pairs(archer_towers) do
		-- 获取箭塔模板并增加其攻击射程
		T(n).attacks.range = T(n).attacks.range * u.range_factor
	end

	-- 1. 游侠荆棘光环：增加光环作用半径
	T("aura_ranger_thorn").aura.radius = T("aura_ranger_thorn").aura.radius * u.range_factor
	
	-- 2. 火枪：增加第2-4个技能的射程
	T("tower_musketeer").attacks.list[2].range = T("tower_musketeer").attacks.list[2].range * u.range_factor
	T("tower_musketeer").attacks.list[3].range = T("tower_musketeer").attacks.list[3].range * u.range_factor
	T("tower_musketeer").attacks.list[4].range = T("tower_musketeer").attacks.list[4].range * u.range_factor
end
```

### 5.1.1 科技列表结构
```lua
upgrades.list = {
	archer_eagle_eye = {
		archer_eagle_eye = 0.9,-- 科技相关变量
		class = "archers",		-- 属于哪个科技树
		price = 1,				-- 星星价格
		level = 2,				-- 科技等级
		ico = DP(14, 7)			-- 图标
	}
}
```

## 5.2 游戏设定
游戏设定用于存储关卡部分信息、游戏难度的差异、图鉴部分数据等

模块位置：`kr/game_settings`

### 5.2.1 结构

#### 1. 难度相关
```lua
-- 索引对应相应难度: 1 为新兵、2 为普通、3 为老兵、4 为不可能
GS.difficulty_enemy_hp_max_factor = {	-- 不同难度下的敌人血量倍率
	0.8,	-- 新兵
	1,		-- 普通
	1.2		-- 老兵
}
GS.difficulty_enemy_speed_factor = {	-- 不同难度下的敌人速度倍率
	1.28,
	1.28,
	1.28
}
GS.difficulty_soldier_hp_max_factor = {	-- 不同难度下的士兵血量倍率
	1.2,
	1,
	1
}
GS.hero_xp_gain_per_difficulty_mode = {	-- 不同难度下的英雄经验获取倍率
	1,
	1,
	1
}
GS.hero_xp_thresholds = {		-- 英雄不同等级需要的经验数量
	300,
	900,
	2000,
	4000,
	8000,
	12000,
	16000,
	20000,
	26000
}
```

#### 2. 关卡相关
```lua
-- 最大支线关卡数
GS.main_campaign_levels = 12
-- 最后一关编号
GS.last_level = 26

-- 关卡解锁
GS.level_ranges = {
	{		-- 主线，按顺序解锁 1-12 关
		1,
		12
	},
	{		-- 蜘蛛支线，所有支线第一关在主线通关后会全部解锁
		13
	},
	{		-- 兽人支线
		14
	},
	{		-- 沼泽与蘑菇人支线，list 表示 15 关通关后仅解锁 22 关，而不是 15-22 按顺序解锁
		15,
		22,
		list = true
	},
	{		-- 强盗支线，16 关通关后解锁 17 关
		16,
		17
	},
	{		-- 巨魔支线
		18,
		19
	},
	{		-- 恶魔支线
		20,
		21
	},
	{		-- 万圣节支线
		23,
		26
	}
}
```

## 5.3 难度设定
难度设定（缩写 DI）用于设置不同难度下的实体模板数据

模块位置：`all/difficulty`

思路同上
```lua
function difficulty:patch_templates()
    -- 内部工具函数：根据难度应用难度相关的数值调整
    -- 如果 t[key] 是表，则根据当前难度等级选择对应的值
    -- 难度索引对应：1=简单，2=普通，3=困难
    local function PT(t, key)
        if t and t[key] and type(t[key]) == "table" then
            -- 获取当前难度对应的值，如果没有则默认使用困难难度（索引3）的值
            t[key] = t[key][self.level] or t[key][3]
            return true  -- 表示已处理
        end
        return false  -- 表示未处理
    end

    -- 获取当前难度下士兵的血量乘数
    local hp_factor_soldier = GS.difficulty_soldier_hp_max_factor[self.level]

	-- E:filter_templates 用于获取具有相应键的所有模板
    for _, t in pairs(E:filter_templates("soldier")) do
        -- 情况1：英雄单位 - 处理所有等级的血量
        if t.hero and t.hero.level_stats and t.hero.level_stats.hp_max then
            local m = t.hero.level_stats.hp_max
            for i = 1, #m do
                m[i] = math.floor(m[i] * hp_factor_soldier)  -- 应用血量乘数
            end
        
        -- 情况2：普通士兵 - 尝试使用PT函数处理
        elseif not PT(t.health, "hp_max") then
            -- PT返回false时，检查并直接应用乘数
            if not t.health.hp_max then
                log.debug("模板 %s 中没有 hp_max 字段", t.template_name)
            else
                t.health.hp_max = math.floor(t.health.hp_max * hp_factor_soldier)
            end
        end
    end
end
```