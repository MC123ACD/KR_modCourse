## 4.1 关卡数据
关卡中所有数据存储于 `kr/data/levels` 中

**其中**：
1. 无后缀为关卡的函数
2. `_data` 为关卡参数
3. `_paths` 为路径数据
4. `_gird` 为网格数据

### 结构：
```lua
locked_hero = 是否锁定英雄: bool,
max_upgrade_level = 科技最大等级: int,
locked_towers = {		-- 锁定的防御塔
	防御塔模板名 1: str,
	-- 防御塔模板名 2...
},
available_towers = {		-- 可用的防御塔（五代可用）
	防御塔模板名 1: str,
	-- 防御塔模板名 2...
},
locked_powers {				-- 锁定的能力
	是否锁定对应索引的能力: bool
},
entities_list = {			-- 进入关卡创建的实体
	{		-- 实体 1
		template = 创建的实体模板名: str,
		pos = 实体位置: vec2,
		
	},
	-- 实体 2...
},
level_mode_overrides = {	-- 不同模式覆盖的键（战役模式索引为 1、英雄为 2、钢铁为 3）
	{},		-- 战役模式
	{		-- 英雄模式
		max_upgrade_level = 2	-- 英雄模式下科技最大等级 2
	}
},
required_sounds = {			-- 加载的音效资源
	资源 1 名称: str,
	-- 资源 2 名称...
},
required_textures = {		-- 加载的纹理
	资源 1 名称: str,
	-- 资源 2 名称...
}
required_exoskeletons = {	-- 加载的骨骼动画资源
	资源 1 名称: str,
	-- 资源 2 名称...
}
```

## 4.2 路径（path）
路径用于规定怪物的行走路线，缩写为 P

**存储位置**：`all/path_db` 的 `paths` 表中
**数据位置**：`kr/data/levels` 中的关卡路径数据（`_paths`）

**路径中**：
1. `ni` 为节点索引（**node index**），即一条路径中的位置
2. `pi` 为路径索引（**path index**），即不同路径
3. `spi` 为子路径索引（**subpath index**），即路径中的三个分支
![[Pasted image 20250812125430.png]]
如图所示一条路径有三条子路径，白点为节点，关卡内按 `H` 即可显示路径

路径函数见[[总结/4. 关卡#路径函数]]

### 4.2.1 随机在路径上召唤实体
在 `level_data` 的 `entities_list` 增加一个实体，在这个实体更新函数写召唤逻辑即可

#### 示例
```lua
-- 模板
tt = RT("s_spawner_entities")
AC(tt, "main_script", "editor")
tt.main_script.update = scripts.s_spawner_entities.update
tt.ts = 0
tt.entity = "enemy_halloween_zombie"	-- 召唤的实体
tt.spawn_margin = {
	30,	-- 距离起点边距
	60	-- 距离终点边距
}
tt.spawn_cooldown = 3	-- 召唤间隔
tt.spawn_count = 1		-- 召唤数量
tt.spawn_wave = 1		-- 开始召唤的波次
tt.spawn_path = {		-- 生成的路径
	1,
	2,
	3
}
tt.enemy_gold = 0.5	-- 召唤的敌人赏金乘数

-- 函数
scripts.s_spawner_entities = {}
function scripts.s_spawner_entities.update(this, store)
	local pi, spi, ni
	local p_pi, p_spi = this.spawn_path, { 1, 2, 3 }
	local start_margin, end_margin = unpack(this.spawn_margin)

	while true do
		if store.waves_finished then
			break
		end

		-- 计算召唤间隔
		if store.wave_group_number >= this.spawn_wave and this.spawn_cooldown < store.tick_ts - this.ts then
			this.ts = store.tick_ts
			for i = 1, this.spawn_count do
				-- 取随机路径上随机节点
				pi, spi = table.random(p_pi), table.random(p_spi)
				ni = math.random(P:get_start_node(pi) + start_margin, P:get_end_node(pi) - end_margin)

				-- 召唤实体
				local e = E:create_entity(this.entity)
				e.pos = P:node_pos(pi, spi, ni)
				e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = pi, spi, ni
				e.render.sprites[1].name = "raise"
				e.enemy.gold = e.enemy.gold * this.enemy_gold
				queue_insert(store, e)
			end
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

-- 关卡数据
entities_list = {
	{
		template = "s_spawner_entities",
		pos = {
			x = 0,
			y = 0
		}
	}
	...
}
```

## 4.3 网格（grid）
网格用于通过设定单元格类型来设定地形，例如水路、冰面等。实体可以通过判断地形来进行一些逻辑，例如判断脚下地形如果是冰面则开始滑冰增加移动速度。网格同时也会规范寻路。

网格缩写为 GR
![[Pasted image 20251223100412.png|600]]
如图所示绿色部分的单元格类型为不可移动，修改英雄集结点英雄只会在灰色部分寻路，关卡内按 `g` 显示网格

**存储位置**：`all/grid_db` 的 `grid` 表中
**数据位置**：`kr/data/levels` 中的关卡网格数据（`_grid`）

网格函数见[[总结/4. 关卡#网格函数]]

## 4.4 关卡编辑器的使用
在 `args` 取消 `screen` 与 `custom` 的注释， `custom` 输入要编辑的关卡的编号运行后即可进入关卡编辑器
![[Pasted image 20250712192159.png|500]]
### 4.4.1 基础介绍
![[Pasted image 20260101133538.png|167]]
1. **Level name**：关卡编号
2. **Game mode**：游戏模式，1 战役，2 英雄，3 钢铁
3. **save**：保存修改
4. **load**：修改关卡编号后加载相应关卡
5. **entities**：实体相关，塔位关卡场景实体等
6. **paths**：路径，敌人行走路线
7. **grid**：网格，地形
8. **nav**：塔位导航

### 4.4.2 修改塔位与增加实体
点击 entities 选项，点击实体下的加号选择实体，右键取消选择，拖动即可移动
![[Pasted image 20260101133458.png|875]]
**选项**：
1. **delete**：删除选择的实体
2. **duplicate**：复制实体
3. **Id**：实体标识
4. **Template**：模板名
5. **pos**：坐标位置

原理为修改关卡数据

#### 增加实体
写入模板名，insert 插入即可
![[Pasted image 20260101134608.png]]
1. **Template**：模板名
2. **search**：搜索相关模板名
3. **insert**：插入模板名的实体

注：插入塔位会同时插入名为 `editor_rally_point` 的默认集结点

### 4.4.3 修改路径
点击 paths 选项选择路径，拖动路径节点即可修改路径
![[Pasted image 20260101135137.png]]
**路径相关选项**：
1. **create**：创建新路径
2. **remove**：移除路径
3. **move up、move down**：上移下移路径
4. **duplicate**：复制路径
5. **flip**：镜像路径
6. **preview points**：显示子路径与路径节点
7. **active**：是否启用路径
8. **Connects to**：连接的路径

**节点相关选项**：
1. **Node id**：选择的节点 id
2. **pos**：选择的节点位置
3. **node width**：选择的节点宽度
4. **subdivide**：细分选择的节点
5. **extend**：扩充选择的节点
6. **remove**：移除选择的节点

### 4.4.4 网格
点击 grid 选项，选择地形类型在地图上绘制网格
![[Pasted image 20260101141903.png]]
1. **Brush size**：画笔大小
2. **size**：单元格大小
3. **offset**：网格中心点偏移

网格类型见 [[3. 常量#地形]]

## 4.5 波次数据
波次的所有数据存储于 `kr/data/waves` 中

**其中**：
1. `_campaign` 为战役模式（1）
2. `_heroic` 为英雄模式（2）
3. `_iron` 为钢铁模式（3）

### 4.5.1 结构
```lua
cash = 初始金币: int,
groups = {		-- 所有波次
	{			-- 第 1 波
		interval = 下一波到来时间: num,
		waves = {		-- 出怪组
			{			-- 第 1 组
				delay = 延迟: num,
				path_index = 出怪路径: int,
				spawns = {		-- 生成的怪物
					{			-- 怪物 1
						interval = 生成间隔: num,
						creep = 怪物模板名: str,
						creep_aux = 交替怪物模板名: str,	-- 每次出 max_same 数量的怪交替怪物
						max_same = 交替数量: int,
						max = 出怪总数量: int,			-- 包含交替的怪物
						fixed_sub_path = 出怪子路径: int,	-- 0 为随机 1-3，1 为 path 指定的子路径
						path = 子路径: int,				-- 用于 fixed_sub_path
						interval_next = 下一个怪物的延迟: num
					},
					-- 怪物 2...
				}
			},
			-- 第 2 组...
		}
	},
	-- 第 2 波...
}
```
- 时间单位为游戏帧
- 所有出怪组都是并发的，使用出怪组延迟控制
- 出怪组一般用于多个怪物组合进攻与进攻不同路径
- 交替出怪用于两种不同怪物轮流进攻
- 每个组的怪物只有前一个出完才会出下一个

### 4.5.2 修改出怪
由于出怪数据的表不易于查看修改，推荐使用 KR_Tools 的波次生成脚本修改
> https://wwuk.lanzouo.com/b007u3i2jg  
> 密码:fv51

![[Pasted image 20250828164236.png|750]]


![[Pasted image 20250828164839.png|550]]
数字改成你修改的关卡编号，然后直接替换波次数据即可.

### 4.5.3 加载资源
在关卡数据的 `required_textures` 键增加对应资源即可。
```lua
required_textures = {
	"go_enemies_bandits",	-- 强盗支线的所有怪物资源
	...
}
```
图像资源基本都在 `_assets/kr-desktop/images/fullhd` 内

注：有些实体的资源在关卡资源内

## 4.6 特殊出怪
特殊出怪数据位于 `kr/data/levels/levelxx_spawner` 中

### 4.6.1 正常出怪模式
#### 结构
```lua
groups = {		-- 组
	{			-- 组 1
		可能出怪点位 1: int,
		-- 可能出怪点位 2...
	},
	-- 组 2...
},
points = {		-- 出怪点位
	{			-- 点位 1
		path = int,		-- 生成路径
		from = vec2,	-- 生成位置
		to = vec2		-- 实际生成节点位置
	},
	-- 点位 2...
},
waves = {	-- 生成的波次
	{		-- 战役模式（战役 1，英雄 2，钢铁 3）的生成
		{	-- 第 1 波
			{	-- 出怪 1
				延迟: num,
				延迟随机变化值: num,
				组: int,
				生成子路径: int,
				生成数量: int,
				是否所有点位同时出怪: bool,
				顺序生成/并行生成: bool,
				出怪随机间隔最小值: num,
				出怪随机间隔最大值: num,
				生成怪物模板名: str,
				自定义参数: any
			},
			-- 出怪 2...
		},
		-- 第二波...
	},
	-- 英雄模式的生成...
}
```

#### 示例
```lua
-- 关卡数据
entities_list = {
	{	-- 加载的特殊出怪数据
		template = "mega_spawner",
		load_file = "level417_spawner",	-- 特殊出怪文件名
	}
}

-- 特殊出怪数据
groups = {		-- 组
	{
		1		-- 组 1 生成在点位 1
	}
},
points = {		-- 点位
	{			-- 点位 1
		path = 3,	-- 位于路径 3
		from = {	-- 点位坐标
			x = 260,
			y = 147
		},
		to = {
			x = 260,
			y = 147
		}
	}
},
waves = {			-- 生成的波次
	[1] = {			-- 战役模式
		[3] = {		-- 第 3 波
			{
				2.6,		-- 延迟 2.6 秒
				0,			-- 延迟不随机变化
				1,			-- 组 1
				1,			-- 生成到子路径 1
				1,			-- 生成 1 个
				false,		-- 所有点位不同时出怪
				true,		-- 顺序出怪
				4,
				4,			-- 出怪随机间隔 4 ~ 4
				"enemy_chaser"	-- 怪物模板名
			}
		}
	}
}
```

### 4.6.2 出怪包模式
包可以理解为模板，提前创建，后续快速使用。缺点是无法指定点位，只能生成在起点节点

#### 结构
```lua
packs = {		-- 包
	包 1 名称 = {
		{	-- 出怪 1
			延迟: num,
			延迟随机变化值: num,
			nil,
			生成子路径: int,
			生成数量: int,
			nil,
			nil,
			出怪随机间隔最小值: num,
			出怪随机间隔最大值: num,
			生成怪物模板名: str
		}
		-- 出怪 2...
	},
	-- 包 2...
},
waves = {	-- 生成的波次
	{		-- 战役模式（战役 1，英雄 2，钢铁 3）的生成
		{	-- 第 1 波
			{	-- 出怪 1
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				"PACK",		-- 生成怪物模板名改为 "PACK"
				{
					spawnPackId = 生成的包名: str,
					path = 生成路径: int
				}
			},
			-- 出怪 2...
		},
		-- 第二波...
	},
	-- 英雄模式的生成...
}
```


#### 示例
```lua
-- 关卡数据
entities_list = {
	{	-- 加载的特殊出怪数据
		template = "mega_spawner",
		load_file = "level417_spawner",
	}
}

-- 特殊出怪数据
packs = {		-- 包
	frogs = {
		{
			0,				-- 延迟 0 帧
			0,				-- 延迟不随机变化
			nil,
			1,				-- 生成到子路径 1
			1,				-- 生成 1 个
			nil,
			nil,
			4,
			4,				-- 出怪随机间隔 4 ~ 4
			"enemy_chaser"	-- 怪物模板名 "enemy_chaser"
		},
		{
			2,				-- 延迟 2 帧
			0,				-- 延迟不随机变化
			nil,
			1,				-- 生成到子路径 1
			10,				-- 生成 10 个
			nil,
			nil,
			4,
			4,				-- 出怪随机间隔 4 ~ 4
			"enemy_chaser"	-- 怪物模板名 "enemy_chaser"
		},
	}
}
waves = {			-- 生成的波次
	[1] = {			-- 战役模式
		[3] = {		-- 第 3 波
			{
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				"PACK",	-- 出怪包模式
				{
					spawnPackId = "frogs",	-- 生成包 "frogs" 的怪物
					path = 1				-- 生成路径
				}
			}
		}
	}
}
```

### 4.6.3 生成器出怪模式
通常用于给一些生成器实体发送出怪信号，用于检查是否正在出怪，播放动画等

#### 结构
```lua
groups = {		-- 组
	组名 = {
		生成器名称1: str,
		-- 生成器名称2...
	}
},
waves = {	-- 生成的波次
	{		-- 战役模式（战役 1，英雄 2，钢铁 3）的生成
		{	-- 第一波
			{	-- 出怪 1
				延迟: num,
				延迟随机变化值: num,
				组: int,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				"CUSTOM",		-- 生成怪物模板名改为 "CUSTOM"
				为生成器的 spawner.spawn_data 键传递的数据: any
			},
			-- 出怪 2...
		},
		-- 第二波...
	},
	-- 英雄模式的生成
}
```

#### 示例
```lua
-- 关卡数据
entities_list = {
	{
		template = "bullywag_spawner",
		pos = {
			x = 260,
			y = 147
		},
		["spawner.name"] = "object1"
	},
	{	-- 加载的特殊出怪数据
		template = "mega_spawner",
		load_file = "level417_spawner",
	},
},

-- 特殊出怪数据
groups = {		-- 组
	{
		1		-- 组 1 生成在点位 1
	},
	som1 = {
		"object1",	-- 组 "som1" 为 "object1" 也就是 "bullywag_spawner" 传递数据
	}
},
points = {		-- 点位
	{			-- 点位 1
		path = 3,	-- 位于路径 3
		from = {	-- 点位坐标
			x = 260,
			y = 147
		},
		to = {
			x = 260,
			y = 147
		}
	}
},
waves = {			-- 生成的波次
	[1] = {			-- 战役模式
		[3] = {		-- 第 3 波
			{		-- 出怪前 1.6 秒（动画时间）给 "som1" 组内的所有生成器传递 true
				1,			-- 延迟
				0,			-- 延迟随机变化值
				"som1",		-- 组 "som1"
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				"CUSTOM",	-- 生成器模式
				true		-- 为生成器的 spawner.spawn_data 键传递的数据
			},
			{
				2.6,		-- 延迟 2.6 帧
				0,			-- 延迟不随机变化
				1,			-- 组 1
				1,			-- 生成子路径
				1,			-- 生成 1 个
				false,		-- 所有点位不同时出怪
				true,		-- 顺序出怪
				4,
				4,			-- 出怪随机间隔 4 ~ 4
				"enemy_chaser"	-- 怪物模板名 "enemy_chaser"
			}
		}
	}
}

-- 生成器实体更新函数
function scripts.basic_spawner.update(this, store, script)
	while true do
		if this.spawner.spawn_data then
			print("当前生成器生成怪物")
			
			this.spawner.spawn_data = nil
		else
			print("当前生成器未生成怪物")
		end

		coroutine.yield()
	end

	queue_remove(store, this)
end

```