```lua
tt.main_script.insert = 函数: func
tt.main_script.update = 函数: func
tt.hero.fn_level_up = 函数: func
-- 这些都是实体函数
```
- 存储位置：实体函数通常存储在 `kr/game_scripts` 与 `all/scripts` 中
- 作用：实体函数通常用于 `main_script` 系统，为实体增加逻辑

## 3.1 插入函数
每次创建实体都会调用一次的函数，称为插入函数（**insert script**）

### 3.1.1 造成伤害
**首先在模板找到函数，并在 `kr/game_scripts` 搜索**

```lua
-- 艾莉丹插入函数
function scripts.hero_elves_archer.insert(this, store)
	-- this 表示调用插入函数的实体
	...
	
	local d = E:create_entity("damage")	-- 造成伤害
	d.value = 233666					-- 伤害
	d.target_id = this.id				-- 目标 id 设置为当前英雄 id
	queue_damage(store, d)				-- 插入伤害队列
end
```

使用修改的英雄进入关卡，英雄掉血，成功

### 3.1.2 造成效果
造成效果同上，不过要插入实体队列（queue_insert）
```lua
local mod = E:create_entity(效果模板名: str)	-- 造成效果
mod.modifier.target_id = this.id			-- 目标
queue_insert(store, mod)					-- 插入实体队列
```

### 3.1.3 实体增加光环

```lua
-- 沙王插入函数，给沙王增加死亡骑士光环
function scripts.hero_alric.insert(this, store, script)
	...
	if this.hero.skills.toughness.level > 0 then		-- 若坚韧技能等级大于 0，可选
		local e = E:create_entity("death_rider_aura")	-- 创建死亡骑士光环
		e.aura.source_id = this.id						-- 来源设置为沙王

		queue_insert(store, e)							-- 将 e 插入实体队列
	end
end

-- 进入游戏后发现光环显示位置错误，在模板移除偏移即可（与修改效果同理）
-- 创建新模板，续承死亡骑士光环
tt = RT("death_rider_aura_alric", "death_rider_aura")
tt.aura.use_mod_offset = nil	-- 移除偏移

-- 插入函数创建新的光环即可：E:create_entity("death_rider_aura_alric")
```

### 3.1.4 E:create_entity - 创建实体
```lua
E:create_entity(实体模板名: str) -> 实体引用: table
```
- 创建实体后需要插入实体队列才会正式创建实体

## 3.2 store - 临时存储
store 位于 `game` 表中，用于存储临时数据，如实体、玩家拥有的金币、生命、游戏时间、实体与伤害队列等

#### 实体存储位置
所有创建的实体都会存储在 `store.entities` 表中，每个实体都有独立 ID，ID 只增不减。

## 3.3 升级函数
每次实体升级时调用的函数，称为升级函数（**level up script**）

### 3.3.1 数据随等级而变化
```lua
-- 模板内
-- 艾莉丹的双刀跳斩
tt.hero.skills.double_strike = CC("hero_skill")
tt.hero.skills.double_strike.cooldown = {	-- 冷却时间随等级变化（原版 12 秒）
	12,	-- 一级 12 秒
	10,	-- 二级 10 秒
	8	-- 三级 8 秒
}

-- 艾莉丹升级函数
function scripts.hero_elves_archer.level_up(this, store, initial)
...
	s = this.hero.skills.double_strike

	if initial and s.level > θ then
		local a = this.melee.attacks[2]		-- 近战攻击 2 为双刀跳斩
		a.disabled = nil
		a.damage_min = s.damage_min[s.level]
		a.damage_max = s.damage_max[s.level]
		
		a.cooldown = s.cooldown[s.level]	-- 增加代码
	end
...
```

## 3.4 更新函数
随着游戏逻辑时间更新而调用的函数，称为更新函数（**update script**）

### 3.4.1 技能造成效果
找到技能造成伤害的部分，在后面加上造成效果的逻辑即可

#### 示例
以给火男烈焰冲击增加燃烧效果为例

```lua
-- 火男模板
tt = RT("hero_ignus", "hero")
tt.timed_attacks.list[1].mod = "mod_lava_ignus"	-- 造成这个效果

local tt = E:register_t("mod_lava_ignus", "mod_lava")
tt.dps.damage_inc = 2	-- 翻倍燃烧伤害

-- 更新函数内
function scripts.hero_ignus.update(this, store)
	...
	a = this.timed_attacks.list[1]
	skill = this.hero.skills.flaming_frenzy
	
	if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts >= a.cooldown then	-- 计算冷却时间
	...
		targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags,
		a.vis_bans)	-- 索敌
	
		if targets then
			for _, t in pairs(targets) do
				-- 造成伤害
				local d = E:create_entity("damage")
				d.damage_type = a.damage_type
				d.source_id = this.id
				d.target_id = t.id
				d.value = math.random(a.damage_min, a.damage_max)
	
				queue_damage(store, d)
	
				-- 造成效果
				local mod = E:create_entity(a.mod)
				mod.modifier.target_id = t.id
				mod.modifier.source_id = this.id
	
				queue_insert(store, mod)
			end
			...
		end
		...
	...
end
```

### 3.4.2 计算时间
计算时间常用到 `store.tick_ts` （游戏时间）与 `ts`（时间戳）

#### 示例
```lua
a = this.timed_attacks.list[1]	-- 某个技能

if store.tick_ts - a.ts > a.cooldown then
	a.ts = store.tick_ts	-- 刷新 a 的时间戳
	...
end
```
表示如果**当前时间**与**上次释放技能 `a` 的时间戳**之差**大于冷却时间**，执行条件代码块
换句话说就是**上次释放技能过去的时间**大于冷却时间

## 3.5 谁在调用插入与更新函数
通常所有函数的调用源头都是 Love 2D 引擎的 `love.update` 回调函数。按照以下调用链通过模拟器（**simulation**）协调系统，通过系统（`sys.main_script`）来调用实体的更新函数与插入函数
![[Pasted image 20251215185551.png|1200]]

## 3.6 打印日志
游戏内置了一套完整的日志系统，用于开发调试和问题排查。日志系统采用分级机制，便于控制不同开发阶段的输出信息量。

### 3.6.1 六级日志系统

| 等级  | 函数             | 用途        | 典型场景                 |
| --- | -------------- | --------- | -------------------- |
| 6 级 | `log.paranoid` | **偏执级调试** | 最详细的跟踪信息，如每帧状态、函数调用栈 |
| 5 级 | `log.debug`    | **调试信息**  | 开发过程中的详细调试信息         |
| 4 级 | `log.todo`     | **待办事项**  | 标记需要完成的功能或修复的问题      |
| 3 级 | `log.info`     | **常规信息**  | 正常的游戏流程信息            |
| 2 级 | `log.warning`  | **警告信息**  | 潜在问题或不规范使用           |
| 1 级 | `log.error`    | **错误信息**  | 程序错误和异常情况            |

### 3.6.2 函数
#### 1. 创建新日志实例
```lua
log:new(打印的日志前缀: str, 日志等级?: int) -> 日志实例: table
```
- 推荐在 `args` 修改全局日志等级

#####  示例
```lua
log.debug("load atlas: %s,%s-%.6f", path, name, ref_scale)

--[[ 输出
[22841.0227] image_db.DEBUG preload_atlas() - load atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000
--]]
```
- `[22841.0227]` 为时间信息
- `image_db` 为前缀
- `DEBUG` 为等级，调试五级
- `preload_atlas` 调用的函数
- `load atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000` 信息


#### 2. 偏执级调试（6 级）
```lua
-- 打印最详细的调试信息
log.paranoid("实体 %d 当前状态: pos=(%.1f, %.1f), hp=%d/%d", 
    this.id, this.pos.x, this.pos.y, this.health.hp, this.health.hp_max)
```
- **用途**：深度跟踪复杂逻辑的执行流程
- **特点**：信息量极大，仅在调试特定问题时开启
- **示例场景**：
  - 追踪 AI 决策过程
  - 监控每帧的状态变化
  - 调试复杂的协程逻辑

#### 3. 调试信息（5 级）
```lua
-- 打印开发调试信息
log.debug("技能 %s 触发，目标=%d，伤害=%d", 
    skill_name, target.id, damage_value)
```
- **用途**：开发阶段的主要调试工具
- **特点**：包含详细的过程信息，但比偏执级简洁
- **示例场景**：
  - 技能释放和冷却
  - 伤害计算过程
  - 实体创建和销毁

#### 4. 待办事项（4 级）
```lua
-- 标记需要完成的功能
log.todo("TODO: 为英雄 %s 实现连击系统", this.hero.name)
-- 或标记已知问题
log.todo("FIXME: 当敌人被冰冻时，伤害计算有误")
```
- **用途**：标记开发中的待办事项和已知问题
- **特点**：便于团队协作和任务跟踪
- **最佳实践**：
  - 描述清晰的问题或功能需求
  - 包含解决建议（如果有）
  - 定期清理已完成的待办事项

#### 5. 常规信息（3 级）
```lua
-- 打印正常的游戏流程信息
log.info("关卡 %d 开始，初始金币=%d，生命=%d", 
    store.wave, store.gold, store.lives)
```
- **用途**：记录正常的游戏运行信息
- **特点**：适合玩家可见的进度信息
- **示例场景**：
  - 关卡开始/结束
  - 英雄升级
  - 重要游戏事件

#### 6. 警告信息（2 级）
```lua
-- 打印潜在问题警告
log.warning("实体 %d 的 hp=%d，但 hp_max=%d，血量数据异常",
    this.id, this.health.hp, this.health.hp_max)
```
- **用途**：提示潜在问题或不规范情况
- **特点**：程序能继续运行，但可能存在风险
- **示例场景**：
  - 数据范围异常
  - 资源加载失败但有备用方案
  - 预期外的游戏状态

#### 7. 错误信息（1 级）
```lua
-- 打印错误信息
log.error("无法找到实体 %d 的目标 %d，技能释放失败",
    this.id, target_id)
```
- **用途**：报告程序错误和异常情况
- **特点**：通常伴随功能失效
- **示例场景**：
  - 空指针访问
  - 资源加载完全失败
  - 关键逻辑无法执行

### 3.6.3 实用技巧

#### 1. 格式化输出
```lua
-- 使用格式化字符串提高可读性
local hit_count = #targets
local total_damage = 0
for _, dmg in pairs(damages) do
    total_damage = total_damage + dmg.value
end

log.info("范围攻击命中 %d 个目标，总伤害 %d", hit_count, total_damage)
```

#### 2. 条件日志
```lua
-- 只在特定条件下输出日志
if DEBUG_MODE then
    log.debug("详细状态: %s", inspect(this))
end

-- 或者在开发阶段使用
if store.tick_ts < 10 then  -- 只在游戏前10秒输出
    log.paranoid("初始状态跟踪: %s", this.id)
end
```

### 3.6.4 调试工作流示例

#### 1. 新功能开发
```lua
function scripts.new_hero.insert(this, store)
    log.todo("实现新英雄的插入函数")
    log.debug("新英雄创建，ID=%d，位置=(%.1f,%.1f)",
        this.id, this.pos.x, this.pos.y)
    
    -- 开发过程中的调试
    log.paranoid("初始组件状态: %s", inspect(this))
    
    -- 实现逻辑...
end

function scripts.new_hero.update(this, store)
    log.todo("实现新英雄的更新函数")
    
    -- 跟踪特定问题
    if this.some_problem then
        log.warning("检测到问题状态: %s", this.some_problem)
    end
    
    -- 实现逻辑...
end
```

#### 2. 问题排查
```lua
function scripts.problem_skill.update(this, store)
    local skill = this.hero.skills.problem_skill
    
    -- 逐步添加日志定位问题
    log.debug("技能检查: level=%d, cooldown=%f", 
        skill.level, skill.cooldown)
    
    if store.tick_ts - skill.last_use > skill.cooldown then
        log.paranoid("技能可用，开始索敌...")
        
        local target = U.find_foremost_enemy(store.entities, this.pos, 0, 100)
        
        if target then
            log.paranoid("找到目标: ID=%d, hp=%d", target.id, target.health.hp)
            
            -- 检查目标状态
            if target.health.hp <= 0 then
                log.warning("目标已死亡但仍被选中，ID=%d", target.id)
                return
            end
            
            -- 执行技能...
        else
            log.debug("未找到有效目标")
        end
    end
end
```

#### 3. 性能分析
```lua
function scripts.heavy_function.update(this, store)
    local start_time = os.clock()
    
    -- 执行复杂计算...
    
    local end_time = os.clock()
    local duration = end_time - start_time
    
    if duration > 0.016 then  -- 超过一帧时间（30fps）
        log.warning("函数执行时间过长: %.3f秒，实体ID=%d", 
            duration, this.id)
        log.paranoid("详细状态: %s", inspect(this))
    elseif duration > 0.001 then  -- 超过1毫秒
        log.debug("函数执行时间: %.3f秒", duration)
    end
end
```

### 3.6.5 更多日志库函数见 [[12. 库#日志库]]

## 3.7 索敌
几乎所有索敌本质都是在一定范围索敌，然后根据条件过滤目标。

### 3.7.1 基础索敌
#### 1. 搜索范围内所有敌人
```lua
U.find_enemies_in_range(
	实体列表: list,
	原点: vec2, 
	最小半径: num, 
	最大半径: num, 
	标签: int, 
	禁止标签: int, 
	过滤函数?: func
) -> 范围内所有敌人: list
```
- `e` 参数通常为 `store.entities`
- 为过滤函数传递：实体、原点
- 过滤函数用于筛选目标，返回假的目标将会被筛选

#### 2. 搜索首个敌人
```lua
U.find_foremost_enemy(
	实体列表: list, 
	原点: vec2, 
	最小半径: num, 
	最大半径: num, 
	预判时间: num, 
	标签: int, 
	禁止标签: int, 
	过滤函数?: func, 
	禁用最小半径的标签: int
) -> 首个敌人: table, 范围内所有敌人: list{敌人: table...}, 预判位置: vec2
```
- 禁用最小半径的标签：拥有此标签的目标不受搜索最小半径限制

所有索敌见[[9. 工具函数#一、索敌]]

### 3.7.2 过滤函数

```lua
local target = U.find_foremost_enemy(..., function(v, origin)	-- v 为实体，origin 为原点
	...	-- 函数体
	return v.health.hp >= 1000	-- 筛选掉血量小于 1000 的敌人
end, ...)	
```

### 3.7.3 寻找血量最高的敌人
```lua
local targets = U.find_enemies_in_range(store.entities, hero.pos, 0, a.radius, a.vis_flags, a.vis_bans)

if targets then
	table.sort(targets, function(e1, e2)
		return e1.health.hp > e2.health.hp	-- 根据血量排序，血量最高的排序在最前
	end)
	
	local target = targets[1]	-- 取血量最高目标
	...
end
```

## 3.8 实体攻击增加条件
### 3.8.1 近战攻击条件
给近战攻击的 `fn_can` 指定条件函数即可。
```lua
tt.melee.attacks[1].fn_can = 条件函数: func
```
- 为条件函数传递： `store`、攻击、目标
- 条件函数返回真表示可以攻击

#### 示例
以给鬼侍灭魂斩增加条件为例：

```lua
-- 模板
tt.melee.attacks[2].trigger_min_hp = 150	-- 释放条件：目标血量大于等于 150
tt.melee.attacks[2].fn_can = scripts.hero_oni.update

-- game_scripts
function scripts.hero_oni.update(this, store)
	...
end

-- 写在更新函数下面
function scripts.hero_oni.melee_fn_can_2(this, store, a, target)
	return target.health.hp >= a.trigger_min_hp
end
```

### 3.8.2 远程攻击条件
给远程攻击的 `filter_fn` 指定条件函数即可。
```lua
tt.ranged.attacks[1].filter_fn = 条件函数: func
```
- 为条件函数传递：目标、原点
- 条件函数返回真表示可以攻击

#### 示例
以小公主为例：
```lua
tt.ranged.attacks[1].trigger_min_hp = 150	
tt.ranged.attacks[1].filter_fn = scripts.hero_alleria.ranged_filter_fn_1

-- game_scripts
function scripts.hero_alleria.ranged_filter_fn_1(v, origin)
	return v.health.hp > trigger_min_hp
end
```

### 3.8.3 释放概率根据条件而变化
给攻击的 `fn_chance` 指定条件函数即可。
```lua
tt.melee.attacks[1].fn_chance = 条件函数: func
```
- 为条件函数传递：当前实体、`store`、攻击、目标

#### 示例
以使鬼侍灭魂斩 100% 秒杀处于流血效果的目标为例：
```lua
-- 鬼侍近战攻击 2 是灭魂斩的秒杀，3 则是灭魂斩不秒杀的真伤
tt.melee.attacks[2].instakill_mod_type = MOD_TYPE_BLEED	-- 效果类型：流血类型
tt.melee.attacks[2].fn_chance = scripts.hero_oni.fn_chance_death_strike

-- game_scripts
function scripts.hero_oni.fn_chance_death_strike(this, store, a, target)
	return U.has_modifier_types(store, target, a.instakill_mod_type) or math.random() < attack.chance
end
```

### 3.8.4 判断是否拥有状态效果
#### 1. 判断拥有单个效果
```lua
U.has_modifiers(store: table, 实体: table, 效果模板名: str) -> 是否拥有: bool, 找到的效果实体: table
```
- 若不传递效果模板名称则返回所有效果

#### 2. 判断拥有效果类型
```lua
U.has_modifier_types(store: table, 实体: table, 效果类型: int...) -> 是否拥有: bool, 所有找到的效果实体: table
```

## 3.9 增加新攻击与技能
### 3.9.1 攻击概率造成效果
```lua
tt.melee.attacks[2] = table.deepclone(tt.melee.attacks[1])		-- 深拷贝的攻击
tt.melee.attacks[2].chance = 概率: num
tt.melee.attacks[2].mod = 效果模板名: str
```

#### 示例
以火男普攻概率造成燃烧效果为例：

```lua
-- 模板
tt.melee.attacks[2] = table.deepclone(tt.melee.attacks[1])		-- 深拷贝近战普攻
tt.melee.attacks[2].chance = 0.5
tt.melee.attacks[2].mod = "mod_lava"

-- 升级函数，只有能升级（有升级函数）的单位才需要修改升级函数
...
this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]
-- 同时将伤害赋值到新攻击上
this.melee.attacks[2].damage_min = ls.melee_damage_min[hl]
this.melee.attacks[2].damage_max = ls.melee_damage_max[hl]
...
```

### 3.9.2 防御塔攻击概率造成效果
防御塔的攻击需要自己写逻辑。

#### 示例
以地震普攻概率造成眩晕效果为例：
```lua
-- 模板
local tower_dwaarp = RT("tower_dwaarp", "tower")
tower_dwaarp.attacks.list[4] = table.deepclone(tower_dwaarp.attacks.list[1])
tower_dwaarp.attacks.list[4].mod = "mod_stun"
tower_dwaarp.attacks.list[4].chance = 0.5

-- 更新函数
function scripts.tower_dwaarp.update(this, store, script)
	...
	local aa_m = this.attacks.list[4]
	
	while true do
		if this.tower.blocked then
			coroutine.yield()
		else
			...
			if store.tick_ts - aa.ts > aa.cooldown then
				...
				-- 若进行攻击 1 则计算概率，然后将攻击 1 改成攻击 4
				if math.random() <= aa_m.chance then
					aa = aa_m
				end
			end
			...
			
			if not drill_ready and not lava_ready and not std_ready then
				coroutine.yield()
			else
				...
				if std_ready and trigger_enemy then
					-- 更新两个时间戳
					aa.ts = store.tick_ts
                    this.attacks.list[1].ts = store.tick_ts
					...
					-- 还原
					aa = this.attacks.list[1]
					std_ready = false
					lava_ready = false
					...
				end
				...
			end
			...
		end
		...
	end
	...
end
```

### 3.9.3 增加远程攻击
#### 1. 士兵
以爵士为例：
```lua
-- 模板
tt = RT("hero_gerald", "hero")
AC(tt, "melee", "timed_attacks", "dodge", "ranged")
...
tt.ranged.attacks[1].bullet = "gerald_arrow"
tt.ranged.attacks[1].bullet_start_offset = {
	v(0, 12)
}
tt.ranged.attacks[1].cooldown = 1
tt.ranged.attacks[1].max_range = 150
tt.ranged.attacks[1].min_range = 25
tt.ranged.attacks[1].shoot_time = fts(6)
tt.ranged.attacks[1].animation = "idle"		-- 使用待机时的动画

tt = RT("gerald_arrow", "arrow")
tt.bullet.damage_min = 10
tt.bullet.damage_max = 25
tt.bullet.prediction_error = false

-- 更新函数
function scripts.hero_gerald.update(this, store)
	...
	brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)	-- 调用近战攻击函数
	-- brk 就是 break，sta 就是 status
	
	if brk or sta ~= A_NO_TARGET then	-- 删除 sta ~= A_NO_TARGET 条件即可让近战攻击与远程攻击同时进行
		-- block empty
	else
		brk, sta = SU.y_soldier_ranged_attacks(store, this)	-- 调用远程攻击函数
		
		if brk then
			-- block empty
		elseif SU.soldier_go_back_step(store, this) then	-- 前往集结点
			-- block empty
		else
			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end
	end
	...
end
```

#### 2. 敌人
以利维坦为例：
```lua
tt = RT("eb_leviathan", "boss")
AC(tt, "attacks", "ranged")
...
tt.ranged.attacks[1].bullet = "bolt_blazefang_eb_leviathan"
tt.ranged.attacks[1].bullet_start_offset = {
	v(25, 10),
	v(12, 22),
	v(6, 4)
}
tt.ranged.attacks[1].cooldown = 1
tt.ranged.attacks[1].hold_advance = true
tt.ranged.attacks[1].max_range = 150
tt.ranged.attacks[1].min_range = 25
tt.ranged.attacks[1].shoot_time = fts(24)
tt.ranged.attacks[1].animation = "idle"		-- 使用待机时的动画
tt.ranged.attacks[1].shared_cooldown = true
...

tt = E:register_t("bolt_blazefang_eb_leviathan", "bolt_blazefang")	-- 续承蜥蜴人未来战士子弹
tt.bullet.damage_max = 1000
tt.bullet.damage_min = 600

-- 更新函数
function scripts.eb_leviathan.update(this, store, script)
	...
	local a = this.ranged.attacks[1]
	
	::label_244_0::

	while true do
		...
		if this.unit.is_stunned then
			coroutine.yield()
		else
			local ranged = U.find_nearest_soldier(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)

			-- 如果找到士兵目标
			if ranged then
				-- 如果可以远程攻击，并且没有被拦截一直进行远程攻击
				while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
					if not SU.y_enemy_range_attacks(store, this, ranged) then
						goto label_244_0
					end
	
					coroutine.yield()
				end
			end
			...
		end
	end
end
```

### 3.9.4 增加新技能
#### 示例
以给尼鲁增加一个技能：每 275 秒增加 1 生命（升级二技能翠绿迸发解锁）为例：

```lua
-- 模板
tt.hero.skills.heal_live = CC("hero_skill")	-- 防御塔与其他单位技能组件是 power
tt.hero.skills.heal_live.cooldown = {
	275,	-- 一级冷却时间 275 秒
	245,	-- 三级冷却时间 245 秒
	210		-- 三级冷却时间 210 秒
}
...
tt.timed_attacks.list[5] = CC("custom_attack")
tt.timed_attacks.list[5].animation = "fairy_dust"	-- 动画套用四技能衰弱咒语
tt.timed_attacks.list[5].sound = "HeroNyruFairyDustCast"	-- 音效，也是借用衰弱咒语
tt.timed_attacks.list[5].cooldown = nil
tt.timed_attacks.list[5].disabled = true
tt.timed_attacks.list[5].heal_live = 1

-- 升级函数
function scripts.hero_muyrn.level_up(this, store, initial)
	s = this.hero.skills.verdant_blast
	sl = s.level
	
	...
	if sl > 0 and initial then
		...
		local a = this.timed_attacks.list[5]
		a.cooldown = this.hero.skills.heal_live.cooldown[sl]
		a.disabled = nil
		...
	end
	...
end

-- 更新函数
function scripts.hero_muyrn.update(this, store)
	...
	if this.unit.is_stunned then
		SU.soldier_idle(store, this)
	else
		...
		a = this.timed_attacks.list[5]
		skill = this.hero.skills.heal_live
	
		if not a.disabled and store.tick_ts - a.ts > a.cooldown then
			a.ts = store.tick_ts
			U.animation_start(this, a.animation, nil, store.tick_ts)
			S:queue(a.sound)	-- 播放音效
			
			store.lives = store.lives + a.heal_live	-- 增加生命
	
			SU.y_hero_animation_wait(this)	-- 等待动画完成
		...
	end
end
```

### 3.9.5 闪避反击
为闪避组件的 `counter_attack` 指定攻击即可。

#### 示例
以爵士格挡为例：
```lua
-- 模板
tt.dodge.counter_attack = CC("melee_attack")
tt.dodge.counter_attack.damage_type = bor(DAMAGE_TRUE, DAMAGE_NO_DODGE)
tt.dodge.counter_attack.reflected_damage_factor = 0.5
tt.dodge.counter_attack.reflected_damage_factor_inc = 0.5	-- 技能升级提升系数
tt.dodge.counter_attack.hit_time = fts(5)
tt.dodge.counter_attack.animation = "counter"
tt.dodge.counter_attack.sound = "HeroPaladinDeflect"

-- 更新函数
function scripts.hero_gerald.update(this, store)
	...
	local d = this.dodge
	
	while true do
		...
		if this.unit.is_stunned then
			SU.soldier_idle(store, this)
		else
			...
			skill = this.hero.skills.block_counter
			
			if skill.level > 0 and d and d.active then
	
				d.active = false		-- 闪避后 dodge.active 会被赋值为真
				d.counter_attack_pending = true	-- counter_attack_pending 为真表示将下次的普攻改成闪避反击
	
				local la = d.last_attack
				local ca = d.counter_attack
	
				if la then
					local counter_damage = ca.reflected_damage_factor + ca.reflected_damage_factor_inc * skill.level
				
					ca.damage_max = la.damage_max * counter_damage
					ca.damage_min = la.damage_min * counter_damage
				end
				...
			end
			...
		end
		...
	end
	...
end
```

### 3.9.6 闪避条件
给闪避的 `can_dodge` 指定条件函数即可。
```lua
tt.dodge.can_dodge = 条件函数: func
```
- 为条件函数传递 `store` 当前实体、远程攻击、攻击、来源
- 条件函数返回真表示可以闪避

#### 示例
以爵士格挡为例：
```lua
-- 模板
tt.dodge.can_dodge = scripts.hero_gerald.fn_can_dodge

-- game_scripts
function scripts.hero_gerald.fn_can_dodge(store, this, ranged_attack, attack, source)
	if (attack and attack.type == "area" or source and source.vis and band(source.vis.flags, F_BOSS) ~= 0) and math.random() > this.dodge.low_chance_factor then
		-- 如果攻击为范围伤害，或为 Boss 计算闪避概率（Boss 闪避概率为三分之一）
		return false
	end

	return true
end
```

### 3.9.7 攻击优先级
攻击优先级存储于攻击的 `order` 中，通过 `U.attack_order` 自动排序。攻击概率造成效果也是通过其排序方法实现的。

#### 排序方法
1. 释放概率不同，释放概率低者在前
2. 释放概率相同，冷却时间长者在前
3. 所有条件相同，攻击索引低者在前

#### 手动指定优先级
```lua
-- 雷格森插入函数
function scripts.hero_regson.insert(this, store)
	...
	this.melee.order = U.attack_order(this.melee.attacks)	-- 删除这个
	...
end

-- 直接在模板指定攻击优先级
tt.melee.order = {
	2,		-- 优先释放近战攻击 2
	1,		-- 之后释放近战攻击 1
	...		-- 注：必须填写所有的攻击，没填写的攻击将永不释放
}

-- 远程攻击同理
this.ranged.order = U.attack_order(this.ranged.attacks)	-- 删除这个

tt.ranged.order = {
	2,		-- 优先释放远程攻击 2
	1,		-- 之后释放远程攻击 1
	...
}
```

## 3.10 特殊效果
### 3.10.1 增加二阶段
以利维坦为例：

```lua
-- 模板
tt = E:register_t("eb_leviathan", "boss")
...
tt.second_phase = {}
tt.second_phase.wait_time = 5		-- 死亡后进入二阶段等待时间
tt.second_phase.hp_max = 10000		-- 二阶段血量
tt.second_phase.armor = 0.5			-- 二阶段护甲

-- 更新函数
function scripts.eb_leviathan.update(this, store, script)
...
	::label_244_0::

	while true do
		if this.health.dead then
			if not this.is_second_phase then
				this.ui.can_click = false		-- 进入二阶段等待时禁止玩家点击，避免显示状态栏
				this.health_bar.hidden = true	-- 进入二阶段等待时隐藏血条
				U.animation_start(this, "death", nil, store.tick_ts, false)		-- 播放死亡动画

				U.y_wait(store, this.second_phase.wait_time)	-- 等待 5 秒

				this.ui.can_click = true		-- 重新启用，允许玩家点击
				this.health_bar.hidden = false	-- 重新显示血条
				this.is_second_phase = true
				this.health.dead = false

				this.health.hp_max = this.second_phase.hp_max		-- 设置新的最大血量
				this.health.hp = this.second_phase.hp_max			-- 设置新的血量
				this.health.armor = this.second_phase.armor			-- 设置新的护甲

				goto label_244_0		-- 直接跳出，避免进入死亡移除环节（正式死亡）
			end

			-- 二阶段死亡则进入死亡移除环节（正式死亡）
			this.phase = "dead"

			LU.kill_all_enemies(store, true)

			for _, t in pairs(tentacles) do
				t.interrupt = true
			end

			do_death()
			queue_remove(store, this)
			signal.emit("boss-killed", this)

			return
		end
		...
	end
	...
end
```

## 3.11 练习

### 练习 1：了解驱动函数逻辑
根据 [[3. 实体函数#3 5 谁在调用插入与更新函数]] 阅读代码了解驱动函数是怎么调用实体函数的

**要点：**
1. **系统存储位置**：系统存储于 `all/systems`
2. **协程机制**：更新函数使用协程（coroutine）管理与控制执行流程
3. **队列**：使用多个队列（实体队列、伤害队列）批量处理操作

### 练习 2：日志与调试实践
（答案见[[第 2 节 - 修改基础/参考答案#练习 3 2：日志与调试实践]]）
```lua
-- 假设你正在为英雄 "暗影刺客" 实现一个新技能 "暗影突袭"
-- 技能效果：对范围内血量最低的敌人造成伤害并附加流血效果

-- 已有代码框架：
function scripts.hero_shadow_assassin.update(this, store)
    local skill = this.hero.skills.shadow_assault
    local attack = this.timed_attacks.list[3]  -- 第3个是暗影突袭
    
    while true do
	    if skill.level > 0 and not attack.disabled then
	        if store.tick_ts - attack.ts >= attack.cooldown then
	            -- 技能可用，开始索敌...
	            
	            -- TODO: 在这里实现技能逻辑
	            -- 要求：
	            -- 1. 找到范围内血量最低的敌人
	            -- 2. 造成伤害 (伤害值 = 基础伤害 + 技能等级 * 伤害成长)
	            -- 3. 附加流血效果
	            -- 4. 刷新技能时间戳
	            -- 5. 播放动画和音效
	            
	            -- 技能参数：
	            -- attack.radius = 200          -- 技能范围
	            -- attack.damage_base = 50      -- 基础伤害
	            -- attack.damage_per_level = 30 -- 每级伤害成长
	            -- attack.mod = "mod_bleed_v2"  -- 流血效果模板
	        end
	    end
	    
	    coroutine.yield()
	end
end

-- 要求：
-- 1. 实现上述TODO部分的技能逻辑
-- 2. 在关键位置添加适当的日志：
--    - 使用 log.debug 记录技能触发和目标选择
--    - 使用 log.info 记录技能释放成功
--    - 使用 log.warning 处理边界情况（如无目标）
--    - 使用 log.error 处理严重错误
--    - 使用 log.paranoid 记录详细的计算过程（可选）
-- 3. 确保代码有良好的错误处理

-- 提示函数：
-- U.find_enemies_in_range  -- 范围内所有敌人
-- table.sort               -- 对表排序
-- E:create_entity("damage")-- 创建伤害实体
-- E:create_entity			-- 创建效果实体
-- queue_damage             -- 排队伤害
-- queue_insert             -- 排队插入实体
-- U.animation_start        -- 播放动画
-- S:queue					-- 播放音效
```

## 3.12 本章总结

### 关键知识点回顾

1. **实体函数概述**
	- **定义**：存储在 `kr/game_scripts` 和 `all/scripts` 中的逻辑函数
	- **作用**：为 `main_script` 系统增加实体逻辑
	- **插入函数（insert）**：实体创建时调用一次
	- **更新函数（update）**：每帧调用，管理实体持续行为
	- **升级函数（level up）**：实体升级时调用

2. **存储位置**
	- **实体存储**：所有实体存储在 `store.entities` 表中
	- **临时存储**：`store` 用于存储游戏临时数据

3. **核心技能实现**
	- **造成伤害**：`E:create_entity("damage")` + `queue_damage`
	- **造成效果**：`E:create_entity` + `queue_insert`
	- **增加光环**：创建光环实体并设置 `source_id`
	- **修改攻击优先级**：直接在模板攻击指定 `order` 数组

4. **时间与状态管理**
	- **游戏时间**：`store.tick_ts`
	- **时间戳**：`a.ts`（攻击的时间戳）
	- **冷却计算**：`store.tick_ts - a.ts >= a.cooldown`
	- **效果判断**：`U.has_modifiers` 和 `U.has_modifier_types`

5. **打印日志**
	- **详细**：`log.paranoid` 打印最详细的跟踪信息
	- **调试**：`log.debug` 打印开发过程中的详细调试信息
	- **代办**：`log.todo` 打印标记需要完成的功能或修复的问题
	- **信息**：`log.info` 打印正常的游戏流程信息
	- **警告**：`log.warning` 打印潜在问题或不规范使用
	- **错误**：`log.error` 打印程序错误和异常情况

6. **索敌与目标选择**
	- **范围索敌**：`U.find_enemies_in_range`
	- **首个敌人**：`U.find_foremost_enemy`
	- **过滤函数**：可自定义条件筛选目标
	- **特殊筛选**：如按血量排序找到最高血量目标

7. **攻击条件控制**
	- **近战条件**：`fn_can` 函数
	- **远程条件**：`filter_fn` 函数
	- **释放概率**：`fn_chance` 函数

8. **扩展攻击与技能**
	- **新增攻击**：使用 `table.deepclone` 复制攻击
	- **概率效果**：设置 `chance` 和 `mod` 属性
	- **士兵新增远程攻击**：需在更新函数中调用远程攻击 `y_soldier_ranged_attacks` 函数
	- **敌人新增远程攻击**：需在逻辑循环中集成远程攻击检与 `y_enemy_range_attacks` 函数
	- **新增技能**：在 `timed_attacks` 中添加，配合升级函数解锁
	- **闪避机制**：`counter_attack` 和 `can_dodge` 函数

9. **特殊机制实现**
	- **二阶段机制**：通过状态标志和血量重置实现

10. **架构与调用机制**
	- **ECS 架构**：实体-组件-系统的分离设计
	- **调用链**：Love2D → 游戏层 → 模拟器 → 实体函数
	- **协程管理**：更新函数使用协程实现复杂逻辑控制

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 理解插入、更新、升级三种实体函数的作用和调用时机
- [ ] 在插入函数中实现伤害、效果、光环等基础功能
- [ ] 使用 `store.tick_ts` 和 `a.ts` 计算时间和冷却
- [ ] 使用日志库打印日志
- [ ] 实现各种索敌逻辑和目标筛选
- [ ] 为攻击添加释放条件和概率控制
- [ ] 通过深拷贝和组件配置新增攻击和技能
- [ ] 实现闪避和反击机制
- [ ] 创建复杂的多阶段机制
- [ ] 理解实体函数的调用链和协程机制

### 思考题
1. 为什么实体函数要分为插入、更新、升级三种类型？这种分离设计如何提高代码的可维护性和性能？
2. 如果要为一个英雄添加一个新的召唤技能，需要考虑哪些方面？
3. ECS 架构如何支持游戏中复杂的行为组合？
4. 协程在游戏逻辑管理中有哪些优势和局限性？
5. 当多个实体需要共享某种行为时，如何设计避免代码重复？
6. 如何处理实体之间的复杂交互（如连锁反应）？

### 实战建议

1. **代码复用**：
   - 观察现有英雄的实现，提取通用模式
   - 创建可复用的辅助函数库

2. **文档习惯**：
   - 为自定义函数添加清晰文档注释
   - 记录重要的设计决策和实现细节

---

**下一章预告**：在第 4 章中，我们将学习修改游戏的关卡，包括路径、网格、出怪等，为更复杂的修改做准备。