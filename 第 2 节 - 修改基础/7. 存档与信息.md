## 7.1 存档
存档用于存储各种长期玩家数据，如英雄等级、加点、完成的成就、关卡完成情况、成就计数等

模块位置：`all/storage`

### 7.1.1 存档位置
1. 原版 `C:\Users\用户\AppData\Roaming\kingdom_rush_xxx` 
2. 调试 `C:\Users\用户\AppData\Roaming\LOVE\kingdom_rush_xxx` 里面
- **也可以点击工作区文件夹内的存档位置快捷方式进行跳转**

### 7.1.2 结构
```lua
{
	achievement_counters = {	-- 成就计数
		成就名: str = 计数: int
		...
	},
	achievements = {			-- 成就解锁状态
		成就名: str = 是否解锁: bool
		...
	},
	difficulty = 难度: int,
	heroes = {					-- 英雄
		selected = 选择的英雄: str,
		status = {			-- 英雄状态
			英雄名: str = {
				skills = {	-- 技能等级状态
					技能名: str = 技能等级: int
					...
				},
				xp = 经验数: int
			}
			...
		}
	},
	levels = {				-- 关卡状态
		{			-- 索引对应相应关卡编号
			战役模式通关的难度: int,		-- 索引对应相应模式
			英雄模式通关的难度: int,
			钢铁模式通关的难度: int,
			"stars" = 战役模式的星星数量: int
		}
	},
	seen = {				-- 敌人信息状态
		敌人名: str = 是否遇到过: bool
		...
	},
	upgrades = {}			-- 科技树状态
}
```

### 7.1.3 load_slot - 读取存档数据
```lua
storage:load_slot(存档索引?: int, 是否强制重新加载文件?: bool)
```
- 默认存档索引为当前存档

### 7.1.4 save_slot - 保存存档数据
```lua
storage:save_slot(保存的表: table, 存档索引?: int)
```
- 默认存档索引为当前存档

保存前必须要先读取存档
**因为这个函数会将存档直接完全替换为保存的表，所以刚开始必须先读取存档，否则存档会丢失此前保存的所有内容，仅有保存的内容**

示例：
```lua
slot = storage:load_slot()	-- slot 接收存档的表，如果你要修改存档必须首先加载存档

slot.heroes.status.hero_gerald.xp = 2333	-- 将爵士的经验设置为 2333 点
slot.data = {"hello world"}		-- 写入新数据

storage:save_slot(slot) 		-- 保存到存档里
```

## 7.2 成就
模块位置：`all/achievements` 
数据位置：`kr/data/achievements_data`
相关函数模块位置：`kr/achievements_handlers`

所有成就函数见 [[16. 成就]]

### 7.2.1 成就数据结构
```lua
{
	name = 名称: str,
	goal = 完成条件（计数次数）: int,
	icon = 图标: int,
	period = 生命周期: int
}
```

**生命周期**：
1. `P_LIFETIME`: 全程
2. `P_SESSION`: 会话
3. `P_LEVEL`: 关卡
4. `P_WAVE`: 波次
5. `P_POWER_1`: 能力 1

### 7.2.2 灵活的计数系统
1. **多周期支持**: 成就可按不同周期统计（全程、关卡、波次等）
2. **多种计数方式**:
    - 简单累加（`inc`）
    - 位标志（`flag`）
    - 最高值记录（`high`）
    - 时间间隔（`lap`）

## 7.3 事件监听
所有事件监听都在 `kr/achievements_handlers` 中

通过 signal 信号库的 `signal.register` 注册与 `signal.emit` 触发信号进行事件监听

signal 信号库函数见 [[13. 库#signal 信号库]]

### 7.3.1 signal.register - 注册信号
```lua
signal:register(信号名: str, 监听器函数: func) -> 监听器函数: func
```

### 7.3.2 signal.emit - 触发信号
```lua
signal:emit(信号名: str, 为监听器函数传递的参数: str...)
```

### 示例
```lua
local function on_damage(value, target_id)
    print(string.format("Damage: damage %s, target id %s", value, target_id))
end
-- 注册信号：名称为 tower-damage
registry:register("tower-damage", on_damage)

-- 适当时机触发信号（调用 on_damage 函数）
local d = E:create_entity("damage")
d.value = 50
d.target_id = this.id
queue_damage(store, d)
-- 触发信号，为监听器函数传递参数
registry:emit("tower-damage", d.value, d.target_id)
-- 输出 Damage: damage 50, target id 1
```

## 7.4 图鉴

## 7.5 信息