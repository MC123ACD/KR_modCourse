# 第 2 章：实体与模板
## 2.1 概念
在 `all/entity_db`（简称 E）的表中：

##### 1. `entities` 表中包含的子表，称为模板（templates）
- **作用**：使用模板创建各种实体，用于存储实体的数据
- 存储位置：`kr/game_templates` 与 `all/templates`
- 读取 `kr/data/balance` 数据
- 模板的表无实际作用，仅用于存储数据与用于函数，数据传递过程： `balance` → 模板 → 实体 → 函数

##### 2. `components` 表中包含的子表，称为组件（components）
- **作用**：为模板增加组件，用于初始化
- 存储位置：`all/components`

##### 3. 使用模板创建的具有额外逻辑的元素与单位、防御塔统称为实体（entities）
- 其中单位（**unit**）特指英雄、士兵、敌人
- 英雄：具有 `hero` 组件
- 士兵：具有 `soldier` 组件的友方
- 敌人：具有 `enemy` 组件
- 防御塔：具有 `tower` 组件

## 2.2 修改属性
### 2.2.1 修改基础属性
#### 修改方法
首先使用搜索功能在 `kr/game_templates` 任意找到一个英雄模板，所有模板名见 [[1. 模板名]]

如图以小公主（`hero_alleria`）为例：
![[Pasted image 20251212181056.png|346]]
```lua
tt = RT("hero_alleria", "hero")				-- tt 指的是 hero_alleria 模板，E:register_t 函数会返回创建的模板的引用
AC(tt, "melee", "ranged", "timed_attacks")	-- 增加组件 melee、ranged、timed_attacks
tt.hero.level_stats.armor = {...}			-- hero 组件的 level_stats.armor，物理护甲
tt.hero.level_stats.hp_max = {...}			-- 最大血量
tt.hero.level_stats.regen_health = {...}	-- 脱战回血
tt.hero.level_stats.melee_damage_max = {...}	-- 近战普攻最大伤害
tt.hero.level_stats.melee_damage_min = {...}	-- 近战普攻最小伤害
tt.hero.level_stats.ranged_damage_max = {...}	-- 远程普攻最大伤害
tt.hero.level_stats.ranged_damage_min = {...}	-- 远程普攻最小伤害
...
```

**展开的 10 个值为索引所对应等级的属性**
```lua
tt.hero.level_stats.hp_max = {
	250,	-- 索引 1 表示 1 级血量为 250
	270,	-- 索引 2 表示 2 级血量为 270
	290,	-- ...
	310,
	330,
	350,
	370,
	390,
	410,
	430
}
```

将第十行血量修改为 666，然后点击运行和调试，运行游戏
![[Pasted image 20250626192149.png|377]]
![[Pasted image 20250626191819.png|541]]
如图血量变为 666 成功

#### 五代修改方法
```lua
tt.hero.level_stats.armor = b.armor
tt.hero.level_stats.hp_max = b.hp_max
tt.hero.level_stats.melee_damage_max = b.basic_melee.damage_max
tt.hero.level_stats.melee_damage_min = b.basic_melee.damage_min
tt.hero.level_stats.ranged_damage_max = b.basic_ranged.damage_max
tt.hero.level_stats.ranged_damage_min = b.basic_ranged.damage_min
```
通过查看模板的定义知道：这里是索引的 `balance`

在 `balance` 搜索要改的英雄，同样可以找到基础属性，修改即可

```lua
hero_muyrn = {				-- 尼鲁
	...
	armor = {...},			-- 物理护甲
	hp_max = {...},			-- 最大血量
	regen_health = {...},	-- 脱战回血
	basic_melee = {			-- 近战普攻
		...
		damage_max = {...},	-- 近战普攻最大伤害
		damage_min = {...}	-- 近战普攻最小伤害
		...
	},
	basic_ranged = {		-- 远程普攻
		...
		damage_max = {...},	-- 远程普攻最大伤害
		damage_min = {...}	-- 远程普攻最大伤害
		...
	},
	...
}
```

### 2.2.2 修改随等级提高的属性
`hero` 组件的 `skills` 通常用于存储会根据等级提高的属性。

#### 修改方法
以艾莉丹（`hero_elves_archer`）为例：
```lua
tt = E:register_t("hero_elves_archer", "hero")
E:add_comps(tt, "melee", "ranged", "dodge")

tt.hero.skills.double_strike = E:clone_c("hero_skill")	-- E:clone_c 函数用于返回深拷贝的组件
tt.hero.skills.double_strike.damage_max = {...}			-- 双刀跳斩最大伤害
tt.hero.skills.double_strike.damage_min = {...}			-- 双刀跳斩最小伤害
tt.hero.skills.multishot = E:clone_c("hero_skill")
tt.hero.skills.multishot.loops = {...}					-- 凌空飞箭射击次数
tt.hero.skills.nimble_fencer = E:clone_c("hero_skill")
tt.hero.skills.nimble_fencer.chance = {...}				-- 敏捷游侠闪避概率
tt.hero.skills.porcupine = E:clone_c("hero_skill")
tt.hero.skills.porcupine.damage_inc = {...}				-- 箭靶最大叠层次数
```

假设要修改艾莉丹的四技能；双刀跳斩的伤害：
首先查资料（见[[1. 模板名]] ）知道：四技能的名称是 `double_strike`
```lua
tt.hero.skills.double_strike.damage_max = {
	80,		-- 3 个值意义同上，索引 1 表示 1 级的伤害
	140,	-- ...
	200
}
```

#### 五代修改方法
还是与基础属性相同在 `balance`
```lua
hero_muyrn = {
	...
	sentinel_wisps = {	-- 哨兵仙灵
		cooldown = {	-- 冷却时间
			25,
			25,
			25
		},
		max_summons = {	-- 生成数量
			1,
			2,
			3
		}
		...
	}
	...
}
```

## 2.3 修改技能
### 2.3.1 近战攻击
拦截后的攻击，称为近战攻击。

近战攻击通常位于 `melee` 组件的 `attacks` 列表中

```lua
tt.melee.attacks[1] = E:clone_c("melee_attack")	-- 返回深拷贝的组件
tt.melee.attacks[1].cooldown = 1				-- 冷却时间
tt.melee.attacks[1].hit_time = fts(8)			-- 攻击前摇
tt.melee.attacks[1].sound = "MeleeSword"		-- 攻击声音
tt.melee.attacks[1].xp_gain_factor = 2.5 		-- 获得的经验
tt.melee.range = 45	-- 拦截范围
```
如代码所示，一般**第一个攻击 `attacks[1]` 都是普攻，其他都是相应行为的技能**

注：有的攻击可能会占有多个攻击，可以通过 `table.deepclone` 复制的攻击来分辨
其用于播放不同动画，与增加额外效果

```lua
tt.melee.attacks[1].animation = "attack"
tt.melee.attacks[1].hit_time = fts(14)
tt.melee.attacks[1].shared_cooldown = true
tt.melee.attacks[1].sound = "MeleeSword"
tt.melee.attacks[2] = table.deepclone(tt.melee.attacks[1])
tt.melee.attacks[2].animation = "attack2"
tt.melee.attacks[2].chance = 0.5	-- 50 % 近战普攻播放 "attack2" 动画
```

### 2.3.2 远程攻击
召唤子弹作为中介的攻击，称为远程攻击（**ranged**）

因为是召唤子弹所以远程攻击的伤害和伤害类型等数据都是写在子弹上的，可以搜索子弹（`bullet`）模板来找到子弹的数据
```lua
-- 艾莉丹远程普攻
tt.ranged.attacks[1] = E:clone_c("bullet_attack")
tt.ranged.attacks[1].bullet = "arrow_hero_alleria"	-- 子弹
tt.ranged.attacks[1].bullet_start_offset = {
	v(0, 12)
}
tt.ranged.attacks[1].max_range = 150
tt.ranged.attacks[1].min_range = 45
tt.ranged.attacks[1].shoot_time = fts(6)
tt.ranged.attacks[1].cooldown = 0.6

-- 子弹模板
tt = RT("arrow_hero_alleria", "arrow")	-- arrow_hero_alleria 续承自 arrow 模板
-- 注：一些属性会在 hero.skills 中
tt.bullet.xp_gain_factor = 2.875
tt.bullet.prediction_error = false

-- 由于续承关系所以搜索 arrow 模板
-- all/templates 的 arrow 模板
local arrow = E:register_t("arrow", "bullet")
...
arrow.bullet.damage_type = DAMAGE_PHYSICAL	-- 默认伤害类型：物伤
```

### 2.3.3 技能
不属于以上两种攻击的攻击，称为技能（**timed_attacks**），例如：召唤实体、给予 buff 等

```lua
-- 熊人模板
tt.timed_attacks.list[1] = CC("spawn_attack")
tt.timed_attacks.list[1].animation = "ancestors"
tt.timed_attacks.list[1].cooldown = 14 + fts(40)
tt.timed_attacks.list[1].cast_time = fts(15)
tt.timed_attacks.list[1].disabled = true
tt.timed_attacks.list[1].entity = "soldier_ingvar_ancestor"		-- 召唤这个实体

-- 维京先祖模板
tt = RT("soldier_ingvar_ancestor", "soldier_militia")		-- E:register_t
AC(tt, "reinforcement", "melee")		-- E:add_comps
...
tt.health.armor = 0.25
tt.health.hp_max = nil		-- 升级技能后动态赋值
tt.melee.attacks[1].damage_max = nil
tt.melee.attacks[1].damage_min = nil
tt.melee.attacks[1].cooldown = 1
tt.melee.attacks[1].hit_time = fts(15)
tt.melee.attacks[1].sound = "MeleeSword"
```


## 2.4 修改近战伤害类型
在 `melee.attacks` 可能找不到伤害类型，可以搜索增加的 `melee` 组件看看有没有默认值

在 `components` 搜索 `melee` 组件
```lua
local melee = register_c("melee")
...
melee.attacks = {}
melee.attacks[1] = CC("melee_attack")

-- 继续搜索 melee_attack 组件
local melee_attack = E:register_c("melee_attack")
...
melee_attack.damage_type = DAMAGE_PHYSICAL		-- 默认伤害类型：物伤

-- 模板内修改
tt.melee.attacks[1].damage_type = DAMAGE_TRUE	-- 修改为真伤
```

四个常用伤害类型：
- `DAMAGE_TRUE` 真伤
- `DAMAGE_PHYSICAL` 物伤
- `DAMAGE_MAGICAL` 法伤
- `DAMAGE_EXPLOSION` 炮伤

所有伤害类型见[[总结/3. 常量#伤害类型]]

## 2.5 模板函数

### 2.5.1 E:register_t - 创建模板
register_t 全称 **register template** 简称 RT。

```lua
E:register_t(模板名: str, 续承模板名?: str) -> 模板表的引用: table
```

#### 示例
```lua
a = RT("a")	-- 创建一个名为 “a” 的模板
a.has_a = true
a.num = 1

template = RT("template", "a")	-- 创建一个名为 “template” 的模板，同时续承 “a” 模板
template.n = 123
-- “template” 模板具有 “a” 模板所有键，修改对应键不影响模板 “a”
-- 也就是 template = { n = 123, has_a = true, num = 1 }
```

### 2.5.2 E:add_comps - 增加组件
add_comps 全称 **add components** 简称 AC。

```lua
E:add_comps(模板: table, 组件名: str...)
```

#### 示例
```lua
component = AC("component")	-- 创建组件 “component”
component.num = 123
component.is_component = true

template = RT("template")
AC(template, "component")		-- 增加组件 “component”
template.n = 1
-- 此时 template = { component = { num = 123, is_component = true }, n = 1}
```

### 2.5.3 E:clone_c - 深拷贝组件
clone_c 全称 **clone componets** 简称 CC

```lua
E:clone_c(组件名: str) -> 深拷贝的表: table
```

#### 示例
```lua
component = RT("component")
component.num = 123
component.is_component = true

template = RT("template")
template.cc = CC("component")	-- 深拷贝组件，此时 cc 就是组件 component
template.num = 1
-- 此时 template = { cc = { num = 123, is_component = true }, num = 1 }
```

### 2.5.4 E:register_c - 创建组件
register_c 全称 **register component**

```lua
E:register_c(组件: str) -> 组件索引: table
```

#### 示例
```lua
a = E:register_c("a")	-- 创建一个名为 “a” 的组件
```

### 更多函数见 [[总结/2. 模板函数.md]]

## 2.6 mod - 状态效果
造成的所有正面以及负面效果统称为状态效果（**modifiers**，缩写 mod）

### 2.6.1 攻击造成效果方法
1. 近战攻击直接在攻击后面增加 `mod` 键
2. 远程攻击增加到子弹模板的 `bullet` 键上，个别子弹无效（函数无实现）
```lua
-- 单位模板内
tt.melee.attacks[1].mod = 效果模板名: str
-- 子弹模板内
tt.bullet.mod = 效果模板名: str
```

#### 示例
```lua
-- 单位模板内
tt.melee.attacks[1].mod = "mod_lava"	-- 普通近战攻击造成燃烧效果

-- 子弹模板内
tt.bullet.mod = "mod_lava"	-- 子弹造成燃烧效果
```

**几个基础效果（位于 `template` 中）**
- `mod_stun` 眩晕
- `mod_slow` 减速
- `mod_freeze` 冻结
- `mod_lava` 燃烧
- `mod_poison` 中毒
- `mod_blood` 流血

### 2.6.2 修改效果
状态效果数据也是通过模板存储的，不能直接修改基础效果模板，由于续承关系直接修改会影响其他效果，所以我们需要创建一个新模板续承基础效果。

```lua
-- mod_lava（燃烧效果）模板
local mod_lava = RT("mod_lava", "modifier")
AC(mod_lava, "dps", "render")
mod_lava.modifier.duration = 2		-- 持续时间
mod_lava.dps.damage_min = 1			-- 最小伤害
mod_lava.dps.damage_max = 1			-- 最大伤害
mod_lava.dps.damage_inc = 3			-- 伤害系数
mod_lava.dps.damage_every = 0.2		-- 伤害频率
mod_lava.dps.damage_type = DAMAGE_TRUE	-- 伤害类型
...

-- 创建新模板 new_mod_lava 续承 mod_lava
tt = RT("new_mod_lava", "mod_lava")
tt.modifier.duration = 10		-- 持续时间 10 秒
tt.dps.damage_min = 5			-- 最小伤害 5
tt.dps.damage_max = 10			-- 最大伤害 10
-- 其他使用默认值

-- 单位模板内
tt.melee.attacks[1].mod = "new_mod_lava"	-- 使用新创建的效果

-- 子弹模板内
tt.bullet.mod = "new_mod_lava"	-- 使用新创建的效果
```

注：并非所有效果都要这样改，如果效果没有其他地方在用可以直接修改。

### 2.6.3 五代修改方法

```lua
-- balance 内
hero_spider = {
	basic_melee = {			-- 近战普攻
		mod = "mod_lava",	-- 增加 mod 键值对
		...
	}
}

-- 模板内
tt.melee.attacks[1].mod = b.basic_melee.mod	-- 读取 balance 内的表
```

### 2.6.4 效果互斥
效果互斥用于防止一些效果同时出现在同一个目标上。

```lua
tt.modifier.bans = {		-- 禁止的效果模板名
	效果模板名: str...
}
tt.modifier.ban_types = {	-- 禁止的效果类型，可选
	效果类型: str...
}
```

**几个效果类型**：
- `MOD_TYPE_BLEED` 流血
- `MOD_TYPE_POISON` 中毒
- `MOD_TYPE_FREEZE` 冻结
- `MOD_TYPE_STUN` 眩晕

所有效果类型见[[总结/3. 常量#效果类型]]

#### 示例：
```lua
tt.modifier.bans = {		-- 禁止的效果模板名
	"mod_freeze",			-- 若目标上有燃烧效果，目标将不会被冻结
	...
}
tt.modifier.ban_types = {	-- 禁止的效果类型
	MOD_TYPE_FREEZE,		--  若目标上有燃烧效果，目标将不会被冻结类型的所有效果冻结
	...
}
```

### 2.6.5 移除禁止的效果
```lua
tt.modifier.remove_banned = 是否移除禁止的效果: bool
```

#### 示例
```lua
-- 燃烧效果模板内
tt.modifier.remove_banned = true
tt.modifier.bans = {
	"mod_freeze",		-- 如果目标上有冻结效果，移除其
	...
} 
tt.modifier.ban_types = {
	MOD_TYPE_FREEZE,	-- 如果目标上有冻结类型的效果，移除其
	...
}
```

### 2.6.6 效果叠加
三种模式（三选一）：
```lua
tt.modifier.allows_duplicates = 是否允许叠加: bool
tt.modifier.replaces_lower = 是否替换低级效果: bool
tt.modifier.resets_same = 是否仅重置持续时间: bool
```

#### 示例
```lua
-- 燃烧效果模板内
tt.modifier.allows_duplicates = true	-- 可叠加多个燃烧效果
-- 或
tt.modifier.replaces_lower = true	-- 替换低级燃烧效果
-- 或
tt.modifier.resets_same = true		-- 仅重置持续时间
```

## 2.7 特殊效果

### 2.7.1 范围攻击
给攻击初始化为范围攻击 `area_attack`，增加伤害范围即可。

```lua
tt.melee.attacks[1] = CC("area_attack")
tt.melee.attacks[1].damage_radius = 伤害范围: num
tt.melee.attacks[1].count = 最大目标数?: int
tt.melee.attacks[1].min_count = 释放限制，敌人数量?: int
```

#### 示例
```lua
tt.melee.attacks[1] = CC("area_attack")
tt.melee.attacks[1].damage_radius = 25	-- 伤害范围 25
tt.melee.attacks[1].count = 3			-- 最多对三名敌人造成伤害
tt.melee.attacks[1].min_count = 2		-- 需要两名敌人才能进行这个攻击
```

### 2.7.2 多次攻击
给攻击增加 `loops` 键，设定攻击次数即可。

```lua
-- 近战攻击
tt.melee.attacks[1].animations = {
	开始时的动画名: str|nil,
	连续攻击时的动画: str|nil,
	结束时的动画名: str|nil
}
tt.melee.attaks[1].loops = 连续攻击次数: int
tt.melee.attaks[1].hit_times = 一次攻击的次数（可指定间隔）: table{ 间隔: num, ... }
-- 可以理解成乘算，loops 为 0 不攻击： 攻击次数 = loops * hit_times

-- 远程攻击，同上 hit_times 变为 shoot_times
tt.ranged.attaks[1].shoot_times = 一次攻击的次数（可指定间隔）: table{ 间隔: num, ... }
```

#### 示例
```lua
-- 近战攻击
tt.melee.attacks[1].animations = {
	nil,		-- 开始动画
	"attack",	-- 连续攻击时的动画，复用普通近战攻击动画
	nil			-- 结束动画
}
tt.melee.attaks[1].loops = 2	-- 连续攻击 2 次
tt.melee.attaks[1].hit_times = { fts(10), fts(15) }	-- 一次攻击两次，第一次间隔 10 帧，第二次间隔 15 帧

-- 远程攻击
tt.ranged.attacks[1].animations = {
	nil,
	"shoot",	-- 复用普通远程攻击动画
	nil
}
tt.ranged.attaks[1].loops = 2
tt.ranged.attaks[1].shoot_times = { fts(10), fts(15) }	-- 一次攻击两次，第一次间隔 10 帧，第二次间隔 15 帧
```

### 2.7.3 子弹携带实体
给子弹的 `bullet.hit_payload` 设定实体模板名，即可让子弹落地后生成实体。

```lua
tt.bullet.hit_payload = 实体模板名: str
```

#### 示例
```lua
tt.bullet.hit_payload = "decal_bolin_mine"		-- 波林扔地雷
```

### 2.7.4 闪避
```lua
AC(tt, "dodge")		-- 增加闪避组件
tt.dodge.chance = 闪避概率: num
tt.dodge.silent = 是否有动画?: bool
```

#### 示例
```lua
AC(tt, "dodge")			-- 增加闪避组件
tt.dodge.chance = 0.25	-- 闪避概率 25 %
tt.dodge.silent = true	-- 无动画
```

### 2.7.5 标签
给单位的 `vis.bans` 让单位不会被某些标签的攻击攻击

```lua
-- 单位模板
tt.vis.bans = 单位禁止的标签: int
tt.vis.flags = 单位的标签: int
tt.ranged.attacks[1].vis_bans = 攻击禁止的标签: int
tt.ranged.attacks[1].vis_flags = 攻击的标签: int
```

每个单位有自己的“身份证”（标签），攻击也有自己的“许可证”（标签）。双方互相检查，匹配不上就不能攻击。

**只看两个条件**：
1. **攻击的 `vis_bans`** 不能包含 **目标的标签**
2. **目标的 `vis_bans`** 不能包含 **攻击的标签**

#### 示例
```lua
-- 单位模板
tt.vis.bans = F_RANGED	-- 不会被远程攻击
tt.ranged.attacks[1].vis_bans = bor(F_BOSS, F_FLYING)	-- 远程攻击不攻击拥有 boss 标签与飞行标签的敌人
tt.ranged.attacks[1].vis_flags = F_RANGED				-- 远程攻击标签
```

#### 位运算增加多个标签
由于标签本质上是数字（通常为二次幂），可以通过 `bit.bor` 来增加多个标签。

```lua
bit.bor(十进制数字: int...) -> 合并后的十进制数字: int
```

**常用标签**：
- `F_BLOCK` 近战攻击
- `F_RANGED` 远程攻击
- `F_HERO` 英雄
- `F_BOSS` Boss
- `F_FLYING` 飞行
- `F_INSTAKILL` 秒杀

所有标签见[[总结/3. 常量#标签]]

## 2.8 练习

### 练习 1：修改英雄
```lua
-- 修改小公主（hero_alleria）模板，要求：
-- 1. 将远程普攻的子弹改为造成燃烧效果
-- 2. 让近战攻击造成中毒效果
-- 3. 增加 50% 闪避率
```

### 练习 2：增加状态效果
```lua
-- 创建一个新的中毒效果 "剧毒"，要求：
-- 1. 继承 mod_poison 模板
-- 2. 持续时间为 5 秒
-- 3. 每 0.5 秒造成 10-15 点真伤
-- 4. 禁止冻结效果叠加
-- 5. 如果目标已有冻结效果，则移除冻结
```

## 2.9 本章总结

### 关键知识点回顾
1. **实体系统架构**：
	- `E.entities`：存放所有实体模板
	- `E.components`：存放所有组件
	- 数据流程：`balance` → 模板 → 实体 → 函数

2. **核心概念**：
	- **模板**：实体的数据蓝图，存储在 `kr/game_templates` 和 `all/templates`
	- **组件**：为模板添加功能模块，存储在 `all/components`
	- **实体**：使用模板创建的具有逻辑的游戏对象

3. **单位分类**：
	- **英雄**：具有 `hero` 组件
	- **士兵**：具有 `soldier` 组件的友方
	- **敌人**：具有 `enemy` 组件
	- **防御塔**：具有 `tower` 组件

4. **攻击类型**：
	- **近战攻击**：拦截后的攻击，使用 `melee` 组件
	- **远程攻击**：召唤子弹作为中介，使用 `ranged` 组件
	- **技能**：特殊攻击，使用 `timed_attacks` 组件

5. **效果**：
	- **造成效果**：给攻击或子弹的 `mod` 设定效果模板名
	- **修改效果**：增加一个新模板并续承原效果
	- **效果互斥**：给 `bans` 设定效果模板名
	- **移除被禁止效果**：`remove_banned` 设为真
	- **效果叠加**：`allows_duplicates` 允许叠加，`replaces_lower` 替换低级效果，`resets_same` 仅重置持续时间

6. **特殊效果**
	- **范围攻击**：使用 `area_attack` 组件，并设定范围
	- **多次攻击**：增加 `loops` 与 `hit_times`（对于近战攻击） 或 `shoot_times`（对于远程攻击）
	- **子弹携带实体**：给 `hit_payload` 设定实体模板名
	- **闪避**：增加 `dodge` 组件并增加概率
	- **标签**：使用 `bans` 与 `flags` 来过滤目标，使用 `bit.bor` 合并位运算增加多个标签

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 理解实体、模板、组件三者的关系
- [ ] 查找并修改英雄的基础属性和等级属性
- [ ] 理解并修改近战、远程、技能三种攻击类型
- [ ] 修改伤害类型和状态效果
- [ ] 使用模板函数创建和修改模板
- [ ] 配置标签系统
- [ ] 实现范围攻击、多次攻击等特殊效果

### 思考题
1. 为什么模板系统要采用 "模板 → 实体 " 的数据传递流程？这样做有什么优势？
2. 组件系统如何实现代码的复用性和模块化？
3. 目标过滤系统中的 "标签" 和 "禁止标签" 是如何工作的？这种设计有什么好处？

---

**下一章预告**：在第 3 章中，我们将学习实体函数，为更复杂的修改打下基础！