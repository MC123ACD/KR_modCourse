## 12.1 什么是协程？

协程是 Lua 中强大的协作式多任务处理机制。与线程不同，协程是用户态的任务，由代码显式控制切换。

协程可理解为有一台机器可以进行各种任务，但是一次只能进行一个任务（单线程），如果正在进行某个任务，此时要想进行另一个任务就需要暂停当前任务（让出），转而执行另一个任务，执行完毕后继续此前的任务（进度不丢失）

### 12.1.1 为什么需要协程？
不用协程时机器执行任务时，会一直等待直到任务完成（阻塞）才会进行下一个任务，期间什么别的都不能做。效率极低。

使用协程执行任务时可随意切换任务，不至于阻塞程序。

#### 示例
```lua
local enemy = {}

function enemy.update()
	while true do	-- 游戏中敌人的更新函数通常为死循环
		if enemy.dead then
			print("敌人已死亡")
			break
		end
		
		if enemy.walk then
			print("敌人移动中...")
		end
		
		print("死循环中...")
	end
end

enemy.update()
-- 由于程序一直在死循环检测敌人，程序完全被阻塞，任何其他代码无法执行
print("这行代码无法执行到")
--[[ 输出
死循环中...
...
--]]
```
使用协程即可解决以上问题。

### 12.1.2 协程基础概念

#### 协程 vs 线程
**协程 Coroutine**：
- 协作式（非抢占式）：由代码控制切换（主动让出）
- 资源开销：轻量级，创建开销小
- 单线程：同一时间只有一个协程执行
- 可暂停：可以在任意点暂停和恢复
- 可预测性：可阅读代码了解执行顺序

**线程 Thread**：
- 抢占式多任务：操作系统控制（强制切换）
- 资源开销：内核态实现，较重
- 操作系统调度
- 可以并行执行
- 不可预测性

#### 协程核心操作
```lua
-- 创建协程
local co = coroutine.create(function()
    print("协程开始")
    coroutine.yield()  -- 让出
    print("协程继续")
end)

-- 启动/恢复协程
coroutine.resume(co)

-- 获取状态
print(coroutine.status(co))  -- suspended
```

#### 使用协程解决以上问题
```lua
local enemy = {}

function enemy.update()
	while true do	-- 游戏中敌人的更新函数通常为死循环
		if enemy.dead then
			print("敌人已死亡")
			break
		end
		
		if enemy.walk then
			print("敌人移动中...")
		end
		
		print("死循环中...")
		coroutine.yield()
	end
end

local co = coroutine.create(enemy.update)
coroutine.resume(co)

-- 现在不会阻塞程序了
print("这行代码无法执行到")
-- 通常游戏有个主循环每帧重启所有协程
coroutine.resume(co)
--[[ 输出
死循环中...
这行代码无法执行到
死循环中...
--]]
```

## 12.2 协程四种状态与生命周期
1. **suspended**：挂起（创建后或让出后）
2. **running**：运行中
3. **normal**：正常（恢复其他协程时）
4. **dead**: 结束（函数执行完毕）

![[Pasted image 20251215100819.png|750]]

## 13.4 创建和运行协程

### 13.4.1 coroutine.create - 创建协程

```lua
coroutine.create(主体函数: func) -> 创建的协程: thread
```
- 创建的协程默认状态为挂起
- 运行时函数报错时不会抛出

#### 示例
```lua
local function simple_task(name)
    print("  协程 " .. name .. " 开始执行")
    print("  第一步: 处理数据")
    coroutine.yield()  -- 让出执行权
    print("  第二步: 保存结果")
    coroutine.yield()  -- 再次让出
    print("  第三步: 清理资源")
    return "任务完成"
end

-- 创建协程（此时是挂起状态）
local co1 = coroutine.create(simple_task)
print("  协程已创建，状态: " .. coroutine.status(co1))  -- suspended

-- 运行协程
local success, result = coroutine.resume(co1, "任务A")
print("  第一次resume结果: success=" .. tostring(success) .. ", result=" .. tostring(result))
print("  协程状态: " .. coroutine.status(co1))  -- suspended

-- 继续运行
success, result = coroutine.resume(co1)
print("  第二次resume结果: success=" .. tostring(success))
print("  协程状态: " .. coroutine.status(co1))  -- suspended

success, result = coroutine.resume(co1)
print("  第三次resume结果: success=" .. tostring(success) .. ", result=" .. tostring(result))
print("  协程状态: " .. coroutine.status(co1))  -- dead
--[[ 输出
协程已创建，状态: suspended
协程 任务A 开始执行
第一步: 处理数据
第一次resume结果: success=true, result=nil
协程状态: suspended
第二步: 保存结果
第二次resume结果: success=true
协程状态: suspended
第三步: 清理资源
第三次resume结果: success=true, result=任务完成
协程状态: dead
--]]
```

### 13.4.2 coroutine.resume - 运行协程
```lua
coroutine.resume(协程: thread, 传递的参数: any...) -> 是否成功: bool, 主体函数返回值|或让出时传递的参数: any
```

### 13.4.3 coroutine.yield - 协程让出
```lua
coroutine.yield(参数: any...) -> 传递的参数: any...
```

### 13.4.4 coroutine.status - 获取协程状态
```lua
coroutine.status(协程: thread) -> 协程状态: "dead"|"normal"|"running"|"suspended"
```

#### 示例
```lua
local function status_example()
    print("  协程内部状态: " .. coroutine.status(coroutine.running()))
    coroutine.yield()
    print("  恢复执行")
end

local co = coroutine.create(status_example)

print("  创建后状态: " .. coroutine.status(co))
coroutine.resume(co)
print("  第一次yield后状态: " .. coroutine.status(co))
coroutine.resume(co)
print("  完成后状态: " .. coroutine.status(co))
--[[ 输出
 创建后状态: suspended
 协程内部状态: running
 第一次yield后状态: suspended
 恢复执行
 完成后状态: dead
--]]
```

### 13.4.5 coroutine.wrap - 包装函数
创建一个新协程。返回一个函数，每次调用该函数都会运行该协程。

```lua
coroutine.wrap(主体函数: func) -> 包装后的函数: func
```

#### 示例
```lua
local function counter(max)
    for i = 1, max do
        print("  计数: " .. i)
        coroutine.yield(i)
    end
    return "计数完成"
end

-- wrap返回一个函数，而不是协程对象
local count_func = coroutine.wrap(counter)

print("  第一次调用:")
local result1 = count_func(5)  -- 相当于 resume
print("  结果: " .. tostring(result1))

print("\n  第二次调用:")
local result2 = count_func()
print("  结果: " .. tostring(result2))

print("\n  继续调用直到完成:")
for i = 3, 6 do
    local result = count_func()
    print("  第" .. i .. "次结果: " .. tostring(result))
end
--[[ 输出
第一次调用:
计数: 1
结果: 1

第二次调用:
计数: 2
结果: 2

继续调用直到完成:
计数: 3
第3次结果: 3
计数: 4
第4次结果: 4
计数: 5
第5次结果: 5
第6次结果: 计数完成
--]]
```


### 13.4.6 coroutine.running - 获取当前运行的协程
```lua
coroutine.running() -> 当前协程: thread
```
- 如果在主线程调用将会返回 nil

#### 示例
```lua
local function get_current_coroutine()
    local running_co = coroutine.running()
    print("  当前协程: " .. tostring(running_co))
    
    if not running_co then
        print("  在主线程中运行")
    else
        print("  在协程中运行")
    end
end

print("  直接调用函数（在主线程）:")
get_current_coroutine()

print("\n  在协程中调用:")
local co_test = coroutine.create(get_current_coroutine)
coroutine.resume(co_test)
--[[ 输出
 直接调用函数（在主线程）:
 当前协程: nil
 在主线程中运行

 在协程中调用:
 当前协程: thread: 0x00d51d78
 在协程中运行
--]]
```

## 13.5 协程的参数传递与错误处理

### 13.5.1 参数传递
```lua
print("协程的参数传递")
local function parameter_example(name, count)
    print("  接收参数: name=" .. name .. ", count=" .. count)
    
    for i = 1, count do
        print("  处理第" .. i .. "项")
        local received = coroutine.yield("进度: " .. i .. "/" .. count)
        if received then
            print("  收到外部数据: " .. received)
        end
    end
    
    return "处理完成: " .. name
end

local co_param = coroutine.create(parameter_example)

-- 第一次resume传递参数
print("  第一次resume:")
local success, progress = coroutine.resume(co_param, "数据导入", 3)
print("  结果: success=" .. tostring(success) .. ", progress=" .. tostring(progress))

-- 后续resume传递数据给yield
print("\n  第二次resume（带数据）:")
success, progress = coroutine.resume(co_param, "继续处理")
print("  结果: success=" .. tostring(success) .. ", progress=" .. tostring(progress))

print("\n  第三次resume（带数据）:")
success, progress = coroutine.resume(co_param, "最后一步")
print("  结果: success=" .. tostring(success) .. ", progress=" .. tostring(progress))

print("\n  第四次resume（获取最终结果）:")
success, progress = coroutine.resume(co_param)
print("  结果: success=" .. tostring(success) .. ", progress=" .. tostring(progress))
--[[ 输出
第一次resume:
接收参数: name=数据导入, count=3
处理第1项
结果: success=true, progress=进度: 1/3

第二次resume（带数据）:
收到外部数据: 继续处理
处理第2项
结果: success=true, progress=进度: 2/3

第三次resume（带数据）:
收到外部数据: 最后一步
处理第3项
结果: success=true, progress=进度: 3/3

第四次resume（获取最终结果）:
结果: success=true, progress=处理完成: 数据导入
--]]
```

### 12.5.2 协程间通信
一般协程之间的通信都是使用通道作为中介传递参数。

```lua
-- 使用通道进行协程通信
local channels = {}

local function create_channel(name)
    channels[name] = {}
    local queue = channels[name]

    return {
        send = function(value)
            table.insert(queue, value)
            coroutine.yield() -- 发送后让出
        end,

        receive = function()
            while #queue == 0 do
                coroutine.yield() -- 等待数据
            end
            
            return table.remove(queue, 1)
        end
    }
end

local ch = create_channel("comm")

local sender = coroutine.create(function()
    for i = 1, 3 do
        print("发送: 消息" .. i)
        ch.send("消息" .. i)
    end
end)

local receiver = coroutine.create(function()
    for i = 1, 3 do
        local msg = ch.receive()
        print("接收: " .. msg)
    end
end)

-- 交替执行
for i = 1, 6 do
    coroutine.resume(sender)
    coroutine.resume(receiver)
end
--[[ 输出
发送: 消息1
接收: 消息1
发送: 消息2
接收: 消息2
发送: 消息3
接收: 消息3
--]]
```

### 13.5.3 错误处理
```lua
print("协程的处理")
local function error_example()
    print("  开始执行")
    coroutine.yield("第一步正常")
    error("故意出错！")  -- 抛出错误
    print("  这行不会执行")
end

local co_error = coroutine.create(error_example)

print("  第一次resume（正常）:")
local success, result = coroutine.resume(co_error)
print("  结果: success=" .. tostring(success) .. ", result=" .. tostring(result))

print("\n  第二次resume（触发错误）:")
success, result = coroutine.resume(co_error)
if not success then
    print("  错误发生: " .. result)
end
print("  协程状态: " .. coroutine.status(co_error))  -- dead
--[[ 输出
  第一次resume（正常）:
  开始执行
  结果: success=true, result=第一步正常

  第二次resume（触发错误）:
  错误发生: d:\KR\VScode_KR_workspace\test.lua:4: 故意出错！
  协程状态: dead
--]]

-- 安全执行模式，捕获错误
local function safe_execute(co, ...)
    local ok, err = coroutine.resume(co, ...)
    
    if not ok then
        print("协程错误: " .. err)
        print("协程状态: " .. coroutine.status(co))
        return false, err
    end
    
    return true, err
end

local function risky_task()
    error("错误！")

    return "成功"
end

local co = coroutine.create(risky_task)
local ok, result = safe_execute(co)
print("执行结果: " .. tostring(result))
--[[ 输出
协程错误: test.lua:15: 错误！
协程状态: dead
执行结果: test.lua:15: 错误！
--]]
```

## 12.6 协程实用模式

### 12.6.1 生产者-消费者模式
```lua
-- 生产者
local function producer(items)
    for i = 1, items do
        print("生产: 产品" .. i)
        coroutine.yield("产品" .. i) -- 生产一个就让出
    end
    
    return "生产完成"
end

-- 消费者
local function consumer(co)
    while true do
        local success, product = coroutine.resume(co, 5)

        if not success or product == "生产完成" then
            break
        end

        print("消费: " .. product)
    end
    print("消费完成")
end

local producer_co = coroutine.create(producer)
consumer(producer_co)
--[[ 输出
生产: 产品1
消费: 产品1
生产: 产品2
消费: 产品2
生产: 产品3
消费: 产品3
生产: 产品4
消费: 产品4
生产: 产品5
消费: 产品5
消费完成
--]]
```

### 12.6.2 异步任务调度
```lua
local tasks = {}  -- 任务队列

local function add_task(func, ...)
    local co = coroutine.create(func)
    table.insert(tasks, {co = co, args = {...}})
end

local function scheduler()
    while #tasks > 0 do
        local task = table.remove(tasks, 1)
        local ok, result = coroutine.resume(task.co, unpack(task.args))
        
        if coroutine.status(task.co) == "suspended" then
            -- 任务还未完成，放回队列
            table.insert(tasks, task)
        end
    end
end

-- 添加任务
add_task(function(name)
    print("任务 " .. name .. " 开始")
    coroutine.yield()
    print("任务 " .. name .. " 继续")
    coroutine.yield()
    print("任务 " .. name .. " 完成")
end, "A")

add_task(function(name)
    print("任务 " .. name .. " 步骤1")
    coroutine.yield()
    print("任务 " .. name .. " 步骤2")
end, "B")

-- 运行调度器
scheduler()
--[[ 输出
任务 A 开始
任务 B 步骤1
任务 A 继续
任务 B 步骤2
任务 A 完成
--]]
```

### 12.6.3 迭代器实现
```lua
-- 使用协程实现迭代器
local function walk_list(list)
    return coroutine.wrap(function()
        for i = 1, #list do
            coroutine.yield(i, list[i])
        end
    end)
end

-- 使用示例
local list = {
    "a",
    "b",
    "c"
}

for i, v in walk_list(list) do
    print(i .. ": " .. v)
end
--[[ 输出
1: a
2: b
3: c
--]]
```

## 12.7 练习

### 练习 1：使用协程实现生成器
（答案见[[第 1 节 - 语法/参考答案#练习 12 1：使用协程实现生成器]]）
```lua
-- 使用协程实现一个范围生成器
-- 使用示例：
for i in range(1, 10, 2) do
    print(i)
end
--[[ 输出
1
3
5
7
9
--]]
```

## 12.8 本章总结

### 关键知识点回顾
1. **协程核心概念**：
	- **协作式多任务**：由程序控制切换（主动让出）
	- **四种状态**：suspended、running、normal、dead
	- **轻量级**：比线程轻量，适合 I/O 密集型任务
	- **可预测性**：可阅读代码预测执行顺序

2. **核心函数**：
	- `coroutine.create` - 创建协程
	- `coroutine.resume` - 启动/恢复执行
	- `coroutine.yield` - 让出执行权
	- `coroutine.status` - 获取状态
	- `coroutine.wrap` - 包装为函数
	- `coroutine.running` - 获取当前协程

3. **数据传递**：
	- resume 参数传递给函数或 yield
	- yield 返回值给 resume
	- 支持多值传递
	- 协程之间的通信

4. **错误处理**：
	- resume 返回 success 标志
	- 协程内错误不会影响主线程

5. **实用模式**：
	- 生产者-消费者模式
	- 异步任务调度
	- 迭代器实现

### 常见错误与技巧
```lua
-- 错误：resume 重启已结束的协程
local co = coroutine.create(function()
	return "done"
end)
coroutine.resume(co)  -- 正确
coroutine.resume(co)  -- 错误！协程已dead

-- 技巧：使用wrap简化调用
local gen = coroutine.wrap(function()
    for i = 1, 3 do
    	coroutine.yield(i)
    end
end)
print(gen(), gen(), gen())  -- 1, 2, 3

-- 注意：yield不能在某些C函数中使用
local function bad_example()
    table.sort({}, function() 
        coroutine.yield()  -- 错误！
    end)
end

-- 技巧：使用协程实现状态保持
local function counter()
    local count = 0
    return coroutine.wrap(function()
        while true do
            count = count + 1
            coroutine.yield(count)
        end
    end)
end

local c = counter()
print(c(), c(), c())  -- 1, 2, 3
```

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 理解协程与线程的区别
- [ ] 创建、启动和暂停协程
- [ ] 在协程间传递数据
- [ ] 使用协程实现生产者-消费者模式
- [ ] 处理协程执行中的错误
- [ ] 使用协程创建迭代器

### 思考题
1. 为什么 Lua 选择使用协程，而不是线程？
2. 协程的 "协作式" 与线程的 "抢占式" 有什么根本区别？
3. 协程的 yield 和 return 在数据传递上有什么不同？
4. 如何用协程实现一个简单的状态机？

---

**下一章预告**：在第 13 章中，我们将学习元表，让我们能够控制其他表的各种行为，实现面向对象编程，向量加减等。
