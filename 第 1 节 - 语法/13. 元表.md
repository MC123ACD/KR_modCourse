
## 13.1 什么是元表？

元表（**Metatable**）是 Lua 中一种特殊的表，可以定义其他表的"行为"。它允许我们改变表的默认操作，比如加法、减法、索引访问等。

### 13.1.1 为什么需要元表？

1. **运算符重载**：让表支持算术运算
2. **自定义行为**：改变表的索引和赋值
3. **面向对象**：实现继承、私有性等特性
4. **保护数据**：创建只读表、受限表

#### 示例：没有元表的限制
```lua
local vector1 = {x = 10, y = 20}
local vector2 = {x = 5, y = 15}

-- 尝试相加两个表（会报错）
local sum = vector1 + vector2  -- 错误！table 不支持加法
print(sum)

-- 尝试比较两个表（比较的是引用，不是值）
print(vector1 == vector2)  -- false（即使值相同也是false）
print(tostring(vector1))   -- table: 0x000001（不是我们想要的格式）
```

## 13.2 元表基础概念

### 13.2.1 setmetatable - 设置元表
```lua
setmetatable(表: table, 元表: table) -> 设置元表后的表: table
```

#### 示例
```lua
-- 创建一个普通表
local mytable = {}

-- 创建一个元表
local metatable = {
	__add = function()
		return "add"
	end
}

-- 设置元表
setmetatable(mytable, metatable)

-- 可简化为
local mytable = setmetatable({}, {
	__add = function()
		return "add"
	end
})
```

### 13.2.2 getmetatable - 获取元表
```lua
getmetatable(表: table) -> 元表: table
```

#### 示例
```lua
local mytable = {}

local metatable = {
	__add = function()
		return "add"
	end
}

setmetatable(mytable, metatable)

local mt = getmetatable(mytable)
print(mt == metatable)  -- true
```

### 13.2.3 元方法类型
元方法分为以下几类：

1. **算术元方法**：`__add`、`__sub `、` __mul `、` __div `、` __mod `、` __pow `、` __unm `（负号）
2. **关系元方法**：`__eq`、`__lt`、`__le`
3. **库元方法**：`__tostring`、`__concat`
4. **索引元方法**：`__index`、`__newindex`
5. **调用元方法**：`__call`

#### 示例
```lua
local Vector = {}
Vector.__index = Vector

function Vector.new(x, y)
    local v = {
    	x = x, 
    	y = y
    }
    setmetatable(v, Vector)
    return v
end

-- 定义 __add 元方法
function Vector.__add(a, b)
    return Vector.new(a.x + b.x, a.y + b.y)
end

-- 定义 __tostring 元方法
function Vector.__tostring(self)
    return string.format("Vector(%d, %d)", self.x, self.y)
end

-- 使用示例
local v1 = Vector.new(10, 20)
local v2 = Vector.new(5, 15)
local v3 = v1 + v2  -- 现在可以相加了！

print(v1)    -- Vector(10, 20)
print(v2)    -- Vector(5, 15)
print(v3)    -- Vector(15, 35)
```

## 13.3 算术和关系元方法

### 13.3.1 算术元方法

```lua
-- 复数类示例
local Complex = {}
Complex.__index = Complex

function Complex.new(real, imag)
    local c = {real = real, imag = imag}
    setmetatable(c, Complex)
    return c
end

-- 加法
function Complex.__add(a, b)
    return Complex.new(a.real + b.real, a.imag + b.imag)
end

-- 减法
function Complex.__sub(a, b)
    return Complex.new(a.real - b.real, a.imag - b.imag)
end

-- 乘法
function Complex.__mul(a, b)
    -- (a+bi)(c+di) = (ac-bd) + (ad+bc)i
    local real = a.real * b.real - a.imag * b.imag
    local imag = a.real * b.imag + a.imag * b.real
    return Complex.new(real, imag)
end

-- 负号
function Complex.__unm(a)
    return Complex.new(-a.real, -a.imag)
end

-- 字符串表示
function Complex.__tostring(self)
    if self.imag >= 0 then
        return string.format("(%d+%di)", self.real, self.imag)
    else
        return string.format("(%d%di)", self.real, self.imag)
    end
end

-- 使用示例
local c1 = Complex.new(3, 4)  -- 3+4i
local c2 = Complex.new(1, 2)  -- 1+2i

print(c1)           -- (3+4i)
print(c2)           -- (1+2i)
print(c1 + c2)      -- (4+6i)
print(c1 - c2)      -- (2+2i)
print(c1 * c2)      -- (-5+10i)
print(-c1)          -- (-3-4i)
```

### 13.3.2 关系元方法
```lua
-- 分数类示例
local Fraction = {}
Fraction.__index = Fraction

function Fraction.new(numerator, denominator)
    local f = {
    	num = numerator, 
    	den = denominator or 1
    }
    setmetatable(f, Fraction)
    return f
end

-- 相等判断（约分后比较）
function Fraction.__eq(a, b)
    return a.num * b.den == b.num * a.den
end

-- 小于判断
function Fraction.__lt(a, b)
    return a.num * b.den < b.num * a.den
end

-- 小于等于判断
function Fraction.__le(a, b)
    return a.num * b.den <= b.num * a.den
end

function Fraction.__tostring(self)
    return string.format("%d/%d", self.num, self.den)
end

-- 使用示例
local f1 = Fraction.new(1, 2)   -- 1/2
local f2 = Fraction.new(2, 4)   -- 2/4
local f3 = Fraction.new(3, 4)   -- 3/4

print(f1 == f2)     -- true（1/2 == 2/4）
print(f1 < f3)      -- true（1/2 < 3/4）
print(f3 <= f2)     -- false（3/4 <= 1/2）
print(f1 <= f2)     -- true（1/2 <= 1/2）
```

### 13.3.3 大于关系元方法
不存在大于关系元方法，但是可以通过交换小于关系原方法的操作数来巧妙实现。我们这里不用实现，因为 Lua 已经帮我们实现了：
```lua
-- 理解大于关系原理
local debugFraction = {}
debugFraction.__index = debugFraction

function debugFraction.new(value)
    local f = {value = value}
    setmetatable(f, debugFraction)
    return f
end

function debugFraction.__lt(a, b)
    print(string.format("调用 __lt: %s < %s, 结果: %s", a.value, b.value, tostring(a.value < b.value)))
end

function debugFraction.__le(a, b)
    print(string.format("调用 __le: %s <= %s, 结果: %s", a.value, b.value, tostring(a.value <= b.value)))
end

local a = debugFraction.new(1)
local b = debugFraction.new(2)

_ = a < b
_ = a <= b
_ = a > b
_ = a >= b
--[[ 输出
调用 __lt: 1 < 2, 结果: true
调用 __le: 1 <= 2, 结果: true
调用 __lt: 2 < 1, 结果: false
调用 __le: 2 <= 1, 结果: false
--]]
```

## 13.4 索引相关元方法

### 13.4.1 `__index` - 索引不存在键
索引表中不存在键时调用元表中的 `__index` 函数，如果 `__index` 是一个表将会在这个表中索引键。

```lua
-- 示例1：使用函数作为 __index
local john = {name = "John", age = 25}
setmetatable(john, {
    __index = function(table, key)
        if key == "birthYear" then
            return 2025 - table.age
        elseif key == "info" then
            return table.name .. ", " .. table.age .. " years old"
        else
            return nil  -- 返回nil表示不存在
        end
    end
})

print(john.name)        -- John（直接访问）
print(john.age)         -- 25（直接访问）
print(john.birthYear)   -- 2000（不存在，调用 __index）
print(john.info)        -- John, 25 years old（不存在，调用 __index）
print(john.sayHello)    -- nil

-- 示例2：使用表作为 __index（实现继承）
local Animal = {
    sound = "???",
    makeSound = function(self)
        return self.sound
    end
}

local Dog = setmetatable({}, {
	__index = Animal
})  -- Dog继承Animal

Dog.sound = "Woof!"
Dog.bark = function(self)
    return self:makeSound() .. " " .. self:makeSound()
end

print(Dog:makeSound())  -- Woof!
print(Dog:bark())       -- Woof! Woof!
```

### 13.4.2 `__newindex` - 不存在索引赋值
给表中不存在的键赋值时调用

```lua
-- 示例1：限制特定键的赋值
local Config = {}

local metatable = {
    __newindex = function(table, key, value)
        if key == "version" then
            print("Cannot modify version!")
        elseif key == "author" then
            print("Cannot modify author!")
        else
            rawset(table, key, value)  -- 使用rawset绕过元方法
        end
    end
}

setmetatable(Config, metatable)

Config.version = "2.0"   -- Cannot modify version!
Config.port = 8080       -- 成功添加新字段
print(Config.port)       -- 8080

-- 示例2：自动类型检查
local Student = {}

local student_meta = {
    __newindex = function(table, key, value)
        if key == "grade" then
            if type(value) ~= "number" or value < 0 or value > 100 then
                print("Grade must be a number between 0 and 100")
            end
        elseif key == "name" then
            if type(value) ~= "string" then
                print("Name must be a string")
            end
        end
        
        rawset(table, key, value)
    end
}

local s1 = {}
setmetatable(s1, student_meta)

s1.grade = "A"         -- Grade must be a number between 0 and 100
s1.name = 123          -- Name must be a string
```

### 13.4.3 rawget - 绕过元方法索引
```lua
rawget(表: table, 索引: any)
```

#### 示例
```lua
local DangerTable = setmetatable({}, {
    __index = function(table, key)
        return table[key]
    end
})

-- print(DangerTable.v)	-- 栈会溢出

-- 使用rawget绕过元方法，避免栈溢出
print(rawget(DangerTable, "v"))  -- nil
```

### 13.4.4 rawset - 绕过元方法赋值
```lua
rawset(表: table, 索引: any, 值: any)
```

#### 示例
```lua
local SecureTable = setmetatable({}, {
    __newindex = function(table, key, value)
        if key == "ban_key" then
            print(string.format("Cannot set key: %s!", key))
        end
    end
})

SecureTable.ban_key = "new"    -- Cannot set key: ban_key!
print(SecureTable.ban_key)     -- nil

-- 使用rawset绕过元方法，为被禁止键赋值
rawset(SecureTable, "ban_key", "new")
print(SecureTable.ban_key)     -- new
```

### 13.4.5 每次索引调用元方法
不存在索引元方法，但是可以通过代理表来巧妙实现。

```lua
local function createTable(t)
    local new_table = t
    
    local proxy = setmetatable({}, {
        __index = function(table, key)
            print(string.format("索引: %s", key))
            return new_table[key]
        end,
        __newindex = function(table, key, value)
            print(string.format("赋值: %s", value))
            new_table[key] = value
        end
    })
    
    return proxy
end

local new_table = createTable()

-- 实际在操作 proxy 空表
new_table.a = 1
new_table.b = 2
_ = new_table.a
b = new_table.b
--[[ 输出
赋值: 1
赋值: 2
索引: a
索引: b
--]]
```

## 13.5 其他重要元方法

### 13.5.1 `__call` 元方法
让表可以像函数一样被调用。

```lua
-- 示例1：函数对象
local Counter = {
    count = 0
}

local counter_meta = {
    __call = function(self, increment)
        self.count = self.count + increment
        return self.count
    end
}

setmetatable(Counter, counter_meta)

print(Counter())      -- 1
print(Counter(5))     -- 6
print(Counter(2))     -- 8

-- 示例2：带参数的构造函数
local Point = {
    x = 0,
    y = 0
}

local point_meta = {
    __call = function(self, x, y)
        local p = {
        	x = x or self.x,
        	y = y or self.y
        }
        setmetatable(p, getmetatable(self))
        return p
    end,
    
    __tostring = function(self)
        return string.format("Point(%d, %d)", self.x, self.y)
    end
}

setmetatable(Point, point_meta)

local p1 = Point()          -- 使用默认值
local p2 = Point(10, 20)    -- 指定值
local p3 = Point(30)        -- 只指定x

print(p1)  -- Point(0, 0)
print(p2)  -- Point(10, 20)
print(p3)  -- Point(30, 0)
```

### 13.5.2 `__tostring` 元方法
自定义表的字符串表示。

```lua
local Book = {
    title = "",
    author = "",
    pages = 0
}

local book_meta = {
    __tostring = function(self)
        return string.format('"%s" by %s (%d pages)', 
                             self.title, self.author, self.pages)
    end
}

function Book.new(title, author, pages)
    local book = {
        title = title,
        author = author,
        pages = pages
    }
    setmetatable(book, book_meta)
    return book
end

local book1 = Book.new("Lua Programming", "John Doe", 350)
local book2 = Book.new("Metatables Guide", "Jane Smith", 200)

print(book1)  -- "Lua Programming" by John Doe (350 pages)
print(book2)  -- "Metatables Guide" by Jane Smith (200 pages)
```

### 13.5.3 `__concat` 元方法
自定义连接操作符(`..`)。

```lua
local StringWrapper = {}

function StringWrapper.new(str)
    local wrapper = {value = str or ""}
    setmetatable(wrapper, {
        __concat = function(a, b)
            local a_val = type(a) == "table" and a.value or a
            local b_val = type(b) == "table" and b.value or b
            return StringWrapper.new(a_val .. b_val)
        end,
        
        __tostring = function(self)
            return self.value
        end
    })
    return wrapper
end

local s1 = StringWrapper.new("Hello")
local s2 = StringWrapper.new(" World")
local s3 = s1 .. s2 .. "!"

print(s3)  -- Hello World!
print(type(s3))  -- table（仍然是StringWrapper对象）
```

## 13.6 元表的高级应用

### 13.6.1 面向对象编程
```lua
-- 实现一个简单的类系统
local Class = {}

function Class.create(name, super)
    local class = {}
    class.name = name
    class.super = super

    -- 设置继承链
    if super then
        setmetatable(class, { __index = super })
    end

    -- 类构造函数
    class.new = function(...)
        local instance = {}
        setmetatable(instance, { __index = class })

        -- 调用初始化方法
        if instance.init then
            instance:init(...)
        end

        return instance
    end

    return class
end

-- 基类：Animal
local Animal = Class.create("Animal")

function Animal:init(name)
    self.name = name
end

function Animal:speak()
    return "???"
end

function Animal:introduce()
    return "I am " .. self.name .. ", I say " .. self:speak()
end

-- 派生类：Dog
local Dog = Class.create("Dog", Animal)

function Dog:speak()
    return "Woof!"
end

function Dog:wagTail()
    return self.name .. " is wagging tail"
end

-- 派生类：Cat
local Cat = Class.create("Cat", Animal)

function Cat:speak()
    return "Meow!"
end

function Cat:purr()
    return self.name .. " is purring"
end

-- 使用示例
local dog = Dog.new("Buddy")
local cat = Cat.new("Whiskers")

print(dog:introduce())  -- I am Buddy, I say Woof!
print(cat:introduce())  -- I am Whiskers, I say Meow!
print(dog:wagTail())    -- Buddy is wagging tail
print(cat:purr())       -- Whiskers is purring

-- 调用父类的函数
print(cat.super:speak())-- ???

-- 检查继承关系
print(getmetatable(Dog).__index == Animal) -- true

```

### 13.6.2 只读表
```lua
local function readOnly(t)
    local proxy = {}
    local metatable = {
        __index = t,
        __newindex = function(table, key, value)
            print("Attempt to modify read-only table", 2)
        end,
        __metatable = "Read-only table"  -- 保护元表本身
    }
    setmetatable(proxy, metatable)
    return proxy
end

local config = {
    version = "1.0",
    port = 8080,
    host = "localhost"
}

local readOnlyConfig = readOnly(config)

print(readOnlyConfig.version)  -- 1.0
print(readOnlyConfig.port)     -- 8080

readOnlyConfig.port = 9090     -- Attempt to modify read-only table
readOnlyConfig.newKey = "test" -- Attempt to modify read-only table

-- 尝试获取元表
print(getmetatable(readOnlyConfig))  -- Read-only table
```

### 13.6.3 默认值表
```lua
function createDefaultTable(defaultValue)
    local t = {}
    local metatable = {
        __index = function(table, key)
            return defaultValue
        end
    }
    setmetatable(t, metatable)
    return t
end

-- 示例1：默认值为0
local scores = createDefaultTable(0)
scores.Alice = 95
scores.Bob = 87

print(scores.Alice)   -- 95
print(scores.Bob)     -- 87
print(scores.Charlie) -- 0（默认值）
print(scores.David)   -- 0（默认值）

-- 示例2：默认值为空表
local groups = createDefaultTable({})
groups.admin = { "Alice", "Bob" }
table.insert(groups.users, "Charlie")

print(#groups.admin)  -- 2
print(#groups.users)  -- 1
print(type(groups.guests)) -- table（默认空表）
```

## 13.7 元表的限制与注意事项

### 13.7.1 常见错误
```lua
-- 错误1：递归调用导致的栈溢出
local t = {}
local mt = {
    __index = function(table, key)
        return table[key]  -- 错误！递归调用
    end
}
setmetatable(t, mt)
-- print(t.x)  -- 栈溢出

-- 正确做法
local t2 = {}
local mt2 = {
    __index = function(table, key)
        return rawget(table, key)  -- 使用rawget避免递归
    end
}

-- 错误2：忘记表传递的是引用，修改元表影响所有实例
local A = {x = 1}
local mt = {}
setmetatable(A, mt)

local B = {x = 2}
setmetatable(B, mt)  -- 和A共享元表

mt.__index = function() return 100 end

print(A.y)  -- 100（可能不是期望的行为）
print(B.y)  -- 100

-- 正确做法：每个实例使用独立的元表
local function createInstance(value)
    local obj = {x = value}
    setmetatable(obj, {
        __index = function(self, key)
            if key == "double" then
                return self.x * 2
            end
        end
    })
    return obj
end

local a = createInstance(10)
local b = createInstance(20)

print(a.double)  -- 20
print(b.double)  -- 40
```

### 13.7.2 性能考虑
```lua
-- 性能测试：元表访问 vs 直接访问
local iterations = 10000000

-- 直接访问
local directTable = { value = 42 }
local start1 = os.clock()
for i = 1, iterations do
    local v = directTable[i]
end
local time1 = os.clock() - start1

-- 通过元表访问
local metaTable = {}
local proxiedTable = { value = 42 }
setmetatable(proxiedTable, {
    __index = function(t, k)
        return rawget(t, k)
    end
})

local start2 = os.clock()
for i = 1, iterations do
    local v = proxiedTable[i]
end
local time2 = os.clock() - start2

print(string.format("直接访问: %.4f 秒", time1))
print(string.format("元表访问: %.4f 秒", time2))
print(string.format("开销: %.2f%%", (time2 - time1) / time1 * 100))
--[[ 输出
直接访问: 0.1740 秒
元表访问: 0.8650 秒
开销: 370%
--]]
```

## 13.8 练习

### 练习 1：实现向量类
```lua
-- 要求：
-- 1. 实现 Vector 类，支持 x, y 坐标
-- 2. 支持加法、减法、乘法（点积）
-- 3. 支持负号操作
-- 4. 支持字符串表示

-- 使用示例：
local v1 = Vector.new(3, 4)
local v2 = Vector.new(1, 2)

print(v1)           -- Vector(3, 4)
print(v2)           -- Vector(1, 2)
print(v1 + v2)      -- Vector(4, 6)
print(v1 - v2)      -- Vector(2, 2)
print(v1 * v2)      -- 11 (点积)
print(-v1)          -- Vector(-3, -4)
```

### 练习 2：跟踪向量的修改
```lua
-- 要求：
-- 1. 跟踪以上向量类的各种访问，加减点积等
-- 2. 可打印访问历史记录

-- 使用示例：
print("\n\n=== 练习2：带日志的向量类测试 ===")
local v1 = TrackedVector.new(3, 4)
local v2 = TrackedVector.new(1, 2)

print("v1 = " .. tostring(v1)) -- Vector(3, 4)
print("v2 = " .. tostring(v2)) -- Vector(1, 2)

local sum = v1 + v2
print("v1 + v2 = " .. tostring(sum)) -- Vector(4, 6)

local diff = v1 - v2
print("v1 - v2 = " .. tostring(diff)) -- Vector(2, 2)

local dot = v1 * v2
print("v1 * v2 = " .. dot) -- 11

local neg = -v1
print("-v1 = " .. tostring(neg)) -- Vector(-3, -4)

print("\n=== v1的操作日志 ===")
local v1_logs = v1:get_log()
print(table.concat(v1_logs, "\n"))

print("\n=== v2的操作日志 ===")
local v2_logs = v2:get_log()
print(table.concat(v2_logs, "\n"))
--[[ 输出
=== 练习2：带日志的向量类测试 ===
v1 = Vector(3, 4)
v2 = Vector(1, 2)
v1 + v2 = Vector(4, 6)
v1 - v2 = Vector(2, 2)
v1 * v2 = 11
-v1 = Vector(-3, -4)

=== v1的操作日志 ===
向量: Vector(3, 4)
1. 创建向量: Vector(3, 4)
2. 被加: 与 Vector(1, 2) 运算, 结果: Vector(4, 6)
3. 被减: 与 Vector(1, 2) 运算, 结果: Vector(2, 2)
4. 点积: 与 Vector(1, 2) 运算, 结果: 11
5. 取负: 运算, 结果: Vector(-3, -4)

=== v2的操作日志 ===
向量: Vector(1, 2)
1. 创建向量: Vector(1, 2)
2. 加数: 与 Vector(3, 4) 运算, 结果: Vector(4, 6)
3. 减数: 与 Vector(3, 4) 运算, 结果: Vector(2, 2)
4. 点积: 与 Vector(3, 4) 运算, 结果: 11
--]]
```

## 13.9 本章总结

### 关键知识点回顾
1. **元表基础**：
	- `setmetatable(t, mt)` - 设置元表
	- `getmetatable(t)` - 获取元表
	- 元表可以改变表的默认行为

2. **算术和关系元方法**：
	- `__add` 加、`__sub` 减、`__mul` 乘、`__div` 除 - 四则运算
	- `__eq`、`__lt`、`__le` - 等于与小于关系比较
	- `__unm` - 负号操作
	- `__mod`、`__pow` - 取模和幂运算
	- 大于关系的原理：交换操作数

3. **索引相关元方法**：
	- `__index` - 索引不存在的键时调用，如果是表则在该表索引
	- `__newindex` - 给不存在的键赋值时调用
	- `rawget` - 绕过 `__index` 索引
	- `rawset` - 绕过 `__newindex` 赋值
	- 使用代理表在每次索引时调用元方法

4. **其他元方法**：
	- `__tostring` - 自定义字符串表示
	- `__call` - 让表可被调用
	- `__concat` - 连接操作符

5. **高级应用**：
	- 面向对象编程（继承、多态）
	- 只读表和受保护表
	- 默认值表
	- 访问跟踪和日志

### 检查清单
完成本章后，你应该能够：
- [ ] 理解元表的作用和原理
- [ ] 设置和获取元表
- [ ] 实现基本的算术和关系运算重载
- [ ] 理解大于关系原理
- [ ] 使用 `__index`、`__newindex` 和代理表控制索引与赋值
- [ ] 实现表的只读保护
- [ ] 使用元表实现简单的类继承
- [ ] 理解 `rawget` 和 `rawset` 的作用
- [ ] 实现表的自定义字符串表示
- [ ] 让表可以像函数一样被调用

### 思考题
1. 元表和原型继承有什么关系？
2. 为什么 Lua 使用元表而不是传统的类继承？
3. 如何实现多重继承？
4. 元表和协程结合可以解决什么问题？