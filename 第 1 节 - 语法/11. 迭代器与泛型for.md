# 第 11 章：迭代器和泛型 for

## 11.1 为什么需要迭代器？

在编程中，我们经常需要遍历集合中的元素。迭代器提供了一种统一的方式来访问各种数据结构。

```lua
-- 不使用迭代器的问题
local fruits = {"苹果", "香蕉", "橙子", "葡萄"}

-- 方式1：使用数值for循环
print("方式1 - 数值for循环:")
for i = 1, #fruits do
    print("  水果" .. i .. ": " .. fruits[i])
end

-- 问题：需要知道数据结构（是数组），需要知道长度
-- 对于不是数组的表，这种方法无效

local student = {
    name = "小明",
    age = 18,
    grade = "高三"
}

-- 方式2：使用pairs（但不是标准迭代器方式）
print("\n方式2 - 使用pairs:")
for k, v in pairs(student) do
    print("  " .. k .. ": " .. v)
end

-- 问题：顺序不确定，不能控制遍历逻辑

-- 迭代器可以解决这些问题！
print("\n使用迭代器的优势:")
print("  1. 统一的遍历接口")
print("  2. 封装遍历逻辑")
print("  3. 支持复杂遍历模式")
print("  4. 惰性求值（需要时才计算）")
```

## 11.2 迭代器基础概念

### 11.2.1 什么是迭代器？

迭代器是一个能够生成序列中下一个值的函数。在 Lua 中，迭代器通常遵循以下模式：

```lua
-- 迭代器三要素：
-- 1. 迭代器函数：每次调用返回下一个值
-- 2. 不可变状态：遍历过程中不变的数据
-- 3. 控制变量：当前遍历位置

-- 简单的迭代器示例：生成数字序列
local function number_iterator(max)
    local i = 0  -- 控制变量（初始值）
    
    -- 迭代器函数
    return function()
        i = i + 1
        if i <= max then
            return i  -- 返回下一个值
        end
        -- 返回nil表示结束
    end
end

print("数字序列迭代器:")
local iter = number_iterator(5)

print("  第一次调用: " .. (iter() or "nil"))
print("  第二次调用: " .. (iter() or "nil"))
print("  第三次调用: " .. (iter() or "nil"))
print("  第四次调用: " .. (iter() or "nil"))
print("  第五次调用: " .. (iter() or "nil"))
print("  第六次调用: " .. (iter() or "nil"))  -- 超过范围，返回nil
--[[ 输出
第一次调用: 1
第二次调用: 2
第三次调用: 3
第四次调用: 4
第五次调用: 5
第六次调用: nil
--]]
```

### 11.2.2 泛型 for 循环

泛型 for 循环是 Lua 中使用迭代器的主要方式：

```lua
for ->迭代器返回的参数: any... in 迭代器函数: func, 不可变状态: any, 控制变量: any do
	-- 循环体
end
```

#### 示例
```lua
-- 基本示例
print("基本示例 - 遍历数组:")
local colors = {"红色", "绿色", "蓝色", "黄色"}

for i, color in ipairs(colors) do
    print("  颜色" .. i .. ": " .. color)
end
--[[ 输出
颜色1: 红色
颜色2: 绿色
颜色3: 蓝色
颜色4: 黄色
--]]

-- ipairs实际上是一个迭代器工厂，返回上述三个值
print("\nipairs的工作原理:")
local iter, t, i = ipairs(colors)
print("  迭代器函数: " .. type(iter))
print("  不可变状态: " .. tostring(t))
print("  控制变量: " .. tostring(i))
--[[ 输出
迭代器函数: function
不可变状态: table: 00D99EA0
控制变量: 0
--]]

-- 手动模拟泛型for循环
print("\n手动模拟泛型for循环:")
local iterator_func, invariant_state, control_var = ipairs(colors)
local var1, var2 = iterator_func(invariant_state, control_var)

while var1 do
    print("  索引: " .. var1 .. ", 值: " .. var2)
    var1, var2 = iterator_func(invariant_state, var1)
end
--[[ 输出
索引: 1, 值: 红色
索引: 2, 值: 绿色
索引: 3, 值: 蓝色
索引: 4, 值: 黄色
--]]
-- 这等价于：
-- for i, color in ipairs(colors) do
--     print("  索引: " .. i .. ", 值: " .. color)
-- end
```

#### 工作流程
```lua
-- 1. 初始化：获取三要素
local iterator_func, state, control_var = ipairs(colors)

-- 2. 第一次调用，为迭代器函数传递不可变状态与控制变量
control_var, value... = iterator_func(state, control_var)  -- control_var = 0 -> 1

-- 3. 循环直到返回 nil
while control_var do
    -- 使用控制变量和其他返回值
    print(control_var, value...)
    
    -- 下一次调用，更新控制变量和其他返回值，注意：不可变状态依旧使用第一次调用时的，不会更新！
    control_var, value... = iterator_func(state, control_var)
end
```

**示意图**：
![[Pasted image 20251211142754.png|1125]]

#### 泛型 for vs 手动 while

```lua
-- 泛型 for（简洁、安全）
for i, v in ipairs(t) do
    print(i, v)
end

-- 手动实现（理解原理）
local iter, state, var = ipairs(t)
local var1, var2 = iter(state, var)
while var1 do
    print(var1, var2)
    var1, var2 = iter(state, var1)
end
```

## 11.3 Lua 内置迭代器

### 11.3.1 ipairs - 数组迭代器

ipairs 用于遍历数组部分（索引从 1 开始）

```lua
for ->索引: int, ->值: any in ipairs(表: table) do
    -- 循环体
end
```

#### 示例
```lua
-- 基本用法
local numbers = {10, 20, 30, 40, 50}
print("遍历数组:")
for i, num in ipairs(numbers) do
    print("  numbers[" .. i .. "] = " .. num)
end

-- ipairs的特性
print("\nipairs的特性:")
local mixed_table = {
    "第一个",        -- 索引1
    "第二个",        -- 索引2
    name = "小明",   -- 键值对，不在数组部分
    "第三个",        -- 索引3
    age = 18        -- 键值对
}

print("混合表的ipairs遍历:")
for i, value in ipairs(mixed_table) do
    print("  索引 " .. i .. ": " .. value)
end
-- 注意：只遍历数组部分（索引1, 2, 3），跳过键值对
--[[ 输出
混合表的ipairs遍历:
  索引 1: 第一个
  索引 2: 第二个
  索引 3: 第三个
--]]

-- 有"洞"的数组
print("\n有洞数组的ipairs:")
local array_with_holes = {"A", nil, "C", "D"}
for i, value in ipairs(array_with_holes) do
    print("  索引 " .. i .. ": " .. (value or "nil"))
end
--[[ 输出
  索引 1: A
--]]
-- 注意：遇到第一个nil就停止，所以只输出索引1
```

#### 实现自定义的 ipairs
```lua
-- 实现自定义的ipairs（理解原理）
local function my_ipairs(t)
    local function iterator(state, index)
        index = index + 1
        local value = state[index]
        
        if value ~= nil then
            return index, value
        end
    end
    
    return iterator, t, 0
end

print("\n自定义ipairs测试:")
for i, value in my_ipairs(numbers) do
    print("  numbers[" .. i .. "] = " .. value)
end
--[[ 输出
numbers[1] = 10
numbers[2] = 20
numbers[3] = 30
numbers[4] = 40
numbers[5] = 50
--]]
```

### 11.3.2 pairs - 通用迭代器

pairs用于遍历表的所有键值对。

```lua
for ->键: any, ->键值: any in ipairs(表: table) do
    -- 循环体
end
```

#### 示例
```lua
-- 基本用法
local student = {
    name = "李雷",
    age = 16,
    grade = "高一",
    class = "1班",
    scores = {85, 92, 78}
}

print("遍历学生信息:")
for key, value in pairs(student) do
    if type(value) == "table" then
        print("  " .. key .. ": [表]")
    else
        print("  " .. key .. ": " .. tostring(value))
    end
end

-- pairs的特性
print("\npairs的特性:")
print("  1. 遍历所有键值对（包括数组部分和字典部分）")
print("  2. 遍历顺序不确定（依赖表的实现）")
print("  3. 可以遍历任何类型的键（除了nil）")

-- 包含各种类型键的表
local complex_table = {
    [1] = "数字键1",
    ["1"] = "字符串键1",
    [true] = "布尔键",
    [function() end] = "函数键",  -- 不常见但可能
    normal = "普通键"
}

print("\n复杂键表的pairs遍历:")
for k, v in pairs(complex_table) do
    local key_type = type(k)
    if key_type == "function" then
        print("  函数键: " .. v)
    else
        print("  " .. key_type .. "键 '" .. tostring(k) .. "': " .. v)
    end
end
```

#### 实现自定义的pairs（简化版）
```lua
local function my_pairs(t)
    local function iterator(state, key)
        -- 获取下一个键值对
        local next_key, next_value = next(state, key)
        return next_key, next_value
    end
    return iterator, t, nil
end

print("\n自定义pairs测试:")
local count = 0
for key, value in my_pairs(student) do
    if count < 3 then  -- 只显示前3个
        print("  " .. key .. ": " .. tostring(value))
    end
    count = count + 1
end
print("  总键值对数: " .. count)
--[[ 输出
scores: table: 00E09E50
name: 李雷
class: 1班
总键值对数: 5
--]]
```

#### next 函数的使用
```lua
-- next函数的使用
print("\nnext函数演示:")
local t = {a = 1, b = 2, c = 3}
local key, value = next(t)  -- 第一个键值对
print("  第一个: " .. key .. " = " .. value)

key, value = next(t, key)   -- 第二个键值对
print("  第二个: " .. key .. " = " .. value)

key, value = next(t, key)   -- 第三个键值对
print("  第三个: " .. key .. " = " .. value)

key, value = next(t, key)   -- 没有更多，返回nil
print("  第四个: " .. tostring(key) .. " = " .. tostring(value))
--[[ 输出
第一个: a = 1
第二个: c = 3
第三个: b = 2
第四个: nil = nil
--]]
```

### 11.3.3 string.gmatch - 字符串迭代器

string.gmatch 用于匹配多个模式。

```lua
string.gmatch(字符串: str, 匹配模式: str) -> 迭代器函数: func
```

#### 示例
```lua
-- 基本用法：遍历单词
local sentence = "The quick brown fox jumps over the lazy dog"
print("句子: " .. sentence)
print("\n遍历单词:")

for word in string.gmatch(sentence, "%a+") do
    print("  单词: " .. word)
end

-- 提取特定模式
local data = "姓名: 张三, 年龄: 25, 城市: 北京, 职业: 工程师"
print("\n提取键值对:")

for key, value in string.gmatch(data, "(%a+):%s*([^,]+)") do
    print("  " .. key .. ": " .. value)
end

-- 解析CSV行
local csv_line = "苹果,5,2.5,12.5"
print("\n解析CSV:")
local index = 1
for field in string.gmatch(csv_line, "([^,]+)") do
    print("  字段" .. index .. ": " .. field)
    index = index + 1
end

-- 解析多行文本
local multiline_text = [[
第一行内容
第二行内容
第三行内容
第四行内容
]]

print("\n遍历文本行:")
local line_number = 1
for line in string.gmatch(multiline_text, "([^\n]+)") do
    print("  行" .. line_number .. ": " .. line)
    line_number = line_number + 1
end

-- 提取URL参数
local url = "https://example.com/search?q=lua&page=2&sort=recent"
print("\n提取URL参数:")

-- 找到查询字符串部分
local query_string = string.match(url, "%?(.+)") or ""
for param in string.gmatch(query_string, "([^&]+)") do
    local key, value = string.match(param, "([^=]+)=?(.*)")
    print("  参数: " .. key .. " = " .. (value ~= "" and value or "true"))
end

-- 实现自定义的字符串分割迭代器
local function split_string(str, delimiter)
    delimiter = delimiter or " "
    local pattern = string.format("([^%s]+)", delimiter)
    
    return string.gmatch(str, pattern)
end

print("\n自定义字符串分割:")
local text = "苹果 香蕉 橙子 葡萄 西瓜"
for fruit in split_string(text) do
    print("  水果: " .. fruit)
end
--[[ 输出
水果: 苹果
水果: 香蕉
水果: 橙子
水果: 葡萄
水果: 西瓜
--]]
```

#### 实现自定义字符串迭代器
```lua
-- 更高级的字符串迭代器：逐字符遍历
local function chars(str)
    local chars = {}
    local i = 1
    local len = #str

    while i <= len do
        local b = string.byte(str, i)
        local char_len

        -- UTF-8 字符长度检测
        if b < 128 then -- ASCII
            char_len = 1
        elseif b >= 194 and b <= 223 then
            char_len = 2
        elseif b >= 224 and b <= 239 then
            char_len = 3
        elseif b >= 240 and b <= 244 then
            char_len = 4
        else
            char_len = 1 -- 无效字节
        end

        table.insert(chars, string.sub(str, i, i + char_len - 1))
        i = i + char_len
    end

    return chars
end

local chars = chars("你好 Hello 世界!")
for i, char in ipairs(chars) do
    print("  字符 " .. i .. ": '" .. char .. "' (字节长度: " .. #char .. ", ASCII: " .. string.byte(char) .. ")")
end
--[[ 输出
字符 1: '你' (字节长度: 3, ASCII: 228)
字符 2: '好' (字节长度: 3, ASCII: 229)
字符 3: ' ' (字节长度: 1, ASCII: 32)
字符 4: 'H' (字节长度: 1, ASCII: 72)
字符 5: 'e' (字节长度: 1, ASCII: 101)
字符 6: 'l' (字节长度: 1, ASCII: 108)
字符 7: 'l' (字节长度: 1, ASCII: 108)
字符 8: 'o' (字节长度: 1, ASCII: 111)
字符 9: ' ' (字节长度: 1, ASCII: 32)
字符 10: '世' (字节长度: 3, ASCII: 228)
字符 11: '界' (字节长度: 3, ASCII: 231)
字符 12: '!' (字节长度: 1, ASCII: 33)
--]]
```

## 11.4 无状态迭代器

无状态迭代器不保存任何状态，所有状态都通过参数传递。

### 11.4.1 理解无状态迭代器

```lua
-- 示例：遍历数组的无状态迭代器
local function array_iterator(t, index)
    index = index + 1
    local value = t[index]
    
    if value then
        return index, value
    end
end

local function iter_array(t)
    return array_iterator, t, 0
end

-- 使用
local fruits = {"苹果", "香蕉", "橙子"}
print("无状态迭代器遍历数组:")
for i, fruit in iter_array(fruits) do
    print("  fruits[" .. i .. "] = " .. fruit)
end

-- 对比：有状态迭代器（使用闭包）
local function stateful_array_iterator(t)
    local i = 0
    
    return function()
        i = i + 1
        local value = t[i]
        
        if value then
            return i, value
        end
    end
end

print("\n有状态迭代器遍历数组:")
for i, fruit in stateful_array_iterator(fruits) do
    print("  fruits[" .. i .. "] = " .. fruit)
end

-- 无状态迭代器的优势
print("\n无状态迭代器优势:")
print("  1. 更高效：不创建闭包")
print("  2. 可复用：相同的迭代器函数可用于多个表")
print("  3. 更简单：状态管理由泛型for处理")

-- 实现一个无状态迭代器来遍历表的键值对
local function next_pair(t, key)
    return next(t, key)
end

local function iter_pairs(t)
    return next_pair, t, nil
end

print("\n无状态pairs迭代器:")
local colors = {red = "红色", green = "绿色", blue = "蓝色"}
for key, value in iter_pairs(colors) do
    print("  " .. key .. ": " .. value)
end
```

### 11.4.2 创建无状态迭代器

```lua
-- 创建各种无状态迭代器

-- 1. 数字范围迭代器
local function range_iterator(limit, current)
    current = current + 1
    if current <= limit then
        return current
    end
end

local function range(from, to)
    return range_iterator, to, from - 1 -- 注意：控制变量初始化为from-1
end

print("数字范围迭代器:")
for i in range(5, 10) do
    print("  i = " .. i)
end
--[[ 输出
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
--]]

-- 2. 质数迭代器
local function is_prime(n)
    if n < 2 then
        return false
    end
    if n == 2 then
        return true
    end
    if n % 2 == 0 then
        return false
    end

    for i = 3, math.sqrt(n), 2 do
        if n % i == 0 then
            return false
        end
    end

    return true
end

local function prime_iterator(limit, current)
    -- 找到下一个质数
    repeat
        current = current + 1
        if current > limit then
            return nil
        end
    until is_prime(current)

    return current
end

local function primes(limit)
    return prime_iterator, limit, 1 -- 从1开始（实际从2开始检查）
end

print("\n质数迭代器（小于50的质数）:")
for prime in primes(50) do
    io.write(prime .. " ")
end
print()
-- 输出 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 

-- 3. 文件行迭代器
local function lines_iterator(file, lines)
    return table.remove(file, 1)
end

local function lines(file)
    -- 返回迭代器函数、文件和nil（初始控制变量）
    return lines_iterator, file, nil
end

print("\n文件行迭代器（模拟）:")
-- 为了演示，我们模拟文件内容
local mock_file_content = {
    "第一行内容",
    "第二行内容",
    "第三行内容",
    nil -- 文件结束
}

for line in lines(mock_file_content) do
    print("  " .. line)
end
--[[ 输出
第一行内容
第二行内容
第三行内容
--]]

-- 4. 表格行迭代器
local function table_rows_iterator(t, row_index)
    row_index = row_index + 1
    local row = t[row_index]
    if row then
        return row_index, unpack(row)
    end
end

local function table_rows(t)
    return table_rows_iterator, t, 0
end

local data_table = {
    { "张三", 18, "男" },
    { "李四", 19, "女" },
    { "王五", 20, "男" }
}

print("\n表格行迭代器:")
for row_index, name, age, gender in table_rows(data_table) do
    print(string.format("  行%d: 姓名=%s, 年龄=%d, 性别=%s",
        row_index, name, age, gender))
end
--[[ 输出
行1: 姓名=张三, 年龄=18, 性别=男
行2: 姓名=李四, 年龄=19, 性别=女
行3: 姓名=王五, 年龄=20, 性别=男
--]]
```

## 11.5 有状态迭代器

有状态迭代器使用闭包来保存状态，更灵活但可能效率稍低。

### 11.5.1 创建有状态迭代器

```lua
-- 有状态迭代器：使用闭包保存状态

-- 1. 计数器迭代器
local function counter(max)
    local count = 0
    
    return function()
        count = count + 1
        if count <= max then
            return count
        end
    end
end

print("计数器迭代器:")
for num in counter(5) do
    print("  计数: " .. num)
end
--[[ 输出
  计数: 1
  计数: 2
  计数: 3
  计数: 4
  计数: 5
--]]

-- 2. 斐波那契数列迭代器
local function fibonacci_iterator(limit)
    local a, b = 0, 1
    local count = 0
    
    return function()
        if count >= limit then
            return nil
        end
        
        local result = a
        a, b = b, a + b
        count = count + 1
        
        return result
    end
end

print("\n斐波那契数列迭代器（前10项）:")
for num in fibonacci_iterator(10) do
    io.write(num .. " ")
end
print()
-- 输出
0 1 1 2 3 5 8 13 21 34 

-- 3. 随机数迭代器
local function random_iterator(count, min, max)
    math.randomseed(os.time())
    local generated = 0
    
    return function()
        if generated >= count then
            return nil
        end
        
        generated = generated + 1
        return math.random(min, max)
    end
end

print("\n随机数迭代器（5个1-100的随机数）:")
for num in random_iterator(5, 1, 100) do
    io.write(num .. " ")
end
print()
-- 输出 68 74 70 95 72（以实际为准）

-- 4. 目录遍历迭代器（模拟）
local function directory_iterator(dir_path)
    -- 模拟的目录内容
    local mock_files = {
        {name = "file1.txt", type = "file", size = 1024},
        {name = "file2.txt", type = "file", size = 2048},
        {name = "subdir1", type = "dir", size = 0},
        {name = "file3.txt", type = "file", size = 3072},
    }
    
    local index = 0
    
    return function()
        index = index + 1
        local item = mock_files[index]
        
        if item then
            return item.name, item.type, item.size
        end
    end
end

print("\n目录遍历迭代器:")
for filename, filetype, filesize in directory_iterator("/mock/path") do
    local type_desc = filetype == "dir" and "目录" or "文件"
    print(string.format("  %s (%s, %d 字节)", filename, type_desc, filesize))
end
--[[ 输出
file1.txt (文件, 1024 字节)
file2.txt (文件, 2048 字节)
subdir1 (目录, 0 字节)
file3.txt (文件, 3072 字节)
--]]

-- 5. 数据库查询结果迭代器（模拟）
local function db_query_iterator(query)
    -- 模拟查询结果
    local mock_results = {
        {id = 1, name = "张三", age = 25},
        {id = 2, name = "李四", age = 30},
        {id = 3, name = "王五", age = 28},
        {id = 4, name = "赵六", age = 35},
    }
    
    local index = 0
    
    return function()
        index = index + 1
        local row = mock_results[index]
        
        if row then
            return row.id, row.name, row.age
        end
    end
end

print("\n数据库查询迭代器:")
for id, name, age in db_query_iterator("SELECT * FROM users") do
    print(string.format("  ID: %d, 姓名: %s, 年龄: %d", id, name, age))
end
--[[ 输出
ID: 1, 姓名: 张三, 年龄: 25
ID: 2, 姓名: 李四, 年龄: 30
ID: 3, 姓名: 王五, 年龄: 28
ID: 4, 姓名: 赵六, 年龄: 35
--]]
```

### 11.5.2 复杂的有状态迭代器

```lua
-- 1. 分页数据迭代器
local function paged_data_iterator(page_size, total_items)
    local current_page = 0
    local current_item = 0
    
    return function()
        -- 计算当前页
        if current_item % page_size == 0 then
            current_page = current_page + 1
            print(string.format("  加载第%d页...", current_page))
        end
        
        current_item = current_item + 1
        
        if current_item > total_items then
            return nil
        end
        
        -- 模拟数据项
        return current_item, "项目" .. current_item
    end
end

print("分页数据迭代器（每页3项，共10项）:")
for id, name in paged_data_iterator(3, 10) do
    print(string.format("    ID: %d, 名称: %s", id, name))
end
--[[ 输出
加载第1页...
  ID: 1, 名称: 项目1
  ID: 2, 名称: 项目2
  ID: 3, 名称: 项目3
加载第2页...
  ID: 4, 名称: 项目4
  ID: 5, 名称: 项目5
  ID: 6, 名称: 项目6
加载第3页...
  ID: 7, 名称: 项目7
  ID: 8, 名称: 项目8
  ID: 9, 名称: 项目9
加载第4页...
  ID: 10, 名称: 项目10
--]]

-- 2. 过滤器迭代器
local function filtered_iterator(original_iterator, filter_func)
    return function()
        while true do
            local values = {original_iterator()}
            
            if values[1] == nil then
                return nil  -- 原始迭代器结束
            end
            
            if filter_func(unpack(values)) then
                return unpack(values)
            end
            -- 如果不满足条件，继续下一个
        end
    end
end

print("\n过滤器迭代器:")
local numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

function number_iterator_from_table(t)
    local index = 0
    return function()
        index = index + 1
        return t[index]
    end
end

-- 只返回偶数
local even_filter = function(num)
    return num % 2 == 0
end

print("偶数过滤器:")
for num in filtered_iterator(number_iterator_from_table(numbers), even_filter) do
    io.write(num .. " ")
end
print()
-- 输出 2 4 6 8 10

-- 3. 转换迭代器
local function transformed_iterator(original_iterator, transform_func)
    return function()
        local values = {original_iterator()}
        
        if values[1] == nil then
            return nil
        end
        
        return transform_func(unpack(values))
    end
end

print("\n转换迭代器:")
-- 将数字转换为平方
local square_transform = function(num)
    return num, num * num
end

print("平方转换:")
for num, square in transformed_iterator(number_iterator_from_table(numbers), square_transform) do
    print(string.format("  %d² = %d", num, square))
end
--[[ 输出
1² = 1
2² = 4
3² = 9
4² = 16
5² = 25
6² = 36
7² = 49
8² = 64
9² = 81
10² = 100
--]]

-- 4. 组合多个迭代器
local function zip_iterators(...)
    local iterators = {...}
    local current_values = {}
    
    return function()
        -- 收集每个迭代器的下一个值
        for i, iter in ipairs(iterators) do
            current_values[i] = {iter()}
            
            -- 如果任何一个迭代器结束，就全部结束
            if current_values[i][1] == nil then
                return nil
            end
        end
        
        -- 返回所有值
        local result = {}
        for i, values in ipairs(current_values) do
            for j, value in ipairs(values) do
                table.insert(result, value)
            end
        end
        
        return unpack(result)
    end
end

print("\n组合迭代器（zip）:")
local names = {"张三", "李四", "王五"}
local ages = {25, 30, 28}
local cities = {"北京", "上海", "广州"}

local name_iter = number_iterator_from_table(names)
local age_iter = number_iterator_from_table(ages)
local city_iter = number_iterator_from_table(cities)

for name, age, city in zip_iterators(name_iter, age_iter, city_iter) do
    print(string.format("  姓名: %s, 年龄: %d, 城市: %s", name, age, city))
end
--[[ 输出
姓名: 张三, 年龄: 25, 城市: 北京
姓名: 李四, 年龄: 30, 城市: 上海
姓名: 王五, 年龄: 28, 城市: 广州
--]]
```

## 11.6 高级迭代器模式

### 11.6.1 树遍历迭代器

```lua
-- 树结构的迭代器
-- 定义树节点
local tree_node = {}

function tree_node.new(value)
    local node = {
        value = value,
        children = {},
        add_child = tree_node.add_child
    }
    return node
end

function tree_node:add_child(child)
    table.insert(self.children, child)
    return self
end

-- 创建一棵树
local root = tree_node.new("root")
local node_a = tree_node.new("A")
local node_b = tree_node.new("B")
local node_a1 = tree_node.new("a1")
local node_a2 = tree_node.new("a2")
local node_b1 = tree_node.new("b1")
local node_b2 = tree_node.new("b2")

root:add_child(node_a):add_child(node_b)
node_a:add_child(node_a1):add_child(node_a2)
node_b:add_child(node_b1):add_child(node_b2)
print([[ 创建树：
   root
   /  \
  A    B
 / \  / \
a1 a2 b1 b2
--]])

-- 先序遍历迭代器（沿着一个分支走到底，再遍历下一个分支）
local function preorder_iterator(node)
    local stack = { node }
    local index = 1

    return function()
        if index > #stack then
            return nil
        end

        local current = stack[index]
        index = index + 1

        -- 将子节点逆序加入栈（保证左子节点先处理）
        for i = #current.children, 1, -1 do
            table.insert(stack, index, current.children[i])
        end
        
        return current.value
    end
end

print("先序遍历:")
for value in preorder_iterator(root) do
    io.write(value .. " ")
end
print()

-- 广度优先遍历迭代器（按层级遍历，先访问同一层的所有节点）
local function bfs_iterator(node)
    local queue = { node }
    local index = 1

    return function()
        if index > #queue then
            return nil
        end

        local current = queue[index]
        index = index + 1

        -- 将子节点加入队列
        for _, child in ipairs(current.children) do
            table.insert(queue, child)
        end

        return current.value
    end
end

print("广度优先遍历:")
for value in bfs_iterator(root) do
    io.write(value .. " ")
end
print()
--[[ 输出
创建树：
   root
   /  \
  A    B
 / \  / \
a1 a2 b1 b2

先序遍历:
root A a1 a2 B b1 b2 
广度优先遍历:
root A B a1 a2 b1 b2 
--]]
```

### 11.6.2 图形遍历迭代器

```lua
-- 图结构的迭代器
-- 定义图
local Graph = {}

function Graph.new()
    local graph = {
        vertices = {},
        edges = {},
        add_vertex = Graph.add_vertex,
        add_edge = Graph.add_edge
    }
    return graph
end

function Graph:add_vertex(name)
    self.vertices[name] = { name = name, neighbors = {} }
    return self.vertices[name]
end

function Graph:add_edge(v1_name, v2_name, weight)
    weight = weight or 1

    local v1 = self.vertices[v1_name]
    local v2 = self.vertices[v2_name]

    if v1 and v2 then
        table.insert(v1.neighbors, { vertex = v2, weight = weight })
        table.insert(v2.neighbors, { vertex = v1, weight = weight }) -- 无向图
        return true
    end

    return false
end

-- 创建图
local graph = Graph.new()
graph:add_vertex("A")
graph:add_vertex("B")
graph:add_vertex("C")
graph:add_vertex("D")
graph:add_vertex("E")

graph:add_edge("A", "B", 1)
graph:add_edge("A", "C", 2)
graph:add_edge("B", "D", 3)
graph:add_edge("C", "D", 1)
graph:add_edge("D", "E", 2)
print([[创建图：
A -- B (1)
|    |
C    D (3)
 \  /
  D (1)
  |
  E (2)
]])

-- 深度优先遍历图的迭代器
local function graph_dfs_iterator(graph, start_vertex_name)
    local visited = {}
    local stack = { graph.vertices[start_vertex_name] }

    return function()
        while #stack > 0 do
            local current = table.remove(stack)

            if not visited[current.name] then
                visited[current.name] = true

                -- 将未访问的邻居加入栈
                for i = #current.neighbors, 1, -1 do
                    local neighbor = current.neighbors[i].vertex
                    if not visited[neighbor.name] then
                        table.insert(stack, neighbor)
                    end
                end

                return current.name
            end
        end
        return nil
    end
end

print("图的深度优先遍历（从A开始）:")
for vertex_name in graph_dfs_iterator(graph, "A") do
    io.write(vertex_name .. " ")
end
print()

-- 广度优先遍历图的迭代器
local function graph_bfs_iterator(graph, start_vertex_name)
    local visited = {}
    local queue = { graph.vertices[start_vertex_name] }
    local index = 1

    return function()
    	while index <= #queue do
	        local current = queue[index]
	        index = index + 1
	
	        if not visited[current.name] then
	            visited[current.name] = true
	            -- 将未访问的邻居加入队列
	            for _, neighbor_info in ipairs(current.neighbors) do
	                local neighbor = neighbor_info.vertex
	                if not visited[neighbor.name] then
	                    table.insert(queue, neighbor)
	                end
	            end
	            return current.name
	        end
	    end
	    return nil
    end
end

print("图的广度优先遍历（从A开始）:")
for vertex_name in graph_bfs_iterator(graph, "A") do
    io.write(vertex_name .. " ")
end
print()

-- 最短路径迭代器（Dijkstra算法简化版）
local function shortest_path_iterator(graph, start_vertex_name, end_vertex_name)
    local distances = {}
    local previous = {}
    local unvisited = {}

    -- 初始化
    for name, vertex in pairs(graph.vertices) do
        distances[name] = math.huge -- 无穷大
        previous[name] = nil
        table.insert(unvisited, name)
    end

    distances[start_vertex_name] = 0

    return function()
        while #unvisited > 0 do
            -- 找到未访问节点中距离最小的
            local min_distance = math.huge
            local min_vertex = nil
            local min_index = 0

            for i, name in ipairs(unvisited) do
                if distances[name] < min_distance then
                    min_distance = distances[name]
                    min_vertex = graph.vertices[name]
                    min_index = i
                end
            end

            if not min_vertex or min_distance == math.huge then
                break -- 没有可达的节点了
            end

            -- 从unvisited中移除
            table.remove(unvisited, min_index)

            -- 如果到达目标节点，构建路径并返回
            if min_vertex.name == end_vertex_name then
                local path = {}
                local current = end_vertex_name

                while current do
                    table.insert(path, 1, current)
                    current = previous[current]
                end

                return path, distances[end_vertex_name]
            end

            -- 更新邻居的距离
            for _, neighbor_info in ipairs(min_vertex.neighbors) do
                local neighbor = neighbor_info.vertex
                local alt = distances[min_vertex.name] + neighbor_info.weight

                if alt < distances[neighbor.name] then
                    distances[neighbor.name] = alt
                    previous[neighbor.name] = min_vertex.name
                end
            end
        end

        return nil -- 没有路径
    end
end

print("\n最短路径查找（从A到E）:")
for path, distance in shortest_path_iterator(graph, "A", "E") do
    print("  路径: " .. table.concat(path, " -> "))
    print("  总距离: " .. distance)
end
--[[ 输出
创建图：
A -- B (1)
|    |
C    D (3)
 \  /
  D (1)
  |
  E (2)

图的深度优先遍历（从A开始）:
A B D C E 
图的广度优先遍历（从A开始）:
A B C D E 

最短路径查找（从A到E）:
  路径: A -> C -> D -> E
  总距离: 5
--]]
```

### 11.6.3 惰性求值迭代器

惰性求值：需要时才计算值

```lua
-- 1. 无限序列迭代器
local function infinite_sequence(start, step)
    local current = start - (step or 1)
    
    return function()
        current = current + (step or 1)
        return current
    end
end

print("自然数序列（惰性）:")
local natural_numbers = infinite_sequence(1)
for i = 1, 10 do
    io.write(natural_numbers() .. " ")
end
print()
-- 输出 1 2 3 4 5 6 7 8 9 10

-- 2. 斐波那契数列（惰性无限）
local function fibonacci_generator()
    local a, b = 0, 1
    
    return function()
        local result = a
        a, b = b, a + b
        return result
    end
end

print("\n斐波那契数列（惰性无限，前15项）:")
local fib = fibonacci_generator()
for i = 1, 15 do
    io.write(fib() .. " ")
end
print()
-- 输出 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 

-- 3. 网络数据流迭代器（模拟）
local function network_stream_iterator(url, buffer_size)
    buffer_size = buffer_size or 4096
    
    local bytes_sent = 0
    local total_bytes = 10240  -- 模拟10KB数据
    
    return function()
        if bytes_sent >= total_bytes then
            return nil
        end
        
        local chunk_size = math.min(buffer_size, total_bytes - bytes_sent)
        bytes_sent = bytes_sent + chunk_size
        
        -- 模拟数据块
        return string.rep("X", chunk_size)
    end
end

print("网络数据流迭代器（模拟）:")
local network_stream = network_stream_iterator("http://example.com/data")
local chunk_count = 0
local total_size = 0

for chunk in network_stream do
    chunk_count = chunk_count + 1
    total_size = total_size + #chunk
    print(string.format("  收到块%d: %d字节", chunk_count, #chunk))
end

print(string.format("  总共收到%d块，总大小%d字节", chunk_count, total_size))
--[[ 输出
收到块1: 4096字节
收到块2: 4096字节
收到块3: 2048字节
总共收到3块，总大小10240字节
--]]

-- 4. 数据库查询流迭代器（惰性获取）
local function database_stream_iterator(query, page_size)
    page_size = page_size or 100
    
    local current_page = 0
    local current_index = 0
    local current_data = nil
    
    return function()
        -- 如果需要新的一页数据
        if current_data == nil or current_index >= #current_data then
            current_page = current_page + 1
            current_index = 0
            
            print(string.format("  查询第%d页数据...", current_page))
            
            -- 模拟数据库查询（实际中这里会有真正的查询）
            current_data = {}
            for i = 1, page_size do
                local item_id = (current_page - 1) * page_size + i
                if item_id > 250 then  -- 模拟总共250条数据
                    current_data = nil
                    break
                end
                table.insert(current_data, {
                    id = item_id,
                    name = "项目" .. item_id,
                    value = math.random(100, 1000)
                })
            end
            
            if current_data == nil then
                return nil  -- 没有更多数据
            end
        end
        
        -- 返回当前数据项
        current_index = current_index + 1
        local item = current_data[current_index]
        
        return item.id, item.name, item.value
    end
end

print("\n数据库查询流迭代器:")
local item_count = 0
for id, name, value in database_stream_iterator("SELECT * FROM items", 50) do
    item_count = item_count + 1
    if item_count <= 3 or item_count >= 248 then  -- 只显示头尾几个
        print(string.format("  ID: %d, 名称: %s, 值: %d", id, name, value))
    elseif item_count == 4 then
        print("  ...")
    end
end
print("  总共查询到 " .. item_count .. " 条记录")
--[[ 输出
查询第1页数据...
ID: 1, 名称: 项目1, 值: 101
ID: 2, 名称: 项目2, 值: 607
ID: 3, 名称: 项目3, 值: 274
...
查询第2页数据...
查询第3页数据...
查询第4页数据...
查询第5页数据...
ID: 248, 名称: 项目248, 值: 729
ID: 249, 名称: 项目249, 值: 626
ID: 250, 名称: 项目250, 值: 416
查询第6页数据...
总共查询到 250 条记录
--]]
```

## 11.7 练习

### 练习 1：实现一个数据管道系统
（答案见[[第 1 节 - 语法/参考答案#练习 11 1：实现一个数据管道系统]]）
```lua
-- 实现一个数据管道系统，组合多个迭代器处理数据（先收集操作，最后迭代时统一处理数据）
-- 使用示例：
-- 构建管道
local pipeline = pipeline_sys.new(number_source(1, 20))
pipeline:filter(function(x) return x % 2 == 0 end) -- 只保留偶数
pipeline:map(function(x) return x * 2 end)         -- 乘以2
pipeline:skip(3)                                   -- 跳过前3个
pipeline:take(5)                                   -- 取5个

print("管道处理结果:")
for value in pipeline:iterator() do
    io.write(value .. " ")
end
print()
--[[ 输出
管道处理结果:
8 12 16 20 24 
--]]
```

## 11.8 本章总结

### 关键知识点回顾

1. **迭代器基础**：
   - 迭代器是生成序列值的函数
   - 迭代器三要素：迭代器函数：每次调用返回下一个值，不可变状态：遍历过程中不变的数据，控制变量：当前遍历位置
   - 泛型 for 循环：`for var1, var2, ... in iter, state, init do ... end`
   - Lua 内置迭代器：`ipairs`, `pairs`, `string.gmatch`

2. **无状态迭代器**：
   - 所有状态通过参数传递
   - 更高效，不创建闭包
   - 示例：`ipairs` 的实现原理

3. **有状态迭代器**：
   - 使用闭包保存状态
   - 更灵活，可以实现复杂逻辑
   - 示例：计数器、斐波那契数列

4. **高级迭代器模式**：
   - 树和图遍历迭代器
   - 惰性求值迭代器
   - 数据管道和查询构建器

### 迭代器设计模式

```lua
-- 1. 简单迭代器模式
local function simple_iterator(data)
    local index = 0
    return function()
        index = index + 1
        return data[index]
    end
end

-- 2. 无状态迭代器模式
local function stateless_iter(state, index)
    -- 计算下一个值
    local next_index, next_value = ...
    return next_index, next_value
end

local function iter_factory(data)
    return stateless_iter, data, initial_index
end

-- 3. 生成器模式
local function generator(pattern)
    return function()
        -- 每次生成下一个值
        return next_value
    end
end

-- 4. 转换器模式
local function transformer(iterator, transform_func)
    return function()
        local values = {iterator()}
        if values[1] then
            return transform_func(unpack(values))
        end
    end
end
```

### 性能考虑

```lua
-- 迭代器的性能特点

-- 1. 无状态 vs 有状态
-- 无状态迭代器通常更高效，但不适合复杂状态

-- 2. 惰性求值的优势
-- 只计算需要的值，节省内存和计算资源

-- 3. 避免在迭代器中做耗时操作
-- 迭代器应该快速返回下一个值

-- 4. 大数据集的处理
-- 考虑使用流式迭代器，避免一次性加载所有数据

-- 性能测试示例
local function array_iterator(t, index)
    index = index + 1
    local value = t[index]

    if value then
        return index, value
    end
end

local function iter_array(t)
    return array_iterator, t, 0
end

local function stateful_array_iterator(t)
    local i = 0

    return function()
        i = i + 1
        local value = t[i]

        if value then
            return i, value
        end
    end
end

local data = {}
for i = 1, 1000000 do
    data[i] = i
end

-- 测试ipairs
local start = os.clock()
for i, v in ipairs(data) do
    -- 空循环
end
print("ipairs: " .. (os.clock() - start) .. "秒")

-- 测试自定义无状态迭代器
start = os.clock()
for i, v in iter_array(data) do
    -- 空循环
end
print("无状态迭代器: " .. (os.clock() - start) .. "秒")

-- 测试有状态迭代器
start = os.clock()
for v in stateful_array_iterator(data) do
    -- 空循环
end
print("有状态迭代器: " .. (os.clock() - start) .. "秒")
--[[ 输出
ipairs: 0.051秒
无状态迭代器: 0.073秒
有状态迭代器: 0.087秒
--]]
```

### 常见错误

```lua
-- 1. 修改迭代中的表
local t = {1, 2, 3, 4, 5}
for i, v in ipairs(t) do
    if v == 3 then
        table.remove(t, i)  -- 这会改变表，可能导致意外行为
    end
end

-- 正确做法：收集要删除的项，然后批量删除
local to_remove = {}
for i, v in ipairs(t) do
    if v == 3 then
        table.insert(to_remove, i)
    end
end
for i = #to_remove, 1, -1 do
    table.remove(t, to_remove[i])
end

-- 2. 迭代器函数调用错误
local function bad_iterator()
    return 1, 2, 3  -- 应该返回函数，而不是值
end

-- 错误：for v in bad_iterator() do ... end

-- 3. 忘记处理nil值
local function iterator_with_nil()
    local data = {1, nil, 3, nil, 5}
    local i = 0
    return function()
        i = i + 1
        return data[i]  -- 可能返回nil，但迭代应该继续
    end
end

-- 4. 无限迭代器缺少终止条件
local function infinite_iterator()
    local i = 0
    return function()
        i = i + 1
        return i  -- 永远不返回nil！
    end
end

-- 使用时要小心
for i in infinite_iterator() do
    if i > 100 then 
    	break	-- 必须手动break
    end
    print(i)
end
```

### 最佳实践

```lua
-- 1. 保持迭代器简单
-- 迭代器应该只负责生成下一个值，不处理复杂业务逻辑

-- 2. 提供清晰的接口
local function create_user_iterator(condition)
    -- 返回迭代器和其他信息
    return iterator, total_count, other_info
end

-- 3. 处理边界情况
local function robust_iterator(data)
    if not data or #data == 0 then
        -- 返回一个立即结束的迭代器
        return function()
        	return nil
        end
    end
    
    -- 正常迭代器
    local index = 0
    return function()
        index = index + 1
        return data[index]
    end
end

-- 4. 文档化迭代器行为
--- 遍历表的键值对
-- @param t 要遍历的表
-- @return 迭代器函数
-- @return 表t（不可变状态）
-- @return nil（初始控制变量）
local function my_pairs(t)
    -- 实现...
end
```

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 理解迭代器的基本概念和工作原理
- [ ] 使用 Lua 内置迭代器（ipairs, pairs, string.gmatch）
- [ ] 创建无状态迭代器和有状态迭代器
- [ ] 实现复杂的遍历模式（树、图等）
- [ ] 使用惰性求值提高性能
- [ ] 构建数据管道
- [ ] 选择适合场景的迭代器类型
- [ ] 避免常见的迭代器错误

### 思考题

1. 无状态迭代器和有状态迭代器各有什么优缺点？如何选择？
2. 如何实现一个迭代器来遍历嵌套的复杂数据结构？
3. 惰性求值迭代器在什么场景下特别有用？
4. 迭代器模式如何提高代码的可复用性和可维护性？
5. 如何处理迭代过程中的错误和异常？

---

**下一章预告**：在第 12 章中，我们将学习协程，让我们能够协作式进行多任务处理。

**学习建议**：
1. 多实践创建各种类型的迭代器
2. 理解无状态和有状态迭代器的区别
3. 尝试用迭代器解决实际问题
4. 注意迭代器的性能特点
5. 学习现有的迭代器模式，理解其设计思想