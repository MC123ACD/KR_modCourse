## 5.1 条件判断：if 语句

控制结构是编程中实现逻辑决策和重复执行的关键。在 Lua 中，最基本的控制结构是 if 语句。

### 5.1.1 基本 if 语句
```lua
if 条件 then
    -- 条件为真时执行的条件代码块
end
```

#### 示例
```lua
-- 示例：检查玩家生命值
local health = 75

if health > 0 then
    print("玩家还活着")
end
```

#### 错误示例
还记得学过的 [[2. 基础语法规则#1 代码块]] 吗？这里条件语句中的条件代码块也是局部作用域

**错误 1**：局部作用域内的局部变量外部不可见
```lua
if true then
    local health = 999
end

print(health)	-- 错误！
```

**错误 2**： 意外定义全局变量
```lua
if true then
    health = 999
end

print(health)	-- 错误！输出 999，虽然成功输出但是意外定义了全局变量，全局变量应避免滥用
```

**正确方法**：
```lua
local health	-- 提前定义局部变量

if true then
    health = 999	-- 这里程序会优先查找有没有已定义的局部变量，所以是给上面定义的局部变量赋值
end

print(health)	-- 正确！输出 999
```

### 5.1.2 if-else 语句
```lua
if 条件 then
    -- 条件为真时执行的条件代码块
else
    -- 条件为假时执行的条件代码块
end
```

#### 示例
```lua
-- 示例：判断玩家是否存活
local health = 0

if health > 0 then
    print("玩家还活着")
    print("当前生命值：" .. health)
else
    print("玩家已死亡")
    print("游戏结束")
end
```

### 5.1.3 if-elseif-else 语句

```lua
if 条件1 then
    -- 条件1为真时执行的条件代码块
elseif 条件2 then
    -- 条件2为真时执行的条件代码块
elseif 条件3 then
    -- 条件3为真时执行的条件代码块
else
    -- 所有条件都为假时执行的条件代码块
end
```

#### 示例
```lua
-- 示例：游戏难度选择
local difficulty_level = "hard"
local enemy_health, player_health	-- 注意！：一定要提前定义局部变量，避免意外定义全局变量

if difficulty_level == "easy" then
    enemy_health = 50
    player_health = 200
elseif difficulty_level == "normal" then
    enemy_health = 100
    player_health = 150
elseif difficulty_level == "hard" then
    enemy_health = 150
    player_health = 100
elseif difficulty_level == "insane" then
    enemy_health = 200
    player_health = 50
else
    print("无效的难度设置，使用默认难度")
    enemy_health = 100
    player_health = 150
end

print("难度：" .. difficulty_level)
print("敌人生命值：" .. enemy_health)
print("玩家生命值：" .. player_health)
```

### 5.1.4 嵌套 if 语句

```lua
-- 示例：等级解锁关卡检查
local player_level = 10

local info_level = "森林"	-- 模拟玩家点击关卡
local level_mode = "夜晚模式"

-- 外层检查
if info_level == "森林" then
    -- 内层检查
    if player_level >= 1 then	-- 玩家等级大于等于 1
        print("玩家等级足够，可以进入森林")
        
        -- 更深层的检查
        if level_mode == "夜晚模式" then	-- 判断关卡模式
            print("玩家进入夜晚的森林")
        elseif level_mode == "白天模式" then
            print("玩家进入白天的森林")
        else
            print("未知模式")
        end
    else
        print("玩家等级不足，不能进入森林")
    end
elseif info_level == "雪地" then
    -- 内层检查
    if player_level >= 11 then	-- 玩家等级大于等于 11
        print("玩家等级足够，可以进入雪地")
        
        -- 更深层的检查
        if level_mode == "夜晚模式" then	-- 判断关卡模式
            print("玩家进入夜晚的雪地")
        elseif level_mode == "白天模式" then
            print("玩家进入白天的雪地")
        else
            print("未知模式")
        end
    else
        print("玩家等级不足，不能进入雪地")
    end
else
    print("未知关卡")
end
```

### 5.1.5 条件表达式中的逻辑运算符

#### 1. 使用 and 连接多个条件
```lua
local age = 25
local has_license = true

if age >= 18 and has_license then	-- 如果年龄大于等于 18，并且有驾驶证
    print("可以驾驶")
else
    print("不能驾驶")
end
```

#### 2. 使用 or 表示多个条件之一成立
```lua
local is_weekend = false
local is_holiday = true

if is_weekend or is_holiday then	-- 如果是周末，或者是节假日
    print("今天是休息日")
else
    print("今天是工作日")
end
```

#### 3. 使用not进行条件取反
```lua
local is_raining = false

if not is_raining then		-- 如果没有下雨
    print("天气晴朗，适合外出")
else
    print("下雨了，记得带伞")
end
```

#### 4. 复杂条件组合
```lua
local temperature = 28
local is_sunny = true
local has_umbrella = false

-- 如果温度大于 25 度，并且是晴天，或者不是晴天，并且带了伞
if (temperature > 25 and is_sunny) or (not is_sunny and has_umbrella) then
    print("适合去公园")
else
    print("最好待在家里")
end
```

#### 5. 示例
```lua
local player_level = 15
local has_quest_item = true
local completed_prerequisite = false

-- 如果玩家等级大于等于 10 并且有任务物品以及完成前置任务
if player_level >= 10 and has_quest_item and completed_prerequisite then
    print("可以接受新任务")
else
    print("条件不足，无法接受任务")
    
    -- 提供具体反馈
    if player_level < 10 then
        print("需要达到10级")
    end
    
    if not has_quest_item then
        print("需要任务物品")
    end
    
    if not completed_prerequisite then
        print("需要完成前置任务")
    end
end
```

## 5.2 循环结构

循环允许我们重复执行一段代码，直到满足特定条件为止。

### 5.2.1 while 循环
```lua
while 条件 do
    -- 循环体（条件为真时重复执行）
end
```

#### 示例
```lua
-- 示例：简单的计数器
local count = 1
while count <= 5 do
    print("当前计数：" .. count)
    count = count + 1  -- 注意！：不要忘记改变循环条件
end
--[[ 输出
当前计数：1
当前计数：2
当前计数：3
当前计数：4
当前计数：5
--]]

-- 注意：如果没有正确改变条件，可能导致无限循环！
-- local count = 1
-- while count <= 5 do
--     print("无限循环？")  -- count永远不大于5，所以会一直执行
--     -- 忘记写 count = count + 1
-- end
```

#### 示例
```lua
-- 实际应用：等待玩家准备
local is_player_ready = false
local wait_time = 0
local max_wait_time = 30  -- 最大等待30秒

print("等待玩家准备...")
-- 如果玩家没有准备，并且没有超过最大等待时间
while not is_player_ready and wait_time < max_wait_time do
    print("等待中... 已等待" .. wait_time .. "秒")
    
    -- 模拟每秒检查一次
    -- 在实际游戏中，这里可能会有网络检查或用户输入检查
    wait_time = wait_time + 1
    
    -- 模拟玩家在第5秒时准备好
    if wait_time == 5 then
        is_player_ready = true
        print("玩家已准备好！")
    end
end

if not is_player_ready then
    print("等待超时，开始游戏")
else
    print("游戏开始")
end
--[[ 输出
等待玩家准备...
等待中... 已等待0秒
等待中... 已等待1秒
等待中... 已等待2秒
等待中... 已等待3秒
等待中... 已等待4秒
玩家已准备好！
游戏开始
--]]
```

### 5.2.2 repeat-until 后判断循环  
```lua
repeat
    -- 循环体
until 条件  -- 当条件为真时停止循环
```

#### 示例
```lua
-- 示例：密码验证（至少尝试一次）
local correct_password = "123456"
local user_password
local attempts = 0

repeat
    attempts = attempts + 1

    -- 模拟用户输入
    if attempts == 1 then
        user_password = "111111"  -- 错误密码
    elseif attempts == 2 then
        user_password = "654321"  -- 错误密码
    else
        user_password = "123456"  -- 正确密码
    end
    
    print("第" .. attempts .. "次尝试输入密码")
    
    if user_password ~= correct_password then
        print(user_password .. "密码错误，请重试")
    end
until user_password == correct_password

print("密码正确，登录成功！")
print("总共尝试次数：" .. attempts)
--[[ 输出
第1次尝试输入密码
111111密码错误，请重试
第2次尝试输入密码
654321密码错误，请重试
第3次尝试输入密码
密码正确，登录成功！
总共尝试次数：3
--]]

-- 游戏中的实际应用：玩家生命值恢复
local player_health = 30
local max_health = 60

print("初始生命值：" .. player_health)

repeat
	-- 模拟每秒恢复一次
    player_health = player_health + 10
    
    if player_health > max_health then
        player_health = max_health
    end
    
    print("血量恢复！当前生命值：" .. player_health)
    -- 直到血量回满
until player_health == max_health

print("生命值已满！")
--[[ 输出
初始生命值：30
血量恢复！当前生命值：40
血量恢复！当前生命值：50
血量恢复！当前生命值：60
生命值已满！
--]]
```

#### while 与 repeat-until 对比
**首先需要明确语义**：
1. while 循环：当条件为真时，继续执行循环体；当条件为假时，退出循环。
2. repeat-until 循环：重复执行循环体，直到条件为真时退出（即条件为真时结束循环）

即：在 repeat-until 循环中，设置的条件是**退出循环的条件**，而在 while 循环中，设置的条件是**继续循环的条件**。
所以：**两个循环设置的条件完全相反**

```lua
-- while
local count = 10

while count < 5 do  -- 继续循环的条件：计数小于 5，一开始就不成立
    print("while循环执行")  -- 循环体不会执行
    count = count + 1
end

print("while循环结束，count = " .. count)		-- 输出 10

-- repeat-until
local count = 10

repeat
    print("repeat-until循环执行")  -- 循环体至少会执行一次
    count = count + 1
until count >= 5  -- 结束循环的条件：计算大于等于 5，检查在循环体之后

print("repeat-until循环结束，count = " .. count)	-- 输出 11
```

### 5.2.3 for 循环：数值 for

```lua
for 变量 = 起始值, 结束值, 步长 do
    -- 循环体
end
-- 步长可以省略，默认为1
```

#### 示例
```lua
print("=== 从1到5 ===")
for i = 1, 5 do
    print("i = " .. i)
end
--[[ 输出
i = 1
i = 2
i = 3
i = 4
i = 5
--]]

print("\n=== 从5到1（递减）===")
for i = 5, 1, -1 do
    print("i = " .. i)
end
--[[ 输出
i = 5
i = 4
i = 3
i = 2
i = 1
--]]

print("\n=== 从0到10，步长为2 ===")
for i = 0, 8, 2 do
    print("偶数: " .. i)
end
--[[ 输出
偶数: 0
偶数: 2
偶数: 4
偶数: 6
偶数: 8
--]]

-- 注意：for循环变量是局部变量
for index = 1, 3 do
    print("循环内 index = " .. index)
end

print("循环外 index = " .. index)  -- 错误！index 在这里不可访问
```

#### 实际应用
```lua
-- 计算示例：累加和阶乘
local sum = 0
local factorial = 1

print("\n=== 计算1到10的和与10的阶乘 ===")
for i = 1, 10 do
    sum = sum + i
    factorial = factorial * i
end
print("1到10的和 = " .. sum)
print("10的阶乘 = " .. factorial)
--[[ 输出
1到10的和 = 55
10的阶乘 = 3628800
--]]

-- 生成乘法表
print("\n=== 乘法表 ===")
for i = 1, 9 do
    for j = 1, i do
        print(j .. " × " .. i .. " = " .. i * j)
    end
end
--[[ 输出
1 × 1 = 1
1 × 2 = 2
...
--]]
```

### 5.2.4 循环控制：break 语句
break用于立即退出当前循环

#### 示例
```lua
-- 示例：寻找第一个能被7整除的数
for i = 8, 100 do
    if i % 7 == 0 then
        print("找到第一个能被7整除的数：" .. i)

        break  -- 找到后立即退出循环
    end
end
-- 输出 找到第一个能被7整除的数：14

-- 游戏示例：搜索敌人直到找到首领
local enemies = {"小兵", "小兵", "小兵", "小兵", "首领", "小兵"}
local boss_found

print("=== 搜索敌人 ===")
for index, enemy in ipairs(enemies) do
    print("遭遇：" .. enemy)
    
    if enemy == "首领" then
        print("找到首领！开始战斗")
        boss_found = true

        break
    end
    
    print("击败" .. enemy)
end

if not boss_found then
    print("没有找到首领")
end
--[[ 输出
遭遇：小兵
击败小兵
遭遇：小兵
击败小兵
遭遇：小兵
击败小兵
遭遇：小兵
击败小兵
遭遇：首领
找到首领！开始战斗
--]]

-- 注意：break只能用于循环中，不能用于if语句
-- if true then
--     break  -- 错误：break不在循环内
-- end

-- 多层循环中的break
print("\n=== 多层循环中的break ===")
for i = 1, 3 do
    print("外层循环 i = " .. i)

    for j = 1, 3 do
        print("  内层循环 j = " .. j)

        if i == 2 and j == 2 then
            print("  触发break，只退出内层循环")

            break
        end
    end
end
--[[ 输出
外层循环 i = 1
  内层循环 j = 1
  内层循环 j = 2
  内层循环 j = 3
外层循环 i = 2
  内层循环 j = 1
  内层循环 j = 2
  触发break，只退出内层循环
外层循环 i = 3
  内层循环 j = 1
  内层循环 j = 2
  内层循环 j = 3
--]]

-- 无限循环中的break
print("\n=== 无限循环与break ===")
local count = 0

while true do  -- 故意创建无限循环
    count = count + 1
    print("无限循环计数：" .. count)
    
    if count >= 5 then
        print("达到5次，使用break退出")
        break
    end
end

print("成功退出无限循环")
--[[ 输出
无限循环计数：1
无限循环计数：2
无限循环计数：3
无限循环计数：4
无限循环计数：5
达到5次，使用break退出
成功退出无限循环
--]]
```

### 5.2.5 进入下一次循环

```lua
-- 与其他语言不同，Lua没有continue语句
-- 但我们可以用其他方法实现类似功能

-- 方法1：使用if语句包装
print("=== 方法1：使用if跳过单次循环 ===")
for i = 1, 10 do
    if i % 2 ~= 0 then  -- 如果不是偶数
        -- 执行代码（相当于跳过偶数）
        print("奇数：" .. i)
    end
    -- 如果是偶数，这里什么都不做，相当于continue
end
--[[ 输出
奇数：1
奇数：3
奇数：5
奇数：7
奇数：9
--]]

-- 方法2：使用反向逻辑
print("\n=== 方法2：反向逻辑 ===")
for i = 1, 10 do
    if i % 2 == 0 then  -- 如果是偶数
        -- 直接进入下一次迭代
        -- 在Lua中没有continue，所以我们用if的else部分
    else
        print("奇数：" .. i)
    end
end
--[[ 输出
奇数：1
奇数：3
奇数：5
奇数：7
奇数：9
--]]

-- 方法3：使用 goto（Lua 5.1不支持，但 LuaJIT 2.0+ 支持）
-- 注意：Lua 5.1 不支持 goto，这里仅能用于 LuaJIT，这里仅说明，后续 LuaJIT 篇详细说明
-- for i = 1, 10 do
--    if i % 2 == 0 then
--        goto continue  -- 跳过后续代码
--    end

--    print("处理奇数：" .. i)

--    ::continue::
-- end

-- 方法4：使用嵌套的if-else
print("\n=== 方法4：跳过特定条件的处理 ===")
for i = 1, 6 do
    if i == 5 then
        print("跳过数字5")
        -- 什么都不做，相当于continue
    else
        -- 正常处理
        if i % 2 == 0 then
            print(i .. "是偶数")
        else
            print(i .. "是奇数")
        end
    end
end
--[[ 输出
1是奇数
2是偶数
3是奇数
4是偶数
跳过数字5
6是偶数
--]]

-- 实际游戏示例：处理敌人列表，跳过已死亡的敌人
print("\n=== 敌人处理示例 ===")
local enemies = {
    {name = "敌人A", health = 50},
    {name = "敌人B", health = 0},  -- 已死亡
    {name = "敌人C", health = 30},
    {name = "敌人D", health = 0},  -- 已死亡
    {name = "敌人E", health = 80}
}

for index, enemy in ipairs(enemies) do
    -- 跳过已死亡的敌人（模拟continue）
    if enemy.health <= 0 then
        print("跳过已死亡的敌人：" .. enemy.name)
        -- 在Lua 5.1中，我们只能这样"跳过"
        -- 实际的代码应该放在else块中
    else
        -- 处理存活的敌人
        print("攻击敌人：" .. enemy.name)
        enemy.health = enemy.health - 20
        print("敌人" .. enemy.name .. "剩余生命值：" .. enemy.health)
    end
end
--[[ 输出
攻击敌人：敌人A
敌人敌人A剩余生命值：30
跳过已死亡的敌人：敌人B
攻击敌人：敌人C
敌人敌人C剩余生命值：10
跳过已死亡的敌人：敌人D
攻击敌人：敌人E
敌人敌人E剩余生命值：60
--]]
```

### 5.2.6 泛型 for 循环（初步了解）

```lua
-- 泛型for循环用于遍历表
-- 我们会在第7章详细学习表，这里先简单了解

-- 使用ipairs遍历数组部分（索引从1开始）
print("=== 使用ipairs遍历数组 ===")
local monsters = {"哥布林", "兽人", "骷髅", "僵尸"}

for index, m in ipairs(monsters) do
    print("第" .. index .. "个怪物: " .. m)
end
--[[ 输出
第1个怪物: 哥布林
第2个怪物: 兽人
第3个怪物: 骷髅
第4个怪物: 僵尸
--]]

-- 使用pairs遍历所有键值对
print("\n=== 使用pairs遍历表 ===")
local player = {
    name = "英雄",
    level = 10,
    health = 100,
    class = "hero"
}

for key, value in pairs(player) do
    print(key .. ": " .. value)
end
--[[ 输出
class: hero
level: 10
name: 英雄
health: 100
--]]
-- 注：pairs的遍历顺序是无序的
```

## 5.3 练习
### 练习 1：猜数字游戏
（答案见 [[第 1 节 - 语法/参考答案#练习 5 1：猜数字游戏]]）
```lua
-- 使用以下代码生成 1 - 100 的随机数，设定一个最大尝试次数，模拟用户多次输入
-- 如果猜错了给出太小了还是太大了的提示，猜中数字或超过最大尝试次数退出循环
math.randomseed(os.time())
local random_number = math.random(1, 100)
```

### 练习2：打印图形
（答案见[[第 1 节 - 语法/参考答案#练习 5.2：打印图形]]）
```lua
-- 使用 io.write("*") （不换行的 print）打印星号与 print() 换行打印以下图形
-- 1. 打印直角三角形
-- 2. 打印倒直角三角形
-- 3. 打印等腰三角形
-- 4. 打印空心菱形
--[[ 输出
1. 直角三角形:
* 
* * 
* * * 
* * * * 
* * * * * 

2. 倒直角三角形:
* * * * * 
* * * * 
* * * 
* * 
* 

3. 等腰三角形:
    *
   ***
  *****
 *******
*********

4. 空心菱形:
    *
   * *
  *   *
 *     *
*       *
 *     *
  *   *
   * *
    *
--]]
```

## 5.4 本章总结

### 关键知识点回顾
1. **条件语句**：
	- `if-then`：基本条件判断
	- `if-then-else`：二选一分支
	- `if-then-elseif-then-else`：多分支选择
	- 嵌套 if 语句：复杂条件逻辑

2. **循环语句**：
	- `while` 循环：先判断条件，条件为真时执行循环体，设置的是继续循环的条件
	- `repeat-until` 循环：先执行循环体，然后判断条件，条件为真时停止，设置的是结束循环的条件
	- `for` 循环（数值）：精确控制循环次数，使用计数器
	- 泛型 `for` 循环：用于遍历表（初步了解）

3. **循环控制**：
	- `break` 语句：立即退出当前循环
	- Lua 没有 `continue` 语句，但可以通过 if 语句模拟

### 编程思维培养
1. **条件逻辑思维**：学会将现实问题转化为条件判断
2. **循环思维**：识别需要重复执行的模式
3. **边界思维**：注意循环的起始、结束条件和边界情况
4. **效率思维**：避免无限循环，合理使用 break

### 常见错误与调试技巧
```lua
-- 错误1：忘记改变循环条件（无限循环）
local i = 1
while i <= 5 do
    print(i)
    -- 忘记写 i = i + 1
end

-- 错误2：错误的条件表达式
local count = 0
while count ~= 10 do  -- 如果count跳过10，可能成为无限循环
    count = count + 2
    print(count)
end

-- 错误3：在for循环中修改循环变量（通常不是好主意）
for i = 1, 10 do
    print(i)
    i = i + 2  -- 不推荐，可能导致意外行为
end

-- 调试技巧：添加打印语句
print("=== 开始循环 ===")
for i = 1, 5 do
    print("循环开始，i = " .. i)
    -- ... 其他代码 ...
    print("循环结束，i = " .. i)
end
print("=== 循环结束 ===")
```

### 最佳实践
```lua
-- 1. 总是使用局部变量作为循环计数器
for i = 1, 10 do  -- i自动成为局部变量
    print(i)
end

-- 2. 复杂条件使用括号提高可读性
if (player_level >= 10 and has_key) or is_admin then
    -- 清晰的逻辑
end

-- 3. 避免过深的嵌套
-- 不好：嵌套太深
if condition1 then
    if condition2 then
        if condition3 then
        	-- 条件代码块
        end
    end
end

-- 更好：使用逻辑运算符
if condition1 and condition2 and condition3 then
	-- 条件代码块
end

-- 4. 避免短路求值失效，尤其是循环内
local n1, n2, n3 = 1, 2, 3
local s1, s2, s3 = "a", "b", "c"

-- 计时
local start1 = os.clock()
for i = 1, 10000000 do
	-- 错误示例，循环内使用变量分组
    local check_n = n1 == 1 and n2 == 2 and n3 == 3
    local check_s = s1 == "a" and s2 == "b" and s3 == "c" -- 即使 n3 判断为假也会继续判断 s123

    if check_n and check_s then	-- 可读性改善，代价是短路求值失效一半
    end
end
local time1 = os.clock() - start1

local start2 = os.clock()
for i = 1, 10000000 do
	-- 正确示例，使用括号分组
	-- n3 判断为假，直接停止判断，虽然可读性较差
    if (n1 == 1 and n2 == 2 and n3 == 3) and (s1 == "a" and s2 == "b" and s3 == "c") then
    end
end
local time2 = os.clock() - start2

-- 或者在循环外部创建变量
local start3 = os.clock()
local check_n = n1 == 1 and n2 == 2 and n3 == 3
local check_s = s1 == "a" and s2 == "b" and s3 == "c"
for i = 1, 10000000 do
    if check_n and check_s then
    end
end
local time3 = os.clock() - start3

print(string.format("括号分组: %.4f 秒", time2))
print(string.format("变量分组: %.4f 秒", time1))
print(string.format("静态变量分组: %.4f 秒", time3))
print(string.format("动态变量分组开销: %.2f%%", (time1 - time2) / time2 * 100))
print(string.format("静态变量分组开销: %.2f%%", (time1 - time3) / time3 * 100))
--[[ 输出
变量分组: 0.1200 秒
括号分组: 0.1010 秒
静态变量分组: 0.0290 秒
动态变量分组开销: 18.81%
静态变量分组开销: -313.79%
--]]
```

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 使用 if 语句实现条件分支
- [ ] 理解并使用各种循环结构
- [ ] 正确使用 break 退出循环
- [ ] 识别并避免无限循环
- [ ] 使用嵌套的控制结构解决复杂问题
- [ ] 理解 while 和 repeat-until 的区别
- [ ] 使用 for 循环处理计数任务

### 思考题
1. 什么情况下应该使用 while 循环而不是 for 循环？
2. 如果需要在循环中跳过某些迭代但不退出循环，有哪些方法？
3. 如何设计一个程序，让用户可以多次尝试直到成功？
4. 在什么情况下应该使用嵌套循环？有什么需要注意的？
5. 如何确保循环能够正常结束，不会成为无限循环？

### 拓展练习
1. 编写一个程序，找出 100 以内所有的素数
2. 创建一个简单的文字冒险游戏，使用条件语句控制游戏流程
3. 实现一个模拟银行 ATM 机的程序，支持存款、取款、查询等功能
4. 编写一个程序，打印出斐波那契数列的前 20 项
5. 创建一个简单的成绩管理系统，可以输入多个学生成绩并统计平均分

---

**下一章预告**：在第 6 章中，我们将深入学习函数。函数是组织和重用代码的重要工具，它能将复杂问题分解为小的、可管理的部分。我们将学习如何定义函数、传递参数、返回值，以及更高级的函数概念。

**学习建议**：
1. 多做练习，特别是循环和条件组合的题目
2. 尝试将日常生活中的决策过程用 if 语句描述
3. 注意观察哪些任务适合用循环自动化
4. 多调试，理解程序执行的流程