### 10.1 为什么要使用断点调试？
在程序开发过程中，调试是必不可少的一环。之前都是使用 `print` 语句进行调试，但随着程序复杂度增加，`print` 调试的局限性逐渐显现。

**print 调试的缺点**：
1. **效率低下**：每次调试都需要手动添加 print 语句，调试完成后还需逐一清理
2. **信息有限**：只能显示特定变量的值，无法查看完整的调用链和执行上下文
3. **表结构查看困难**：需要手动拼接输出，复杂嵌套表需要递归处理
4. **缺乏控制**：无法暂停程序、单步执行，只能看到固定的输出结果

**断点调试的优点**：
1. **高效便捷**：设置一次断点，多次运行生效
2. **信息全面**：查看作用域内所有变量、调用堆栈、内存地址
3. **可视化表结构**：自动展开显示复杂嵌套表
4. **完全控制**：单步执行、条件断点、批量管理等高级功能

## 10.2 断点基础使用
在代码行左侧增加断点
![[Pasted image 20251225185539.png|227]]

使用 DEBUG 模式运行
![[Pasted image 20251225185723.png|375]]

可以看到程序在第一行中断了（DEBUG 模式默认在第一行打了断点）
![[Pasted image 20251225185853.png|294]]
可以在控制栏继续运行
![[Pasted image 20251225190026.png]]

继续后在运行与调试选项中可以查看变量值，或者鼠标光标悬停在变量上
![[Pasted image 20251225190451.png|475]]

运行下一行代码，可以看到 a 变为了 2
![[Pasted image 20251225191640.png|500]]
### 10.1.2 控制栏说明
**继续**（快捷键 `F5`）：运行程序直到触发下一个断点
**逐过程**（快捷键 `F10`）：运行下一行代码，遇到函数直接执行整个函数
**单步调试**（快捷键 `F11`）：运行下一行代码，遇到函数进入函数内单步运行
**单步跳出**（快捷键 `shift + F11`）：跳出当前代码块

### 10.1.3 调用堆栈
```lua
local current_num = 0

local function third()
    current_num = 3
    print("执行 third 函数")		-- 断点打这里
end

local function second()
    current_num = 2
    print("执行 second 函数")

    third()
end

local function first()
    current_num = 1
    print("执行 first 函数")

    second()
end

first()
```

可以在调用堆栈查看调用堆栈，点击 second 可以跳转到调用 third 的代码行查看其作用域内的变量
![[Pasted image 20251225195034.png]]
**调用堆栈解读**：
- **最顶部**：当前暂停位置 (`third`)
- **从上到下**：函数调用顺序
- **每个层级**：显示函数名、参数值、所在文件
- **点击任意层级**：跳转到对应的代码位置，查看当时的变量状态

## 10.3 调试控制台
调试控制台可以直接执行 Lua 代码：

```lua
-- 使用调试控制台进行交互
local inventory = {
    items = {
        { id = 1, name = "药水", count = 5 },
        { id = 2, name = "武器", count = 2 },
        { id = 3, name = "防具", count = 3 }
    },
    gold = 1000
}

local function find_item_by_name(name)
    for _, item in ipairs(inventory.items) do
        if item.name == name then
            return item
        end
    end
    return nil
end

print("断点打这里")
-- 断点后在调试控制台中可以：
-- 1. 查看变量: > inventory
-- 2. 调用函数: > find_item_by_name("药水")
-- 3. 修改值: > inventory.gold = 1500
-- 4. 执行表达式: > #inventory.items
```
![[Pasted image 20251225203906.png]]

## 10.4 监视变量
监视变量用于在大量变量与复杂镶套中快速查看指定变量值

```lua
-- 调试复杂表达式
local complex_data = {
    users = {
        {name = "Alice", scores = {85, 92, 78}},
        {name = "Bob", scores = {88, 76, 95}},
        {name = "Charlie", scores = {92, 89, 91}}
    },
    config = {
        weights = {0.3, 0.4, 0.3},
        threshold = 80
    }
}

local function calculate_weighted_scores()
    local results = {}
    
    for i, user in ipairs(complex_data.users) do
        -- 在调试时添加监视表达式：
        -- 1. user.name
        -- 2. #user.scores
        -- 3. complex_data.config.weights[1]
        
        local weighted_sum = 0		-- 断点打这里
        for j, score in ipairs(user.scores) do
            weighted_sum = weighted_sum + score * complex_data.config.weights[j]
        end
        
        table.insert(results, {
            name = user.name,
            score = weighted_sum,
            passed = weighted_sum >= complex_data.config.threshold
        })
    end
    
    return results
end

local results = calculate_weighted_scores()
```
![[Pasted image 20251225201739.png]]

## 10.5 特殊断点
右键断点可以编辑断点设置其他类型的断点。
![[Pasted image 20251225202221.png|725]]
### 10.5.1 条件断点（表达式）
条件断点允许输入条件来在指定条件下触发断点，适合过滤无关触发。

```lua
-- 条件断点示例
local function find_special_num(num)
    for i = 1, num do
    	local current_num = i
    
        if i == 100 then        -- 可以设置条件断点：i == 99 提前一步暂停
            print("找到特殊数字！")
        end
    end
end

find_special_num(100)
```

### 10.5.2 命中断点（命中次数）
命中断点允许在断点被触发特定次数后才暂停程序执行，适合调试循环或重复调用的情况。

```lua
-- 调试循环中的特定迭代
local function process_items(items)
    local processed = {}
    local total_value = 0
    
    for i, item in ipairs(items) do
        local value = item.price * item.quantity	-- 设置命中次数断点：== 3 在第3次迭代时暂停
        total_value = total_value + value
        
        table.insert(processed, {
            id = item.id,
            name = item.name,
            value = value,
            cumulative = total_value
        })
        
        print(string.format("处理第%d项: %s = %d", i, item.name, value))
    end
    
    return processed, total_value
end

local inventory = {
    {id = 1, name = "苹果", price = 5, quantity = 10},
    {id = 2, name = "香蕉", price = 3, quantity = 15},
    {id = 3, name = "橙子", price = 4, quantity = 8},  -- 我们想检查这一项
    {id = 4, name = "葡萄", price = 8, quantity = 6},
    {id = 5, name = "西瓜", price = 15, quantity = 3}
}

local results, total = process_items(inventory)
print("总计价值:", total)
```

### 10.5.3 日志断点（记录点）
日志断点不会暂停程序，而是在触发时输出信息到控制台，适合在不中断流程的情况下跟踪程序状态。
日志断点类似于 `print`，花括号 `{}` 内可以输入变量。

```lua
local a = 1

for i = 1, 10 do
    a = a + 1	-- 增加日志断点：触发断点 i = {i}
end
--[[ 输出
触发断点 i = 1.0
触发断点 i = 2.0
触发断点 i = 3.0
触发断点 i = 4.0
触发断点 i = 5.0
触发断点 i = 6.0
触发断点 i = 7.0
触发断点 i = 8.0
触发断点 i = 9.0
触发断点 i = 10.0
--]]
```

### 10.3.4 等待断点（触发的断点）
等待断点指定的另一个断点触发后，等待断点才会触发，适合在不重复设定复杂条件断点的情况下应用其条件。

```lua
local a = 1

for i = 1, 100 do
    print(a)	-- 增加条件断点：i == 50
    print(-a)	-- 增加等待断点：指定上面的断点
    a = a + 1
end
-- 将会在 i = 50 时先后触发两个断点
```
## 10.6 常见调试场景

### 1. 循环调试
```lua
local function debug_loop()
    local matrix = {}
    
    -- 初始化矩阵
    for i = 1, 3 do
        matrix[i] = {}
        for j = 1, 3 do
            matrix[i][j] = i * j  -- 在此行添加断点，观察循环变量
        end
    end
    
    -- 处理矩阵
    local sum = 0
    for i = 1, #matrix do
        for j = 1, #matrix[i] do
            sum = sum + matrix[i][j]
        end
    end
    
    return matrix, sum
end

debug_loop()
```

### 2. 递归函数调试
```lua
local function factorial(n)
    if n <= 1 then
        return 1
    end

    local v = n * factorial(n - 1)

    return v	-- 打断点观察阶乘值
end

local function fibonacci(n)
    if n <= 1 then
        return n
    end

    local v = fibonacci(n - 1) + fibonacci(n - 2)

    return v	-- 打断点观察数列值
end

-- 测试递归函数
print("5的阶乘:", factorial(5))
print("斐波那契第6项:", fibonacci(6))
```

### 3. 辅助阅读代码
查看调用堆栈可方便查看调用链，在特定位置断点查看变量值可辅助理解代码含义，使用单步可让程序自动跳转到执行位置。
```lua
-- 简单的购物车系统 - 通过断点理解代码逻辑

-- 1. 商品数据
-- 断点: 查看商品初始化
local products = {
    { id = 1, name = "苹果", price = 5.5, stock = 100 },
    { id = 2, name = "香蕉", price = 3.2, stock = 80 },
    { id = 3, name = "橙子", price = 4.8, stock = 60 },
    { id = 4, name = "葡萄", price = 8.9, stock = 40 }
}

-- 2. 购物车数据
-- 断点: 观察购物车初始化
local shopping_cart = {
    items = {},    -- 购买的商品
    total = 0,     -- 总金额
    item_count = 0 -- 商品数量
}

-- 3. 查找商品函数
-- 断点: 了解如何查找商品
local function find_product(product_id)
    for _, product in ipairs(products) do
        if product.id == product_id then
            return product
        end
    end
    return nil
end

-- 4. 添加商品到购物车
-- 断点: 查看核心逻辑
local function add_to_cart(product_id, quantity)
    quantity = quantity or 1 -- 默认数量为1

    -- 查找商品
    local product = find_product(product_id)
    if not product then
        return false, "商品不存在"
    end

    -- 检查库存
    if product.stock < quantity then
        return false, "库存不足"
    end

    -- 更新购物车
    local existing_item = shopping_cart.items[product_id]
    if existing_item then
        -- 已存在，增加数量
        existing_item.quantity = existing_item.quantity + quantity
        existing_item.subtotal = existing_item.quantity * product.price
    else
        -- 新商品
        shopping_cart.items[product_id] = {
            product_id = product_id,
            name = product.name,
            price = product.price,
            quantity = quantity,
            subtotal = product.price * quantity
        }
        shopping_cart.item_count = shopping_cart.item_count + 1
    end

    -- 更新库存
    product.stock = product.stock - quantity

    -- 更新总金额
    shopping_cart.total = shopping_cart.total + (product.price * quantity)

    return true, "添加成功"
end

-- 5. 从购物车移除商品
-- 断点: 理解移除逻辑
local function remove_from_cart(product_id, quantity)
    local item = shopping_cart.items[product_id]
    if not item then
        return false, "商品不在购物车中"
    end

    quantity = quantity or item.quantity -- 默认移除全部

    if quantity > item.quantity then
        quantity = item.quantity
    end

    -- 更新购物车
    if quantity == item.quantity then
        -- 移除整个商品
        shopping_cart.items[product_id] = nil
        shopping_cart.item_count = shopping_cart.item_count - 1
    else
        -- 减少数量
        item.quantity = item.quantity - quantity
        item.subtotal = item.quantity * item.price
    end

    -- 恢复库存
    local product = find_product(product_id)
    if product then
        product.stock = product.stock + quantity
    end

    -- 更新总金额
    shopping_cart.total = shopping_cart.total - (item.price * quantity)

    -- 如果总金额为负，设为0
    if shopping_cart.total < 0 then
        shopping_cart.total = 0
    end

    return true, "移除成功"
end

-- 6. 显示购物车
-- 断点: 查看显示逻辑
local function show_cart()
    if shopping_cart.item_count == 0 then
        print("购物车为空")
        return
    end

    print("\n=== 购物车内容 ===")
    print(string.format("%-5s %-10s %-8s %-8s %-8s",
        "ID", "商品名", "单价", "数量", "小计"))
    print(string.rep("-", 45))

    local count = 0
    for _, item in pairs(shopping_cart.items) do
        count = count + 1
        print(string.format("%-5d %-10s %-8.2f %-8d %-8.2f",
            item.product_id, item.name, item.price,
            item.quantity, item.subtotal))
    end

    print(string.rep("-", 45))
    print(string.format("总计: %.2f 元", shopping_cart.total))
    print(string.format("商品总数: %d 件", shopping_cart.item_count))
end

-- 7. 显示商品列表
-- 断点: 查看商品展示
local function show_products()
    print("\n=== 商品列表 ===")
    print(string.format("%-5s %-10s %-8s %-8s",
        "ID", "商品名", "价格", "库存"))
    print(string.rep("-", 35))

    for _, product in ipairs(products) do
        print(string.format("%-5d %-10s %-8.2f %-8d",
            product.id, product.name, product.price, product.stock))
    end
end

-- 8. 结算函数
-- 断点: 了解结算过程
local function checkout()
    if shopping_cart.item_count == 0 then
        return false, "购物车为空"
    end

    print("\n=== 结算 ===")
    show_cart()

    -- 应用折扣（满100减10）
    local discount = 0
    if shopping_cart.total >= 100 then
        discount = 10
        print(string.format("\n折扣: -%.2f 元", discount))
    end

    local final_total = shopping_cart.total - discount
    print(string.format("实付金额: %.2f 元", final_total))

    -- 清空购物车
    for product_id, item in pairs(shopping_cart.items) do
        shopping_cart.items[product_id] = nil
    end

    shopping_cart.total = 0
    shopping_cart.item_count = 0

    return true, "结算成功"
end

-- 9. 主程序流程
-- 断点: 开始跟踪整个流程
local function main()
    print("欢迎使用购物车系统!")

    -- 初始状态
    show_products()

    -- 测试购物车操作
    print("\n[测试1] 添加商品到购物车")
    -- 断点: 跟踪添加过程
    local success, message = add_to_cart(1, 3) -- 3个苹果
    print("添加苹果:", message)

    success, message = add_to_cart(2, 2) -- 2个香蕉
    print("添加香蕉:", message)

    success, message = add_to_cart(3, 5) -- 5个橙子
    print("添加橙子:", message)

    -- 查看购物车
    show_cart()

    print("\n[测试2] 再次添加相同商品")
    -- 断点: 观察重复添加
    success, message = add_to_cart(1, 2) -- 再添加2个苹果
    print("再添加苹果:", message)

    show_cart()
    show_products() -- 查看库存变化

    print("\n[测试3] 移除部分商品")
    -- 断点: 跟踪移除过程
    success, message = remove_from_cart(3, 2) -- 移除2个橙子
    print("移除橙子:", message)

    show_cart()
    show_products() -- 查看库存恢复

    print("\n[测试4] 尝试结算")
    -- 断点: 观察结算流程
    success, message = checkout()
    print("结算结果:", message)

    print("\n[测试5] 结算后查看状态")
    show_cart()

    print("\n谢谢使用!")
end

-- 10. 运行程序
main()
```

## 10.7 为什么需要错误处理？

在现实的程序中，错误是不可避免的。没有错误处理的程序就像没有刹车的汽车一样危险。

```lua
-- 没有错误处理的危险程序
local function get_table_value(t, k1, k2)
	return t[k1][k2]
end

local t = {}
get_table_value(t, "key1", "key2")	-- t.key1 为 nil，t.key1.key2 会报错：尝试索引 nil 值
-- 程序会在这里抛出错误，程序终止
print("这行代码不会执行")
```

## 10.8 Lua 的错误类型
#### 1. 语法错误
```lua
-- 1. 忘记写值
local x =
-- 错误: unexpected symbol near '<eof>'

-- 2. 代码块没有闭合
local t = {
    1,
    2,
    3
-- 错误: '}' expected (to close '{' at line 1)
if a then
-- 错误: 'end' expected (to close 'if' at line 1) near '<eof>'
```

#### 2. 运行时错误
```lua
-- 索引 nil 值
print(undefined_table.v)
-- 错误: attempt to index global 'undefined_table' (a nil value) 尝试索引 nil 值
```

#### 3. 逻辑错误
```lua
-- 程序能运行，结果不对
local function calculate_average(numbers)
    local sum = 0
    
    for i = 1, #numbers do
        sum = sum + numbers[i]
    end
    
    return sum / #numbers  -- 如果numbers为空表，会除以0，返回 1.#INF
end
```

#### 4. 资源错误
```lua
-- 1. 文件不存在
local file, err = io.open("nonexistent.txt", "r")
if not file then
    print(err)  -- 输出: nonexistent.txt: No such file or directory
end

-- 2. 内存不足
local huge_table = {}
for i = 1, math.huge do
	huge_table[i] = string.rep("x", 1000000)
end
-- 报错: not enough memory

-- 3. 栈溢出
local function err_fn()
    err_fn()
end
err_fn()
-- 报错: stack overflow
```

## 10.9 错误信息
```lua
local function test_fn()
    a.b.c = 123
end

test_fn()
--[[ 输出
lua: test.lua:2: attempt to index global 'a' (a nil value)
stack traceback:
	test.lua:2: in function 'test_fn'
	test.lua:5: in main chunk
	[C]: ?
--]]
```

`test.lua:2` 为错误的路径模块与行数
`attempt to index global 'a' (a nil value)` 为错误信息：尝试索引 nil 值
`stack traceback` 调用堆栈（从下往上看）
`test.lua:5: in main chunk` 在主代码块先执行了第 5 行代码
`test.lua:2: in function 'test_fn'` 最后执行了 `test_fn` 函数中的第 2 行

## 10.10 错误处理
### 10.10.1 pcall - 保护调用
pcall (protected call) 是Lua最基本的错误处理机制，以保护模式调用函数。函数中的任何错误不会抛出；取而代之的是 `pcall` 会将错误捕获。

```lua
pcall(保护函数: func, 函数参数: any...) -> 是否有错误: bool, 返回值|错误信息: any|str...
```

#### 示例
```lua
-- pcall处理多个返回值
local function multiple_returns()
    return 1, 2, 3, 4, 5
end

local function failing_function()
    error("出错了！", 0)
end

print("\n多返回值处理:")
success, a, b, c, d, e = pcall(multiple_returns)
if success then
    print("  成功返回: " .. a .. ", " .. b .. ", " .. c .. ", " .. d .. ", " .. e)
else
    print("  错误: " .. a)  -- 注意：错误信息在第一个返回值
end

success, err = pcall(failing_function)
if not success then
    print("  捕获错误: " .. err)
end
--[[ 输出
成功返回: 1, 2, 3, 4, 5
捕获错误: 出错了！
--]]
```

### 10.10.2 xpcall - 带错误处理的保护调用

xpcall 比 pcall 更强大，可以指定错误信息处理函数

```lua
xpcall(保护函数: func, 信息处理函数: func, 函数参数: any...) -> 是否有错误: bool, 返回值|处理后的信息: any|str...
```

#### 示例
```lua
-- 错误处理函数
local function error_handler(err)
    -- err参数是错误信息
    local debug_info = debug.traceback("错误追踪:", 2)
    return string.format("发生错误: %s\n%s", err, debug_info)
end

local function risky_operation()
    local t = {1, 2, 3}
    return t[10] * 2  -- t[10]是nil，nil * 2会出错
end

print("xpcall示例1:")
local success, result = xpcall(risky_operation, error_handler)
if success then
    print("  结果: " .. result)
else
    print("  错误处理:\n" .. result)
end
--[[ 输出
发生错误: test.lua:10: attempt to perform arithmetic on field '?' (a nil value)
错误追踪:
stack traceback:
	test.lua:10: in function <test.lua:8>
	[C]: in function 'xpcall'
	test.lua:14: in main chunk
	[C]: ?
--]]
```

### 10.10.3 error - 抛出错误

```lua
error(信息: str, 错误级别?: int)
```
- 错误级别默认为 1

#### 示例
```lua
-- 示例1：基本错误抛出
local function validate_age(age)
    if type(age) ~= "number" then
        error("年龄必须是数字", 2)  -- level=2表示错误在调用者的位置
    end
    
    if age < 0 then
        error("年龄不能为负数", 2)
    end
    
    if age > 150 or age == 0 then
        error("年龄不合理", 2)
    end
    
    return true
end

print("年龄验证测试:")
local test_ages = {25, -5, "二十", 200, 0}

for i, age in ipairs(test_ages) do
    local success, result = pcall(validate_age, age)
    if success then
        print("  年龄 " .. age .. ": 有效")
    else
        print("  年龄 " .. age .. ": " .. result)
    end
end
--[[ 输出
年龄 25: 有效
年龄 -5: 年龄不能为负数
年龄 二十: 年龄必须是数字
年龄 200: 年龄不合理
年龄 0: 有效
--]]

-- 示例2：错误级别的作用
local function level_demo()
    print("\n错误级别演示:")
    
    local function inner_function()
        error("错误发生在inner_function", 0)  -- level 0: 不添加位置信息
    end
    
    local function middle_function()
        error("错误发生在middle_function", 1)  -- level 1: 调用error的位置
    end
    
    local function outer_function()
        error("错误发生在outer_function", 2)  -- level 2: 调用者的位置
    end
    
    -- 测试不同level
    local function test_error(func, level_desc)
        local success, err = pcall(func)
        if not success then
            print("  " .. level_desc .. ": " .. err)
        end
    end
    
    test_error(inner_function, "level 0")
    test_error(middle_function, "level 1")
    test_error(outer_function, "level 2")
end

level_demo()
```

### 10.10.4 assert - 断言

assert 用于检查条件，如果条件为假则抛出错误

```lua
assert(条件: bool, 错误信息?: str, 参数?: any...) -> 参数: any...
```
- 错误信息默认为 `"assertion failed!"`

#### 示例
```lua
-- 示例1：基本断言
function calculate_bmi(weight, height)
    -- 参数验证
    assert(type(weight) == "number", "体重必须是数字")
    assert(type(height) == "number", "身高必须是数字")
    assert(weight > 0, "体重必须大于0")
    assert(height > 0, "身高必须大于0")
    
    return weight / (height * height)
end

print("BMI计算测试:")
local test_cases = {
    {70, 1.75},     -- 有效
    {-70, 1.75},    -- 无效体重
    {70, -1.75},    -- 无效身高
    {"70", 1.75},   -- 字符串体重
}

for i, case in ipairs(test_cases) do
    local success, result = pcall(calculate_bmi, case[1], case[2])
    if success then
        print(string.format("  体重%.1fkg, 身高%.2fm -> BMI: %.1f", 
              case[1], case[2], result))
    else
        print("  错误: " .. result)
    end
end

-- 示例2：assert与error的区别
print("\nassert vs error:")

function using_assert(value)
    assert(value ~= nil, "值不能为nil")
    return value * 2
end

function using_error(value)
    if value == nil then
        error("值不能为nil", 2)
    end
    return value * 2
end

-- 两个函数的功能相同，但assert更简洁
local test_values = {5, nil}

for i, value in ipairs(test_values) do
    print("\n测试值: " .. tostring(value))
    
    local success1, result1 = pcall(using_assert, value)
    if success1 then
        print("  assert版本: " .. result1)
    else
        print("  assert版本错误: " .. result1)
    end
    
    local success2, result2 = pcall(using_error, value)
    if success2 then
        print("  error版本: " .. result2)
    else
        print("  error版本错误: " .. result2)
    end
end

-- 示例3：在生产环境中禁用断言
-- 在开发时使用断言检查，发布时可以关闭
local DEBUG_MODE = true

function release_assert(condition, message)
    if DEBUG_MODE then
        assert(condition, message)
    elseif not condition then
        -- 在生产环境中，记录错误但不抛出
        print("[生产环境错误] " .. (message or "断言失败"))
        return false
    end
    return true
end

print("\n生产环境断言:")
local function test_function(x)
    if not release_assert(x > 0, "x必须大于0") then
        return nil
    end
    return x * 2
end

-- 测试模式
DEBUG_MODE = true
print("调试模式:")
local success, result = pcall(test_function, -5)
if not success then
    print("  错误: " .. result)
end

-- 生产模式
DEBUG_MODE = false
print("\n生产模式:")
local result = test_function(-5)
if result then
    print("  结果: " .. result)
else
    print("  函数返回nil（不抛出错误）")
end
```

## 10.11 错误处理策略

### 10.11.1 防御性编程
假设一切可能出错，并提前处理

```lua
-- 示例1：安全的表访问
local function safe_table_access(t, key, default)
    if type(t) ~= "table" then
        return default
    end
    
    local value = t[key]
    if value == nil then
        return default
    end
    
    return value
end

print("安全表访问:")
local config = {theme = "dark", language = "zh-CN"}
print("  主题: " .. safe_table_access(config, "theme", "light"))
print("  音量: " .. safe_table_access(config, "volume", 70))  -- 使用默认值
print("  非表: " .. safe_table_access("不是表", "key", "默认"))
--[[ 输出
主题: dark
音量: 70
非表: 默认
--]]

-- 示例2：安全的函数调用
local function safe_call(func, ...)
    if type(func) ~= "function" then
        return nil, "不是函数"
    end
    
    local success, result = pcall(func, ...)
    if not success then
        return nil, result
    end
    
    return result
end

print("\n安全函数调用:")
local function add(a, b)
	return a + b
end
local result, err = safe_call(add, 5, 3)
if result then
    print("  5 + 3 = " .. result)
else
    print("  错误: " .. err)
end

result, err = safe_call("不是函数", 5, 3)
if result then
    print("  结果: " .. result)
else
    print("  错误: " .. err)
end
--[[ 输出
5 + 3 = 8
 错误: 不是函数
--]]

-- 示例3：验证输入数据
local function validate_user_input(input)
    -- 多层验证
    if not input then
        return nil, "输入不能为空"
    end
    
    if type(input) ~= "table" then
        return nil, "输入必须是表"
    end
    
    -- 验证必填字段
    local required = {"username", "email", "password"}
    for _, field in ipairs(required) do
        if not input[field] or #tostring(input[field]) == 0 then
            return nil, "字段 '" .. field .. "' 不能为空"
        end
    end
    
    -- 验证邮箱格式
    local email = input.email
    if not string.match(email, "^[%w%.%-]+@[%w%.%-]+%.[%a]+$") then
        return nil, "邮箱格式无效"
    end
    
    -- 验证密码强度
    local password = input.password
    if #password < 8 then
        return nil, "密码至少需要8个字符"
    end
    
    return true
end

print("\n输入验证:")
local inputs = {
    {username = "user1", email = "test@example.com", password = "secure123"},
    {username = "", email = "test@example.com", password = "short"},  -- 用户名为空
    {username = "user2", email = "invalid-email", password = "password123"},  -- 邮箱无效
    {username = "user3", email = "test@example.com", password = "123"},  -- 密码太短
}

for i, input in ipairs(inputs) do
    local valid, err = validate_user_input(input)
    if valid then
        print("  输入 " .. i .. ": 有效")
    else
        print("  输入 " .. i .. ": 无效 - " .. err)
    end
end
--[[ 输出
  输入 1: 有效
  输入 2: 无效 - 字段 'username' 不能为空
  输入 3: 无效 - 邮箱格式无效
  输入 4: 无效 - 密码至少需要8个字符
--]]
```

### 10.11.2 错误恢复策略

```lua
-- 错误恢复：从错误中恢复并继续执行
-- 策略1：重试机制
local function retry_operation(operation, max_attempts, delay)
    max_attempts = max_attempts or 3
    delay = delay or 1  -- 默认延迟1秒
    
    for attempt = 1, max_attempts do
        local success, result = pcall(operation)
        
        if success then
            return result
        end
        
        print(string.format("  尝试 %d/%d 失败: %s", 
              attempt, max_attempts, result))
        
        if attempt < max_attempts then
            print(string.format("  等待 %.1f 秒后重试...", delay))
            -- 在实际应用中，这里应该使用 os.execute 或类似方法等待
            -- 为了示例简化，我们只是打印
        end
    end
    
    return nil, "所有重试尝试都失败"
end

print("重试机制:")
local function unreliable_operation()
    math.randomseed(os.time())
    if math.random() < 0.7 then  -- 70%失败率
        error("操作失败: 随机错误")
    end
    return "操作成功"
end

local result, err = retry_operation(unreliable_operation, 5, 0.5)
if result then
    print("  最终结果: " .. result)
else
    print("  最终错误: " .. err)
end

-- 策略2：降级服务
print("\n降级服务:")
local function fetch_data(source, fallback_source)
    -- 尝试主数据源
    local success, data = pcall(source.fetch)
    
    if success then
        print("  使用主数据源")
        return data
    end
    
    print("  主数据源失败: " .. data)
    print("  尝试备用数据源...")
    
    -- 尝试备用数据源
    success, data = pcall(fallback_source.fetch)
    
    if success then
        print("  使用备用数据源")
        return data
    end
    
    print("  备用数据源也失败: " .. data)
    
    -- 返回缓存或默认数据
    print("  返回缓存数据")
    return {cached = true, data = "默认数据"}
end

-- 模拟数据源
local primary_source = {
    fetch = function()
        if math.random() < 0.5 then
            error("主数据源不可用")
        end
        return {source = "primary", data = "新鲜数据"}
    end
}

local fallback_source = {
    fetch = function()
        if math.random() < 0.3 then
            error("备用数据源不可用")
        end
        return {source = "fallback", data = "稍旧的数据"}
    end
}

for i = 1, 3 do
    print("\n尝试 " .. i .. ":")
    local data = fetch_data(primary_source, fallback_source)
    print("  获取的数据: " .. data.data .. " (来源: " .. (data.source or "缓存") .. ")")
end

-- 策略3：优雅降级
print("\n优雅降级:")
local function render_ui(use_advanced_features)
    local features = {}
    
    -- 基础功能总是可用的
    features.basic = true
    
    -- 高级功能可能不可用
    if use_advanced_features then
        local success = pcall(function()
            -- 模拟需要特定库或环境的功能
            if not package.loaded["advanced_graphics"] then
                error("高级图形库未安装")
            end
            features.advanced_graphics = true
        end)
        
        if not success then
            print("  警告: 高级图形功能不可用，使用基础渲染")
            features.advanced_graphics = false
        end
    else
        features.advanced_graphics = false
    end
    
    -- 根据可用功能渲染UI
    if features.advanced_graphics then
        print("  使用高级UI渲染")
    else
        print("  使用基础UI渲染")
    end
    
    return features
end

print("渲染测试:")
render_ui(true)
render_ui(false)

-- 策略4：隔离故障
print("\n故障隔离:")
local function isolated_operation(operation_name, operation_func)
    -- 在独立的协程中执行操作，防止一个操作失败影响其他操作
    local co = coroutine.create(function()
        local success, result = pcall(operation_func)
        if not success then
            print("  操作 '" .. operation_name .. "' 失败: " .. result)
            return nil, result
        end
        return result
    end)
    
    local success, result = coroutine.resume(co)
    if success and coroutine.status(co) == "dead" then
        return result
    else
        return nil, "操作未完成"
    end
end

print("隔离执行:")
local results = {}

results.op1 = isolated_operation("操作1", function()
    error("操作1故意失败")
end)

results.op2 = isolated_operation("操作2", function()
    return "操作2成功"
end)

results.op3 = isolated_operation("操作3", function()
    error("操作3也失败")
end)

print("\n所有操作结果:")
for name, result in pairs(results) do
    if result then
        print("  " .. name .. ": " .. result)
    else
        print("  " .. name .. ": 失败")
    end
end
```

## 10.12 自定义错误类型

```lua
-- 创建结构化的错误类型，便于处理
-- 错误类型定义
local ErrorTypes = {
    VALIDATION = {
        code = 100,
        name = "VALIDATION_ERROR",
        description = "输入验证失败"
    },
    DATABASE = {
        code = 200,
        name = "DATABASE_ERROR",
        description = "数据库操作失败"
    },
    NETWORK = {
        code = 300,
        name = "NETWORK_ERROR",
        description = "网络通信失败"
    },
    PERMISSION = {
        code = 400,
        name = "PERMISSION_ERROR",
        description = "权限不足"
    },
    INTERNAL = {
        code = 500,
        name = "INTERNAL_ERROR",
        description = "内部服务器错误"
    }
}

-- 错误创建函数
local function create_error(error_type, message, details)
    local error_info = ErrorTypes[error_type]
    if not error_info then
        error_info = ErrorTypes.INTERNAL
    end
    
    return {
        type = error_type,
        code = error_info.code,
        name = error_info.name,
        message = message or error_info.description,
        details = details,
        timestamp = os.time(),
        stack_trace = debug.traceback("", 2)
    }
end

-- 错误抛出函数
local function throw_error(error_type, message, details)
    error(create_error(error_type, message, details), 2)
end

-- 错误处理函数
local function handle_error(err, context)
    -- 如果是我们的自定义错误
    if type(err) == "table" and err.code then
        print(string.format("[错误处理] 类型: %s (%d)", err.name, err.code))
        print(string.format("          消息: %s", err.message))
        
        if err.details then
            print(string.format("          详情: %s", tostring(err.details)))
        end
        
        if context then
            print(string.format("          上下文: %s", context))
        end
        
        print("          调用栈:")
        print(err.stack_trace)
        
        -- 根据错误类型采取不同措施
        if err.type == "VALIDATION" then
            return nil, "输入错误，请检查后重试"
        elseif err.type == "PERMISSION" then
            return nil, "权限不足，请联系管理员"
        elseif err.type == "NETWORK" then
            -- 可以尝试重试
            return nil, "网络错误，请稍后重试"
        else
            return nil, "系统错误，请联系技术支持"
        end
    else
        -- 其他类型的错误
        return nil, "未知错误: " .. tostring(err)
    end
end

-- 使用自定义错误
print("自定义错误演示:")

local function register_user(user_data)
    -- 验证输入
    if not user_data or not user_data.username then
        throw_error("VALIDATION", "用户名不能为空", user_data)
    end
    
    if #user_data.username < 3 then
        throw_error("VALIDATION", "用户名至少需要3个字符", 
                   {username = user_data.username, length = #user_data.username})
    end
    
    -- 模拟数据库操作
    local success, db_result = pcall(function()
        -- 模拟数据库错误
        if user_data.username == "admin" then
            error("用户名已存在")
        end
        return {id = 123, username = user_data.username}
    end)
    
    if not success then
        throw_error("DATABASE", "创建用户失败", {error = db_result})
    end
    
    -- 模拟权限检查
    if user_data.username == "root" then
        throw_error("PERMISSION", "不允许注册root用户")
    end
    
    return db_result
end

-- 测试不同的错误情况
local test_cases = {
    {username = ""},           -- 验证错误
    {username = "ab"},         -- 用户名太短
    {username = "admin"},      -- 数据库错误
    {username = "root"},       -- 权限错误
    {username = "正常用户"},   -- 成功
}

for i, test_case in ipairs(test_cases) do
    print(string.format("\n测试用例 %d: 用户名='%s'", i, test_case.username))
    
    local success, result = pcall(register_user, test_case)
    if success then
        print("  成功: 用户ID = " .. result.id)
    else
        local _, user_message = handle_error(result, "用户注册")
        print("  失败: " .. user_message)
    end
end
--[[ 输出
测试用例 1: 用户名=''
[错误处理] 类型: VALIDATION_ERROR (100)
          消息: 用户名至少需要3个字符
          详情: table: 00C22798
          上下文: 用户注册
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:99: in function <test.lua:92>
	[C]: in function 'pcall'
	test.lua:136: in main chunk
	[C]: ?
  失败: 输入错误，请检查后重试

测试用例 2: 用户名='ab'
[错误处理] 类型: VALIDATION_ERROR (100)
          消息: 用户名至少需要3个字符
          详情: table: 00C22B30
          上下文: 用户注册
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:99: in function <test.lua:92>
	[C]: in function 'pcall'
	test.lua:136: in main chunk
	[C]: ?
  失败: 输入错误，请检查后重试

测试用例 3: 用户名='admin'
[错误处理] 类型: DATABASE_ERROR (200)
          消息: 创建用户失败
          详情: table: 00C22C20
          上下文: 用户注册
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	est.lua:113: in function <test.lua:92>
	[C]: in function 'pcall'
	test.lua:136: in main chunk
	[C]: ?
  失败: 系统错误，请联系技术支持

测试用例 4: 用户名='root'
[错误处理] 类型: PERMISSION_ERROR (400)
          消息: 不允许注册root用户
          上下文: 用户注册
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:118: in function <test.lua:92>
	[C]: in function 'pcall'
	test.lua:136: in main chunk
	[C]: ?
  失败: 权限不足，请联系管理员

测试用例 5: 用户名='正常用户'
  成功: 用户ID = 123
--]]
```

## 10.13 练习

### 练习 1：使用断点阅读代码
```lua
local GradeSystem = {
    students = {},
    courses = {},
    grades = {},
    statistics = {
        total_students = 0,
        total_courses = 0,
        average_scores = {}
    }
}

local function generate_id(prefix, existing_ids)
    local max_id = 0
    for id, _ in pairs(existing_ids) do
        local num = tonumber(id:match("%d+$"))
        if num and num > max_id then
            max_id = num
        end
    end
    return string.format("%s%04d", prefix, max_id + 1)
end

local function calculate_weighted_average(scores, credits)
    local total_score = 0
    local total_credit = 0

    for course_id, score in pairs(scores) do
        local credit = credits[course_id] or 1
        total_score = total_score + score * credit
        total_credit = total_credit + credit
    end

    return total_credit > 0 and total_score / total_credit or 0
end

function GradeSystem:add_student(name, major, class)
    local student_id = generate_id("STU", self.students)

    self.students[student_id] = {
        id = student_id,
        name = name,
        major = major or "未分配",
        class = class or "未知班级",
        enrolled_courses = {},
        enroll_date = os.date("%Y-%m-%d")
    }

    self.statistics.total_students = self.statistics.total_students + 1

    return student_id
end

function GradeSystem:add_course(name, credit, teacher)
    local course_id = generate_id("COU", self.courses)

    self.courses[course_id] = {
        id = course_id,
        name = name,
        credit = credit or 1,
        teacher = teacher or "待分配",
        enrolled_students = {}
    }

    self.statistics.total_courses = self.statistics.total_courses + 1

    return course_id
end

function GradeSystem:enroll_course(student_id, course_id)
    local student = self.students[student_id]
    local course = self.courses[course_id]

    if not student or not course then
        return false, "学生或课程不存在"
    end

    if student.enrolled_courses[course_id] then
        return false, "该课程已选"
    end

    student.enrolled_courses[course_id] = true
    student.enrolled_courses[course.name] = course_id

    course.enrolled_students[student_id] = true

    self.grades[student_id] = self.grades[student_id] or {}
    self.grades[student_id][course_id] = nil

    return true, "选课成功"
end

function GradeSystem:record_grade(student_id, course_id, score)
    local student = self.students[student_id]

    if (not self.grades[student_id] or not self.grades[student_id][course_id]) and (not student or not student.enrolled_courses[course_id]) then
        return false, "学生未选此课程"
    end

    if score < 0 or score > 100 then
        return false, "分数必须在0-100之间"
    end

    self.grades[student_id] = self.grades[student_id] or {}
    self.grades[student_id][course_id] = score

    self:update_statistics()

    return true, "成绩录入成功"
end

function GradeSystem:update_statistics()
    local course_scores = {}
    local course_counts = {}

    for student_id, courses in pairs(self.grades) do
        for course_id, score in pairs(courses) do
            if score then
                course_scores[course_id] = (course_scores[course_id] or 0) + score
                course_counts[course_id] = (course_counts[course_id] or 0) + 1
            end
        end
    end

    for course_id, total_score in pairs(course_scores) do
        local count = course_counts[course_id] or 1
        self.statistics.average_scores[course_id] = total_score / count
    end
end

function GradeSystem:get_student_report(student_id)
    local student = self.students[student_id]
    if not student then
        return nil, "学生不存在"
    end

    local report = {
        student_id = student_id,
        name = student.name,
        major = student.major,
        class = student.class,
        courses = {},
        total_average = 0,
        weighted_average = 0
    }

    local total_score = 0
    local total_courses = 0
    local scores_with_credits = {}
    local credits = {}

    for course_id, _ in pairs(student.enrolled_courses) do
        if type(course_id) == "string" and course_id:match("^COU") then
            local course = self.courses[course_id]
            local score = self.grades[student_id] and self.grades[student_id][course_id]

            if course then
                local course_info = {
                    id = course_id,
                    name = course.name,
                    credit = course.credit,
                    teacher = course.teacher,
                    score = score or "未录入"
                }

                table.insert(report.courses, course_info)

                if score then
                    total_score = total_score + score
                    total_courses = total_courses + 1
                    scores_with_credits[course_id] = score
                    credits[course_id] = course.credit
                end
            end
        end
    end

    if total_courses > 0 then
        report.total_average = total_score / total_courses

        report.weighted_average = calculate_weighted_average(scores_with_credits, credits)
    end

    table.sort(report.courses, function(a, b)
        local score_a = a.score or 0
        local score_b = b.score or 0
        return score_a > score_b
    end)

    return report
end

function GradeSystem:get_course_report(course_id)
    local course = self.courses[course_id]
    if not course then
        return nil, "课程不存在"
    end

    local report = {
        course_id = course_id,
        name = course.name,
        credit = course.credit,
        teacher = course.teacher,
        enrolled_count = 0,
        graded_count = 0,
        average_score = 0,
        score_distribution = {
            excellent = { name = "优秀", count = 0 },
            good = { name = "良好", count = 0 },
            medium = { name = "中等", count = 0 },
            pass = { name = "及格", count = 0 },
            fail = { name = "不及格", count = 0 }
        },
        student_list = {}
    }

    local total_score = 0

    for student_id, _ in pairs(course.enrolled_students) do
        report.enrolled_count = report.enrolled_count + 1

        local score = self.grades[student_id] and self.grades[student_id][course_id]
        if score then
            report.graded_count = report.graded_count + 1
            total_score = total_score + score
            score_dis = report.score_distribution

            if score >= 90 then
                score_dis.excellent.count = score_dis.excellent.count + 1
            elseif score >= 80 then
                score_dis.good.count = score_dis.good.count + 1
            elseif score >= 70 then
                score_dis.medium.count = score_dis.medium.count + 1
            elseif score >= 60 then
                score_dis.pass.count = score_dis.pass.count + 1
            else
                score_dis.fail.count = score_dis.fail.count + 1
            end

            local student = self.students[student_id]
            if student then
                table.insert(report.student_list, {
                    student_id = student_id,
                    name = student.name,
                    score = score,
                    grade = score >= 90 and "优秀" or
                        score >= 80 and "良好" or
                        score >= 70 and "中等" or
                        score >= 60 and "及格" or "不及格"
                })
            end
        end
    end

    if report.graded_count > 0 then
        report.average_score = total_score / report.graded_count
    end

    table.sort(report.student_list, function(a, b)
        return a.score > b.score
    end)

    return report
end

function GradeSystem:find_top_students(min_average, limit)
    local qualified_students = {}

    for student_id, student in pairs(self.students) do
        local report = self:get_student_report(student_id)
        if report and report.weighted_average >= (min_average or 85) then
            table.insert(qualified_students, {
                student_id = student_id,
                name = student.name,
                major = student.major,
                class = student.class,
                weighted_average = report.weighted_average,
                course_count = #report.courses
            })
        end
    end

    table.sort(qualified_students, function(a, b)
        return a.weighted_average > b.weighted_average
    end)

    if limit and limit > 0 then
        qualified_students = { unpack(qualified_students, 1, limit) }
    end

    return qualified_students
end

local function initialize_test_data(system)
    local math_id = system:add_course("高等数学", 4, "张教授")
    local english_id = system:add_course("大学英语", 3, "王老师")
    local programming_id = system:add_course("程序设计", 3, "李教授")
    local physics_id = system:add_course("大学物理", 3, "赵教授")
    local history_id = system:add_course("中国近代史", 2, "刘老师")

    local stu1 = system:add_student("张三", "计算机科学", "计科2001")
    local stu2 = system:add_student("李四", "软件工程", "软工2001")
    local stu3 = system:add_student("王五", "信息安全", "信安2001")
    local stu4 = system:add_student("赵六", "计算机科学", "计科2001")
    local stu5 = system:add_student("钱七", "软件工程", "软工2001")

    system:enroll_course(stu1, math_id)
    system:enroll_course(stu1, english_id)
    system:enroll_course(stu1, programming_id)

    system:enroll_course(stu2, math_id)
    system:enroll_course(stu2, english_id)
    system:enroll_course(stu2, physics_id)

    system:enroll_course(stu3, programming_id)
    system:enroll_course(stu3, physics_id)
    system:enroll_course(stu3, history_id)

    system:enroll_course(stu4, math_id)
    system:enroll_course(stu4, programming_id)
    system:enroll_course(stu4, physics_id)
    system:enroll_course(stu4, history_id)

    system:enroll_course(stu5, english_id)
    system:enroll_course(stu5, programming_id)
    system:enroll_course(stu5, history_id)

    local scores = {
        [stu1] = { [math_id] = 88, [english_id] = 92, [programming_id] = 95 },
        [stu2] = { [math_id] = 76, [english_id] = 85, [physics_id] = 82 },
        [stu3] = { [programming_id] = 91, [physics_id] = 78, [history_id] = 88 },
        [stu4] = { [math_id] = 94, [programming_id] = 89, [physics_id] = 86, [history_id] = 92 },
        [stu5] = { [english_id] = 79, [programming_id] = 83, [history_id] = 85 }
    }

    for student_id, course_scores in pairs(scores) do
        for course_id, score in pairs(course_scores) do
            system:record_grade(student_id, course_id, score)
        end
    end

    print(string.format("已添加 %d 名学生，%d 门课程",
        system.statistics.total_students,
        system.statistics.total_courses))
end

local function demonstrate_system_workflow()
    initialize_test_data(GradeSystem)

    print("\n查询学生成绩单")
    local report, err = GradeSystem:get_student_report("STU0004")

    if report then
        print(string.format("学生: %s (%s - %s)",
            report.name, report.major, report.class))
        print(string.format("加权平均分: %.2f, 简单平均分: %.2f",
            report.weighted_average, report.total_average))
        print("各科成绩:")

        for i, course in ipairs(report.courses) do
            print(string.format("  %s (%s): %s (学分: %d)",
                course.name, course.teacher,
                course.score, course.credit))
        end
    else
        print("错误:", err)
    end

    print("\n查询课程统计")
    local course_report, course_err = GradeSystem:get_course_report("COU0003")

    if course_report then
        print(string.format("课程: %s (%s)",
            course_report.name, course_report.teacher))
        print(string.format("选课人数: %d, 已录入成绩: %d",
            course_report.enrolled_count, course_report.graded_count))
        print(string.format("平均分: %.2f", course_report.average_score))
        print("成绩分布:")

        local distribution = {}

        for _, dis in pairs(course_report.score_distribution) do
            if dis.count > 0 then
                print(string.format("  %s: %d人", dis.name, dis.count))
            end
        end

        print("成绩前3名:")
        for i = 1, math.min(3, #course_report.student_list) do
            local student = course_report.student_list[i]
            print(string.format("  %d. %s: %.1f (%s)",
                i, student.name, student.score, student.grade))
        end
    else
        print("错误:", course_err)
    end

    print("\n查找成绩优异学生(平均分≥85)")
    local top_students = GradeSystem:find_top_students(85, 5)

    print(string.format("找到 %d 名符合条件的学生:", #top_students))
    for i, student in ipairs(top_students) do
        print(string.format("  %d. %s (%s) - 平均分: %.2f, 已修课程: %d门",
            i, student.name, student.major,
            student.weighted_average, student.course_count))
    end

    print("\n模拟新操作流程")

    local new_student_id = GradeSystem:add_student("孙八", "人工智能", "智能2001")
    print(string.format("添加新学生: %s", new_student_id))

    local success, msg = GradeSystem:enroll_course(new_student_id, "COU0001")
    print(string.format("选课结果: %s - %s", success and "成功" or "失败", msg))

    success, msg = GradeSystem:record_grade(new_student_id, "COU0001", 96)
    print(string.format("成绩录入: %s - %s", success and "成功" or "失败", msg))

    local new_report, new_err = GradeSystem:get_student_report(new_student_id)
    if new_report then
        print(string.format("新学生成绩单: 平均分 %.2f, 已修 %d 门课",
            new_report.weighted_average, #new_report.courses))
    end

    print("\n系统统计信息")
    print(string.format("系统概况: %d 名学生, %d 门课程",
        GradeSystem.statistics.total_students,
        GradeSystem.statistics.total_courses))

    print("各课程平均分:")
    for course_id, avg_score in pairs(GradeSystem.statistics.average_scores) do
        local course = GradeSystem.courses[course_id]
        if course then
            print(string.format("  %s: %.2f", course.name, avg_score))
        end
    end
end

local function main()
    local start_time = os.clock()
    demonstrate_system_workflow()
    local end_time = os.clock()

    print(string.format("\n程序执行时间: %.3f 秒", end_time - start_time))
end

-- 运行主程序
main()
```

### 练习 2：模拟数据库操作错误处理
（答案见[[第 1 节 - 语法/参考答案#练习 10.2：模拟数据库操作错误处理]]）
```lua
-- 模拟数据库操作的错误处理
-- 使用示例：
-- 使用数据库
print("数据库操作测试:")
local db = data_base.new {
    host = "localhost",
    database = "mydb",
    username = "admin",
    password = "secret"
}

-- 包装数据库操作为安全操作
function safe_database_operation(db, operation_name, operation, ...)
    print("\n操作: " .. operation_name)

    local result, err = db:safe_execute(operation, ...)

    if result then
        print("  成功")
        return result
    else
        local _, user_msg = handle_error(err, operation_name)
        print("  失败: " .. user_msg)
        return nil, err
    end
end

-- 测试各种操作
-- 连接数据库
safe_database_operation(db, "连接数据库", db.connect)

-- 查询数据
local users, err = safe_database_operation(db, "查询用户", function(self)
    return self:query("SELECT * FROM users WHERE status = 'active'")
end)

if users then
    print("  查询到 " .. #users .. " 个用户")
end

-- 测试插入重复数据
local insert_result, err = safe_database_operation(db, "插入用户", function(self)
    return self:query("INSERT INTO users (name, email) VALUES (?, ?)",
        { "测试用户", "duplicate@example.com" })
end)

-- 测试事务
print("\n测试事务操作:")
local transaction_success, transaction_err = pcall(function()
    db:begin_transaction()

    -- 多个操作
    db:query("UPDATE accounts SET balance = balance - 100 WHERE id = 1")
    db:query("UPDATE accounts SET balance = balance + 100 WHERE id = 2")

    db:commit()
    print("  事务执行成功")
end)

if not transaction_success then
    print("  事务失败: " .. tostring(transaction_err))
    if db.transaction_active then
        db:rollback()
    end
end

-- 断开连接
safe_database_operation(db, "断开连接", db.disconnect)
--[[ 输出
操作: 连接数据库
  连接数据库 localhost:3306...
[错误处理] 类型: NETWORK_ERROR (300)
          消息: 数据库连接失败
          详情: table: 00E5CEA0
          上下文: 连接数据库
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:114: in function <test.lua:104>
	[C]: in function 'pcall'
	test.lua:213: in function 'safe_execute'
	test.lua:253: in function 'safe_database_operation'
	test.lua:267: in main chunk
	[C]: ?
  失败: 网络错误，请稍后重试

操作: 查询用户
  检测到连接问题，尝试重连...
  连接数据库 localhost:3306...
[错误处理] 类型: DATABASE_ERROR (200)
          消息: 数据库未连接
          上下文: 查询用户
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:126: in function <test.lua:124>
	(tail call): ?
	[C]: in function 'pcall'
	test.lua:213: in function 'safe_execute'
	test.lua:253: in function 'safe_database_operation'
	test.lua:270: in main chunk
	[C]: ?
  失败: 系统错误，请联系技术支持

操作: 插入用户
  检测到连接问题，尝试重连...
  连接数据库 localhost:3306...
[错误处理] 类型: DATABASE_ERROR (200)
          消息: 数据库未连接
          上下文: 插入用户
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:126: in function <test.lua:124>
	(tail call): ?
	[C]: in function 'pcall'
	test.lua:213: in function 'safe_execute'
	test.lua:253: in function 'safe_database_operation'
	test.lua:279: in main chunk
	[C]: ?
  失败: 系统错误，请联系技术支持

测试事务操作:
  开始事务
  事务失败: table: 00E5CF68
  回滚事务

操作: 断开连接
  断开数据库连接
  成功
--]]
```

## 10.14 本章总结

### 关键知识点回顾

1. **断点的使用**：
	- 代码行左侧打断点
	- 使用控制栏控制程序运行
	- 使用调用堆栈查看函数调用链
	- 在调试控制台执行 Lua 代码
	- 使用监视变量快速查找指定变量

2. **控制栏的使用**：
	- **继续**：继续运行程序
	- **逐过程**：运行下一行代码
	- **单步**：运行下一行代码，包括函数内
	- **单步跳出**：跳出当前代码块

3. **特殊断点**：
	- **条件断点**：判断通过触发，过滤无关触发
	- **命中断点**：命中指定次数触发，适合递归与循环
	- **日志断点**：不中断程序，打印临时日志
	- **等待断点**：指定断点触发后触发

4. **错误类型**：
	- **语法错误**：代码块未闭合
	- **运行错误**：索引 nil
	- **逻辑错误**：结果错误
	- **资源错误**：未找到文件、内存不足、栈溢出

5. **错误处理**：
	- `pcall`：保护调用，捕获错误
	- `xpcall`：带错误处理函数的保护调用
	- `error`：主动抛出错误
	- `assert`：条件断言，失败时抛出错误

6. **错误处理策略**：
	- 防御性编程
	- 错误恢复（重试、降级、隔离）
	- 错误日志和监控
	- 自定义错误类型

7. **最佳实践**：
	- 输入验证
	- 资源清理
	- 错误传播
	- 用户友好错误消息

### 错误处理模式

```lua
-- 模式 1：立即返回错误
function process_data(data)
    if not data then
        return nil, "数据不能为空"
    end
    -- 处理数据...
    return result
end

-- 模式 2：抛出异常
function validate_input(input)
    if not input then
        error("输入不能为空", 2)
    end
    -- 验证通过...
end

-- 模式 3：使用断言
function critical_operation(param)
    assert(param ~= nil, "参数不能为 nil")
    -- 关键操作...
end

-- 模式 4：错误转换
function api_wrapper(func)
    return function(...)
        local success, result = pcall(func, ...)
        if not success then
            -- 转换为 API 错误格式
            return {success = false, error = result}
        end
        return {success = true, data = result}
    end
end
```

### 常见错误处理陷阱

```lua
-- 陷阱 1：忽略错误
local file = io.open("missing.txt", "r")
local content = file:read("*all")  -- 如果文件不存在，file 是 nil，这里会崩溃
file:close()

-- 正确做法
local file, err = io.open("missing.txt", "r")
if not file then
    print("错误: " .. err)
    return
end

-- 陷阱 2：错误信息不明确
local function bad_error_handling()
    local success, result = pcall(some_operation)
    if not success then
        print("错误")  -- 不明确
    end
end

-- 正确做法
local function good_error_handling()
    local success, result = pcall(some_operation)
    if not success then
        print("操作失败: " .. result)
        print("调用栈: " .. debug.traceback())
    end
end

-- 陷阱 3：过度使用 pcall
local function overuse_pcall()
    -- 每个操作都用 pcall 包装，性能差且代码冗长
    local s1, r1 = pcall(operation1)
    local s2, r2 = pcall(operation2)
    local s3, r3 = pcall(operation3)
    -- ...
end

-- 正确做法：在合适的层级处理错误
local function proper_error_handling()
    local function inner()
        operation1()
        operation2()
        operation3()
    end
    
    local success, err = pcall(inner)
    if not success then
        -- 统一处理错误
        handle_error(err)
    end
end

-- 陷阱 4：资源泄漏
local function resource_leak()
    local file = io.open("test.txt", "w")
    file:write("数据")
    -- 忘记关闭文件！
    -- 如果后面发生错误，文件永远不会关闭
end

-- 正确做法：确保资源释放
local function proper_resource_handling()
    local file, err = io.open("test.txt", "w")
    if not file then
        return nil, err
    end
    
    local success, result = pcall(function()
        file:write("数据")
        -- 其他可能失败的操作...
    end)
    
    -- 无论如何都关闭文件
    file:close()
    
    if not success then
        return nil, result
    end
    
    return true
end
```

### 性能考虑

```lua
-- 错误处理对性能的影响

-- 1. pcall 有一定开销，避免在紧循环中使用
local function benchmark_pcall()
    local start = os.clock()
    
    -- 直接调用
    for i = 1, 100000 do
        local _ = math.sqrt(i)
    end
    local time1 = os.clock() - start
    
    start = os.clock()
    -- 使用 pcall
    for i = 1, 100000 do
        local success, result = pcall(math.sqrt, i)
    end
    local time2 = os.clock() - start
    
    print("直接调用: " .. time1 .. "秒")
    print("pcall 调用: " .. time2 .. "秒")
    print("开销: " .. (time2 - time1) .. "秒")
end

-- 2. 在适当层级处理错误，避免不必要的包装
-- 不好：每个函数都用 pcall
local function process_data_unsafe(data)
    local s1, r1 = pcall(validate, data)
    local s2, r2 = pcall(transform, data)
    local s3, r3 = pcall(save, data)
    -- 检查每个结果...
end

-- 好：在高层统一处理
local function process_data_safe(data)
    local function process()
        validate(data)
        transform(data)
        save(data)
    end
    
    local success, err = pcall(process)
    if not success then
        return nil, err
    end
    
    return true
end
```

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 会使用各种调试功能
- [ ] 理解 Lua 的错误处理机制
- [ ] 使用 pcall 和 xpcall 保护代码执行
- [ ] 使用 error 和 assert 主动抛出错误
- [ ] 实现防御性编程策略
- [ ] 设计错误恢复机制
- [ ] 创建和使用自定义错误类型
- [ ] 记录和监控错误信息
- [ ] 避免常见的错误处理陷阱

### 思考题

1. 为什么需要这么多调试功能？
2. 什么时候应该返回错误码，什么时候应该抛出异常？
3. 如何处理不可恢复的错误（如内存不足）？
4. 如何在分布式系统中传播和处理错误？
5. 错误处理策略如何影响代码的可读性和可维护性？
6. 如何平衡错误处理的完整性和性能开销？

### 拓展练习

1. 实现一个完整的错误处理框架，支持错误分类，包括完整日志模块
2. 实现一个智能重试机制，根据错误类型动态调整重试策略

---

**下一章预告**：在第 11 章中，我们将学习迭代器和泛型 for。这是 Lua 中非常强大的特性，让我们能够以统一的方式遍历各种数据结构，包括自定义的数据结构。我们将学习如何创建和使用迭代器，理解泛型 for 的工作原理，以及如何实现各种复杂的遍历模式。

**学习建议**：
1. 多使用断点，了解错误都会在什么情况下触发
2. 在实际编码中养成错误处理的习惯
3. 从简单错误处理开始，逐步实现更复杂的策略
4. 注意区分可恢复错误和不可恢复错误
5. 记录错误信息，便于调试和维护
6. 定期审查错误处理代码，确保其正确性和完整性