# 第 10 章：错误处理

## 10.1 为什么需要错误处理？

在现实的程序中，错误是不可避免的。没有错误处理的程序就像没有刹车的汽车一样危险。

```lua
-- 没有错误处理的危险程序
local function get_table_value(t, k1, k2)
	return t[k1][k2]
end

local t = {}
get_table_value(t, "key1", "key2")	-- t.key1 为 nil，t.key1.key2 会报错：尝试索引 nil 值
-- 程序会在这里抛出错误，程序终止
print("这行代码不会执行")
```

## 10.2 Lua 的错误类型

```lua
-- Lua中的错误分为几种类型

-- 1. 语法错误（在加载时发现）
-- local x =  -- 如果忘记写值，会报语法错误

-- 2. 运行时错误
-- 访问不存在的表
-- print(undefined_table.v)  -- 错误: 尝试索引nil值

-- 3. 逻辑错误（程序能运行，但结果不对）
local function calculate_average(numbers)
    local sum = 0
    
    for i = 1, #numbers do
        sum = sum + numbers[i]
    end
    
    return sum / #numbers  -- 如果numbers为空表，会除以0，返回 1.#INF
end

-- 4. 资源错误
-- 文件不存在、内存不足、网络连接失败等

-- 演示各种错误
local function demonstrate_errors()
    print("\n1. 类型错误:")
    local result = {} + 10  -- 尝试对表进行算术运算
    print("结果: " .. result)
end

-- 使用pcall保护调用
local success, error_message = pcall(demonstrate_errors)
if not success then
    print("捕获到错误: " .. error_message)
end
-- 输出 捕获到错误: attempt to perform arithmetic on a table value

local function index_nil_err()
    print("\n2. 索引错误:")
    print(abc[10]) -- 尝试索引nil值
end

local function call_number_err()
    print("\n3. 调用错误:")
    local not_a_function = 42
    not_a_function() -- 尝试调用数字
end

success, error_message = pcall(index_nil_err)
if not success then
    print("捕获到错误: " .. error_message)
end

success, error_message = pcall(call_number_err)
if not success then
    print("捕获到错误: " .. error_message)
end
--[[ 输出
2. 索引错误:
捕获到错误: attempt to index global 'abc' (a nil value)

3. 调用错误:
捕获到错误: attempt to call local 'not_a_function' (a number value)
--]]
```

### 10.3 错误信息
```lua
local function test_fn()
    a.b.c = 123
end

test_fn()
--[[ 输出
lua: test.lua:2: attempt to index global 'a' (a nil value)
stack traceback:
	test.lua:2: in function 'test_fn'
	test.lua:5: in main chunk
	[C]: ?
--]]
```

`test.lua:2` 为错误的路径模块与行数
`attempt to index global 'a' (a nil value)` 为错误信息：尝试索引 nil 值
`stack traceback` 调用堆栈（从下往上看）
`test.lua:5: in main chunk` 在主代码块先执行了第 5 行代码
`test.lua:2: in function 'test_fn'` 最后执行了 `test_fn` 函数中的第 2 行

## 10.4 错误处理
### 10.4.1 pcall - 保护调用
pcall (protected call) 是Lua最基本的错误处理机制，以保护模式调用函数。函数中的任何错误不会抛出；取而代之的是 `pcall` 会将错误捕获。

```lua
pcall(保护函数: func, 函数参数: any...) -> 是否有错误: bool, 返回值|错误信息: any|str...
```

#### 示例
```lua
-- pcall处理多个返回值
local function multiple_returns()
    return 1, 2, 3, 4, 5
end

local function failing_function()
    error("出错了！", 0)
end

print("\n多返回值处理:")
success, a, b, c, d, e = pcall(multiple_returns)
if success then
    print("  成功返回: " .. a .. ", " .. b .. ", " .. c .. ", " .. d .. ", " .. e)
else
    print("  错误: " .. a)  -- 注意：错误信息在第一个返回值
end

success, err = pcall(failing_function)
if not success then
    print("  捕获错误: " .. err)
end
--[[ 输出
成功返回: 1, 2, 3, 4, 5
捕获错误: 出错了！
--]]
```

### 10.4.2 xpcall - 带错误处理的保护调用

xpcall 比 pcall 更强大，可以指定错误信息处理函数

```lua
xpcall(保护函数: func, 信息处理函数: func, 函数参数: any...) -> 是否有错误: bool, 返回值|处理后的信息: any|str...
```

#### 示例
```lua
-- 错误处理函数
local function error_handler(err)
    -- err参数是错误信息
    local debug_info = debug.traceback("错误追踪:", 2)
    return string.format("发生错误: %s\n%s", err, debug_info)
end

local function risky_operation()
    local t = {1, 2, 3}
    return t[10] * 2  -- t[10]是nil，nil * 2会出错
end

print("xpcall示例1:")
local success, result = xpcall(risky_operation, error_handler)
if success then
    print("  结果: " .. result)
else
    print("  错误处理:\n" .. result)
end
--[[ 输出
发生错误: test.lua:10: attempt to perform arithmetic on field '?' (a nil value)
错误追踪:
stack traceback:
	test.lua:10: in function <test.lua:8>
	[C]: in function 'xpcall'
	test.lua:14: in main chunk
	[C]: ?
--]]
```

### 10.4.3 error - 抛出错误

```lua
error(信息: str, 错误级别?: int)
```
- 错误级别默认为 1

#### 示例
```lua
-- 示例1：基本错误抛出
local function validate_age(age)
    if type(age) ~= "number" then
        error("年龄必须是数字", 2)  -- level=2表示错误在调用者的位置
    end
    
    if age < 0 then
        error("年龄不能为负数", 2)
    end
    
    if age > 150 or age == 0 then
        error("年龄不合理", 2)
    end
    
    return true
end

print("年龄验证测试:")
local test_ages = {25, -5, "二十", 200, 0}

for i, age in ipairs(test_ages) do
    local success, result = pcall(validate_age, age)
    if success then
        print("  年龄 " .. age .. ": 有效")
    else
        print("  年龄 " .. age .. ": " .. result)
    end
end
--[[ 输出
年龄 25: 有效
年龄 -5: 年龄不能为负数
年龄 二十: 年龄必须是数字
年龄 200: 年龄不合理
年龄 0: 有效
--]]

-- 示例2：错误级别的作用
local function level_demo()
    print("\n错误级别演示:")
    
    local function inner_function()
        error("错误发生在inner_function", 0)  -- level 0: 不添加位置信息
    end
    
    local function middle_function()
        error("错误发生在middle_function", 1)  -- level 1: 调用error的位置
    end
    
    local function outer_function()
        error("错误发生在outer_function", 2)  -- level 2: 调用者的位置
    end
    
    -- 测试不同level
    local function test_error(func, level_desc)
        local success, err = pcall(func)
        if not success then
            print("  " .. level_desc .. ": " .. err)
        end
    end
    
    test_error(inner_function, "level 0")
    test_error(middle_function, "level 1")
    test_error(outer_function, "level 2")
end

level_demo()
```

### 10.4.4 assert - 断言

assert 用于检查条件，如果条件为假则抛出错误

```lua
assert(条件: bool, 错误信息?: str, 参数?: any...) -> 参数: any...
```
- 错误信息默认为 `"assertion failed!"`

#### 示例
```lua
-- 示例1：基本断言
function calculate_bmi(weight, height)
    -- 参数验证
    assert(type(weight) == "number", "体重必须是数字")
    assert(type(height) == "number", "身高必须是数字")
    assert(weight > 0, "体重必须大于0")
    assert(height > 0, "身高必须大于0")
    
    return weight / (height * height)
end

print("BMI计算测试:")
local test_cases = {
    {70, 1.75},     -- 有效
    {-70, 1.75},    -- 无效体重
    {70, -1.75},    -- 无效身高
    {"70", 1.75},   -- 字符串体重
}

for i, case in ipairs(test_cases) do
    local success, result = pcall(calculate_bmi, case[1], case[2])
    if success then
        print(string.format("  体重%.1fkg, 身高%.2fm -> BMI: %.1f", 
              case[1], case[2], result))
    else
        print("  错误: " .. result)
    end
end

-- 示例2：assert与error的区别
print("\nassert vs error:")

function using_assert(value)
    assert(value ~= nil, "值不能为nil")
    return value * 2
end

function using_error(value)
    if value == nil then
        error("值不能为nil", 2)
    end
    return value * 2
end

-- 两个函数的功能相同，但assert更简洁
local test_values = {5, nil}

for i, value in ipairs(test_values) do
    print("\n测试值: " .. tostring(value))
    
    local success1, result1 = pcall(using_assert, value)
    if success1 then
        print("  assert版本: " .. result1)
    else
        print("  assert版本错误: " .. result1)
    end
    
    local success2, result2 = pcall(using_error, value)
    if success2 then
        print("  error版本: " .. result2)
    else
        print("  error版本错误: " .. result2)
    end
end

-- 示例3：在生产环境中禁用断言
-- 在开发时使用断言检查，发布时可以关闭
local DEBUG_MODE = true

function release_assert(condition, message)
    if DEBUG_MODE then
        assert(condition, message)
    elseif not condition then
        -- 在生产环境中，记录错误但不抛出
        print("[生产环境错误] " .. (message or "断言失败"))
        return false
    end
    return true
end

print("\n生产环境断言:")
local function test_function(x)
    if not release_assert(x > 0, "x必须大于0") then
        return nil
    end
    return x * 2
end

-- 测试模式
DEBUG_MODE = true
print("调试模式:")
local success, result = pcall(test_function, -5)
if not success then
    print("  错误: " .. result)
end

-- 生产模式
DEBUG_MODE = false
print("\n生产模式:")
local result = test_function(-5)
if result then
    print("  结果: " .. result)
else
    print("  函数返回nil（不抛出错误）")
end
```

## 10.5 错误处理策略

### 10.5.1 防御性编程
假设一切可能出错，并提前处理

```lua
-- 示例1：安全的表访问
local function safe_table_access(t, key, default)
    if type(t) ~= "table" then
        return default
    end
    
    local value = t[key]
    if value == nil then
        return default
    end
    
    return value
end

print("安全表访问:")
local config = {theme = "dark", language = "zh-CN"}
print("  主题: " .. safe_table_access(config, "theme", "light"))
print("  音量: " .. safe_table_access(config, "volume", 70))  -- 使用默认值
print("  非表: " .. safe_table_access("不是表", "key", "默认"))
--[[ 输出
主题: dark
音量: 70
非表: 默认
--]]

-- 示例2：安全的函数调用
local function safe_call(func, ...)
    if type(func) ~= "function" then
        return nil, "不是函数"
    end
    
    local success, result = pcall(func, ...)
    if not success then
        return nil, result
    end
    
    return result
end

print("\n安全函数调用:")
local function add(a, b)
	return a + b
end
local result, err = safe_call(add, 5, 3)
if result then
    print("  5 + 3 = " .. result)
else
    print("  错误: " .. err)
end

result, err = safe_call("不是函数", 5, 3)
if result then
    print("  结果: " .. result)
else
    print("  错误: " .. err)
end
--[[ 输出
5 + 3 = 8
 错误: 不是函数
--]]

-- 示例3：验证输入数据
local function validate_user_input(input)
    -- 多层验证
    if not input then
        return nil, "输入不能为空"
    end
    
    if type(input) ~= "table" then
        return nil, "输入必须是表"
    end
    
    -- 验证必填字段
    local required = {"username", "email", "password"}
    for _, field in ipairs(required) do
        if not input[field] or #tostring(input[field]) == 0 then
            return nil, "字段 '" .. field .. "' 不能为空"
        end
    end
    
    -- 验证邮箱格式
    local email = input.email
    if not string.match(email, "^[%w%.%-]+@[%w%.%-]+%.[%a]+$") then
        return nil, "邮箱格式无效"
    end
    
    -- 验证密码强度
    local password = input.password
    if #password < 8 then
        return nil, "密码至少需要8个字符"
    end
    
    return true
end

print("\n输入验证:")
local inputs = {
    {username = "user1", email = "test@example.com", password = "secure123"},
    {username = "", email = "test@example.com", password = "short"},  -- 用户名为空
    {username = "user2", email = "invalid-email", password = "password123"},  -- 邮箱无效
    {username = "user3", email = "test@example.com", password = "123"},  -- 密码太短
}

for i, input in ipairs(inputs) do
    local valid, err = validate_user_input(input)
    if valid then
        print("  输入 " .. i .. ": 有效")
    else
        print("  输入 " .. i .. ": 无效 - " .. err)
    end
end
--[[ 输出
  输入 1: 有效
  输入 2: 无效 - 字段 'username' 不能为空
  输入 3: 无效 - 邮箱格式无效
  输入 4: 无效 - 密码至少需要8个字符
--]]
```

### 10.5.2 错误恢复策略

```lua
-- 错误恢复：从错误中恢复并继续执行
-- 策略1：重试机制
local function retry_operation(operation, max_attempts, delay)
    max_attempts = max_attempts or 3
    delay = delay or 1  -- 默认延迟1秒
    
    for attempt = 1, max_attempts do
        local success, result = pcall(operation)
        
        if success then
            return result
        end
        
        print(string.format("  尝试 %d/%d 失败: %s", 
              attempt, max_attempts, result))
        
        if attempt < max_attempts then
            print(string.format("  等待 %.1f 秒后重试...", delay))
            -- 在实际应用中，这里应该使用 os.execute 或类似方法等待
            -- 为了示例简化，我们只是打印
        end
    end
    
    return nil, "所有重试尝试都失败"
end

print("重试机制:")
local function unreliable_operation()
    math.randomseed(os.time())
    if math.random() < 0.7 then  -- 70%失败率
        error("操作失败: 随机错误")
    end
    return "操作成功"
end

local result, err = retry_operation(unreliable_operation, 5, 0.5)
if result then
    print("  最终结果: " .. result)
else
    print("  最终错误: " .. err)
end

-- 策略2：降级服务
print("\n降级服务:")
local function fetch_data(source, fallback_source)
    -- 尝试主数据源
    local success, data = pcall(source.fetch)
    
    if success then
        print("  使用主数据源")
        return data
    end
    
    print("  主数据源失败: " .. data)
    print("  尝试备用数据源...")
    
    -- 尝试备用数据源
    success, data = pcall(fallback_source.fetch)
    
    if success then
        print("  使用备用数据源")
        return data
    end
    
    print("  备用数据源也失败: " .. data)
    
    -- 返回缓存或默认数据
    print("  返回缓存数据")
    return {cached = true, data = "默认数据"}
end

-- 模拟数据源
local primary_source = {
    fetch = function()
        if math.random() < 0.5 then
            error("主数据源不可用")
        end
        return {source = "primary", data = "新鲜数据"}
    end
}

local fallback_source = {
    fetch = function()
        if math.random() < 0.3 then
            error("备用数据源不可用")
        end
        return {source = "fallback", data = "稍旧的数据"}
    end
}

for i = 1, 3 do
    print("\n尝试 " .. i .. ":")
    local data = fetch_data(primary_source, fallback_source)
    print("  获取的数据: " .. data.data .. " (来源: " .. (data.source or "缓存") .. ")")
end

-- 策略3：优雅降级
print("\n优雅降级:")
local function render_ui(use_advanced_features)
    local features = {}
    
    -- 基础功能总是可用的
    features.basic = true
    
    -- 高级功能可能不可用
    if use_advanced_features then
        local success = pcall(function()
            -- 模拟需要特定库或环境的功能
            if not package.loaded["advanced_graphics"] then
                error("高级图形库未安装")
            end
            features.advanced_graphics = true
        end)
        
        if not success then
            print("  警告: 高级图形功能不可用，使用基础渲染")
            features.advanced_graphics = false
        end
    else
        features.advanced_graphics = false
    end
    
    -- 根据可用功能渲染UI
    if features.advanced_graphics then
        print("  使用高级UI渲染")
    else
        print("  使用基础UI渲染")
    end
    
    return features
end

print("渲染测试:")
render_ui(true)
render_ui(false)

-- 策略4：隔离故障
print("\n故障隔离:")
local function isolated_operation(operation_name, operation_func)
    -- 在独立的协程中执行操作，防止一个操作失败影响其他操作
    local co = coroutine.create(function()
        local success, result = pcall(operation_func)
        if not success then
            print("  操作 '" .. operation_name .. "' 失败: " .. result)
            return nil, result
        end
        return result
    end)
    
    local success, result = coroutine.resume(co)
    if success and coroutine.status(co) == "dead" then
        return result
    else
        return nil, "操作未完成"
    end
end

print("隔离执行:")
local results = {}

results.op1 = isolated_operation("操作1", function()
    error("操作1故意失败")
end)

results.op2 = isolated_operation("操作2", function()
    return "操作2成功"
end)

results.op3 = isolated_operation("操作3", function()
    error("操作3也失败")
end)

print("\n所有操作结果:")
for name, result in pairs(results) do
    if result then
        print("  " .. name .. ": " .. result)
    else
        print("  " .. name .. ": 失败")
    end
end
```

## 10.6 自定义错误类型

```lua
-- 创建结构化的错误类型，便于处理
-- 错误类型定义
local ErrorTypes = {
    VALIDATION = {
        code = 100,
        name = "VALIDATION_ERROR",
        description = "输入验证失败"
    },
    DATABASE = {
        code = 200,
        name = "DATABASE_ERROR",
        description = "数据库操作失败"
    },
    NETWORK = {
        code = 300,
        name = "NETWORK_ERROR",
        description = "网络通信失败"
    },
    PERMISSION = {
        code = 400,
        name = "PERMISSION_ERROR",
        description = "权限不足"
    },
    INTERNAL = {
        code = 500,
        name = "INTERNAL_ERROR",
        description = "内部服务器错误"
    }
}

-- 错误创建函数
local function create_error(error_type, message, details)
    local error_info = ErrorTypes[error_type]
    if not error_info then
        error_info = ErrorTypes.INTERNAL
    end
    
    return {
        type = error_type,
        code = error_info.code,
        name = error_info.name,
        message = message or error_info.description,
        details = details,
        timestamp = os.time(),
        stack_trace = debug.traceback("", 2)
    }
end

-- 错误抛出函数
local function throw_error(error_type, message, details)
    error(create_error(error_type, message, details), 2)
end

-- 错误处理函数
local function handle_error(err, context)
    -- 如果是我们的自定义错误
    if type(err) == "table" and err.code then
        print(string.format("[错误处理] 类型: %s (%d)", err.name, err.code))
        print(string.format("          消息: %s", err.message))
        
        if err.details then
            print(string.format("          详情: %s", tostring(err.details)))
        end
        
        if context then
            print(string.format("          上下文: %s", context))
        end
        
        print("          调用栈:")
        print(err.stack_trace)
        
        -- 根据错误类型采取不同措施
        if err.type == "VALIDATION" then
            return nil, "输入错误，请检查后重试"
        elseif err.type == "PERMISSION" then
            return nil, "权限不足，请联系管理员"
        elseif err.type == "NETWORK" then
            -- 可以尝试重试
            return nil, "网络错误，请稍后重试"
        else
            return nil, "系统错误，请联系技术支持"
        end
    else
        -- 其他类型的错误
        return nil, "未知错误: " .. tostring(err)
    end
end

-- 使用自定义错误
print("自定义错误演示:")

local function register_user(user_data)
    -- 验证输入
    if not user_data or not user_data.username then
        throw_error("VALIDATION", "用户名不能为空", user_data)
    end
    
    if #user_data.username < 3 then
        throw_error("VALIDATION", "用户名至少需要3个字符", 
                   {username = user_data.username, length = #user_data.username})
    end
    
    -- 模拟数据库操作
    local success, db_result = pcall(function()
        -- 模拟数据库错误
        if user_data.username == "admin" then
            error("用户名已存在")
        end
        return {id = 123, username = user_data.username}
    end)
    
    if not success then
        throw_error("DATABASE", "创建用户失败", {error = db_result})
    end
    
    -- 模拟权限检查
    if user_data.username == "root" then
        throw_error("PERMISSION", "不允许注册root用户")
    end
    
    return db_result
end

-- 测试不同的错误情况
local test_cases = {
    {username = ""},           -- 验证错误
    {username = "ab"},         -- 用户名太短
    {username = "admin"},      -- 数据库错误
    {username = "root"},       -- 权限错误
    {username = "正常用户"},   -- 成功
}

for i, test_case in ipairs(test_cases) do
    print(string.format("\n测试用例 %d: 用户名='%s'", i, test_case.username))
    
    local success, result = pcall(register_user, test_case)
    if success then
        print("  成功: 用户ID = " .. result.id)
    else
        local _, user_message = handle_error(result, "用户注册")
        print("  失败: " .. user_message)
    end
end
--[[ 输出
测试用例 1: 用户名=''
[错误处理] 类型: VALIDATION_ERROR (100)
          消息: 用户名至少需要3个字符
          详情: table: 00C22798
          上下文: 用户注册
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:99: in function <test.lua:92>
	[C]: in function 'pcall'
	test.lua:136: in main chunk
	[C]: ?
  失败: 输入错误，请检查后重试

测试用例 2: 用户名='ab'
[错误处理] 类型: VALIDATION_ERROR (100)
          消息: 用户名至少需要3个字符
          详情: table: 00C22B30
          上下文: 用户注册
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:99: in function <test.lua:92>
	[C]: in function 'pcall'
	test.lua:136: in main chunk
	[C]: ?
  失败: 输入错误，请检查后重试

测试用例 3: 用户名='admin'
[错误处理] 类型: DATABASE_ERROR (200)
          消息: 创建用户失败
          详情: table: 00C22C20
          上下文: 用户注册
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	est.lua:113: in function <test.lua:92>
	[C]: in function 'pcall'
	test.lua:136: in main chunk
	[C]: ?
  失败: 系统错误，请联系技术支持

测试用例 4: 用户名='root'
[错误处理] 类型: PERMISSION_ERROR (400)
          消息: 不允许注册root用户
          上下文: 用户注册
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:118: in function <test.lua:92>
	[C]: in function 'pcall'
	test.lua:136: in main chunk
	[C]: ?
  失败: 权限不足，请联系管理员

测试用例 5: 用户名='正常用户'
  成功: 用户ID = 123
--]]
```

## 10.7 练习

### 练习 1：模拟网络请求的错误处理
（答案见[[第 1 节 - 语法/参考答案#练习 10 1：模拟网络请求的错误处理]]）
```lua
-- 模拟网络请求的错误处理，服务器未响应、网络错误、未响应等，模拟每过几秒进行重试，支持批量请求
-- 使用示例：
-- 使用HTTP客户端
print("HTTP客户端测试:")
local client = http_client.new{
    max_retries = 2,
    timeout = 5,
    base_url = "https://api.example.com"
}

-- 测试单个请求
print("\n1. 测试单个请求:")
local response, err = client:request_with_retry("GET", "/users/404")
if response then
    print("  成功: " .. response.body)
else
    local _, user_msg = handle_error(err)
    print("  失败: " .. user_msg)
end

-- 测试批量请求
print("\n2. 测试批量请求:")
local requests = {
    {method = "GET", path = "/users/1"},
    {method = "GET", path = "/users/404"},  -- 会返回404
    {method = "POST", path = "/users", data = '{"name": "测试"}'},
    {method = "GET", path = "/users/500"},  -- 会返回500
}

local responses, errors = client:batch_request(requests)

print("\n批量请求结果:")
for i, response in pairs(responses) do
    print(string.format("  请求 %s 成功: %s", i, response.body))
end
for i, err in pairs(errors) do
    print(string.format("  请求 %s 失败: ", i))
    local _, user_msg = handle_error(err)
end
--[[ 输出
1. 测试单个请求:
  尝试 1/2...
  请求: GET https://api.example.com/users/404
  等待 1.0 秒后重试...
  尝试 2/2...
  请求: GET https://api.example.com/users/404
[ERROR] 类型: NETWORK_ERROR (300)
          消息: 资源未找到
          详情: table: 00F81980
          调用栈: 
stack traceback:
	test.lua:93: in function 'request'
	test.lua:113: in function 'request_with_retry'
	test.lua:170: in main chunk
	[C]: ?
  失败: 网络错误，请稍后重试

2. 测试批量请求:

批量请求 1/4:
  尝试 1/2...
  请求: GET https://api.example.com/users/1

批量请求 2/4:
  尝试 1/2...
  请求: GET https://api.example.com/users/404
  等待 1.0 秒后重试...
  尝试 2/2...
  请求: GET https://api.example.com/users/404

批量请求 3/4:
  尝试 1/2...
  请求: POST https://api.example.com/users

批量请求 4/4:
  尝试 1/2...
  请求: GET https://api.example.com/users/500
  等待 1.0 秒后重试...
  尝试 2/2...
  请求: GET https://api.example.com/users/500

批量请求结果:
  请求 1 成功: {"success": true, "data": "default", "method": "GET"}
  请求 3 成功: {"success": true, "data": "{"name": "测试"}", "method": "POST"}
  请求 2 失败: 
[ERROR] 类型: NETWORK_ERROR (300)
          消息: 资源未找到
          详情: table: 00F88238
          调用栈: 
stack traceback:
	test.lua:93: in function 'request'
	test.lua:113: in function 'request_with_retry'
	test.lua:144: in function 'batch_request'
	test.lua:187: in main chunk
	[C]: ?
  请求 4 失败: 
[ERROR] 类型: NETWORK_ERROR (300)
          消息: 系统错误
          详情: table: 00F88288
          调用栈: 
stack traceback:
	test.lua:93: in function 'request'
	test.lua:113: in function 'request_with_retry'
	test.lua:144: in function 'batch_request'
	test.lua:187: in main chunk
	[C]: ?
--]]
```

### 练习 2：模拟数据库操作错误处理
（答案见[[第 1 节 - 语法/参考答案#练习 10 2：模拟数据库操作错误处理]]）
```lua
-- 模拟数据库操作的错误处理
-- 使用示例：
-- 使用数据库
print("数据库操作测试:")
local db = data_base.new {
    host = "localhost",
    database = "mydb",
    username = "admin",
    password = "secret"
}

-- 包装数据库操作为安全操作
function safe_database_operation(db, operation_name, operation, ...)
    print("\n操作: " .. operation_name)

    local result, err = db:safe_execute(operation, ...)

    if result then
        print("  成功")
        return result
    else
        local _, user_msg = handle_error(err, operation_name)
        print("  失败: " .. user_msg)
        return nil, err
    end
end

-- 测试各种操作
-- 连接数据库
safe_database_operation(db, "连接数据库", db.connect)

-- 查询数据
local users, err = safe_database_operation(db, "查询用户", function(self)
    return self:query("SELECT * FROM users WHERE status = 'active'")
end)

if users then
    print("  查询到 " .. #users .. " 个用户")
end

-- 测试插入重复数据
local insert_result, err = safe_database_operation(db, "插入用户", function(self)
    return self:query("INSERT INTO users (name, email) VALUES (?, ?)",
        { "测试用户", "duplicate@example.com" })
end)

-- 测试事务
print("\n测试事务操作:")
local transaction_success, transaction_err = pcall(function()
    db:begin_transaction()

    -- 多个操作
    db:query("UPDATE accounts SET balance = balance - 100 WHERE id = 1")
    db:query("UPDATE accounts SET balance = balance + 100 WHERE id = 2")

    db:commit()
    print("  事务执行成功")
end)

if not transaction_success then
    print("  事务失败: " .. tostring(transaction_err))
    if db.transaction_active then
        db:rollback()
    end
end

-- 断开连接
safe_database_operation(db, "断开连接", db.disconnect)
--[[ 输出
操作: 连接数据库
  连接数据库 localhost:3306...
[错误处理] 类型: NETWORK_ERROR (300)
          消息: 数据库连接失败
          详情: table: 00E5CEA0
          上下文: 连接数据库
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:114: in function <test.lua:104>
	[C]: in function 'pcall'
	test.lua:213: in function 'safe_execute'
	test.lua:253: in function 'safe_database_operation'
	test.lua:267: in main chunk
	[C]: ?
  失败: 网络错误，请稍后重试

操作: 查询用户
  检测到连接问题，尝试重连...
  连接数据库 localhost:3306...
[错误处理] 类型: DATABASE_ERROR (200)
          消息: 数据库未连接
          上下文: 查询用户
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:126: in function <test.lua:124>
	(tail call): ?
	[C]: in function 'pcall'
	test.lua:213: in function 'safe_execute'
	test.lua:253: in function 'safe_database_operation'
	test.lua:270: in main chunk
	[C]: ?
  失败: 系统错误，请联系技术支持

操作: 插入用户
  检测到连接问题，尝试重连...
  连接数据库 localhost:3306...
[错误处理] 类型: DATABASE_ERROR (200)
          消息: 数据库未连接
          上下文: 插入用户
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:126: in function <test.lua:124>
	(tail call): ?
	[C]: in function 'pcall'
	test.lua:213: in function 'safe_execute'
	test.lua:253: in function 'safe_database_operation'
	test.lua:279: in main chunk
	[C]: ?
  失败: 系统错误，请联系技术支持

测试事务操作:
  开始事务
  事务失败: table: 00E5CF68
  回滚事务

操作: 断开连接
  断开数据库连接
  成功
--]]
```

## 10.8 本章总结

### 关键知识点回顾

1. **错误类型**：
   - 语法错误
   - 运行时错误
   - 逻辑错误
   - 资源错误

2. **错误处理**：
   - `pcall`：保护调用，捕获错误
   - `xpcall`：带错误处理函数的保护调用
   - `error`：主动抛出错误
   - `assert`：条件断言，失败时抛出错误

3. **错误处理策略**：
   - 防御性编程
   - 错误恢复（重试、降级、隔离）
   - 错误日志和监控
   - 自定义错误类型

4. **最佳实践**：
   - 输入验证
   - 资源清理
   - 错误传播
   - 用户友好错误消息

### 错误处理模式

```lua
-- 模式 1：立即返回错误
function process_data(data)
    if not data then
        return nil, "数据不能为空"
    end
    -- 处理数据...
    return result
end

-- 模式 2：抛出异常
function validate_input(input)
    if not input then
        error("输入不能为空", 2)
    end
    -- 验证通过...
end

-- 模式 3：使用断言
function critical_operation(param)
    assert(param ~= nil, "参数不能为 nil")
    -- 关键操作...
end

-- 模式 4：错误转换
function api_wrapper(func)
    return function(...)
        local success, result = pcall(func, ...)
        if not success then
            -- 转换为 API 错误格式
            return {success = false, error = result}
        end
        return {success = true, data = result}
    end
end
```

### 常见错误处理陷阱

```lua
-- 陷阱 1：忽略错误
local file = io.open("missing.txt", "r")
local content = file:read("*all")  -- 如果文件不存在，file 是 nil，这里会崩溃
file:close()

-- 正确做法
local file, err = io.open("missing.txt", "r")
if not file then
    print("错误: " .. err)
    return
end

-- 陷阱 2：错误信息不明确
local function bad_error_handling()
    local success, result = pcall(some_operation)
    if not success then
        print("错误")  -- 不明确
    end
end

-- 正确做法
local function good_error_handling()
    local success, result = pcall(some_operation)
    if not success then
        print("操作失败: " .. result)
        print("调用栈: " .. debug.traceback())
    end
end

-- 陷阱 3：过度使用 pcall
local function overuse_pcall()
    -- 每个操作都用 pcall 包装，性能差且代码冗长
    local s1, r1 = pcall(operation1)
    local s2, r2 = pcall(operation2)
    local s3, r3 = pcall(operation3)
    -- ...
end

-- 正确做法：在合适的层级处理错误
local function proper_error_handling()
    local function inner()
        operation1()
        operation2()
        operation3()
    end
    
    local success, err = pcall(inner)
    if not success then
        -- 统一处理错误
        handle_error(err)
    end
end

-- 陷阱 4：资源泄漏
local function resource_leak()
    local file = io.open("test.txt", "w")
    file:write("数据")
    -- 忘记关闭文件！
    -- 如果后面发生错误，文件永远不会关闭
end

-- 正确做法：确保资源释放
local function proper_resource_handling()
    local file, err = io.open("test.txt", "w")
    if not file then
        return nil, err
    end
    
    local success, result = pcall(function()
        file:write("数据")
        -- 其他可能失败的操作...
    end)
    
    -- 无论如何都关闭文件
    file:close()
    
    if not success then
        return nil, result
    end
    
    return true
end
```

### 性能考虑

```lua
-- 错误处理对性能的影响

-- 1. pcall 有一定开销，避免在紧循环中使用
local function benchmark_pcall()
    local start = os.clock()
    
    -- 直接调用
    for i = 1, 100000 do
        local _ = math.sqrt(i)
    end
    local time1 = os.clock() - start
    
    start = os.clock()
    -- 使用 pcall
    for i = 1, 100000 do
        local success, result = pcall(math.sqrt, i)
    end
    local time2 = os.clock() - start
    
    print("直接调用: " .. time1 .. "秒")
    print("pcall 调用: " .. time2 .. "秒")
    print("开销: " .. (time2 - time1) .. "秒")
end

-- 2. 在适当层级处理错误，避免不必要的包装
-- 不好：每个函数都用 pcall
local function process_data_unsafe(data)
    local s1, r1 = pcall(validate, data)
    local s2, r2 = pcall(transform, data)
    local s3, r3 = pcall(save, data)
    -- 检查每个结果...
end

-- 好：在高层统一处理
local function process_data_safe(data)
    local function process()
        validate(data)
        transform(data)
        save(data)
    end
    
    local success, err = pcall(process)
    if not success then
        return nil, err
    end
    
    return true
end
```

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 理解 Lua 的错误处理机制
- [ ] 使用 pcall 和 xpcall 保护代码执行
- [ ] 使用 error 和 assert 主动抛出错误
- [ ] 实现防御性编程策略
- [ ] 设计错误恢复机制
- [ ] 创建和使用自定义错误类型
- [ ] 记录和监控错误信息
- [ ] 避免常见的错误处理陷阱

### 思考题

1. 什么时候应该返回错误码，什么时候应该抛出异常？
2. 如何处理不可恢复的错误（如内存不足）？
3. 如何在分布式系统中传播和处理错误？
4. 错误处理策略如何影响代码的可读性和可维护性？
5. 如何平衡错误处理的完整性和性能开销？

### 拓展练习

1. 实现一个完整的错误处理框架，支持错误分类，包括完整日志模块
2. 创建一个性能监控系统，记录和分析错误发生的模式和频率
3. 设计一个容错的计算引擎，能够在部分组件失败时继续运行
4. 实现一个智能重试机制，根据错误类型动态调整重试策略
5. 创建一个错误报告系统，自动收集错误信息并生成报告

---

**下一章预告**：在第 11 章中，我们将学习迭代器和泛型 for。这是 Lua 中非常强大的特性，让我们能够以统一的方式遍历各种数据结构，包括自定义的数据结构。我们将学习如何创建和使用迭代器，理解泛型 for 的工作原理，以及如何实现各种复杂的遍历模式。

**学习建议**：
1. 在实际编码中养成错误处理的习惯
2. 从简单错误处理开始，逐步实现更复杂的策略
3. 注意区分可恢复错误和不可恢复错误
4. 记录错误信息，便于调试和维护
5. 定期审查错误处理代码，确保其正确性和完整性