## 第 13 章：LuaJIT

### 13.1 LuaJIT 简介

LuaJIT 是一个高性能的 Lua 解释器和即时编译器（JIT），它完全兼容 Lua 5.1，但性能通常比标准 Lua 快得多。

**LuaJIT 的主要特性**：
1. 高性能 JIT 编译器
2. 提供 FFI 允许直接调用 C 函数和使用 C 数据结构
3. 内存使用更少
4. 完全兼容 Lua 5.1
5. 支持更多字节码指令

### 13.2 JIT 编译器

```lua
-- JIT编译器的使用和优化
print("=== JIT编译器 ===")

-- 性能测试：标准Lua vs LuaJIT
function benchmark_loop()
    local sum = 0
    for i = 1, 10000000 do
        sum = sum + i
    end
    return sum
end

print("性能测试开始...")
local start_time = os.clock()
local result = benchmark_loop()
local end_time = os.clock()

print(string.format("计算结果: %.0f", result))
print(string.format("执行时间: %.3f秒", end_time - start_time))

-- JIT控制
if jit then
    print("\nJIT控制:")
    
    -- 开启/关闭JIT
    jit.off()  -- 关闭JIT
    print("JIT已关闭")
    
    start_time = os.clock()
    benchmark_loop()
    end_time = os.clock()
    print(string.format("无JIT执行时间: %.3f秒", end_time - start_time))
    
    jit.on()  -- 开启JIT
    print("JIT已开启")
    
    start_time = os.clock()
    benchmark_loop()
    end_time = os.clock()
    print(string.format("有JIT执行时间: %.3f秒", end_time - start_time))
    
    -- 刷新JIT缓存
    jit.flush()
    print("JIT缓存已刷新")
end

-- 热点代码检测
function hot_function()
    local total = 0
    for i = 1, 1000 do
        total = total + math.sin(i) * math.cos(i)
    end
    return total
end

print("\n热点代码检测:")
-- LuaJIT会自动检测并编译热点代码
for i = 1, 100 do
    hot_function()
end
print("热点函数已执行多次，应该已被JIT编译")
```

### 13.3 FFI（外部函数接口）

FFI 是 LuaJIT 最强大的特性之一，允许直接调用 C 函数和使用 C 数据结构。

```lua
-- FFI使用示例
print("=== FFI（外部函数接口） ===")

local ffi = require("ffi")

-- 1. 声明C函数和类型
ffi.cdef[[
    // 标准库函数
    int printf(const char *fmt, ...);
    int strlen(const char *s);
    void *malloc(size_t size);
    void free(void *ptr);
    
    // 数学函数
    double sin(double x);
    double cos(double x);
    double sqrt(double x);
    
    // 系统调用
    int system(const char *command);
    
    // 自定义结构体
    typedef struct {
        int x;
        int y;
    } Point;
    
    typedef struct {
        char name[32];
        int age;
        float score;
    } Student;
]]

-- 2. 调用C函数
print("调用C标准库函数:")
ffi.C.printf("Hello from C printf! %s\n", ffi.new("const char*", "via LuaJIT"))

local str = "Hello, World!"
local length = ffi.C.strlen(str)
print("字符串长度: " .. length)

-- 3. 使用数学函数
local angle = 45 * math.pi / 180
local sin_value = ffi.C.sin(angle)
local cos_value = ffi.C.cos(angle)
print(string.format("\n数学函数: sin(45°)=%.3f, cos(45°)=%.3f", sin_value, cos_value))

-- 4. 创建和使用C结构体
print("\nC结构体使用:")
-- 创建Point结构体
local point = ffi.new("Point")
point.x = 10
point.y = 20
print("Point: x=" .. point.x .. ", y=" .. point.y)

-- 创建Student结构体
local student = ffi.new("Student")
ffi.copy(student.name, "张三")
student.age = 18
student.score = 95.5

print(string.format("Student: name=%s, age=%d, score=%.1f",
      ffi.string(student.name), student.age, student.score))

-- 5. 内存管理
print("\n内存管理:")
local size = 100 * ffi.sizeof("int")
local buffer = ffi.C.malloc(size)
print("分配内存: " .. size .. " 字节")

if buffer ~= ffi.NULL then
    -- 将buffer转换为int数组
    local int_array = ffi.cast("int*", buffer)
    
    -- 初始化数组
    for i = 0, 99 do
        int_array[i] = i * 2
    end
    
    -- 访问数组元素
    print("int_array[50] = " .. int_array[50])
    
    -- 释放内存
    ffi.C.free(buffer)
    print("内存已释放")
end

-- 6. 调用系统命令
print("\n系统调用:")
local result = ffi.C.system("echo 'Hello from system call'")
print("系统命令返回值: " .. result)

-- 7. 性能对比：FFI vs 纯Lua
print("\n性能对比 - FFI vs 纯Lua:")

function lua_math_benchmark()
    local sum = 0
    for i = 1, 1000000 do
        sum = sum + math.sin(i) + math.cos(i)
    end
    return sum
end

function ffi_math_benchmark()
    local sum = 0
    for i = 1, 1000000 do
        sum = sum + ffi.C.sin(i) + ffi.C.cos(i)
    end
    return sum
end

-- 测试纯Lua
local start = os.clock()
local lua_result = lua_math_benchmark()
local lua_time = os.clock() - start

-- 测试FFI
start = os.clock()
local ffi_result = ffi_math_benchmark()
local ffi_time = os.clock() - start

print(string.format("纯Lua: %.3f秒, 结果: %.3f", lua_time, lua_result))
print(string.format("FFI: %.3f秒, 结果: %.3f", ffi_time, ffi_result))
print(string.format("加速比: %.1fx", lua_time / ffi_time))
```

### 13.4 goto - 代码跳转

goto 语句提供了一种低级的控制流跳转机制，可以在代码块内直接跳转到指定标签位置。

可以使用 goto 来模拟 continue 跳过单次循环。

#### 语法
```lua
::跳转标签名称::	-- 定义跳转位置

goto 跳转到的标签
```
- 注：goto 会降低代码可读性，非必要不建议滥用


#### 核心用途

#### 1. 模拟 `continue` 语句
```lua
-- Lua 没有 continue 关键字，用 goto 实现
for i = 1, 10 do
    if i % 2 == 0 then      -- 跳过偶数
        print("跳过偶数: " .. i)
        goto continue
    end
    
    print("处理奇数: " .. i)
    
    ::continue::  -- 循环末尾的标签
end
--[[ 输出
处理奇数: 1
跳过偶数: 2
处理奇数: 3
跳过偶数: 4
处理奇数: 5
跳过偶数: 6
处理奇数: 7
跳过偶数: 8
处理奇数: 9
跳过偶数: 10
--]]
```

#### 2. 跳出多重嵌套
```lua
for i = 1, 3 do
    for j = 1, 3 do
        if i == 2 and j == 2 then
            print("找到目标，跳出所有循环")
            goto exit_loops
        end
        print(i, j)
    end
end

::exit_loops::
print("继续执行后续代码")
--[[ 输出
1	1
1	2
1	3
2	1
找到目标，跳出所有循环
继续执行后续代码
--]]
```

#### 3. 卫语句模式（提前返回）
```lua
-- 在非函数中模拟"提前返回"逻辑
local x = 10

::validate::
if x <= 0 then
    print("x 必须大于0")
    goto end_process
end

if x > 100 then
    print("x 不能超过100")
    goto end_process
end

print("x 有效: " .. x)

::end_process::
print("验证完成")
--[[ 输出
x 有效: 10
验证完成
--]]
```


#### 重要限制与规则

##### 1. 作用域限制（最重要！）
```lua
-- 不允许：跳进函数
local function test()
    ::inside_func::
end

goto inside_func  -- 错误！不能跳进函数

-- 不允许：跳进局部变量作用域
if condition then
    local x = 10
    ::label3::
end

goto label3  -- 错误！可能跳过局部变量初始化
```

##### 2. 标签定义规则
```lua
-- 合法标签名（字母、数字、下划线）
::valid_label::
::Label123::
::_start::

-- 不合法标签名
::123start::    -- 不能以数字开头
::my-label::    -- 不能包含连字符
::end::         -- 不能用保留字
```

##### 3. 其他限制
```lua
-- 不能跳到标签定义之前（如果标签在局部变量之后）
local x = 10
goto my_label  -- 错误！跳过了局部变量 y 定义

local y = 20
::my_label::
print(y)  -- 此时 y 未定义？
```

#### 最佳实践建议

##### 1. 使用场景优先级
```lua
-- 优先方案：使用函数和返回值
local function processItem(item)
    if not isValid(item) then
        return false  -- 代替 goto
    end
    -- 正常处理
    return true
end

-- 次选方案：goto 用于简单循环控制
for i = 1, 10 do
    if shouldSkip(i) then
    	goto continue
    end
    
    process(i)
    ::continue::
end
```

##### 2. 代码可读性维护
```lua
-- 难以理解：过度使用 goto
goto step1
::step3:: print("步骤3")
goto end
::step1:: print("步骤1")
goto step2
::step2:: print("步骤2")
goto step3
::end::

-- 清晰明了：限制使用范围
for i = 1, 5 do
    if i == 3 then
    	goto skip_print
    end
    
    print("正常: " .. i)
    ::skip_print::
end
```

##### 3. 替代方案参考
```lua
-- 替代多重嵌套跳出
local function findInNested()
    for i = 1, 3 do
        for j = 1, 3 do
            if i * j == 6 then
                return i, j  -- 用返回值代替 goto
            end
        end
    end
end
```

#### 常见问题解答

**Q: 为什么 goto 有这么多限制？**  
A: 为了避免创建"面条代码"，确保程序结构清晰，防止跳过变量初始化等危险操作。

**Q: 什么时候应该使用 goto？**  
A: 仅当：
1. 需要模拟 `continue`
2. 简单跳出多重循环
3. 没有更清晰的结构化替代方案

**Q: goto 的性能影响？**  
A: Lua 的 `goto` 是编译期处理，运行时几乎没有性能开销。


### 13.5 LuaJIT 特有功能

```lua
-- LuaJIT特有功能

-- 1. bit库 - 位运算
print("1. bit库 - 位运算:")
local bit = require("bit")

local a = 0x0F  -- 00001111
local b = 0xF0  -- 11110000

print(string.format("a = 0x%X (%d)", a, a))
print(string.format("b = 0x%X (%d)", b, b))
print(string.format("bit.band(a, b) = 0x%X", bit.band(a, b)))  -- 与
print(string.format("bit.bor(a, b) = 0x%X", bit.bor(a, b)))    -- 或
print(string.format("bit.bxor(a, b) = 0x%X", bit.bxor(a, b)))  -- 异或
print(string.format("bit.bnot(a) = 0x%X", bit.bnot(a)))        -- 非
print(string.format("bit.lshift(a, 2) = 0x%X", bit.lshift(a, 2)))  -- 左移
print(string.format("bit.rshift(b, 2) = 0x%X", bit.rshift(b, 2)))  -- 右移

-- 2. ffi.C - 访问C命名空间
print("\n2. 访问C命名空间:")
if ffi then
    -- 获取当前时间
    ffi.cdef[[
        time_t time(time_t *tloc);
        char *ctime(const time_t *timep);
    ]]
    
    local current_time = ffi.C.time(nil)
    local time_str = ffi.C.ctime(ffi.new("time_t[1]", current_time))
    print("当前时间: " .. ffi.string(time_str))
end

-- 3. 扩展的字符串函数
print("\n3. 扩展的字符串函数:")

-- string.buffer（LuaJIT特有）
if string.buffer then
    print("string.buffer 可用")
    
    -- 创建缓冲区
    local buf = string.buffer(1024)  -- 1KB缓冲区
    print("缓冲区大小: " .. #buf .. " 字节")
    
    -- 写入数据
    buf:put("Hello")
    buf:put(" ")
    buf:put("World!")
    
    -- 获取内容
    local content = buf:get()
    print("缓冲区内容: " .. content)
else
    print("string.buffer 不可用（需要LuaJIT 2.1+）")
end

-- 4. 表操作优化
print("\n4. 表操作优化:")

-- LuaJIT对表操作进行了优化
local large_table = {}
local start_time = os.clock()

-- 插入大量数据
for i = 1, 1000000 do
    large_table[i] = i * 2
end

local insert_time = os.clock() - start_time
print("插入100万条数据耗时: " .. string.format("%.3f", insert_time) .. "秒")

-- 访问数据
start_time = os.clock()
local sum = 0
for i = 1, 1000000 do
    sum = sum + large_table[i]
end
local access_time = os.clock() - start_time
print("访问100万条数据耗时: " .. string.format("%.3f", access_time) .. "秒")
print("总和: " .. sum)

-- 5. 协程优化
print("\n5. 协程优化:")

local function coroutine_test()
    local co = coroutine.create(function()
        for i = 1, 5 do
            print("  协程执行: " .. i)
            coroutine.yield(i)
        end
    end)
    
    for i = 1, 5 do
        local success, value = coroutine.resume(co)
        if success then
            print("  收到值: " .. value)
        end
    end
end

print("协程性能测试...")
local start = os.clock()
for i = 1, 10000 do
    coroutine_test()
end
local elapsed = os.clock() - start
print(string.format("执行10000次协程测试耗时: %.3f秒", elapsed))

-- 6. 垃圾回收优化
print("\n6. 垃圾回收优化:")
print("LuaJIT的垃圾回收器经过了优化，特别适合长时间运行的应用")

-- 显示GC统计
local gc_stats = {
    count = collectgarbage("count"),
    step = collectgarbage("step"),
    isrunning = collectgarbage("isrunning")
}

print("GC统计:")
print("  内存使用: " .. string.format("%.2f", gc_stats.count) .. " KB")
print("  GC是否运行: " .. tostring(gc_stats.isrunning))

-- 手动触发GC
collectgarbage("collect")
print("手动触发GC后内存: " .. string.format("%.2f", collectgarbage("count")) .. " KB")
```
