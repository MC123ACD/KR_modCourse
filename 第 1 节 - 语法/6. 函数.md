## 6.1 函数的基本概念

函数是组织和重用代码的基本单元。它让我们可以将一段具有特定功能的代码封装起来，通过名称调用执行。

#### 为什么要使用函数？

在开始学习函数语法之前，先看看不使用函数时的问题：

```lua
-- 不使用函数的重复代码
print("=== 玩家1 ===")
local player1_name = "小明"
local player1_level = 10
local player1_health = 100
print("姓名：" .. player1_name)
print("等级：" .. player1_level)
print("生命值：" .. player1_health)

print("=== 玩家2 ===")
local player2_name = "小红"
local player2_level = 8
local player2_health = 80
print("姓名：" .. player2_name)
print("等级：" .. player2_level)
print("生命值：" .. player2_health)

print("=== 玩家3 ===")
local player3_name = "小刚"
local player3_level = 12
local player3_health = 120
print("姓名：" .. player3_name)
print("等级：" .. player3_level)
print("生命值：" .. player3_health)
```

上面的代码有很多重复模式。函数可以解决这个问题！

## 6.2 函数的定义与调用

### 6.2.1 函数定义的基本语法
```lua
-- 使用function关键字定义的全局
local function 函数名(参数: any...)
    -- 函数体
    -- 可以包含多条语句
    return 返回值  -- 可选
end

-- 以上语法等价于此
local 函数名 = function(参数: any...)
    -- 函数体
    return 返回值
end
```

#### 示例
```lua
-- 示例1：简单的问候函数
local function greet()
    print("你好！欢迎来到Lua世界！")
end

-- 调用函数
greet()  -- 输出：你好！欢迎来到Lua世界！
greet()  -- 可以多次调用
greet()

-- 示例2：带参数的函数
local function greet_person(name)
    print("你好，" .. name .. "！")
end

-- 调用带参数的函数
greet_person("小明")   -- 输出：你好，小明！
greet_person("小红")   -- 输出：你好，小红！
greet_person("老师")   -- 输出：你好，老师！

-- 示例3：使用函数表达式
local calculate_area = function(width, height)
    local area = width * height
    return area
end

-- 调用函数表达式
local result = calculate_area(5, 3)
print("面积为：" .. result)  -- 输出：面积为：15
```

### 6.2.2 改进的玩家信息显示程序

现在用函数重构之前的重复代码：

```lua
-- 定义显示玩家信息的函数
local function show_player_info(name, level, health)
    print("=== " .. name .. " ===")
    print("姓名：" .. name)
    print("等级：" .. level)
    print("生命值：" .. health)
end

-- 使用函数，使代码变得更简洁
show_player_info("小明", 10, 100)
show_player_info("小红", 8, 80)
show_player_info("小刚", 12, 120)
```

## 6.3 参数传递

### 6.3.1 基本参数传递

#### 单个参数
```lua
local function double_number(x)
    return x * 2
end

print("5的两倍是：" .. double_number(5))  -- 输出：10
```

#### 多个参数
```lua
local function calculate_rectangle(width, height)
    local area = width * height
    local perimeter = 2 * (width + height)
    return area, perimeter
end

-- 接收多个返回值
local area, perimeter = calculate_rectangle(4, 3)
print("长方形：面积=" .. area .. ", 周长=" .. perimeter)  -- 面积=12, 周长=14
```

#### 示例
```lua
-- 实际游戏示例：计算伤害
local function calculate_damage(attack, defense, multiplier)
    local damage = attack - defense
    
    if damage < 0 then
        damage = 0
    end
    
    damage = damage * (multiplier or 1)  -- multiplier可选，默认为1
    return damage
end

-- 测试伤害计算
local damage1 = calculate_damage(50, 30, 1.5)  -- 攻击50，防御30，倍率1.5
local damage2 = calculate_damage(40, 45, 1.0)  -- 攻击40，防御45
local damage3 = calculate_damage(100, 20)      -- multiplier未提供，使用默认值1

print("伤害1：" .. damage1)  -- 输出：30 ((50-30)*1.5)
print("伤害2：" .. damage2)  -- 输出：0 ((40-45)为负，设为0)
print("伤害3：" .. damage3)  -- 输出：80
```

### 6.3.2 参数传递的特性

#### 引用传递
```lua
-- 对于表类型，参数传递的是引用（表的内容可以被修改）
local function modify_table(t)
    t.x = t.x * 2  -- 修改表的内容
    print("函数内 t.x = " .. t.x)
end

local my_table = {x = 10, y = 20}
print("调用前 my_table.x = " .. my_table.x)	-- 10

modify_table(my_table)		-- 函数内 t.x = 20
print("调用后 my_table.x = " .. my_table.x)	-- 20（改变了！）

-- 注意：表本身不会被替换
local function replace_table(t)
    t = {x = 100, y = 200}  -- 这不会影响原始表，只是让 t 指向了 {x = 100, y = 200} 这个表
    print("函数内 t.x = " .. t.x)
end

local original_table = {x = 10, y = 20}
print("调用前 original_table.x = " .. original_table.x)	-- 10

replace_table(original_table)		-- 函数内 t.x = 100
print("调用后 original_table.x = " .. original_table.x)	-- 10（没有改变！）
```

这个 `t` 变量可以理解为箭头（指针）指向表这个“盒子”，给指针 `t` 赋值，只是让指针指向了另一个表，通过 `t.x` 访问则是先通过指针找到指向的表然后修改里面的 `x` 键。

**示意图**：
![[Pasted image 20251208134125.png|600]]

#### 值传递
```lua
-- 数字等值，传递的是 "值"
local function modify_value(x)
    x = x * 2  -- 修改的是副本，不影响原始值
    print("函数内 x = " .. x)
end

local num = 10
print("调用前 num = " .. num)	-- 10

modify_value(num)		-- 函数内 x = 20
print("调用后 num = " .. num)	-- 10（没有改变！）

--[[ 这些类型（值类型）都是直接传递值的副本：
	local a = 10      -- 数字
	local b = true    -- 布尔
	local c = nil     -- nil
--]] 
```

### 6.3.3 变长参数（可变参数）

```lua
-- 使用 ... 接收可变数量的参数
local function sum(...)
    local numbers = {...}  -- 将参数收集到表中
    local total = 0
    
    for i, num in ipairs(numbers) do
        total = total + num
    end
    
    return total
end

-- 测试变长参数函数
print("1+2 = " .. sum(1, 2))                    -- 3
print("1+2+3 = " .. sum(1, 2, 3))              -- 6
print("1+2+3+4+5 = " .. sum(1, 2, 3, 4, 5))    -- 15
print("空参数 = " .. sum())                     -- 0

-- 混合固定参数和可变参数
local function format_string(separator, ...)
    local parts = {...}
    local result = ""
    
    for i, part in ipairs(parts) do
        if i > 1 then
            result = result .. separator
        end
        result = result .. tostring(part)
    end
    
    return result
end

-- 测试格式化函数
print(format_string(", ", "苹果", "香蕉", "橙子"))    -- 苹果, 香蕉, 橙子
print(format_string(" - ", "A", "B", "C", "D"))      -- A - B - C - D
print(format_string(" and ", "猫", "狗"))             -- 猫 and 狗

-- 实际应用：计算平均值
local function average(...)
    local numbers = {...}
    local count = #numbers
    
    if count == 0 then
        return 0
    end
    
    local total = sum(...)  -- 重用之前的sum函数
    return total / count
end

print("平均值1：" .. average(10, 20, 30))        -- 20
print("平均值2：" .. average(1, 2, 3, 4, 5))     -- 3
print("平均值3：" .. average(100))               -- 100
```

## 6.4 返回值

### 6.4.1 单返回值

```lua
-- 返回单个值
local function is_even(number)
    if number % 2 == 0 then
        return true
    else
        return false
    end
end

-- 调用单返回值函数
local result = is_even(10)
print("10是偶数吗？" .. tostring(result))  -- true

-- 更简洁的写法
local function is_odd(number)
    return number % 2 == 1
end

print("7是奇数吗？" .. tostring(is_odd(7)))  -- true

-- 注意：返回值后面的代码不会被执行
local function is_odd(number)
    return number % 2 == 1
    
    print("这里不会被执行")
end
```

#### 示例
```lua
-- 实际游戏示例：计算等级所需经验
function get_exp_for_level(level)
    -- 假设每级所需经验是 level * 100
    return level * 100
end

print("升到10级需要经验：" .. get_exp_for_level(10))  -- 1000
```

### 6.4.2 多返回值

```lua
-- 返回多个值
function min_max(numbers)
    if #numbers == 0 then
        return nil, nil  -- 返回两个nil
    end
    
    local min_val = numbers[1]
    local max_val = numbers[1]
    
    for i = 2, #numbers do
        if numbers[i] < min_val then
            min_val = numbers[i]
        end
        if numbers[i] > max_val then
            max_val = numbers[i]
        end
    end
    
    return min_val, max_val
end

-- 接收多个返回值
local scores = {85, 92, 78, 90, 88}
local min_score, max_score = min_max(scores)
print("最低分：" .. min_score)  -- 78
print("最高分：" .. max_score)  -- 92

-- 如果只需要部分返回值，可以用下划线忽略
local _, highest = min_max(scores)  -- 只关心最高分
print("只关心最高分：" .. highest)

-- 返回值和接收值的数量可以不匹配（多余的会被视为 nil）
local a, b, c = min_max(scores)
print("a = " .. tostring(a))  -- 78
print("b = " .. tostring(b))  -- 92
print("c = " .. tostring(c))  -- nil（只有两个返回值）
```

#### 示例
```lua
-- 游戏示例：获取玩家位置
function get_player_position(player_id)
    -- 模拟从游戏引擎获取位置
    local x = 100 + player_id * 10
    local y = 50 + player_id * 5
    local z = 0  -- 2D游戏中的高度
    
    return x, y, z
end

-- 获取玩家1的位置
local x1, y1, z1 = get_player_position(1)
print("玩家1位置：(" .. x1 .. ", " .. y1 .. ", " .. z1 .. ")")

-- 获取玩家2的位置（只关心x和y坐标）
local x2, y2 = get_player_position(2)
print("玩家2位置：(" .. x2 .. ", " .. y2 .. ")")
```

### 6.4.3 返回表的技巧

```lua
-- 有时返回表比返回多个值更方便
function get_player_stats(player_id)
    -- 模拟获取玩家状态
    return {
        health = 100 - player_id * 10,
        mana = 50 + player_id * 5,
        level = player_id,
        experience = player_id * 100
    }
end

-- 使用返回的表
local stats = get_player_stats(3)
print("玩家3状态：")
print("生命值：" .. stats.health)
print("魔法值：" .. stats.mana)
print("等级：" .. stats.level)
print("经验：" .. stats.experience)

-- 可以直接在表达式中使用
print("生命值/魔法值比例：" .. get_player_stats(4).health / get_player_stats(4).mana)
```

### 6.4.4 返回函数

```lua
-- 函数可以返回另一个函数
function create_multiplier(factor)
    -- 返回一个新的函数
    return function(x)
        return x * factor
    end
end

-- 创建特定的乘法器
local double = create_multiplier(2)
local triple = create_multiplier(3)
local times_ten = create_multiplier(10)

-- 使用返回的函数
print("2的两倍：" .. double(2))      -- 4
print("2的三倍：" .. triple(2))      -- 6
print("2的十倍：" .. times_ten(2))   -- 20

-- 实际应用：创建不同难度的游戏关卡
function create_enemy_generator(difficulty)
    local health_multiplier = 1 + (difficulty - 1) * 0.5  -- 难度越高，生命值越高
    
    return function(base_health)
        return base_health * health_multiplier
    end
end

-- 创建不同难度的敌人生成器
local easy_enemy = create_enemy_generator(1)   -- 简单
local normal_enemy = create_enemy_generator(2) -- 普通
local hard_enemy = create_enemy_generator(3)   -- 困难

print("简单敌人生命值：" .. easy_enemy(100))    -- 100
print("普通敌人生命值：" .. normal_enemy(100))  -- 150
print("困难敌人生命值：" .. hard_enemy(100))    -- 200
```

### 6.5.5 技巧
有些函数内的判断可以使用**卫语句**来提前返回，降低镶套与缩进层数，同时也可以提高性能
```lua
-- 解锁关卡检查
local player_level = 10

local info_level = "森林"	-- 模拟玩家点击关卡
local level_mode = "夜晚模式"
local unlocked_level = {forest = true}

local function check_level_unlock()
	if info_level == "森林" then
	    if player_level >= 1 then	-- 玩家等级大于等于 1
	        if level_mode == "夜晚模式" then	-- 判断关卡模式
				if unlocked_level.forest then
					print("玩家进入夜晚的森林")
				else
					return "错误，玩家未解锁森林"
				end
	        elseif level_mode == "白天模式" then
	            if unlocked_level.forest then
					print("玩家进入白天的森林")
				else
					return "错误，玩家未解锁森林"
				end
	        else
	            return "错误，未知模式"
	        end
	    else
	        return "错误，玩家等级不足，不能进入森林"
	    end
	end
end

-- 改进版本
local function check_level_unlock()
	if info_level == "森林" then
	    if player_level < 1 then	-- 提前判断等级是否足够，不足直接返回
	    	return "玩家等级不足，不能进入森林"
	    end
	    
	    if not unlocked_level.forest then	-- 提前判断是否解锁关卡，没有解锁直接返回
			return "错误，玩家未解锁森林"
		end
		
		if level_mode == "夜晚模式" then	-- 判断关卡模式
			print("玩家进入夜晚的森林")
		elseif level_mode == "白天模式" then
			print("玩家进入白天的森林")
		else
			return "错误，未知模式"
		end
	end
end

local err = check_level_unlock()
if err then
	print(err)
end
```

## 6.5 匿名函数

匿名函数（也叫 lambda 函数）是没有名字的函数，通常作为值使用。

```lua
-- 基本匿名函数
local add = function(a, b)
    return a + b
end

print("5 + 3 = " .. add(5, 3))  -- 8

-- 立即调用的匿名函数（IIFE）
local result = (function(x)
    return x * x
end)(5)

print("5 的平方：" .. result)  -- 25

-- 作为参数传递给其他函数
local numbers = {1, 2, 3, 4, 5}

-- 使用匿名函数作为回调
function process_numbers(numbers, processor)
    for i, num in ipairs(numbers) do
        numbers[i] = processor(num)
    end
    
    return numbers
end

-- 传入匿名函数处理数组
local doubled = process_numbers({1, 2, 3}, function(x) return x * 2 end)
print("加倍后的数组：")
for i, v in ipairs(doubled) do
    print("  " .. v)  -- 2, 4, 6
end
```

## 6.6 函数的作用域和闭包

### 6.6.1 作用域

```lua
local function outer()
    print("进入 outer 函数的局部作用域")
    
    local outer_var = "局部变量"
    
    function inner()	-- 全局函数
        print("inner 函数访问: " .. outer_var)
    end
    
    -- 调用全局函数
    inner()
    print("退出 outer 函数的局部作用域")
end

outer()

-- 注意：inner 函数如果在外部调用，需要先调用 outer 函数定义 inner
```

### 6.6.2 闭包

闭包是 Lua 中一个强大而有趣的概念。简单说，闭包就是一个能记住并访问其创建时环境的函数。

```lua
-- 基本闭包示例
-- 计数器函数
local function make_counter()
    local count = 0  -- 局部变量，外部无法直接访问
    
    -- 返回一个函数，这个函数能访问 count
    return function()
        count = count + 1
        return count
    end
end

-- 创建两个独立的计数器
local counter1 = make_counter()		-- 存储了一个独立的 count，每次调用 counter1 将存储的 count + 1
local counter2 = make_counter()		-- 这里创建了一个新的 count

print("计数器 1:")
print(counter1())  -- 1
print(counter1())  -- 2
print(counter1())  -- 3

print("计数器 2:")
print(counter2())  -- 1（独立计数）
print(counter2())  -- 2
print(counter2())  -- 3

print(counter1())  -- 4
print(counter2())  -- 4
```

#### 示例
```lua
-- 闭包的实际应用：创建配置器
local function create_configurator(default_config)
    local config = default_config
    
    return {
        get = function(key)
            return config[key]
        end,
        
        set = function(key, value)
            config[key] = value
            return true
        end,
        
        show = function()
            print("当前配置:")
            for k, v in pairs(config) do
                print("  " .. k .. ": " .. tostring(v))
            end
        end
    }
end

-- 使用配置器
local game_config = create_configurator({
    sound = true,
    music = true,
    difficulty = "normal",
    volume = 70
})

game_config.show()
game_config.set("difficulty", "hard")
game_config.set("volume", 80)
print("新的难度：" .. game_config.get("difficulty"))
--[[ 输出
当前配置:
  difficulty: normal
  music: true
  sound: true
  volume: 70
新的难度：hard
--]]
```

## 6.7 递归函数

递归是函数调用自身的技术，常用于解决分治问题。

```lua
-- 经典的阶乘函数
local function factorial(n)
    if n <= 1 then
        return 1
	end
	
    return n * factorial(n - 1)
end

print("5 的阶乘: " .. factorial(5))  -- 120
print("10 的阶乘: " .. factorial(10)) -- 3628800

-- 斐波那契数列
local function fibonacci(n)
    if n <= 0 then
        return 0
    elseif n == 1 then
        return 1
    end
    
    return fibonacci(n - 1) + fibonacci(n - 2)
end

print("斐波那契数列前 10 项:")
for i = 0, 9 do
    print(fibonacci(i) .. " ")  -- 0 1 1 2 3 5 8 13 21 34
end

-- 注意：递归要有终止条件，否则会导致栈溢出
local function infinite_recursion()
    infinite_recursion()  -- 无限递归，会导致错误
end

-- infinite_recursion()  -- 不要真的调用！
```


## 6.8 文档注释

文档注释类似于类型注解，标注函数作用、每个参数的作用、返回值，同时集成在 vscode 中，鼠标悬浮在函数上即可直接显示参数作用。

推荐给你的所有函数增加文档注释，便于阅读代码。

```lua
---函数作用
---@param 参数 参数类型 参数作用
---@return 返回类型 返回描述
```

#### 示例
```lua
-- 注意：只能写到定义函数的上面

---对某人说 hello
---@param name string 名称
---@return string 完整文本
local function say_hello(name)
	local text = "hello " .. name

	print(text)
	return text
end

say_hello("bob")
-- 输出 hello bob
```

鼠标悬浮到 `say_hello` 函数上面显示：
![[Pasted image 20251211205307.png|345]]

## 6.9 练习

### 练习 1：简单的计算器函数库
（答案见 [[第 1 节 - 语法/参考答案#练习 6 1：简单的计算器函数库]]）
```lua
-- 写几个计算器用的函数，需要有基础四则运算，平均值计算
-- 使用示例：
-- 使用函数库
print("5 + 3 = " .. add(5, 3))
print("10 - 4 = " .. subtract(10, 4))
print("6 * 7 = " .. multiply(6, 7))

local result, error_msg = divide(10, 0)
if error_msg then
    print("错误: " .. error_msg)
else
    print("10 / 2 = " .. result)
end

print("平均值(1,2,3,4,5) = " .. average(1, 2, 3, 4, 5))
--[[ 输出
5 + 3 = 8
10 - 4 = 6
6 * 7 = 42
错误: 除数不能为 0
平均值(1,2,3,4,5) = 3
--]]
```

### 练习 2：提取函数，优化代码
（答案见 [[第 1 节 - 语法/参考答案#练习 6 2：提取函数，优化代码]]）
```lua
-- 将以下所有代码提取为函数，再改进代码，要求：使用卫语句

-- 购物车商品处理程序

-- 模拟购买的物品
local cart = {
    { name = "苹果", price = 5, quantity = 3 },
    { name = "香蕉", price = 3, quantity = 2 },
    { name = "橙子", price = 6, quantity = 4 },
    { name = "葡萄", price = 8, quantity = 1 }
}

-- 打印商品详细信息
print("=== 商品详情 ===")

for _, item in ipairs(cart) do
    local item_total = item.price * item.quantity

    print("商品: " .. item.name)
    print("单价: " .. item.price .. "元")
    print("数量: " .. item.quantity)
    print("小计: " .. item_total .. "元")
    print("------------")
end

-- 计算购物车信息
local total_price = 0
local total_quantity = 0

for _, item in ipairs(cart) do
    total_price = total_price + (item.price * item.quantity)
    total_quantity = total_quantity + item.quantity
end

print("购物车总价: " .. total_price .. "元")

-- 判断是否有优惠（满50减10，满100减25，买10个赠1个）
if total_price >= 50 and total_price < 100 then
    if total_quantity >= 10 then
        print("购物车物品总数：" .. total_quantity .. "个，赠品1个")
        local discount_price = total_price - 10
        print("符合优惠条件，满50减10")
        print("优惠后价格: " .. discount_price .. "元")
    else
        local discount_price = total_price - 10
        print("符合优惠条件，满50减10")
        print("优惠后价格: " .. discount_price .. "元")
    end
elseif total_price >= 100 then
    if total_quantity >= 10 then
        print("购物车物品总数：" .. total_quantity .. "个，赠品1个")
        local discount_price = total_price - 25
        print("符合优惠条件，满100减25")
        print("优惠后价格: " .. discount_price .. "元")
    else
        local discount_price = total_price - 25
        print("符合优惠条件，满100减25")
        print("优惠后价格: " .. discount_price .. "元")
    end
else
    print("未满50元，无优惠")
end

print("\n=== 推荐商品 ===")
-- 根据购物车推荐相关商品
local recommendations = {
    { name = "梨子", price = 6 },
    { name = "芒果", price = 10 }
}

for _, cart_item in ipairs(cart) do
    if cart_item.name == "苹果" then
        print("您购买了苹果，可能也喜欢:")
        for _, rec in ipairs(recommendations) do
            local rec_total = rec.price * 1 -- 假设推荐买1个
            print("  " .. rec.name .. ": " .. rec.price .. "元/个")
        end
    end

    if cart_item.name == "香蕉" then
        print("您购买了香蕉，可能也喜欢:")
        for _, rec in ipairs(recommendations) do
            local rec_total = rec.price * 1
            print("  " .. rec.name .. ": " .. rec.price .. "元/个")
        end
    end

    if cart_item.name == "橙子" then
        print("您购买了橙子，可能也喜欢:")
        for _, rec in ipairs(recommendations) do
            local rec_total = rec.price * 1
            print("  " .. rec.name .. ": " .. rec.price .. "元/个")
        end
    end
end
```

## 6.10 本章总结

### 关键知识点回顾

1. **函数定义**：
	- `function name(params) ... end` 语法
	- 函数表达式：`local name = function(params) ... end`
	- 匿名函数：直接作为值使用

2. **参数传递**：
	- 值类型是值传递，表是引用传递
	- 变长参数：使用 `...`
	- 参数可以有默认值（通过 `or` 实现）

3. **返回值**：
	- 可以返回单个值或多个值
	- 可以返回函数（高阶函数）
	- 可以返回表来组织复杂数据

4. **高级概念**：
	- 闭包：能记住创建环境的函数
	- 递归：函数调用自身

5. **文档注释**：
	- 使用 --- 进行文档注释
	- 使用 @param 和 @return 描述参数与返回值作用

### 函数设计的最佳实践

```lua
-- 1. 函数应该只做一件事（单一职责）
local function calculate_area(width, height)  -- 好：只计算面积
    return width * height
end

local function calculate_area_and_perimeter(width, height)  -- 不太好：做两件事
    return width * height, 2 * (width + height)
end

-- 2. 使用有意义的函数名
local function get_player_health(player_id)  -- 好：名字说明功能
    -- ...
end

local function f1(x)  -- 不好：名字没有意义
    -- ...
end

-- 3. 参数数量适中（不超过 3-4 个）
local function create_player(name, class, level)  -- 好：参数明确
    -- ...
end

local function setup_game(player1_name, player1_class, player1_level,
                    player2_name, player2_class, player2_level,
                    map_name, difficulty)  -- 不好：参数太多
    -- ...
end

-- 4. 使用返回值表示成功/失败
local function load_file(file)
    if not file then
        return nil, "错误，无法加载文件"  -- 失败时返回 nil 和错误信息
    end

    return file
end

-- 5. 局部函数应该声明为 local
local function helper_function()  -- 好：不会污染全局命名空间
    -- ...
end

-- 6. 使用卫语句提前返回
local function get_player_info(player)	-- 不好：镶套过多
	if not player.dead then
		if player.level_up then
			print("玩家升级了")
		end
		if player.walk then
			print("玩家移动中...")
		end
	else
		print("玩家已死亡")
		return "玩家已死亡"
	end
end

local function get_player_info(player)	-- 好：较少镶套
	if player.dead then
		print("玩家已死亡")
		return "玩家已死亡"
	end
	
	if player.level_up then
		print("玩家升级了")
	end
	if player.walk then
		print("玩家移动中...")
	end
end
```

### 常见错误

```lua
-- 错误 1：忘记写 return 语句
function add(a, b)
    local sum = a + b
    -- 忘记写 return sum
end

local result = add(2, 3)
print(result)  -- 输出：nil

-- 错误 2：递归没有终止条件
local function infinite_recursion(n)
    print(n)
    infinite_recursion(n + 1)  -- 无限递归！
end
-- infinite_recursion(1)  -- 会导致栈溢出

-- 错误 3：修改不应该修改的参数
local function process_user_data(user)
    user = {}  -- 错误：这不会影响原始参数
    -- 应该修改 user 的字段，而不是替换整个表
end

-- 错误 4：全局变量污染
local function calculate()
    result = 10  -- 错误：创建了全局变量
    local local_result = 10  -- 正确：使用局部变量
end
```

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 定义和调用函数
- [ ] 理解参数传递的机制
- [ ] 使用变长参数处理不定数量的参数
- [ ] 从函数返回单个或多个值
- [ ] 创建和使用匿名函数
- [ ] 理解闭包的概念和用途
- [ ] 编写递归函数
- [ ] 设计模块化的函数库

### 思考题

1. 什么时候应该使用多个返回值，什么时候应该返回表？
2. 闭包和普通函数有什么区别？什么时候应该使用闭包？
3. 递归有什么优缺点？如何避免递归导致的栈溢出？
4. 为什么应该优先使用局部函数而不是全局函数？
5. 如何设计一个良好的函数 API（参数、返回值、错误处理）？

### 拓展练习

1. 创建一个简单的银行账户系统，包含存款、取款、查询功能
2. 实现一个简单的缓存系统，使用闭包来保存缓存数据
3. 编写一个函数，可以生成不同难度的数学题目
4. 创建一个事件系统，允许注册回调函数并在特定事件发生时调用
5. 实现一个简单的状态机，使用函数表示不同状态的行为

---

**下一章预告**：在第 7 章中，我们将深入学习 Lua 的核心数据结构——表（Table）。表是 Lua 中最重要、最灵活的数据结构，它可以用来实现数组、字典、对象、模块等几乎所有复杂数据结构。我们将学习表的创建、操作、遍历以及各种高级用法。

**学习建议**：
1. 多练习函数的设计和实现
2. 尝试用函数重构重复的代码
3. 理解闭包的概念，这是 Lua 的精华之一
4. 注意函数的命名和参数设计，写出易读易用的代码
5. 尝试编写一些实用的小工具函数库

**常见问题解答**：
Q: 为什么值类型，参数传递时传递的是副本？
A: 值类型传递副本是因为它们**简单且不可变**，复制开销小且语义安全。表传递引用是因为它**可能很大且需要共享修改（多个变量操作一个表）**，传递指针更高效。