## 9.1 什么是模块？

当一个 Lua 文件被另一个 Lua 文件加载，并且返回一个表或其他值时这个 Lua 文件被称为模块（**Module**）

**模块主要用于**：
1. 分类，将相关函数与变量组织在一个模块，避免将所有代码写到同一个文件内
2. 便于模块化代码复用
3. 独立命名空间，避免命名冲突

在编写大型程序时，将所有代码放在一个文件中会变得难以管理。模块系统可以帮助我们管理：

```lua
-- 不使用模块的问题示例
-- 假设我们在开发一个游戏，所有代码都在一个文件里：

-- main.lua（糟糕的代码组织）
-- 游戏配置
local game_config = { width = 800, height = 600 }

-- 玩家相关函数
local player_name = "英雄"
local player_health = 100

local function take_damage(amount)
    player_health = player_health - amount
    if player_health < 0 then
        player_health = 0
    end
end

local function heal(amount)
    player_health = player_health + amount
end

-- 怪物相关函数
local monsters = {}

local function create_monster(name, health)
    table.insert(monsters, {name = name, health = health})
end

local function attack_monster(index, damage)
    if monsters[index] then
        monsters[index].health = monsters[index].health - damage
    end
end

-- UI相关函数
local function show_hud()
    print("生命值: " .. player_health)
end

-- 游戏循环
local function game_loop()
    -- 很多代码...
end

-- 问题：
-- 1. 所有代码混在一起，难以维护
-- 2. 命名冲突风险高
-- 3. 无法重用代码
-- 4. 多人协作困难
```

## 9.2 创建你的第一个模块

### 9.2.1 简单的模块示例

```lua
-- 创建一个 Lua 文件：math_utils.lua
-- 数学工具模块

local math_utils = {}  -- 模块表，最后返回

-- 1. 定义模块函数
function math_utils.add(a, b)
    return a + b
end

function math_utils.subtract(a, b)
    return a - b
end

function math_utils.multiply(a, b)
    return a * b
end

function math_utils.divide(a, b)
    if b == 0 then
        return nil, "除数不能为0"
    end
    
    return a / b
end

-- 2. 模块常量
math_utils.PI = 3.1415926535898
math_utils.E = 2.7182818284590

-- 3. 内部辅助函数（不对外暴露）
local function check_number(value)
    return type(value) == "number"
end

-- 4. 复杂的模块函数
function math_utils.average(...)
    local numbers = {...}
    local sum = 0
    local count = 0
    
    for i, num in ipairs(numbers) do
        if check_number(num) then
            sum = sum + num
            count = count + 1
        end
    end
    
    if count == 0 then
        return nil, "没有有效数字"
    end
    
    return sum / count
end

-- 5. 返回模块，一个模块可以也理解为一个函数，注意：一定要最后返回，与函数相同返回后后面的代码不会执行
return math_utils
```

### 9.2.2 使用模块

```lua
-- 创建一个 Lua 文件在里面中使用刚刚创建的模块

-- 使用 require 加载模块
local math_utils = require("math_utils")

-- 使用模块函数
print("5 + 3 = " .. math_utils.add(5, 3))
print("10 - 4 = " .. math_utils.subtract(10, 4))
print("6 × 7 = " .. math_utils.multiply(6, 7))

local result, err = math_utils.divide(10, 2)

if err then
    print("错误: " .. err)
else
    print("10 ÷ 2 = " .. result)
end

-- 使用模块常量
print("π ≈ " .. math_utils.PI)
print("自然常数 e ≈ " .. math_utils.E)

-- 使用复杂函数
local avg, avg_err = math_utils.average(10, 20, 30, "无效", 40)

if avg_err then
    print("平均值错误: " .. avg_err)
else
    print("平均值: " .. avg)  -- (10+20+30+40)/4 = 25
end
--[[ 输出
5 + 3 = 8
10 - 4 = 6
6 × 7 = 42
10 ÷ 2 = 5
π ≈ 3.1415926535898
自然常数 e ≈ 2.718281828459
平均值: 25
--]]

-- 尝试访问内部函数（会失败）
-- local result = math_utils.check_number(5)  -- 错误：nil值
```

### 9.2.3 模块加载机制

```lua
require(模块名: str) -> any
```
`require` 会执行以下步骤：
1. 在 `package.loaded` 中检查模块是否已加载
2. 如果已加载，直接返回缓存
3. 否则在 `package.path` 指定的路径按从左到右的顺序查找指定名字的模块
4. 加载并执行该文件，并返回返回值
5. 以  `package.loaded[模块名] = 返回值` 缓存

```lua
-- package.path 具有默认值，通常在 main 模块中增加额外路径
-- 查看package.path
print("Lua模块路径: " .. package.path)
-- 输出 Lua模块路径: ;.\?.lua;C:\Program Files (x86)\Lua\5.1\lua\?.lua;C:\Program Files (x86)\Lua\5.1\lua\?\init.lua;C:\Program Files (x86)\Lua\5.1\?.lua;C:\Program Files (x86)\Lua\5.1\?\init.lua;C:\Program Files (x86)\Lua\5.1\lua\?.luac
-- “?” 加载模块时会格式化为加载的模块名称，用 “;” 分隔每个路径，“.” 会格式化为加载模块的 Lua 文件的目录

-- require的缓存机制演示
local module1 = require("math_utils")
local module2 = require("math_utils")

print("两个require返回的是同一个表吗？ " .. tostring(module1 == module2))  -- true

-- 手动清除缓存
package.loaded.math_utils = nil
local module3 = require("math_utils")	-- 重新加载，此时会创建一个新表

print("清除缓存后重新加载，是同一个表吗？ " .. tostring(module1 == module3))  -- false
```

## 9.3 模块的高级特性

### 9.3.1 模块的多种返回方式

```lua
-- 模块可以有多种返回方式

-- 方式1：直接返回表（最常见）
-- module1.lua
local M = {}
M.version = "1.0"

return M

-- 方式2：返回函数
-- module2.lua
return function(config)
    local module = {}
    module.config = config
    module.run = function() print("运行中...") end
    return module
end

-- 使用：
-- local create_module = require("module2")
-- local my_module = create_module({setting = "value"})

-- 方式3：在模块中设置全局变量（不推荐，但某些情况需要）
-- module3.lua
GLOBAL_MODULE = {}
GLOBAL_MODULE.name = "全局模块"
return GLOBAL_MODULE

-- 方式4：修改传入的表
-- module4.lua
return function(t)
    t.add = function(a, b) return a + b end
    t.version = "1.0"
    
    return t  -- 通常返回修改后的表
end

-- 使用：
-- local mod = require("module4")({})
```

### 9.3.2 模块环境

#### 全局表（\_G）
Lua 中所有全局变量，与 Lua 的内置函数都存储在一个名叫 \_G 的全局表（**Global Table**）中
所有模块的默认环境 （**Environment**）都是指向 \_G 表。

#### 设定环境
可以通过 `setfenv` 修改指针将环境指向另一个表。

```lua
-- 使用setfenv控制模块环境（Lua 5.1特性）

-- 创建一个干净的模块环境
local module_env = {}

-- 设置环境的基本函数
module_env.print = print

-- 创建待编译模块
local my_module_code = [[
-- 在这个环境中，只有环境设定的函数可用
local M = {}

function M.say_hello()
    print("Hello World!")	-- 这里如果没有给环境设定 print 将会报错
end

return M
]]

-- 加载并执行代码
-- 使用 loadstring 将以上字符串编译为可调用的函数
local chunk = loadstring(my_module_code)
-- 使用 setfenv 设定环境，将这个模块内的环境从 _G 修改为 module_env
setfenv(chunk, module_env)

-- 执行被编译后的模块
local module = chunk()

module.say_hello()
```

### 9.3.3 模块依赖

```lua
-- 模块可以依赖其他模块

-- 创建一个日志模块
-- logger.lua
local logger = {}

function logger.info(msg)
    print("[INFO] " .. msg)
end

function logger.warn(msg)
    print("[WARN] " .. msg)
end

function logger.error(msg)
    print("[ERROR] " .. msg)
end

return logger

-- 创建一个数据库模块，依赖日志模块
-- database.lua
local logger = require("logger")

local database = {}

function database.connect(connection_string)
    logger.info("连接到数据库: " .. connection_string)
    -- 模拟连接逻辑
    return {connected = true}
end

function database.query(conn, sql)
    logger.info("执行查询: " .. sql)
    -- 模拟查询
    return {{id = 1, name = "测试数据"}}
end

function database.disconnect(conn)
    logger.info("断开数据库连接")
    conn.connected = false
end

return database

-- 主程序使用有依赖的模块
local db = require("database")

local conn = db.connect("server=localhost;database=test")
local results = db.query(conn, "SELECT * FROM users")
db.disconnect(conn)

-- 环形依赖问题
-- module_a.lua 需要 module_b
-- module_b.lua 需要 module_a
-- 这会导致问题！应该避免环形依赖
```

## 9.4 Lua 标准库模块

Lua 自带了一些非常有用的标准库模块。

### 9.4.1 math 数学库

```lua
-- 基本数学函数
print("绝对值: math.abs(-10) = " .. math.abs(-10))
print("平方根: math.sqrt(16) = " .. math.sqrt(16))
print("幂运算: math.pow(2, 3) = " .. math.pow(2, 3))  -- 也可以用 2^3
print("指数: math.exp(1) = " .. math.exp(1))  -- e^1
print("自然对数: math.log(math.exp(1)) = " .. math.log(math.exp(1)))

-- 三角函数（参数为弧度）
local angle = math.pi / 4  -- 45度
print("\n三角函数（45度）:")
print("  sin: " .. math.sin(angle))
print("  cos: " .. math.cos(angle))
print("  tan: " .. math.tan(angle))

-- 反三角函数
print("\n反三角函数:")
print("  asin(0.5): " .. math.asin(0.5))
print("  acos(0.5): " .. math.acos(0.5))
print("  atan(1): " .. math.atan(1))

-- 取整函数
local num = 3.7
print("\n取整函数:")
print("  原始值: " .. num)
print("  math.floor: " .. math.floor(num))  -- 向下取整
print("  math.ceil: " .. math.ceil(num))    -- 向上取整
print("  math.modf: " .. select(1, math.modf(num)))  -- 返回整数和小数部分

-- 随机数
print("\n随机数:")
math.randomseed(os.time())  -- 设置随机种子
print("  随机整数(1-100): " .. math.random(1, 100))
print("  随机小数[0-1): " .. math.random())

-- 最大值和最小值
print("\n极值:")
print("  最大值: " .. math.max(10, 20, 5, 30, 15))
print("  最小值: " .. math.min(10, 20, 5, 30, 15))

-- 常量
print("\n数学常量:")
print("  π: " .. math.pi)
print("  无穷大: " .. math.huge)

-- 弧度与角度转换
print("\n角度弧度转换:")
local degrees = 180
local radians = math.rad(degrees)
print("  " .. degrees .. "度 = " .. radians .. "弧度")
print("  " .. radians .. "弧度 = " .. math.deg(radians) .. "度")
```

### 9.4.2 string 字符串库

我们之前学过的字符串操作函数其实都是使用的这个库，这里仅补充。

```lua
-- string.byte 和 string.char
local str = "ABC"
print("string.byte:")
for i = 1, #str do
    print("  位置 " .. i .. ": " .. string.byte(str, i))
end

print("\nstring.char:")
print("  65,66,67 -> " .. string.char(65, 66, 67))

-- string.reverse 反转字符串
print("\nstring.reverse:")
print("  'hello' -> '" .. string.reverse("hello") .. "'")

-- string.lower 和 string.upper
print("\n大小写转换:")
print("  'Hello World' -> 小写: '" .. string.lower("Hello World") .. "'")
print("  'Hello World' -> 大写: '" .. string.upper("Hello World") .. "'")

-- string.dump 函数序列化
print("\nstring.dump（函数序列化）:")
local func = function(x) return x * 2 end
local dumped = string.dump(func)
print("  函数序列化后长度: " .. #dumped)

-- 重新加载函数
local loaded_func = loadstring(dumped)
print("  重新加载后执行: loaded_func(5) = " .. loaded_func(5))
```

### 9.4.3 table 表库

```lua
-- 我们已经学过table.insert, table.remove, table.concat, table.sort
-- 这里补充其他函数

-- table.maxn (Lua 5.1特有，返回最大数字索引)
local t = {1, 2, 3}
t[10] = 10
print("table.maxn: " .. table.maxn(t))  -- 10

-- 自带的库功能较少一些函数需要自行实现
-- table.copy 浅复制
function table.shallow_copy(original)
    local copy = {}
    
    for k, v in pairs(original) do
        copy[k] = v
    end
    
    return copy
end

-- table.deep_copy 深复制
function table.deep_copy(original, seen)
    seen = seen or {}
    
    if type(original) ~= "table" then
        return original
    end
    
    if seen[original] then
        return seen[original]
    end
    
    local copy = {}
    seen[original] = copy
    
    for k, v in pairs(original) do
        copy[table.deep_copy(k, seen)] = table.deep_copy(v, seen)
    end
    
    return copy
end

-- table.merge 合并表
function table.merge(t1, t2)
    local result = {}
    
    for k, v in pairs(t1) do
        result[k] = v
    end
    
    for k, v in pairs(t2) do
        result[k] = v
    end
    
    return result
end

-- table.keys 获取所有键
function table.keys(t)
    local keys = {}
    
    for k in pairs(t) do
        table.insert(keys, k)
    end
    
    return keys
end

-- table.values 获取所有值
function table.values(t)
    local values = {}
    
    for _, v in pairs(t) do
        table.insert(values, v)
    end
    
    return values
end
```

### 9.4.4 os 操作系统库

```lua
-- os.time 获取当前时间
local current_time = os.time()
print("当前时间戳: " .. current_time)

-- os.date 格式化时间
print("\nos.date格式化:")
print("  默认格式: " .. os.date())
print("  自定义格式: " .. os.date("%Y-%m-%d %H:%M:%S"))
print("  只获取年份: " .. os.date("%Y"))
print("  星期几: " .. os.date("%A"))
print("  月份: " .. os.date("%B"))

-- 时间戳转换
print("\n时间戳转换:")
local timestamp = os.time({year=2024, month=12, day=27, hour=14, min=30, sec=0})
print("  2024-12-27 14:30:00 的时间戳: " .. timestamp)
print("  转换回来: " .. os.date("%Y-%m-%d %H:%M:%S", timestamp))

-- os.difftime 时间差
local start_time = os.time()
-- 模拟耗时操作
for i = 1, 1000000 do end
local end_time = os.time()
print("\n时间差: " .. os.difftime(end_time, start_time) .. "秒")

-- os.execute 执行系统命令
print("\nos.execute执行命令:")
-- 注意：在某些环境中，这个可能被禁用
local result = os.execute("echo Hello from OS")
print("  返回值: " .. tostring(result))

-- os.getenv 获取环境变量
print("\nos.getenv环境变量:")
local path = os.getenv("PATH")
print("  PATH长度: " .. (path and #path or "无"))
print("  HOME: " .. (os.getenv("HOME") or "无"))

-- os.remove 删除文件
print("\nos.remove删除文件:")
-- 先创建测试文件
local test_file = "test_temp.txt"
local file = io.open(test_file, "w")
if file then
    file:write("测试内容")
    file:close()
    print("  创建测试文件: " .. test_file)
    
    local success, err = os.remove(test_file)
    if success then
        print("  删除成功")
    else
        print("  删除失败: " .. tostring(err))
    end
end

-- os.rename 重命名文件
print("\nos.rename重命名文件:")
-- 类似操作，这里省略

-- os.tmpname 生成临时文件名
local temp_name = os.tmpname()
print("临时文件名: " .. temp_name)
```

### 9.4.5 io 输入输出库

```lua
-- 文件操作
print("文件操作示例:")

-- 写入文件
local filename = "test_output.txt"
local file = io.open(filename, "w")

if file then
    file:write("第一行\n")
    file:write(string.format("第二行: 数字 %d\n", 42))
    file:write("第三行\n")
    file:close()
    print("  写入文件: " .. filename)
else
    print("  无法打开文件: " .. filename)
end

-- 读取文件
print("\n读取文件:")
file = io.open(filename, "r")

if file then
    print("  整个文件内容:")
    local content = file:read("*all")
    print(content)
    file:close()
else
    print("  无法打开文件")
end

-- 逐行读取
print("\n逐行读取:")
file = io.open(filename, "r")

if file then
    local line_number = 1
    
    for line in file:lines() do
        print("  行" .. line_number .. ": " .. line)
        line_number = line_number + 1
    end
    file:close()
end

-- 标准输入输出
print("\n标准输入输出:")
-- io.write 不会自动添加换行
io.write("请输入你的名字: ")
-- 在实际环境中，这里可以读取用户输入
-- local name = io.read()
local name = "测试用户"  -- 模拟输入
print("你好, " .. name .. "!")

-- 文件位置操作
print("\n文件位置操作:")
file = io.open(filename, "r")
if file then
    -- 读取前10个字符
    local first_10 = file:read(10)
    print("  前10字符: " .. first_10)
    
    -- 获取当前位置
    local pos = file:seek()
    print("  当前位置: " .. pos)
    
    -- 跳转到文件开始
    file:seek("set", 0)
    
    -- 再次读取
    local again = file:read(10)
    print("  跳转后读取: " .. again)
    
    file:close()
end

-- 清理测试文件
os.remove(filename)
print("\n清理测试文件")
```

### 9.4.6 debug 调试库

```lua
-- debug库主要用于调试和元编程
-- 注意：在生产代码中应谨慎使用

-- debug.getinfo 获取函数信息
local function test_function(x, y)
    local sum = x + y
    return sum
end

local info = debug.getinfo(test_function)
print("函数信息:")
print("  名称: " .. (info.name or "匿名"))
print("  定义位置: " .. info.source)
print("  当前行: " .. info.currentline)
print("  参数数量: " .. info.nparams)
print("  是否可变参数: " .. tostring(info.isvararg))

-- debug.getlocal 获取局部变量
local function test_locals()
    local a = 10
    local b = "hello"
    local c = {1, 2, 3}
    
    -- 获取局部变量信息
    print("\n局部变量:")
    for i = 1, math.huge do
        local name, value = debug.getlocal(2, i)  -- 2表示上一层调用栈
        if not name then break end
        print("  " .. name .. " = " .. tostring(value))
    end
end

test_locals()

-- debug.traceback 获取调用栈
local function function_a()
    function_b()
end

local function function_b()
    function_c()
end

local function function_c()
    print("\n调用栈追踪:")
    print(debug.traceback("错误发生位置", 2))
end

function_a()

-- debug.sethook 设置钩子（用于调试）
print("\n调试钩子示例:")
local hook_calls = 0

-- 设置一个简单的钩子，统计函数调用次数
debug.sethook(function(event, line)
    if event == "call" then
        hook_calls = hook_calls + 1
    end
end, "c")  -- 'c' 表示在函数调用时触发

-- 执行一些函数调用
local function recursive_func(n)
    if n > 0 then
        recursive_func(n - 1)
    end
end

recursive_func(5)
print("  函数调用次数: " .. hook_calls)

-- 清除钩子
debug.sethook()
print("  钩子已清除")

-- debug.upvalue 访问闭包的上值
print("\n闭包上值访问:")
local function create_counter()
    local count = 0
    
    return function()
        count = count + 1
        return count
    end
end

local counter = create_counter()
counter()  -- count = 1
counter()  -- count = 2

-- 获取上值
local name, value = debug.getupvalue(counter, 1)
print("  上值 '" .. name .. "' = " .. value)

-- 修改上值
debug.setupvalue(counter, 1, 100)
print("  修改后: " .. counter())  -- 101
```

## 9.5 使用 LuaRocks 安装库
LuaRocks 是 Lua 的包管理器，类似于Python的pip

> LuaRocks 官网：
> [LuaRocks - The Lua package manager](https://luarocks.org/)

#### 9.5.1 在终端安装库
```lua
luarocks install 库名
```

![[Pasted image 20251210202636.png|675]]
以上命令会将 Lua 库安装到 `C:/Users/用户名/AppData/Local/VirtualStore/Program Files (x86)/Lua/5.1/lua`
由于服务器位于国外，下载较慢耐心等待即可

#### 9.5.2 使用
```lua
-- 以 dkjson 库为例
-- 需要确保安装此库： luarocks install dkjson
local dkjson = require("dkjson")

-- 将 lua 表编译为 json
print(dkjson.encode({foo = "bar", baz = 123}))
-- 输出 {"baz":123,"foo":"bar"}
```

## 9.6 模块设计模式

### 9.6.1 单例模式

单例模式：确保一个类只有一个实例

```lua
-- 配置管理器（单例）
local config_manager = {}
config_manager.__index = config_manager

function config_manager.get_instance()
    if not config_manager.instance then
        local instance = setmetatable({}, config_manager)
        instance.settings = {}
        config_manager.instance = instance
    end
    return config_manager.instance
end

function config_manager:set(key, value)
    self.settings[key] = value
end

function config_manager:get(key)
    return self.settings[key]
end

-- 测试单例
local config1 = config_manager.get_instance()
config1:set("volume", 80)

local config2 = config_manager.get_instance()
print("config1 音量: " .. config1:get("volume"))
print("config2 音量: " .. config2:get("volume"))
print("是同一个实例吗？ " .. tostring(config1 == config2))
--[[ 输出
config1 音量: 80
config2 音量: 80
是同一个实例吗？ true
--]]

-- 尝试直接创建新实例（会失败）
-- local config3 = config_manager:new()  -- 错误：没有new方法
```

### 9.6.2 工厂模式

工厂模式：通过工厂函数创建对象

```lua
-- 形状工厂
local shape_factory = {}

function shape_factory.create_circle(radius)
    local circle = {
        type = "circle",
        radius = radius,
        area = function(self)
            return math.pi * self.radius * self.radius
        end,
        draw = function(self)
            print("绘制圆形，半径: " .. self.radius)
        end
    }
    return circle
end

function shape_factory.create_rectangle(width, height)
    local rectangle = {
        type = "rectangle",
        width = width,
        height = height,
        area = function(self)
            return self.width * self.height
        end,
        draw = function(self)
            print("绘制矩形，宽: " .. self.width .. ", 高: " .. self.height)
        end
    }
    return rectangle
end

function shape_factory.create_square(side)
    -- 复用createRectangle
    return shape_factory.create_rectangle(side, side)
end

-- 使用工厂
local shapes = {
    shape_factory.create_circle(5),
    shape_factory.create_rectangle(4, 6),
    shape_factory.create_square(3)
}

for i, shape in ipairs(shapes) do
    print("形状" .. i .. " (" .. shape.type .. "):")
    print("  面积: " .. shape:area())
    shape:draw()
end
--[[ 输出
形状1 (circle):
  面积: 78.539816339745
绘制圆形，半径: 5
形状2 (rectangle):
  面积: 24
绘制矩形，宽: 4, 高: 6
形状3 (rectangle):
  面积: 9
绘制矩形，宽: 3, 高: 3
--]]
```

### 9.6.3 观察者模式

观察者模式：对象间的一对多依赖关系

```lua
-- 事件管理器
local event_manager = {}
event_manager.__index = event_manager

function event_manager.new()
    local instance = setmetatable({}, event_manager)
    instance.listeners = {}
    return instance
end

function event_manager:subscribe(event, callback)
    if not self.listeners[event] then
        self.listeners[event] = {}
    end
    table.insert(self.listeners[event], callback)
end

function event_manager:unsubscribe(event, callback)
    if self.listeners[event] then
        for i, cb in ipairs(self.listeners[event]) do
            if cb == callback then
                table.remove(self.listeners[event], i)
                break
            end
        end
    end
end

function event_manager:publish(event, ...)
    if self.listeners[event] then
        for _, callback in ipairs(self.listeners[event]) do
            callback(...)
        end
    end
end

-- 使用观察者模式
local events = event_manager.new()

-- 定义观察者
local function player_joined(player_name)
    print("系统: 玩家 " .. player_name .. " 加入了游戏")
end

local function player_left(player_name)
    print("系统: 玩家 " .. player_name .. " 离开了游戏")
end

local function achievement_unlocked(player_name, achievement)
    print("成就: " .. player_name .. " 解锁了 '" .. achievement .. "'")
end

-- 订阅事件
events:subscribe("player_join", player_joined)
events:subscribe("player_leave", player_left)
events:subscribe("achievement", achievement_unlocked)

-- 发布事件
events:publish("player_join", "小明")
events:publish("player_join", "小红")
events:publish("achievement", "小明", "首次登录")
events:publish("player_leave", "小红")

-- 取消订阅
events:unsubscribe("player_leave", player_left)
events:publish("player_leave", "小明")  -- 这个不会触发回调
--[[ 输出
系统: 玩家 小明 加入了游戏
系统: 玩家 小红 加入了游戏
成就: 小明 解锁了 '首次登录'
系统: 玩家 小红 离开了游戏
--]]
```

### 9.6.4 模块配置模式

模块配置模式：灵活的模块配置

```lua
-- 灵活的日志模块
local logger = {}

function logger.new(config)
    config = config or {}
    
    local instance = {
        level = config.level or "INFO",
        output = config.output or function(msg) print(msg) end,
        format = config.format or "[%LEVEL%] %MESSAGE%"
    }
    
    function instance:log(level, message)
        -- 检查日志级别
        local levels = {DEBUG = 1, INFO = 2, WARN = 3, ERROR = 4}
        if levels[level] < levels[self.level] then
            return
        end
        
        -- 格式化消息
        local formatted = self.format
        formatted = string.gsub(formatted, "%%LEVEL%%", level)
        formatted = string.gsub(formatted, "%%MESSAGE%%", message)
        
        -- 输出
        self.output(formatted)
    end
    
    function instance:debug(msg)
        self:log("DEBUG", msg)
    end
    
    function instance:info(msg)
        self:log("INFO", msg)
    end
    
    function instance:warn(msg)
        self:log("WARN", msg)
    end
    
    function instance:error(msg)
        self:log("ERROR", msg)
    end
    
    return instance
end

-- 使用不同配置
print("控制台日志:")
local console_logger = logger.new()
console_logger:info("系统启动")
console_logger:debug("详细调试信息")  -- 默认级别为INFO，DEBUG不会输出

print("\n文件日志:")
local file_logger = logger.new{
    level = "DEBUG",
    output = function(msg)
        -- 模拟写入文件
        print("[文件] " .. msg)
    end,
    format = "%LEVEL% - %MESSAGE%"
}
file_logger:debug("详细调试信息")  -- 这次会输出
file_logger:error("发生错误")

print("\n自定义格式:")
local fancy_logger = logger.new{
    format = "✨ %LEVEL% ✨ => %MESSAGE%"
}
fancy_logger:info("系统运行正常")
--[[ 输出
控制台日志:
[INFO] 系统启动

文件日志:
[文件] DEBUG - 详细调试信息
[文件] ERROR - 发生错误

自定义格式:
✨ INFO ✨ => 系统运行正常
--]]
```

## 9.7 练习

### 练习 1：创建一个简单日志模块
（答案见[[第 1 节 - 语法/参考答案#练习 9 1：创建一个日志模块]]）
```lua
-- 创建一个调试用的日志模块，增加多个打印模式，错误、信息等，同时可以自动格式化

-- 示例：
local log = require("log"):new("module_name")

log.error("无法加载模块 %s", "log")
-- 输出 [ERROR] module_name: 无法加载模块 log

log.info("加载模块中...")
-- 输出 [INFO] module_name: 加载模块中...
```

## 9.8 本章总结

### 关键知识点回顾

1. **模块基础**：
	- 使用 `local M = {}` 创建模块表
	- 通过 `return M` 导出模块
	- 使用 `require` 加载模块

2. **模块机制**：
	- `package.path` 定义模块搜索路径
	- `package.loaded` 缓存已加载模块

3. **标准库模块**：
	- `math`：数学运算
	- `string`：字符串处理
	- `table`：表操作
	- `os`：操作系统接口
	- `io`：输入输出
	- `debug`：调试工具

4. **LuaRocks 包管理器**：
	- 在终端使用 `luarocks install` 安装包
	- 安装到 `C:/Users/用户名/AppData/Local/VirtualStore/Program Files (x86)/Lua/5.1/lua`

1. **模块设计模式**：
    - 单例模式
    - 工厂模式
    - 观察者模式
    - 模块配置模式

### 模块设计最佳实践

```lua
-- 1. 清晰的模块结构
-- module/
--   ├── init.lua           -- 模块入口
--   ├── core.lua           -- 核心功能
--   ├── utils.lua          -- 工具函数
--   └── constants.lua      -- 常量定义

-- 2. 良好的命名规范
local MyModule = {}  -- 模块表
local private_var    -- 局部变量（私有）
MyModule.PUBLIC_CONSTANT = 100  -- 公共常量

-- 3. 错误处理
function MyModule.safe_operation()
    local success, result = pcall(function()
        -- 可能失败的操作
        return risky_operation()
    end)
    
    if not success then
        return nil, result  -- 返回错误信息
    end
    
    return result
end

-- 4. 文档化
--- 计算两个数的和
-- @param a 第一个数
-- @param b 第二个数
-- @return 两数之和
function MyModule.add(a, b)
    return a + b
end

-- 5. 版本控制
MyModule.VERSION = "1.0.0"
MyModule.AUTHOR = "Your Name"
```

### 常见错误

```lua
-- 错误 1：忘记 return 模块
local M = {}
-- 做一些设置...
-- 忘记写: return M

-- 错误 2：污染全局命名空间
-- 在模块中直接创建全局变量
GLOBAL_VAR = 100  -- 不好！

-- 错误 3：循环依赖
-- module_a.lua 需要 module_b
-- module_b.lua 需要 module_a
-- 解决方案：重构代码，提取公共部分

-- 错误 4：过度使用 require
-- 在循环中反复 require 同一个模块
for i = 1, 100 do
    local mod = require("some_module")  -- 每次都会检查缓存，但仍然有开销
end

-- 错误 5：模块路径问题
-- 不设置正确的 package.path
-- 解决方案：在程序开始时设置
package.path = package.path .. ";./lib/?.lua"
```

### 性能优化建议

```lua
-- 1. 延迟加载（Lazy Loading）
local LazyModule = {}
local _loaded_module = nil

function LazyModule.do_something()
    if not _loaded_module then
        _loaded_module = require("heavy_module")
    end
    return _loaded_module:do_work()
end

-- 2. 模块缓存
local cached_modules = {}

function get_module(name)
    if not cached_modules[name] then
        cached_modules[name] = require(name)
    end
    return cached_modules[name]
end

-- 3. 避免在模块初始化时做太多工作
-- 不好：模块加载时连接数据库
local db = connect_to_database()  -- 模块加载变慢

-- 好：需要时再连接
local function get_db()
    if not _db then
        _db = connect_to_database()
    end
    return _db
end
```

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 创建和使用 Lua 模块
- [ ] 理解模块加载机制
- [ ] 使用 Lua 标准库模块
- [ ] 使用 LuaRocks 管理第三方包
- [ ] 设计良好的模块结构
- [ ] 实现常见的模块设计模式
- [ ] 处理模块依赖和循环引用
- [ ] 创建可配置的模块系统

### 思考题

1. Lua 模块系统和面向对象语言（如 Java、Python）的包系统有什么异同？
2. 什么时候应该将代码拆分为多个模块？模块划分的原则是什么？
3. 如何处理模块间的循环依赖问题？
4. Lua 的`require`机制如何避免重复加载同一模块？
5. 在设计一个库时，如何平衡灵活性和易用性？

### 拓展练习

1. 实现一个国际化的模块，支持多语言文本
2. 创建一个数据验证模块，支持各种数据格式验证
3. 实现一个事件总线系统，支持跨模块通信

---

**下一章预告**：在第 10 章中，我们将学习调试与错误处理。编写健壮的程序需要妥善调试并处理错误和异常，我们将学习 Lua 的调试技巧与错误处理机制，包括断点、 `pcall`、`xpcall`、`error`、`assert` 等，以及如何创建自定义错误类型和错误处理策略。

**学习建议**：
1. 多实践模块的创建和使用，理解模块化编程的好处
2. 熟悉标准库模块，它们能解决很多常见问题
3. 学习使用 LuaRocks 管理依赖
4. 尝试重构现有代码，将其模块化
5. 注意模块设计的边界和接口设计