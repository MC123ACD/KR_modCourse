### 14.1 LuaJIT 简介

LuaJIT 是一个高性能的 Lua 解释器和即时编译器（JIT），它完全兼容 Lua 5.1，但性能通常比标准 Lua 快得多。

**LuaJIT 的主要特性**：
1. 高性能 JIT 编译器
2. 提供 FFI 允许直接调用 C 函数和使用 C 数据结构
3. 内存使用更少
4. 完全兼容 Lua 5.1
5. 支持更多字节码指令

## 14.2 使用 LuaJIT
同 [[2. 基础语法规则#2 1 2 修复无法中文乱码]]
切换到 LuaJIT 运行程序即可。

## 14.3 JIT 编译器
JIT 编译器用于将 Lua 字节码动态编译为本地机器码，提高 2-15 倍性能。

```lua
-- 性能测试：标准Lua vs LuaJIT
local function benchmark_loop()
    local sum = 0
    for i = 1, 10000000 do
        sum = sum + i
    end
    return sum
end

local start1 = os.clock()
local result = benchmark_loop()
local time1 = os.clock() - start1

-- 启用 JIT 编译器
jit.on()
local start2 = os.clock()
local result = benchmark_loop()
local time2 = os.clock() - start2

print(string.format("Lua 执行时间: %.4f秒", time1))
print(string.format("JIT 执行时间: %.4f秒", time2))
print(string.format("性能提高: %.2f%%", (time1 - time2) / time2 * 100))
--[[ 输出
Lua 执行时间: 0.0410秒
JIT 执行时间: 0.0110秒
性能提高: 270%
--]]
```

## 14.4 goto - 代码跳转

goto 语句提供了一种低级的控制流跳转机制，可以在代码块内直接跳转到指定标签位置。
可以使用 goto 来模拟 continue 跳过单次循环。
```lua
::跳转标签名称::	-- 定义跳转位置

goto 跳转到的标签
```

#### 核心用途

##### 1. 模拟 `continue` 语句
```lua
-- Lua 没有 continue 关键字，用 goto 实现
for i = 1, 10 do
    if i % 2 == 0 then      -- 跳过偶数
        print("跳过偶数: " .. i)
        goto continue
    end
    
    print("处理奇数: " .. i)
    
    ::continue::  -- 循环末尾的标签
end
--[[ 输出
处理奇数: 1
跳过偶数: 2
处理奇数: 3
跳过偶数: 4
处理奇数: 5
跳过偶数: 6
处理奇数: 7
跳过偶数: 8
处理奇数: 9
跳过偶数: 10
--]]
```

##### 2. 跳出多重嵌套
```lua
for i = 1, 3 do
    for j = 1, 3 do
        if i == 2 and j == 2 then
            print("找到目标，跳出所有循环")
            goto exit_loops
        end
        print(i, j)
    end
end

::exit_loops::
print("继续执行后续代码")
--[[ 输出
1	1
1	2
1	3
2	1
找到目标，跳出所有循环
继续执行后续代码
--]]
```

#####   3. 卫语句模式（提前返回）
```lua
-- 在非函数中模拟"提前返回"逻辑
local x = -1

::validate::
if x <= 0 then
    print("x 必须大于0")
    goto end_process
end

if x > 100 then
    print("x 不能超过100")
    goto end_process
end

print("x 有效: " .. x)

::end_process::
print("验证完成")
--[[ 输出
x 必须大于0
验证完成
--]]
```

#### 重要限制与规则

##### 1. 作用域限制（最重要！）
```lua
-- 不允许：跳进函数
local function test()
    ::inside_func::
end

goto inside_func

-- 不允许：跳进其他代码块
if condition then
    local x = 10
    ::label3::
end

goto label3

-- 不允许：跳过局部变量定义
goto lable1

local a = 123

::lable1::
```

##### 2. 标签定义规则
```lua
-- 合法标签名（字母、数字、下划线）
::valid_label::
::Label123::
::_start::

-- 不合法标签名
::123start::    -- 不能以数字开头
::my-label::    -- 不能包含连字符
::end::         -- 不能用保留字
```

## 14.5 其他功能

```lua
-- 1. bit库 - 位运算
print("1. bit库 - 位运算:")
local bit = require("bit")

local a = 0x0F -- 00001111
local b = 0xF0 -- 11110000

print(string.format("a = 0x%X (%d)", a, a))
print(string.format("b = 0x%X (%d)", b, b))
print(string.format("bit.band(a, b) = 0x%X", bit.band(a, b)))     -- 与
print(string.format("bit.bor(a, b) = 0x%X", bit.bor(a, b)))       -- 或
print(string.format("bit.bxor(a, b) = 0x%X", bit.bxor(a, b)))     -- 异或
print(string.format("bit.bnot(a) = 0x%X", bit.bnot(a)))           -- 非
print(string.format("bit.lshift(a, 2) = 0x%X", bit.lshift(a, 2))) -- 左移
print(string.format("bit.rshift(b, 2) = 0x%X", bit.rshift(b, 2))) -- 右移

-- 2. 表操作优化
-- jit.on()
print("\n2. 表操作优化:")
local large_table = {}
local start_time = os.clock()

-- 插入大量数据
for i = 1, 1000000 do
    large_table[i] = i * 2
end

local insert_time = os.clock() - start_time
print("插入100万条数据耗时: " .. string.format("%.3f", insert_time) .. "秒")

-- 访问数据
start_time = os.clock()
local sum = 0
for i = 1, 1000000 do
    sum = sum + large_table[i]
end
local access_time = os.clock() - start_time
print("访问100万条数据耗时: " .. string.format("%.3f", access_time) .. "秒")
print("总和: " .. sum)

-- 3. 协程优化
print("\n3. 协程优化:")
local sum = 0

local function coroutine_test()
    local co = coroutine.create(function()
        for i = 1, 5 do
            coroutine.yield(i)
        end
    end)

    for i = 1, 5 do
        local success, value = coroutine.resume(co)
        if success then
            sum = sum + value
        end
    end
end

local start = os.clock()
for i = 1, 10000 do
    coroutine_test()
end
local elapsed = os.clock() - start
print(string.format("总和 %s", sum))
print(string.format("执行10000次协程测试耗时: %.3f秒", elapsed))

-- 4. 垃圾回收优化
print("\n4. 垃圾回收优化:")

-- 显示GC统计
local gc_stats = {
    count = collectgarbage("count"),
    step = collectgarbage("step"),
    isrunning = collectgarbage("isrunning")
}

print("GC统计:")
print("  内存使用: " .. string.format("%.2f", gc_stats.count) .. " KB")
print("  GC是否运行: " .. tostring(gc_stats.isrunning))

-- 手动触发GC
collectgarbage("collect")
print("手动触发GC后内存: " .. string.format("%.2f", collectgarbage("count")) .. " KB")
--[[ 输出
1. bit库 - 位运算:
a = 0xF (15)
b = 0xF0 (240)
bit.band(a, b) = 0x0
bit.bor(a, b) = 0xFF
bit.bxor(a, b) = 0xFF
bit.bnot(a) = 0xFFFFFFFFFFFFFFF0
bit.lshift(a, 2) = 0x3C
bit.rshift(b, 2) = 0x3C

2. 表操作优化:
插入100万条数据耗时: 0.016秒
访问100万条数据耗时: 0.008秒
总和: 1000001000000

3. 协程优化:
总和 150000
执行10000次协程测试耗时: 0.006秒

4. 垃圾回收优化:
GC统计:
  内存使用: 13410.04 KB
  GC是否运行: true
手动触发GC后内存: 8252.30 KB
--]]
```

## 14.6 FFI（外部函数接口）

FFI 是 LuaJIT 最强大的特性之一，允许直接调用 C 函数、使用 C 数据类型和内存操作，无需编写 C 扩展模块。
FFI 提供了 Lua 与 C 世界之间的桥梁，通过合理使用可以显著提升性能，但需要谨慎处理内存和类型安全问题。

```lua
-- FFI使用示例
local ffi = require("ffi")

-- 1. 声明C函数和类型
ffi.cdef [[
    // 标准库函数
    int strlen(const char *s);
    void *malloc(size_t size);
    void free(void *ptr);

    // 数学函数
    double sin(double x);
    double cos(double x);
    double sqrt(double x);

    // 系统调用
    int system(const char *command);

    // 自定义结构体
    typedef struct {
        int x;
        int y;
    } Point;

    typedef struct {
        char name[32];
        int age;
        float score;
    } Student;
]]

-- 2. 调用C函数
print("调用C标准库函数:")
local str = "Hello, World!"
local length = ffi.C.strlen(str)
print("字符串长度: " .. length)

-- 3. 使用数学函数
local angle = 45 * math.pi / 180
local sin_value = ffi.C.sin(angle)
local cos_value = ffi.C.cos(angle)
print(string.format("\n数学函数: sin(45°)=%.3f, cos(45°)=%.3f", sin_value, cos_value))

-- 4. 创建和使用C结构体
print("\nC结构体使用:")
-- 创建Point结构体
local point = ffi.new("Point")
point.x = 10
point.y = 20
print("Point: x=" .. point.x .. ", y=" .. point.y)

-- 创建Student结构体
local student = ffi.new("Student")
ffi.copy(student.name, "张三")
student.age = 18
student.score = 95.5

print(string.format("Student: name=%s, age=%d, score=%.1f",
    ffi.string(student.name), student.age, student.score))

-- 5. 内存管理
print("\n内存管理:")
local size = 100 * ffi.sizeof("int")
local buffer = ffi.C.malloc(size)
print("分配内存: " .. size .. " 字节")

if buffer ~= ffi.NULL then
    -- 将buffer转换为int数组
    local int_array = ffi.cast("int*", buffer)

    -- 初始化数组
    for i = 0, 99 do
        int_array[i] = i * 2
    end

    -- 访问数组元素
    print("int_array[50] = " .. int_array[50])

    -- 释放内存
    ffi.C.free(buffer)
    print("内存已释放")
end

-- 6. 调用系统命令
print("\n系统调用:")
local result = ffi.C.system("echo 'Hello from system call'")
print("系统命令返回值: " .. result)
--[[ 输出
调用C标准库函数:
字符串长度: 13

数学函数: sin(45°)=0.707, cos(45°)=0.707

C结构体使用:
Point: x=10, y=20
Student: name=张三, age=18, score=95.5

内存管理:
分配内存: 400 字节
int_array[50] = 100
内存已释放

系统调用:
系统命令返回值: 0
'Hello from system call'
--]]
```

### 14.6.1 FFI 基础

#### 加载 FFI 模块
```lua
local ffi = require("ffi")
```

#### 基本工作流程
1. 声明 C 类型和函数
2. 调用 C 函数
3. 管理 C 数据

### 14.6.2 声明 C 类型

#### 基本类型声明
```lua
ffi.cdef [[
    // 基础类型
    typedef int bool;
    typedef char int8_t;
    typedef short int16_t;
    typedef int int32_t;
    typedef long long int64_t;
    typedef unsigned char uint8_t;
    typedef unsigned short uint16_t;
    typedef unsigned int uint32_t;
    typedef unsigned long long uint64_t;
    typedef float float32_t;
    typedef double float64_t;
    
    // 指针类型
    typedef void* pointer;
    typedef const char* cstring;
    
    // 标准库类型
    typedef long time_t;
    typedef struct tm tm_t;
]]
```

#### 结构体声明
```lua
ffi.cdef [[
    // 简单结构体
    typedef struct {
        int x;
        int y;
    } Point;
    
    // 嵌套结构体
    typedef struct {
        Point start;
        Point end;
    } Line;
    
    // 数组作为成员
    typedef struct {
        char name[64];
        int scores[10];
    } Student;
    
    // 位字段
    typedef struct {
        unsigned int flag1 : 1;
        unsigned int flag2 : 1;
        unsigned int : 6;  // 未使用位
        unsigned int value : 8;
    } BitField;
    
    // 联合体
    typedef union {
        int i;
        float f;
        char bytes[4];
    } DataUnion;
]]
```

#### 函数声明
```lua
ffi.cdef [[
    // 标准库函数
    // 字符串操作
    size_t strlen(const char *s);
    char *strcpy(char *dest, const char *src);
    char *strcat(char *dest, const char *src);
    int strcmp(const char *s1, const char *s2);
    char *strstr(const char *haystack, const char *needle);
    
    // 内存操作
    void *malloc(size_t size);
    void *calloc(size_t num, size_t size);
    void *realloc(void *ptr, size_t size);
    void free(void *ptr);
    void *memcpy(void *dest, const void *src, size_t n);
    void *memset(void *s, int c, size_t n);
    
    // 数学函数
    double sin(double x);
    double cos(double x);
    double tan(double x);
    double sqrt(double x);
    double pow(double x, double y);
    double log(double x);
    double exp(double x);
    double fabs(double x);
    
    // 输入输出
    int printf(const char *format, ...);
    int sprintf(char *str, const char *format, ...);
    int scanf(const char *format, ...);
    int puts(const char *s);
    
    // 系统调用
    int system(const char *command);
    time_t time(time_t *t);
    char *ctime(const time_t *timer);
    
    // 自定义函数原型
    double calculate_average(double *array, int length);
    void process_data(void *data, size_t size);
]]
```

### 14.6.3 调用 C 函数

#### 访问标准库
```lua
-- 直接调用C标准库函数
print("字符串长度:", ffi.C.strlen("Hello, World!"))
print("正弦值:", ffi.C.sin(math.pi / 2))
print("平方根:", ffi.C.sqrt(2.0))
```

#### 调用系统函数
```lua
-- 调用系统命令
local result = ffi.C.system("ls -la")
print("命令返回值:", result)

-- 获取当前时间
local time_ptr = ffi.new("time_t[1]")
ffi.C.time(time_ptr)
local time_str = ffi.C.ctime(time_ptr)
print("当前时间:", ffi.string(time_str))
```

### 14.6.4 创建和操作 C 数据

#### 创建结构体实例
```lua
-- 创建结构体（自动初始化为0）
local point = ffi.new("Point")
point.x = 10
point.y = 20
print("Point:", point.x, point.y)

-- 创建并初始化
local point2 = ffi.new("Point", {x = 30, y = 40})

-- 创建结构体数组
local points = ffi.new("Point[5]")
points[0].x = 1
points[0].y = 2
points[1] = {x = 3, y = 4}

-- 创建包含数组的结构体
local student = ffi.new("Student")
ffi.copy(student.name, "Alice")
for i = 0, 9 do
    student.scores[i] = math.random(60, 100)
end
```

#### 内存分配和管理
```lua
-- 动态分配内存
local size = 100 * ffi.sizeof("int")
local buffer = ffi.C.malloc(size)
print("分配了", size, "字节内存")

if buffer ~= ffi.NULL then
    -- 转换为特定类型指针
    local int_array = ffi.cast("int*", buffer)
    
    -- 初始化数组
    for i = 0, 99 do
        int_array[i] = i * i
    end
    
    -- 访问元素
    print("int_array[50] =", int_array[50])
    
    -- 重新分配内存
    local new_size = 200 * ffi.sizeof("int")
    local new_buffer = ffi.C.realloc(buffer, new_size)
    
    -- 释放内存
    ffi.C.free(new_buffer)
    print("内存已释放")
end

-- 使用calloc（初始化为0）
local zero_buffer = ffi.C.calloc(10, ffi.sizeof("double"))
```

#### 字符串操作
```lua
-- 创建C字符串
local cstr = ffi.new("char[64]")
ffi.copy(cstr, "Hello from C string")

-- 转换为Lua字符串
local lua_str = ffi.string(cstr)
print("Lua字符串:", lua_str)

-- 使用sprintf格式化
local buffer = ffi.new("char[256]")
ffi.C.sprintf(buffer, "格式化输出: %s, 数值: %d, 浮点数: %.2f", 
              "测试", 123, 45.678)
print(ffi.string(buffer))
```

### 14.6.5 回调函数和函数指针

#### 定义回调函数类型
```lua
ffi.cdef [[
    // 回调函数类型
    typedef void (*callback_t)(int status, const char *message);
    
    // 接受回调的函数
    void register_callback(callback_t cb);
    void trigger_event(int event_id);
]]

-- Lua回调函数
local function lua_callback(status, message)
    print("回调被调用:")
    print("  状态:", status)
    print("  消息:", ffi.string(message))
end

-- 将Lua函数转换为C回调
local cb = ffi.cast("callback_t", lua_callback)

-- 注意：回调函数会被垃圾回收，需要保持引用
_G.keep_alive = cb
```

### 14.6.6 类型检查和转换

#### 类型检查
```lua
local var = ffi.new("int", 42)

print("类型信息:")
print("  ffi.typeof(var):", ffi.typeof(var))
print("  ffi.istype('int', var):", ffi.istype('int', var))
print("  ffi.sizeof(var):", ffi.sizeof(var))
print("  ffi.alignof('int'):", ffi.alignof('int'))
print("  ffi.offsetof('Student', 'name'):", ffi.offsetof('Student', 'name'))
```

#### 类型转换
```lua
-- 基本类型转换
local int_val = ffi.new("int", 42)
local ptr = ffi.cast("void*", int_val)
local int_ptr = ffi.cast("int*", ptr)

-- 指针算术
local array = ffi.new("int[10]")
for i = 0, 9 do
    array[i] = i * 10
end

-- 获取元素指针
local elem_ptr = array + 5  -- 指向array[5]
print("array[5] =", elem_ptr[0])
```

### 14.6.7 实用示例

#### 示例 1：高性能数学计算
```lua
local function vector_operations()
    ffi.cdef [[
        typedef struct {
            double x, y, z;
        } Vector3;
        
        double dot_product(Vector3 a, Vector3 b);
        Vector3 cross_product(Vector3 a, Vector3 b);
        double vector_length(Vector3 v);
    ]]
    
    local vec1 = ffi.new("Vector3", {x=1, y=2, z=3})
    local vec2 = ffi.new("Vector3", {x=4, y=5, z=6})
    
    -- 点积（模拟）
    local dot = vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z
    print("点积:", dot)
    
    -- 叉积（模拟）
    local cross = ffi.new("Vector3")
    cross.x = vec1.y * vec2.z - vec1.z * vec2.y
    cross.y = vec1.z * vec2.x - vec1.x * vec2.z
    cross.z = vec1.x * vec2.y - vec1.y * vec2.x
    print("叉积:", cross.x, cross.y, cross.z)
end
```

#### 示例 2：处理二进制数据
```lua
local function binary_data_processing()
    -- 创建二进制缓冲区
    local buffer_size = 1024
    local buffer = ffi.new("uint8_t[?]", buffer_size)
    
    -- 填充数据
    for i = 0, buffer_size - 1 do
        buffer[i] = math.random(0, 255)
    end
    
    -- 计算校验和
    local checksum = 0
    for i = 0, buffer_size - 1 do
        checksum = checksum + buffer[i]
    end
    checksum = checksum % 256
    
    print("缓冲区大小:", buffer_size)
    print("校验和:", checksum)
    
    -- 查找特定字节
    local target = 0xAA
    for i = 0, buffer_size - 1 do
        if buffer[i] == target then
            print("找到", string.format("0x%02X", target), "在位置", i)
        end
    end
end
```

#### 示例 3：与系统 API 交互
```lua
local function system_interaction()
    -- 注意：这部分代码依赖于操作系统
    ffi.cdef [[
        // Windows API示例
        #ifdef _WIN32
        #include <windows.h>
        void Sleep(DWORD milliseconds);
        DWORD GetTickCount();
        #endif
        
        // POSIX示例
        #ifndef _WIN32
        #include <unistd.h>
        unsigned int sleep(unsigned int seconds);
        #endif
    ]]
    
    -- 跨平台休眠
    local function msleep(milliseconds)
        if ffi.os == "Windows" then
            ffi.C.Sleep(milliseconds)
        else
            ffi.C.usleep(milliseconds * 1000)
        end
    end
    
    print("开始休眠...")
    msleep(1000)  -- 休眠1秒
    print("休眠结束")
end
```

### 14.6.8 限制和注意事项

#### FFI 的限制
1. **平台依赖性**：FFI 代码可能在不同平台表现不同
2. **类型安全**：错误的类型使用可能导致崩溃
3. **内存泄漏**：需要手动管理内存
4. **回调函数**：Lua 回调可能被垃圾回收

#### 调试技巧
```lua
-- 启用调试信息
ffi.cdef [[
    // 添加详细的错误检查
]]

-- 使用assert进行运行时检查
local ptr = ffi.C.malloc(100)
assert(ptr ~= ffi.NULL, "内存分配失败")

-- 添加日志记录
local function debug_alloc(size)
    print("分配内存:", size, "字节")
    local ptr = ffi.C.malloc(size)
    print("返回指针:", tostring(ptr))
    return ptr
end
```

## 14.7 最佳实践建议

#### 1. goto 使用场景优先级
```lua
-- 优先方案：使用函数和返回值
local function processItem(item)
    if not isValid(item) then
        return false  -- 代替 goto
    end
    -- 正常处理
    return true
end

-- 次选方案：goto 用于简单循环控制
for i = 1, 10 do
    if shouldSkip(i) then
    	goto continue
    end
    
    process(i)
    ::continue::
end
```

#### 2. 代码可读性维护
```lua
-- 难以理解：过度使用 goto
goto step1
::step3::
print("步骤3")
goto end
::step1::
print("步骤1")
goto step2
::step2::
print("步骤2")
goto step3
::end::

-- 清晰明了：限制使用范围
for i = 1, 5 do
    if i == 3 then
    	goto skip_print
    end
    
    print("正常: " .. i)
    ::skip_print::
end
```

#### 3. 性能优化技巧
```lua
-- 1. 复用类型对象
local Point_type = ffi.typeof("Point")
local points = {}
for i = 1, 1000 do
    points[i] = Point_type()  -- 比ffi.new更快
end

-- 2. 批量操作
local function process_batch(data, count)
    local buffer = ffi.new("double[?]", count)
    for i = 0, count - 1 do
        buffer[i] = data[i + 1] * 2
    end
    -- 批量处理buffer
    return buffer
end

-- 3. 避免频繁的类型转换
local cached_type = ffi.typeof("int[100]")
local array = cached_type()
```

#### 4. 内存管理最佳实践
```lua
-- 1. 使用gc来管理内存
local function create_large_buffer()
    local buf = ffi.gc(ffi.C.malloc(1024 * 1024), ffi.C.free)
    -- buf会在垃圾回收时自动释放
    return buf
end

-- 2. 显式内存管理
local function manual_memory_management()
    local buffers = {}
    
    local function allocate(name, size)
        local buf = ffi.C.malloc(size)
        if buf == ffi.NULL then
            error("内存分配失败")
        end
        buffers[name] = buf
        return buf
    end
    
    local function cleanup()
        for name, buf in pairs(buffers) do
            ffi.C.free(buf)
            buffers[name] = nil
        end
    end
    
    -- 使用...
    local data = allocate("data", 1024)
    
    -- 清理...
    cleanup()
end
```

## 14.8 本章总结

### 关键知识点回顾
1. **LuaJIT 核心特性**：
	- 高性能 JIT 编译器 - 动态编译字节码为机器码
	- FFI（外部函数接口） - 直接调用 C 函数和使用 C 数据结构
	- 完全兼容 Lua 5.1 - 无缝迁移现有代码
	- 更低的内存占用 - 优化内存管理

2. **JIT 编译器**：
	- `jit.on()` - 启用 JIT 编译
	- `jit.off()` - 禁用 JIT 编译
	- 性能提升 2-15 倍 - 特别适合循环和数值计算
	- 动态编译 - 运行时将热点代码编译为机器码

3. **FFI 外部函数接口**：
	- `ffi.cdef` - 声明 C 函数和类型
	- `ffi.C` - 调用标准 C 库函数
	- `ffi.new` - 创建 C 结构体实例
	- `ffi.cast` - 类型转换
	- `ffi.string` - 转换 C 字符串为 Lua 字符串
	- `ffi.copy` - 复制数据到 C 缓冲区
	- 直接内存管理 - 使用 malloc/free

4. **goto 语句**：
	- `::label::` - 定义标签
	- `goto label` - 跳转到标签
	- 模拟 continue - Lua 原生无 continue
	- 跳出多重嵌套 - 简化复杂控制流
	- 卫语句模式 - 提前返回逻辑

5. **其他增强功能**：
	- bit 库 - 位运算操作
	- 表操作优化 - 大规模数据处理
	- 协程优化 - 轻量级并发
	- 垃圾回收优化 - 更高效的内存管理

### 检查清单
完成本章后，你应该能够：
- [ ] 理解 LuaJIT 的性能优势和应用场景
- [ ] 启用和禁用 JIT 编译器
- [ ] 使用 FFI 调用 C 标准库函数
- [ ] 创建和使用 C 结构体
- [ ] 进行 C 风格的内存分配和管理
- [ ] 正确使用 goto 实现流程控制
- [ ] 理解 goto 的作用域限制
- [ ] 使用 bit 库进行位运算
- [ ] 利用 LuaJIT 优化大规模数据处理
- [ ] 手动控制垃圾回收机制

### 思考题
1. JIT 编译器在什么场景下性能提升最明显？什么场景下可能效果有限？
2. FFI 与传统的 Lua C API 扩展方式相比有什么优势和劣势？
3. 为什么 goto 在大多数编程语言中都不推荐使用？Lua 中的 goto 有哪些特殊限制？
4. 使用 FFI 直接操作内存时需要注意哪些安全问题？
5. 如何平衡代码可读性和使用 goto 带来的便利性？

---

### 常见问题解答

**Q: 为什么 goto 有这么多限制？**  
A: 为了避免创建"面条代码"，确保程序结构清晰，防止跳过变量初始化等危险操作。

**Q: 什么时候应该使用 goto？**  
A: 仅当：
1. 需要模拟 `continue`
2. 简单跳出多重循环
3. 没有更清晰的结构化替代方案

**Q: goto 的性能影响？**  
A: Lua 的 `goto` 是编译期处理，运行时几乎没有性能开销。