## 3.1 变量声明：理解作用域

### 3.1.1 局部变量（Local Variables）

```lua
-- 使用local关键字声明局部变量
local level = 1
local health = 100
local damage = 12

-- 局部变量只在声明它的代码块内有效
do
    local x = 10
    print("内部 x = " .. x)  -- 可以访问x
end

print(x)  -- 输出 nil，Lua 中不存在的值都是 nil
```

**局部变量的特点**：
1. 只在声明它的代码块内可见
2. 使用 `local` 关键字声明
3. 推荐优先使用局部变量
4. 性能比全局变量好

### 3.1.2 全局变量（Global Variables）

```lua
-- 不使用local关键字，直接赋值创建全局变量
global_counter = 0  -- 全局变量

do
    global_counter = global_counter + 1
end

print(global_counter)  -- 输出：1

-- 也可直接在代码块内定义
do
    x = 1
end

print(x)  -- 输出：1
```

**全局变量的特点**：
1. 在整个程序中都可以访问
2. 不需要关键字，直接赋值即创建
3. 不要过度使用（容易造成命名冲突）

### 3.1.3 代码块
代码块是一组语句的集合：
```lua
local z = 100

do		-- do-end创建普通代码块
    local x = 10
    local y = 20
    print(x + y)	-- 30
    print(z)		-- 100
end

if 条件 then		-- 创建条件代码块
	local x = 10
	a = 1000	-- 全局变量
    print(x)	-- 10
end

print(x)	-- nil
```

代码块可以理解为一个 “盒子”盒子内部可以访问外面，以及内部之间的访问，盒子外部无法访问内部。
全局变量其实是定义到一个全局作用域（\_G）访问变量时优先从当前作用域查找变量，最后从 \_G 查找全局变量。

**示意图**：
![[Pasted image 20251209094358.png|900]]

#### 所有代码块
1. do-end 代码块
2. 判断条件内的条件代码块
3. 循环内的循环体
4. 函数内的函数体

#### 代码块的作用域
一个代码块的内部称为一个作用域

```lua
local x = 5  -- 这里文件顶层代码其实也是个作用域

do
    local x = 10  -- 局部作用域，只在do...end块内有效
    print("内部 x = " .. x)  -- 输出：内部 x = 10
end

print("外部 x = " .. x)  -- 输出：外部 x = 5
```

### 3.1.4 变量声明的最佳实践

```lua
-- 1. 一次声明多个局部变量
local x, y, z = 10, 20, 30

-- 2. 先声明，后赋值
local player_name
local player_score

player_name = "李雷"
player_score = 1000

-- 3. 交换变量值（无需临时变量）
local a, b = 10, 20
a, b = b, a  -- 交换后：a=20, b=10

-- 4. 声明但不初始化（值为nil）
local uninitialized
print(type(uninitialized))  -- 输出：nil
```

**作用域示例**：
```lua
-- 作用域示例：理解变量可见性
local global_x = 100

do
    -- 内层作用域可以访问外部的局部变量
    print("在内部访问外部变量: " .. global_x)  -- 输出：100
    
    -- 这个x只在当前作用域内有效
    local x = 50
    print("局部作用域内的x: " .. x)  -- 输出：50

    -- 如果没有提前在外部声明，将会创建全局变量
    global_z = 300  -- 创建全局变量
end

print("全局变量 global_z: " .. (global_z))  -- 输出：300
print("外部的x: " .. (x))  -- 输出：nil（局部作用域内的x不可见）
```

## 3.2 Lua 的 8 种基本数据类型

Lua 是动态类型语言，变量类型由值决定。使用 `type()` 函数可以查看数据类型。

### 3.2.1 nil - 空值

```lua
-- nil表示"无"或"不存在"
local empty = nil
local undefined  -- 未赋值的变量默认为nil

print("empty的类型: " .. type(empty))  -- 输出：nil
print("undefined的类型: " .. type(undefined))  -- 输出：nil
```

#### nil的特殊用途：删除变量或表元素
```lua
local config = { sound = true, music = true }
config.music = nil  -- 删除music设置
print("music 值：" .. config.music)  -- 输出：nil
```

### 3.2.2 boolean - 布尔值

```lua
-- 只有两个值：true和false
local is_game_over = false
local is_player_alive = true
local has_key = false

-- 在条件判断中使用
if is_player_alive then
    print("玩家还活着")
else
    print("游戏结束")
end

-- Lua中只有false和nil被视为"假"，其他都是"真"
local truth_test = 0  -- 数字0在Lua中是真值
if truth_test then
    print("数字0是真值")  -- 这行会执行
end

if nil then
    print("nil是真值？")  -- 这行不会执行
else
    print("nil是假值")  -- 这行会执行
end
```

### 3.2.3 number - 数字

```lua
-- Lua 5.1中所有数字都是双精度浮点数
local integer = 42      -- 整数
local float = 3.14      -- 浮点数
local negative = -10    -- 负数
local scientific = 2e3  -- 科学计数法：2×10³=2000
local hex = 0xFF        -- 十六进制：255
local oct = 0755        -- 八进制：493（0开头）

print("整数: " .. integer)
print("浮点数: " .. float)
print("科学计数法: " .. scientific)
print("十六进制: " .. hex)
```

### 3.2.4. string - 字符串

```lua
-- 字符串创建
local str1 = "双引号字符串"	-- 注：不能在其中使用双引号
local str2 = '单引号字符串'	-- 注：不能在其中使用单引号
local str3 = [[多行字符串
可以包含换行
和各种引号]]
```

### 3.2.5 table - 表

#### 创建空表
```lua
local empty_table = {}
```

#### 作为数组使用（索引从1开始）
```lua
local towers = {"箭塔", "兵营", "法师塔", "炮塔"}
print("第一个防御塔: " .. towers[1])  -- 输出：箭塔
```

#### 作为字典/映射使用
```lua
local tower = {
    name = "炮塔",
    level = 10,
    damage = 100,
    ["class"] = "防御塔"  -- 如果键包含特殊字符或关键字，需要方括号
}

-- 索引字典
print("防御塔: " .. tower.name)
print("等级: " .. tower.level)
print("防御塔类型: " .. tower.class)

-- 第二个索引方法
print("防御塔: " .. tower["name"])
print("等级: " .. tower["level"])
print("防御塔类型: " .. tower["class"])
```

#### 混合使用
```lua
local config = {
    "设置1",				-- 索引1（数组部分）
    "设置2",				-- 索引2

    version = "1.0",	-- 键值对（字典部分）
    author = "开发者"
}

print(config[1])		-- 输出：设置1
print(config.version)   -- 输出：1.0
```

### 3.2.6 function - 函数

```lua
-- 函数也是一种数据类型，可以赋值给变量
local say_hello = function(name)
    return "你好, " .. name
end

-- 等价于
local function say_hello(name)
    return "你好, " .. name
end

-- 与变量相同也有全局函数
say_hello = function(name)
    return "你好, " .. name
end

-- 等价于
function say_hello(name)
    return "你好, " .. name
end

-- 函数作为值传递
local greeting_func = say_hello	-- 此时 greeting_func 就是 say_hello
print(greeting_func("世界"))		-- 输出：你好, 世界

-- 函数存储在表中
local math_operations = {
    add = function(a, b)
    	return a + b
    end,

    subtract = function(a, b)
    	return a - b
    end
}

print("5 + 3 = " .. math_operations.add(5, 3))		-- 输出 8
print("5 - 3 = " .. math_operations.subtract(5, 3))	-- 输出 2
```

### 3.2.7 thread - 协程

```lua
-- thread：协程，用于实现协作式多任务
local co = coroutine.create(function()
    print("协程执行中")
    coroutine.yield()
    print("协程恢复")
end)

coroutine.resume(co)  -- 输出：协程执行中
coroutine.resume(co)  -- 输出：协程恢复
```

### 3.2.8 userdata - 用户数据
userdata 用于存储C语言数据，主要用于与C交互
通常由C库创建，Lua代码只能使用，不能创建

## 3.3 获取数据类型

```lua
type(值: any) -> 数据类型: "nil"|"number"|"string"|"boolean"|"table"|"function"|"thread"|"userdata"
```

#### 示例
```lua
print(type("字符串"))	-- 输出 "string"
print(type(123))	-- 输出 "number"
print(type({1, 2, 3}))	-- 输出 "table"
```

## 3.4 练习

### 练习 1：数据类型识别
（答案见 [[第 1 节 - 语法/参考答案#练习 3 1：数据类型识别]]）
```lua
-- 创建一个函数，可以识别并输出传入的值的数据类型
```

## 3.5 本章总结

### 关键知识点回顾
1. **变量声明**：
	- 使用 `local` 声明局部变量
	- 直接赋值创建全局变量（不推荐滥用）
	- 代码块的作用域的 “盒子模型”

1. **8 种数据类型**：
	- `nil`：空值
	- `boolean`：布尔值（true/false）
	- `number`：数字（所有数字都是双精度浮点）
	- `string`：字符串
	- `table`：表（Lua 的核心数据结构）
	- `function`：函数（一等公民）
	- `userdata`：C 数据（与 C 交互）
	- `thread`：协程（协作式多任务）

3. **type()函数**：
	- 返回数据类型的字符串表示
	- 用于类型检查和调试

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 正确声明局部变量和全局变量
- [ ] 理解代码块的作用域
- [ ] 识别和使用 8 种基本数据类型
- [ ] 使用 `type()` 函数检查变量类型
- [ ] 理解 Lua 中"真值"的概念（只有 false 和 nil 是假）

### 思考题
1. 为什么 Lua 中 `0` 是真值而 `false` 是假值？这样设计有什么好处？
2. 表（table）为什么是 Lua 的核心数据结构？它能替代哪些其他数据结构？
3. 在什么情况下应该使用全局变量？什么情况下应该避免？

---

**下一章预告**：在第 4 章中，我们将学习运算符，这是进行基础运算的关键！

**拓展练习**：
1. 创建一个变量交换函数，不使用临时变量
2. 写一个函数判断一个数字是奇数还是偶数