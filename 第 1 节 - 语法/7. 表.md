## 7.1 什么是表？

表是 Lua 中唯一的数据结构，但它极其强大和灵活。通过表，Lua 可以实现数组、字典、对象、模块等几乎所有复杂数据结构。

### 表的核心理念

```lua
-- 比喻：表就像一个"万能容器"
-- 想象一下，有一个魔法背包：
-- 1. 可以按顺序放东西（数组）
-- 2. 可以给东西贴标签，按名字找（字典）
-- 3. 可以放其他背包（嵌套）
-- 4. 甚至可以放"使用说明"（函数）

-- 实际示例：一个表可以表示一个游戏角色
local player = {
    name = "小明",		-- 字符串键
    level = 10,			-- 字符串键
    health = 100,		-- 字符串键
    ["武器类型"] = "剑",	-- 包含特殊字符的键
    [123] = "编号",		-- 数字键
    is_online = true	-- 布尔值键
}

print("玩家姓名: " .. player.name)		-- 小明
print("玩家等级: " .. player.level)		-- 10
print("特殊键: " .. player["武器类型"])	-- 剑
print("数字键: " .. player[123])			-- 编号
```

## 7.2 表的创建和初始化

### 7.2.1 创建空表

```lua
-- 创建空表
local empty_table = {}  -- 最简单的空表

-- 检查表是否为空
print("空表大小: " .. #empty_table)  -- 输出: 0
print("空表类型: " .. type(empty_table))  -- 输出: table
```

### 7.2.2 使用构造器初始化表
#### 作为数组（列表）使用
```lua
-- 注意：Lua的数组索引从1开始！
local monsters = {"僵尸", "骷髅", "蜘蛛", "土匪"}
print("第一个怪物: " .. monsters[1])	-- 僵尸
print("怪物数量: " .. #monsters)		-- 4
```

#### 作为字典（映射）使用
```lua
local player = {
    name = "李雷",
    age = 18,
    class = "战士",
    level = 5
}
print("玩家: " .. player.name)		-- 李雷
print("职业: " .. player["class"])	-- 战士

-- 使用方括号的复杂键
local complex_keys = {
    ["full name"] = "张三",		-- 包含空格的键
    ["score-100"] = 95,			-- 包含连字符的键
    [true] = "布尔键",			-- 布尔值作为键
    [function() end] = "函数键"  -- 函数作为键（不常见但可能）
}

print(complex_keys["full name"])  -- 张三
print(complex_keys[true])         -- 布尔键
```

#### 混合使用（数组部分+字典部分）
```lua
local mixed = {
    "第一个元素",    -- 数组部分，索引1
    "第二个元素",    -- 数组部分，索引2

    author = "小明",	-- 字典部分，键"author"
    version = 1.0	-- 字典部分，键"version"
}
print(mixed[1])            -- 第一个元素
print(mixed.author)        -- 小明
```

#### 嵌套表
```lua
local game_world = {
    name = "魔法世界",
    players = {
        {name = "战士", level = 10},
        {name = "法师", level = 8}
    },
    settings = {
        difficulty = "normal",
        sound = true,
        graphics = "high"
    }
}

print("游戏世界: " .. game_world.name)	-- 魔法世界
print("第一个玩家: " .. game_world.players[1].name)  -- 战士
print("难度设置: " .. game_world.settings.difficulty)  -- normal
```

### 7.2.3 表的引用特性
表传递引用是因为它**可能很大且需要共享修改（多个变量操作一个表）**，传递指针更高效。

```lua
-- 重要概念：表是引用类型
local original = {x = 10, y = 20}
local reference = original  -- 不是复制，是引用同一个表

reference.x = 100  -- 修改引用也会影响原始表
print("original.x = " .. original.x)  -- 100

-- 如果需要复制表，需要手动操作（后面会讲）

-- 表的相等比较是比较引用，不是内容
local a = {1, 2, 3}
local b = {1, 2, 3}
local c = a

print("a == b ? " .. tostring(a == b))  -- false（不同对象）
print("a == c ? " .. tostring(a == c))  -- true（同一对象）
```

## 7.3 表的操作

### 7.3.1 直接修改与增加元素

我们可以直接通过等于号来增加与修改元素，缺点是数组必须要知道增加位置。

```lua
-- 列表
local monsters = {"僵尸", "骷髅", "蜘蛛", "土匪"}
monsters[1] = "恶魔"
print("第一个怪物: " .. monsters[1])	-- 恶魔

-- 字典
-- 创建空表
local inventory = {}

-- 添加元素到字典部分
inventory["gold"] = 100
-- inventory.gold = 100  -- 等价写法
inventory.silver = 50
inventory.copper = 200

for k, v in pairs(inventory) do
	print(k .. ": " .. v)
end
--[[ 输出
copper: 200
silver: 50
gold: 100
--]]
```

### 7.3.2 table.insert - 插入元素到数组

table.insert 会在数组的指定位置插入一个新元素，并将该位置及之后的元素依次后移。

```lua
-- 不指定增加位置
table.insert(表: table, 元素: any)
-- 指定增加位置
table.insert(表: table, 增加位置: any, 元素: any)
```
- 增加位置默认为数组末尾

#### 示例
```lua
local inventory = {}

-- 添加元素到数组末尾
print("添加元素到数组末尾")
table.insert(inventory, "药水")
table.insert(inventory, "钥匙")
inventory[#inventory + 1] = "地图" -- 等价写法

-- 修改元素
inventory.gold = 150 -- 修改现有元素
inventory[2] = "万能钥匙" -- 修改数组部分

print("库存:")
for k, v in pairs(inventory) do
    print(k .. ": " .. v)
end

print("\n插入元素 “剑” 到数组第二个索引，将元素 2 后移。")
table.insert(inventory, 2, "剑")

print("库存:")
for k, v in pairs(inventory) do
    print(k .. ": " .. v)
end
--[[ 输出
插入元素到数组末尾
库存:
1: 药水
2: 万能钥匙
3: 地图
gold: 150

添加元素 “剑” 到数组第二个索引，将元素 2 后移
库存:
1: 药水
2: 剑
3: 万能钥匙
4: 地图
gold: 150
--]]

-- 示例：模拟queue（队列）操作
local queue = {}

local function enqueue(item)
    table.insert(queue, item)
end

local function dequeue()
    if #queue > 0 then
        return table.remove(queue, 1)
    end

    return nil
end

-- 测试队列
enqueue("任务1")
enqueue("任务2")
enqueue("任务3")

print("\n队列操作:")
print("出队: " .. dequeue()) -- 任务1
print("出队: " .. dequeue()) -- 任务2
print("当前队列长度: " .. #queue) -- 1
--[[ 输出
出队: 任务1
出队: 任务2
当前队列长度: 1
--]]
```

### 7.3.3 table.remove - 移除数组元素

table.remove 用于移除数组中指定位置的元素，并将后续元素前移以填补空缺，保持数组的连续性。

```lua
table.remove(表: table, 删除位置?: int) -> 删除的元素: any
```
- 移除位置默认为数组末尾

#### 示例
```lua
-- 1. 直接删除，缺点：删除数组元素后数组有 “洞”
local items = {
    "剑",
    "盾",
    "药水",
    "钥匙",
    "地图",
    gold = 100,
    weight = 50
}

print("原始物品:")
for k, v in pairs(items) do
    print(k .. ": " .. v)
end

-- 删除数组元素
items[2] = nil -- 删除第二个元素（盾）
print("\n删除盾牌后:")
for k, v in pairs(items) do
    print(k .. ": " .. v)
end

-- 注意：设置nil不会自动调整数组
-- 数组部分可能会有"洞"
print("\n有洞的数组遍历（ipairs会在第一个nil停止）:")
for i, v in ipairs(items) do
    print(i .. ": " .. v)
end

-- 删除字典元素
items.gold = nil
print("\n删除金币后:")
for k, v in pairs(items) do
    print(k .. ": " .. v)
end
--[[ 删除
原始物品:
1: 剑
2: 盾
3: 药水
4: 钥匙
5: 地图
weight: 50
gold: 100

删除盾牌后:
1: 剑
3: 药水
4: 钥匙
5: 地图
weight: 50
gold: 100

有洞的数组遍历（ipairs会在第一个nil停止）:
1: 剑

删除金币后:
1: 剑
3: 药水
4: 钥匙
5: 地图
weight: 50
--]]

-- 2. 使用 table.remove 移除后自动调整数组
local items = {
    "剑",
    "盾",
    "药水",
    "钥匙",
    "地图",
    gold = 100,
    weight = 50
}

local removed = table.remove(items, 2)	-- 移除第二个索引的元素（盾）

print("移除了" .. removed .. "，现在第二个索引的元素:" .. items[2])

print("ipairs 遍历（table.remove 自动补洞）:")
for i, v in ipairs(items) do
    print(i .. ": " .. v)
end
--[[ 输出
移除了盾，现在第二个索引的元素: 药水

ipairs 遍历（table.remove 自动补洞）:
1: 剑
2: 药水
3: 钥匙
4: 地图
--]]

-- 实际游戏中删除物品的例子
local backpack = {
    "红药水", "蓝药水", "传送卷轴", "回城卷轴", "解毒剂"
}

function remove_item(container, item_name)
    for i = #container, 1, -1 do  -- 从后往前遍历，避免索引变化问题
        if container[i] == item_name then
            table.remove(container, i)
            print("已移除: " .. item_name)
            return true
        end
    end
    
    print("未找到物品: " .. item_name)
    
    return false
end

print("\n背包内容:")
for i, v in ipairs(backpack) do
    print("  " .. i .. ": " .. v)
end

remove_item(backpack, "传送卷轴")
remove_item(backpack, "不存在的物品")

print("\n移除后的背包:")
for i, v in ipairs(backpack) do
    print("  " .. i .. ": " .. v)
end
--[[ 输出
背包内容:
  1: 红药水
  2: 蓝药水
  3: 传送卷轴
  4: 回城卷轴
  5: 解毒剂
已移除: 传送卷轴
未找到物品: 不存在的物品

移除后的背包:
  1: 红药水
  2: 蓝药水
  3: 回城卷轴
  4: 解毒剂
--]]
```

### 7.3.4 查询元素

```lua
local game_data = {
    players = {
        {name = "小明", score = 1000},
        {name = "小红", score = 850},
        {name = "小刚", score = 920}
    },
    settings = {
        sound = {volume = 70, enabled = true},
        graphics = {quality = "high", resolution = "1920x1080"}
    }
}

-- 检查键是否存在
print("检查键是否存在:")
print("有players键吗? " .. tostring(game_data.players ~= nil))  -- true
print("有monsters键吗? " .. tostring(game_data.monsters ~= nil))  -- false
```

#### 使用逻辑运算符安全的访问表
```lua
-- 注意：表中不存在的键值对都是 nil
-- 使用 game_data.players[1] 如果没有 game_data.players 将会报错，因为 game_data.players 是 nil，nil 无法索引

-- 安全的访问方式：使用逻辑运算符短路求值，如果判断到不存在的键直接停止后续逻辑运算
local player_name = game_data.players and game_data.players[1] and game_data.players[1].name
print("第一个玩家: " .. (player_name or "未知"))
```

### 7.3.5 表的长度运算符符

```lua
-- #操作符用于获取表的数组部分的长度
-- 注意：它只在数组部分是连续的且从1开始时才准确

-- 连续数组
local arr1 = {1, 2, 3, 4, 5}
print("arr1长度: " .. #arr1)  -- 5

-- 有"洞"的数组
local arr2 = {1, nil, 3, 4, 5}
print("arr2长度（有洞）: " .. #arr2)  -- 1（遇到第一个nil就停止）

local arr3 = {1, 2, 3}
arr3[5] = 5
print("arr3长度（不连续）: " .. #arr3)  -- 3（只计算连续部分）

-- 字典部分不影响长度
local mixed = {
    "a", "b", "c",
    name = "测试",
    value = 100
}
print("mixed长度: " .. #mixed)  -- 3（只计算数组部分）

-- 安全获取表长度的方法
function table_length(t)
    local count = 0
    for _ in pairs(t) do
        count = count + 1
    end
    return count
end

local test_table = {a = 1, b = 2, c = 3, d = 4}
print("表总元素数: " .. table_length(test_table))  -- 4
print("数组长度操作符: " .. #test_table)          -- 0（没有数组部分）
```

#### 示例
```lua
-- 实际应用：统计玩家数量
local players = {
    {name = "玩家1", ready = true},
    {name = "玩家2", ready = false},
    {name = "玩家3", ready = true},
    {name = "玩家4", ready = true}
}

print("玩家总数: " .. #players)
print("就绪玩家数: " .. (function()
    local count = 0
    for _, player in ipairs(players) do
        if player.ready then
            count = count + 1
        end
    end
    return count
end)())
```

## 7.4 表遍历

### 7.4.1 ipairs - 遍历数组部分

```lua
-- ipairs用于遍历数组部分（索引从1开始，连续）
local colors = {"红色", "绿色", "蓝色", "黄色", "紫色"}

print("使用ipairs遍历:")
for index, color in ipairs(colors) do
    print("  颜色" .. index .. ": " .. color)
end

-- ipairs在遇到nil时会停止
local with_holes = {"第一", nil, "第三", "第四"}
print("\n有洞的数组，ipairs遍历:")
for i, v in ipairs(with_holes) do
    print("  " .. i .. ": " .. v)
end
-- 只会输出: 1: 第一
```

#### 示例
```lua
-- 实际游戏示例：遍历技能列表
local skills = {
    {name = "火球术", damage = 30, mana_cost = 10},
    {name = "治疗术", heal = 50, mana_cost = 15},
    {name = "冰箭术", damage = 25, mana_cost = 8, slow = true}
}

print("\n技能列表:")

for i, skill in ipairs(skills) do
    print("  技能" .. i .. ": " .. skill.name)
    if skill.damage then
        print("    伤害: " .. skill.damage)
    end
    if skill.heal then
        print("    治疗: " .. skill.heal)
    end
    print("    消耗法力: " .. skill.mana_cost)
end
```

### 7.4.2 pairs - 遍历所有元素

```lua
-- pairs遍历表的所有键值对（包括数组和字典部分）
local student = {
    "小明",                -- 数组部分，索引1
    age = 18,              -- 字典部分
    grade = "高三",        -- 字典部分
    "男",                  -- 数组部分，索引2
    ["出生日期"] = "2005-03-15"  -- 字典部分
}

print("使用pairs遍历:")
for key, value in pairs(student) do
    print("  " .. tostring(key) .. ": " .. tostring(value))
end
-- 注意：pairs的遍历顺序是无序的！
```

#### 对比ipairs和pairs
```lua
local data = {
    "第一个",
    "第二个",
    key1 = "值1",
    "第三个",
    key2 = "值2"
}

print("\n使用ipairs遍历:")
for i, v in ipairs(data) do
    print("  " .. i .. ": " .. v)  -- 只输出数组部分：1,2,3
end

print("\n使用pairs遍历:")
for k, v in pairs(data) do
    print("  " .. tostring(k) .. ": " .. tostring(v))  -- 输出所有键值对
end
```

#### 示例
```lua
-- 实际应用：遍历物品栏
local inventory = {
    gold = 150,
    silver = 300,
    ["生命药水"] = 5,
    ["魔法药水"] = 3,
    weapons = {"木剑", "铁盾"}
}

print("\n物品栏内容:")

for item, amount in pairs(inventory) do
    if type(amount) == "number" then
        print("  " .. item .. ": " .. amount)
    elseif type(amount) == "table" then
        print("  " .. item .. ":")
        
        for i, weapon in ipairs(amount) do
            print("    " .. i .. ". " .. weapon)
        end
    end
end
```

### 7.4.3 自定义遍历顺序

```lua
-- 由于 pairs 遍历顺序不确定，有时我们需要特定顺序
local scores = {
    ["小明"] = 85,
    ["小红"] = 92,
    ["小刚"] = 78,
    ["李雷"] = 88,
    ["韩梅梅"] = 95
}

-- 方法1：先收集键，然后排序
print("按名字排序输出:")

local keys = {}

for name in pairs(scores) do
    table.insert(keys, name)
end

table.sort(keys)  -- 按字母顺序排序

for _, name in ipairs(keys) do
    print("  " .. name .. ": " .. scores[name])
end

-- 方法2：按分数排序
print("\n按分数从高到低排序:")
local entries = {}
for name, score in pairs(scores) do
    table.insert(entries, {name = name, score = score})
end

-- 自定义排序函数
table.sort(entries, function(a, b)
    return a.score > b.score  -- 降序排列
end)

for i, entry in ipairs(entries) do
    print("  " .. i .. ". " .. entry.name .. ": " .. entry.score)
end
```

#### 示例
```lua
-- 实际应用：游戏排行榜
local leaderboard = {
    {name = "Player1", score = 15000, time = 360},
    {name = "Player2", score = 12000, time = 420},
    {name = "Player3", score = 18000, time = 300},
    {name = "Player4", score = 9000, time = 500}
}

-- 按分数降序，分数相同时按时间升序
table.sort(leaderboard, function(a, b)
    if a.score == b.score then
        return a.time < b.time  -- 时间少的排在前面
    end
    
    return a.score > b.score  -- 分数高的排在前面
end)

print("\n游戏排行榜:")
for rank, player in ipairs(leaderboard) do
    print(string.format("  第%d名: %s (分数: %d, 时间: %d秒)", 
          rank, player.name, player.score, player.time))
end
```

## 7.5 表相关函数

Lua 提供了几个内置函数来操作表。

### 7.5.1 table.concat - 连接为字符串

```lua
table.concat(列表: list, 分隔符?: str, 起始位置?: int, 结束位置?: int)
```
- 不指定分隔符则直接进行连接
- 不指定起始位置与结束位置默认连接所有元素

#### 示例
```lua
-- table.concat用于连接数组部分的元素
local words = {"Hello", "Lua", "World", "!"}

-- 简单连接
local sentence = table.concat(words)
print("简单连接: " .. sentence)  -- HelloLuaWorld!

-- 用分隔符连接
sentence = table.concat(words, " ")
print("空格分隔: " .. sentence)  -- Hello Lua World !

-- 指定起始和结束位置
sentence = table.concat(words, ", ", 2, 3)
print("部分连接: " .. sentence)  -- Lua, World

-- 实际应用：构建路径
local path_parts = {"home", "user", "projects", "lua", "main.lua"}
local path = table.concat(path_parts, "/")
print("文件路径: " .. path)  -- home/user/projects/lua/main.lua

-- 构建SQL查询条件
local conditions = {"age > 18", "status = 'active'", "score >= 60"}
local where_clause = table.concat(conditions, " AND ")
print("SQL条件: WHERE " .. where_clause)

-- 构建HTML列表
local items = {"苹果", "香蕉", "橙子"}
local html_list = "<ul>\n"
for i, item in ipairs(items) do
    html_list = html_list .. "  <li>" .. item .. "</li>\n"
end
html_list = html_list .. "</ul>"
print("\nHTML列表:\n" .. html_list)
```

### 7.5.2 table.sort - 排序

#### 语法
```lua
table.sort(单结构表: list|dict, 匿名函数?: func)
```
- 不指定匿名函数则对于字符串将会以字母升序排序，数字以大小升序排序
- 为匿名函数传递比较的两个值，匿名函数必须返回布尔值，为真排序在前，为假排序在后

#### 示例
```lua
-- table.sort用于对数组部分进行排序
local numbers = {5, 2, 8, 1, 9, 3}

print("原始数组: " .. table.concat(numbers, ", "))

-- 默认排序（升序）
table.sort(numbers)
print("升序排序: " .. table.concat(numbers, ", "))

-- 降序排序
table.sort(numbers, function(a, b)
    return a > b
end)
print("降序排序: " .. table.concat(numbers, ", "))
--[[ 输出
原始数组: 5, 2, 8, 1, 9, 3
升序排序: 1, 2, 3, 5, 8, 9
降序排序: 9, 8, 5, 3, 2, 1
--]]

-- 字符串排序
local letter = { "b", "a", "c", "y", "z", "x" }
table.sort(letter)
print("\n字母排序: " .. table.concat(letter, ", "))
--[[ 输出
字母排序: a, b, c, x, y, z
--]]

-- 复杂数据排序
local students = {
    {name = "小明", score = 85, age = 18},
    {name = "小红", score = 92, age = 17},
    {name = "小刚", score = 78, age = 19},
    {name = "李雷", score = 85, age = 18}
}

-- 按分数降序，分数相同时按名字升序
table.sort(students, function(a, b)
    if a.score == b.score then
        return a.name < b.name
    end
    
    return a.score > b.score
end)

print("\n学生排名:")
for i, student in ipairs(students) do
    print(string.format("  第%d名: %s (分数: %d, 年龄: %d)", 
          i, student.name, student.score, student.age))
end

-- 自定义排序：按字符串长度
local words = {"apple", "banana", "cat", "elephant", "dog"}

table.sort(words, function(a, b)
    return #a < #b  -- 按长度升序
end)

print("\n按长度排序: " .. table.concat(words, ", "))
```

## 7.6 表的高级用法

### 7.6.1 表的复制

#### 浅复制（浅拷贝）
```lua
-- 浅拷贝（只复制一层）
local function shallow_copy(original)
    local copy = {}
    
    for k, v in pairs(original) do
        copy[k] = v
    end
    
    return copy
end

-- 测试复制
local original = {
    name = "原始表",
    data = {1, 2, 3},
    nested = {
        a = "A",
        b = {x = 10, y = 20}
    }
}

local shallow = shallow_copy(original)

-- 修改原表
original.name = "修改后的原表"
original.data[1] = 100
original.nested.b.x = 999

print("浅复制测试:")
print("  原表.name: " .. original.name)  -- 修改后的原表
print("  浅复制.name: " .. shallow.name)  -- 原始表（字符串被复制）
print("  原表.data[1]: " .. original.data[1])  -- 100
print("  浅复制.data[1]: " .. shallow.data[1])  -- 100（表是引用！）
```

#### 深复制（深拷贝）
```lua
-- 深复制（复制所有嵌套结构）
local function deep_copy(original, seen)
    seen = seen or {}
    
    if type(original) ~= "table" then
        return original
    end
    
    if seen[original] then
        return seen[original]
    end
    
    local copy = {}
    seen[original] = copy
    
    for k, v in pairs(original) do
        copy[deep_copy(k, seen)] = deep_copy(v, seen)
    end
    
    return copy
end

-- 测试复制
local original = {
    name = "原始表",
    data = {1, 2, 3},
    nested = {
        a = "A",
        b = {x = 10, y = 20}
    }
}

local deep = deep_copy(original)

-- 修改原表
original.name = "修改后的原表"
original.data[1] = 100
original.nested.b.x = 999

print("\n深复制测试:")
print("  深复制.name: " .. deep.name)  -- 原始表
print("  深复制.data[1]: " .. deep.data[1])  -- 1（独立副本）
print("  深复制.nested.b.x: " .. deep.nested.b.x)  -- 10（独立副本）
```

### 7.6.2 表的合并

#### 浅合并
```lua
-- 合并两个表（浅合并）
local function shallow_merge(t1, t2)
    local result = {}
    
    for k, v in pairs(t1) do
        result[k] = v
    end
    
    for k, v in pairs(t2) do
        result[k] = v
    end
    
    return result
end

-- 测试合并
local defaults = {
    sound = true,
    volume = 70,
    graphics = {
        quality = "medium",
        resolution = "1280x720"
    }
}

local user_settings = {
    volume = 80,
    language = "中文",
    graphics = {
        resolution = "1920x1080",
        shadows = true
    }
}

local merged = shallow_merge(defaults, user_settings)

print("合并后的设置:")
for k, v in pairs(merged) do
    if type(v) == "table" then
        print("  " .. k .. ":")
        
        for k2, v2 in pairs(v) do
            print("    " .. k2 .. ": " .. tostring(v2))
        end
    else
        print("  " .. k .. ": " .. tostring(v))
    end
end
--[[ 输出
合并后的设置:
  language: 中文
  volume: 80
  sound: true
  graphics:
    shadows: true
    resolution: 1920x1080
--]]
```

#### 深合并
```lua
-- 深度合并
local function deep_merge(t1, t2)
    local result = {}
    
    for k, v in pairs(t1) do
        result[k] = v
    end
    
    for k, v in pairs(t2) do
        if type(result[k]) == "table" and type(v) == "table" then
            result[k] = deep_merge(result[k], v)
        else
            result[k] = v
        end
    end
    
    return result
end

-- 测试合并
local defaults = {
    sound = true,
    volume = 70,
    graphics = {
        quality = "medium",
        resolution = "1280x720"
    }
}

local user_settings = {
    volume = 80,
    language = "中文",
    graphics = {
        resolution = "1920x1080",
        shadows = true
    }
}

local merged = deep_merge(defaults, user_settings)

print("合并后的设置:")
for k, v in pairs(merged) do
    if type(v) == "table" then
        print("  " .. k .. ":")
        
        for k2, v2 in pairs(v) do
            print("    " .. k2 .. ": " .. tostring(v2))
        end
    else
        print("  " .. k .. ": " .. tostring(v))
    end
end
--[[ 输出
合并后的设置:
  language: 中文
  volume: 80
  sound: true
  graphics:
    shadows: true
    quality: medium
    resolution: 1920x1080
--]]
```

### 7.6.3 表作为对象使用

#### 示例
```lua
-- 表可以存储函数，模拟对象
local player = {
    name = "英雄",
    health = 100,
    level = 1
}

-- 添加方法，注意：这里使用冒号定义
function player:take_damage(amount)
    self.health = self.health - amount
    
    if self.health < 0 then
        self.health = 0
        print(self.name .. " 倒下了！")
    else
        print(self.name .. " 受到 " .. amount .. " 点伤害，剩余生命: " .. self.health)
    end
end
-- 以上代码等价于，由于这里是定义到表内的，所以不分局部与全局函数
function player.take_damage(self, amount)
    self.health = self.health - amount
    
    if self.health < 0 then
        self.health = 0
        print(self.name .. " 倒下了！")
    else
        print(self.name .. " 受到 " .. amount .. " 点伤害，剩余生命: " .. self.health)
    end
end

function player:heal(amount)
    self.health = self.health + amount
    print(self.name .. " 恢复了 " .. amount .. " 点生命，当前生命: " .. self.health)
end

function player:level_up()
    self.level = self.level + 1
    self.health = self.health + 20
    print(self.name .. " 升级到 " .. self.level .. " 级！")
end

-- 使用冒号调用方法
player:take_damage(30)  -- 英雄 受到 30 点伤害，剩余生命: 70
player:heal(10)         -- 英雄 恢复了 10 点生命，当前生命: 80
player:level_up()       -- 英雄 升级到 2 级！
-- 以上代码等价于（需要显式传递self）
player.take_damage(player, 30)
player.heal(player, 10)
player.level_up(player)

-- 创建多个"实例"
local function create_player(name)
    local new_player = {
        name = name,
        health = 100,
        level = 1
    }
    
    -- 使用方法共享（避免每个对象都复制方法）
    new_player.take_damage = player.take_damage
    new_player.heal = player.heal
    new_player.level_up = player.level_up
    
    return new_player
end

local player1 = create_player("战士")
local player2 = create_player("法师")

player1:take_damage(40)  -- 战士 受到 40 点伤害，剩余生命: 60
player2:level_up()       -- 法师 升级到 2 级！
```

#### 冒号语法糖
可以使用语法糖 `:` 冒号来隐式传递 `self` 参数。

```lua
-- 定义函数
function player:take_damage(amount) ... end
-- 这等价于
function player.take_damage(self, amount) ... end

-- 调用函数
player:take_damage(40)
-- 这等价于
player.take_damage(player, 40)
```

### 7.6.4 元表（Metatable）基础

```lua
-- 元表可以改变表的默认行为
-- 这是Lua最强大的特性之一，我们这里先简单介绍

-- 实现向量加法
-- 创建两个表
local v1 = {x = 10, y = 20}
local v2 = {x = 5, y = 15}

-- 默认情况下，表不能直接相加
-- print(v1 + v2)  -- 错误：尝试对表进行算术运算

-- 创建元表
local mt = {}

-- 定义元表的__add方法（用于加法）
mt.__add = function(a, b)
    return {
        x = a.x + b.x,
        y = a.y + b.y
    }
end

-- 设置元表
setmetatable(v1, mt)
setmetatable(v2, mt)

-- 现在表可以相加了！
local v3 = v1 + v2
print("v1 + v2 = {x=" .. v3.x .. ", y=" .. v3.y .. "}")  -- {x = 15, y = 35}
```

## 7.7 练习

### 练习 1：简单的联系人管理系统
（答案见 [[第 1 节 - 语法/参考答案#练习 7 1：简单的联系人管理系统]]）
```lua
-- 实现一个简单的联系人管理系统，要求：可增加联系人到通讯录，可读取联系人，可以打印通讯录所有联系人
-- 使用示例：
-- 测试联系人管理系统
add_contact("张三", "13800138000", "zhangsan@email.com")
add_contact("李四", "13900139000")
add_contact("王五", "13700137000", "wangwu@company.com")

list_contacts()

find_contact("张三")
find_contact("赵六")

remove_contact("李四")
list_contacts()

--[[ 输出
=== 联系人管理系统 ===
已添加联系人: 张三
已添加联系人: 李四
已添加联系人: 王五
通讯录为空
找到联系人 张三:
  电话: 17300138000
  邮箱: zhangsan@email.com
未找到联系人: 赵六
已删除联系人: 李四
通讯录为空
--]]
```

### 练习 2：购物车系统
（答案见 [[第 1 节 - 语法/参考答案#练习 7 2：购物车系统]]）
```lua
-- 实现一个购物车系统，可以向购物车增加与移除商品，然后通过购物车购买，买完清空购物车，要求：自行查资料使用 string.format 格式化价格，让价格仅保留两位小数与对齐（%宽度.小数位数f）
-- 使用示例：
-- 测试购物车系统
print("=== 购物车系统 ===")
shopping_cart:add_item("苹果", 5.5, 2)
shopping_cart:add_item("香蕉", 3.2, 3)
shopping_cart:add_item("苹果", 5.5, 1)  -- 增加苹果数量

shopping_cart:show_cart()

shopping_cart:remove_item("香蕉", 1)  -- 减少香蕉数量

shopping_cart:show_cart()

shopping_cart:clear()
shopping_cart:show_cart()

--[[ 输出
== 购物车系统 ===
已添加商品: 苹果 x2
已添加商品: 香蕉 x3
已更新商品: 苹果 x1
=== 购物车 ===
1. 苹果          单价:   5.50 数量:   3 小计:    16.50
2. 香蕉          单价:   3.20 数量:   3 小计:     9.60

总计: 38.90 元
已减少商品: 香蕉 x1，剩余: x2
=== 购物车 ===
1. 苹果          单价:   5.50 数量:   3 小计:    16.50
2. 香蕉          单价:   3.20 数量:   2 小计:     6.40

总计: 35.70 元
已清空购物车
购物车为空
--]]
```

## 7.8 本章总结

### 关键知识点回顾

1. **表的创建和初始化**：
	- 使用 `{}` 创建空表
	- 构造器语法可以初始化数组和字典部分
	- 表是引用类型，赋值传递的是引用

2. **表的操作**：
	- 增：有洞直接赋值，无洞使用 `table.insert`
	- 删：有洞设为 `nil` ，无洞使用 `table.remove`
	- 查：通过键访问，注意处理 `nil` 值
	- 长度：`#` 操作符只计算数组部分

3. **表遍历**：
	- `ipairs`：遍历连续数组部分（索引从 1 开始）
	- `pairs`：遍历所有键值对（顺序不确定）
	- 自定义排序遍历

4. **相关函数**
	- `table.concat` 将表连接为字符串
	- `table.sort` 表排序，匿名函数传递两个参数

5. **高级用法**：
	- 表的复制（浅复制和深复制）
	- 表的合并
	- 表作为对象使用（存储函数）
	- 使用语法糖 `:` 冒号来隐式传递 `self` 参数
	- 元表基础（改变表的默认行为）

### 表的设计模式

```lua
-- 模式 1：配置对象
local config = {
    window = {
        width = 800,
        height = 600,
        title = "我的游戏"
    },
    player = {
        speed = 5,
        health = 100
    }
}

-- 模式 2：数据记录
local student = {
    id = 1001,
    name = "小明",
    scores = {85, 92, 78},
    average = function(self)
        local sum = 0
        
        for _, score in ipairs(self.scores) do
            sum = sum + score
        end
        
        return sum / #self .scores
    end
}

-- 模式 3：命名空间（模块模式）
local math_utils = {}

function math_utils.clamp(value, min, max)
    if value < min then return min end
    if value > max then return max end
    
    return value
end

function math_utils.lerp(a, b, t)
    return a + (b - a) * t
end

-- 使用
local value = math_utils.clamp(150, 0, 100)  -- 100
```

### 常见错误

```lua
-- 错误 1：误用 #操作符
local t = {}
t[100] = "值"
print( #t )  -- 0，不是 100！

-- 错误 2：在循环中修改表
local items = {1, 2, 3, 4, 5}
for i, v in ipairs(items) do
    if v == 2 then
        table.remove(items, i)  -- 这会导致跳过下一个元素
    end
end

-- 正确做法：从后往前遍历
for i = #items , 1, -1 do
    if items[i] == 2 then
        table.remove(items, i)
    end
end

-- 错误 3：忘记表的引用特性
local original = {data = {1, 2, 3}}
local copy = original  -- 这只是引用，不是复制！
copy.data[1] = 100  -- 也会修改 original

-- 错误 4：混合数组和字典时的不当操作
local mixed = {1, 2, 3, a = "A"}
table.sort(mixed)  -- 错误：不能对混合表排序！

local dict = {a = 1, b = 2}
local l = #dict		-- 错误：长度运算符仅适用于字符串与列表，这里 l = 0
```

### 性能优化建议

```lua
-- 1. 预分配大数组（如果知道大小）
local big_array = {}
for i = 1, 10000 do
    big_array[i] = 0  -- 避免多次重新分配
end

-- 2. 避免在循环中多次计算表长度
local items = {1, 2, 3, 4, 5}
local length = #items  -- 先计算一次
for i = 1, length do
    -- 使用缓存的值
end

-- 3. 使用局部引用访问嵌套表的深层元素
local config = {
    game = {
        settings = {
            graphics = {
                quality = "high"
            }
        }
    }
}

-- 不好：多次查找
print(config.game.settings.graphics.quality)
print(config.game.settings.graphics.resolution)

-- 好：使用局部引用
local graphics = config.game.settings.graphics
print(graphics.quality)
print(graphics.resolution)

-- 4. 选择合适的遍历方式
-- ipairs 比 pairs 快（只遍历数组部分）
-- 如果需要遍历所有元素，但表主要是数组，先用 ipairs
```

### 检查清单
（点击勾选框勾选）
完成本章后，你应该能够：
- [ ] 创建和初始化各种类型的表
- [ ] 对表进行增删改查操作
- [ ] 正确遍历表的数组部分和所有元素
- [ ] 使用表相关内置函数
- [ ] 实现表的浅复制和深复制
- [ ] 使用表模拟对象和命名空间
- [ ] 理解元表的基本概念
- [ ] 设计和使用复杂的数据结构

### 思考题

1. Lua 为什么选择表作为唯一的数据结构？这种设计有什么优缺点？
2. 什么情况下应该使用数组形式的表，什么情况下应该使用字典形式的表？
3. 表的引用特性在什么情况下是有用的，什么情况下会带来问题？
4. 如何设计一个高效的表来存储大量数据？
5. 元表能实现哪些强大的功能？你能想到什么实际应用场景？

### 拓展练习

1. 实现一个简单的数据库系统，支持增删改查操作
2. 创建一个图数据结构，支持添加节点、边和路径查找
3. 创建一个事件系统，支持事件的注册、触发和取消

---

**下一章预告**：在第 8 章中，我们将学习字符串处理。字符串是编程中无处不在的数据类型，Lua 提供了强大的字符串操作功能，包括基础操作和强大的模式匹配（类似正则表达式但更简洁）。我们将学习如何创建、操作、搜索和格式化字符串。

**学习建议**：
1. 多练习表的创建和操作，这是 Lua 的核心
2. 尝试用表解决各种实际问题
3. 理解表的引用特性，避免常见错误
4. 学习表的性能特点，编写高效的代码
5. 探索表的高级用法，特别是作为对象和模块的使用