**本篇为所有练习的参考答案，下滑查看**
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-

### **练习 2.2**：判断以下哪些是合法的标识符：
1. `playerName` ✓
2. `2ndPlayer` ✗（以数字开头）
3. `player_score` ✓
4. `local` ✗（关键字）
5. `_internal` ✓
6. `my-var` ✗（包含连字符）

### 练习 2.3：创建一个自我介绍程序
```lua
-- 基本信息
local name = "张三"
local age = 25
local interests = "编程、游戏、阅读"
local goal = "掌握Lua编程，开发自己的小游戏"

-- 输出信息
print("姓名: " .. name)
print("年龄: " .. age .. "岁")
print("兴趣爱好: " .. interests)
print("学习目标: " .. goal)
```

### 练习 3.1：数据类型识别
```lua
local function describe_value(value)
    local t = type(value)
    local description
    
    if t == "nil" then
        description = "空值"
    elseif t == "boolean" then
        description = "布尔值"
    elseif t == "number" then
        description = "数字"
    elseif t == "string" then
        description = "字符串"
    elseif t == "table" then
        description = "表"
    elseif t == "function" then
        description = "函数"
    end
    
    print(description)
end

-- 测试输出
describe_value(nil)				-- 输出 空值
describe_value(true)			-- 输出 布尔值
describe_value(123)				-- 输出 数字
describe_value("string")		-- 输出 字符串
describe_value({1, 2, 3})		-- 输出 表
describe_value(describe_value)	-- 输出 函数
```

### 练习 4.1：简单计算器
```lua
local operator = "+"	-- 模拟用户输入
local a = 5
local b = 3

if operator == "+" then
	print(a + b)
elseif operator == "-" then
	print(a - b)
elseif operator == "*" then
	print(a * b)
elseif operator == "/" then
	print(a / b)
elseif operator == "%" then
	print(a % b)
elseif operator == "^" then
	print(a ^ b)
end
```

### 练习 5.1：猜数字游戏
```lua
print("我已经想好了一个1-100之间的数字")

-- 生成随机数
math.randomseed(os.time())  -- 设置随机种子
local random_number = math.random(1, 100)
local guess_count = 0
local max_guesses = 4

print("你有" .. max_guesses .. "次机会猜中这个数字")

while guess_count < max_guesses do
    guess_count = guess_count + 1
    local remaining_guesses = max_guesses - guess_count + 1
    
    print("\n第" .. guess_count .. "次尝试，还剩" .. remaining_guesses .. "次机会")
    print("请输入你的猜测（1-100）:")
    
    -- 模拟用户输入
    local guess
    if guess_count == 1 then
        guess = 50  -- 第一次猜50
    elseif guess_count == 2 then
        guess = 25  -- 第二次猜25
    else
        guess = secret_number  -- 第三次猜中
    end
    
    print("你猜的是：" .. guess)
    
    if guess < secret_number then
        print("太小了！")
    elseif guess > secret_number then
        print("太大了！")
    else
        print("恭喜你！猜对了！")
        print("你用了" .. guess_count .. "次猜中数字" .. secret_number)
        break
    end
    
    if guess_count == max_guesses then
        print("\n很遗憾，你没有在" .. max_guesses .. "次内猜中")
        print("正确答案是：" .. secret_number)
    end
end

print("游戏结束")
--[[ 输出
我已经想好了一个1-100之间的数字
你有4次机会猜中这个数字

第1次尝试，还剩10次机会
请输入你的猜测（1-100）:
你猜的是：50
太大了！

第2次尝试，还剩9次机会
请输入你的猜测（1-100）:
你猜的是：25
太小了！

第3次尝试，还剩8次机会
请输入你的猜测（1-100）:
你猜的是：26
恭喜你！猜对了！
你用了3次猜中数字26
游戏结束
--]]
```

### 练习 5.2：打印图形
```lua
-- 1. 打印直角三角形
print("\n1. 直角三角形:")
local height = 5
for i = 1, height do
    for j = 1, i do
        io.write("* ")
    end
    
    print()
end

-- 2. 打印倒直角三角形
print("\n2. 倒直角三角形:")
for i = height, 1, -1 do
    for j = 1, i do
        io.write("* ")
    end
    
    print()
end

-- 3. 打印等腰三角形
print("\n3. 等腰三角形:")
for i = 1, height do
    -- 打印空格
    for j = 1, height - i do
        io.write(" ")
    end
    -- 打印星号
    for j = 1, 2 * i - 1 do
        io.write("*")
    end
    print()
end

-- 4. 打印空心菱形
print("\n4. 空心菱形:")
local diamond_height = 8
local half = diamond_height / 2 + 1

-- 上半部分
for i = 1, half do
    for j = 1, half - i do
        io.write(" ")
    end
    
    io.write("*")
    
    if i > 1 then
        for j = 1, 2 * i - 3 do
            io.write(" ")
        end
        io.write("*")
    end
    
    print()
end

-- 下半部分
for i = half - 1, 1, -1 do
    for j = 1, half - i do
        io.write(" ")
    end
    
    io.write("*")
    
    if i > 1 then
        for j = 1, 2 * i - 3 do
            io.write(" ")
        end
        io.write("*")
    end
    
    print()
end
--[[ 输出
1. 直角三角形:
* 
* * 
* * * 
* * * * 
* * * * * 

2. 倒直角三角形:
* * * * * 
* * * * 
* * * 
* * 
* 

3. 等腰三角形:
    *
   ***
  *****
 *******
*********

4. 空心菱形:
    *
   * *
  *   *
 *     *
*       *
 *     *
  *   *
   * *
    *
--]]
```

### 练习 6.1：简单的计算器函数库
```lua
-- 加法
local function add(a, b)
    return a + b
end

-- 减法
local function subtract(a, b)
    return a - b
end

-- 乘法
local function multiply(a, b)
    return a * b
end

-- 除法（带错误检查）
local function divide(a, b)
    if b == 0 then
        return nil, "除数不能为 0"
    end
    
    return a / b
end

-- 平均值
local function average(...)
    local numbers = {...}
    local sum = 0
    
    for _, num in ipairs(numbers) do
        sum = sum + num
    end
    
    return sum / #numbers
end

-- 使用函数库
print("5 + 3 = " .. add(5, 3))
print("10 - 4 = " .. subtract(10, 4))
print("6 * 7 = " .. multiply(6, 7))

local result, error_msg = divide(10, 0)
if error_msg then
    print("错误: " .. error_msg)
else
    print("10 / 2 = " .. result)
end

print("平均值(1,2,3,4,5) = " .. average(1, 2, 3, 4, 5))
--[[ 输出
5 + 3 = 8
10 - 4 = 6
6 * 7 = 42
错误: 除数不能为 0
平均值(1,2,3,4,5) = 3
--]]
```

### 练习 6.2：提取函数，优化代码
```lua
-- 模拟购买的物品
local function get_cart_item()
    return {
        { name = "苹果", price = 5, quantity = 3 },
        { name = "香蕉", price = 3, quantity = 2 },
        { name = "橙子", price = 6, quantity = 4 },
        { name = "葡萄", price = 8, quantity = 1 }
    }
end

-- 打印商品详细信息
local function print_item_info(cart)
    print("=== 商品详情 ===")

    for _, item in ipairs(cart) do
        local item_total = item.price * item.quantity

        print("商品: " .. item.name)
        print("单价: " .. item.price .. "元")
        print("数量: " .. item.quantity)
        print("小计: " .. item_total .. "元")
        print("------------")
    end
end

-- 计算购物车总价
local function calculate_cart_info(cart)
    local total_price, total_quantity = 0, 0

    for _, item in ipairs(cart) do
        total_price = total_price + (item.price * item.quantity)
        total_quantity = total_quantity + item.quantity
    end

    print("购物车总价: " .. total_price .. "元")

    return total_price, total_quantity
end

-- 判断是否有优惠（满50减10，满100减25，买10个赠1个）
local function check_discount(total_price, total_quantity)
    if total_price < 50 then
        print("未满50元，无优惠")
        return
    end

    if total_quantity >= 10 then
        print("购物车物品总数：" .. total_quantity .. "个，赠品1个")
    end

    local discount_price = total_price

    if total_price >= 100 then
        discount_price = total_price - 25
        print("符合优惠条件，满100减25")
    elseif total_price >= 50 then
        discount_price = total_price - 10
        print("符合优惠条件，满50减10")
    end

    print("优惠后价格: " .. discount_price .. "元")
end

local function rec_item(recommendations)
    for _, rec in ipairs(recommendations) do
        local rec_total = rec.price * 1 -- 假设推荐买1个
        print("  " .. rec.name .. ": " .. rec.price .. "元/个")
    end
end

-- 根据购物车推荐相关商品
local function recommendations_item(cart)
    print("\n=== 推荐商品 ===")
    local recommendations = {
        { name = "梨子", price = 6 },
        { name = "芒果", price = 10 }
    }

    for _, cart_item in ipairs(cart) do
        if cart_item.name == "苹果" then
            print("您购买了苹果，可能也喜欢:")
            rec_item(recommendations)
        elseif cart_item.name == "香蕉" then
            print("您购买了香蕉，可能也喜欢:")
            rec_item(recommendations)
        elseif cart_item.name == "橙子" then
            print("您购买了橙子，可能也喜欢:")
            rec_item(recommendations)
        end
    end
end

-- 主程序
local function main()
    -- 获取购物车物品
    local cart = get_cart_item()

    -- 打印商品信息
    print_item_info(cart)

    -- 计算总价和总数量
    local total_price, total_quantity = calculate_cart_info(cart)

    -- 检查优惠
    check_discount(total_price, total_quantity)

    -- 推荐相关商品
    recommendations_item(cart)
end

-- 运行主程序
main()
--[[ 输出
=== 商品详情 ===
商品: 苹果
单价: 5元
数量: 3
小计: 15元
------------
商品: 香蕉
单价: 3元
数量: 2
小计: 6元
------------
商品: 橙子
单价: 6元
数量: 4
小计: 24元
------------
商品: 葡萄
单价: 8元
数量: 1
小计: 8元
------------
购物车总价: 53元
购物车物品总数：10个，赠品1个
符合优惠条件，满50减10
优惠后价格: 43元

=== 推荐商品 ===
您购买了苹果，可能也喜欢:
  梨子: 6元/个
  芒果: 10元/个
您购买了香蕉，可能也喜欢:
  梨子: 6元/个
  芒果: 10元/个
您购买了橙子，可能也喜欢:
  梨子: 6元/个
  芒果: 10元/个
--]]
```

### 练习 7.1：简单的联系人管理系统
```lua
local contacts = {}

local function add_contact(name, phone, email)
    if contacts[name] then
        print("联系人 " .. name .. " 已存在")
        return false
    end
    
    contacts[name] = {
        phone = phone,
        email = email or ""
    }
    
    print("已添加联系人: " .. name)
    return true
end

local function find_contact(name)
    local contact = contacts[name]
    
    if not contact then
    	print("未找到联系人: " .. name)
    	
        return nil
    end
    
	print("找到联系人 " .. name .. ":")
	print("  电话: " .. contact.phone)
	print("  邮箱: " .. (contact.email ~= "" and contact.email or "无"))
	return contact
end

local function list_contacts()
    if #contacts == 0 then
        print("通讯录为空")
        return
    end
    
    print("=== 通讯录 ===")
    local count = 0
    
    for name, info in pairs(contacts) do
        count = count + 1
        print(count .. ". " .. name .. " - " .. info.phone)
    end
    
    print("总计: " .. count .. " 个联系人")
end

local function remove_contact(name)
	if not contacts[name] then
        print("联系人不存在: " .. name)
        return false
    end

	contacts[name] = nil
	print("已删除联系人: " .. name)
	return true
end

-- 测试联系人管理系统
add_contact("张三", "13800138000", "zhangsan@email.com")
add_contact("李四", "13900139000")
add_contact("王五", "13700137000", "wangwu@company.com")

list_contacts()

find_contact("张三")
find_contact("赵六")

remove_contact("李四")
list_contacts()

--[[ 输出
=== 联系人管理系统 ===
已添加联系人: 张三
已添加联系人: 李四
已添加联系人: 王五
通讯录为空
找到联系人 张三:
  电话: 17300138000
  邮箱: zhangsan@email.com
未找到联系人: 赵六
已删除联系人: 李四
通讯录为空
--]]
```

### 练习 7.2：购物车系统
```lua
local shopping_cart = {
    items = {},      -- 商品列表
    total_price = 0  -- 总价
}

function shopping_cart:add_item(name, price, quantity)
    quantity = quantity or 1
    
    -- 检查是否已存在
    for _, item in ipairs(self.items) do
        if item.name == name then
            item.quantity = item.quantity + quantity
            item.subtotal = item.price * item.quantity
            self.total_price = self.total_price + price * quantity
            print("已更新商品: " .. name .. " x" .. quantity)
            
            return
        end
    end
    
    -- 新商品
    local new_item = {
        name = name,
        price = price,
        quantity = quantity,
        subtotal = price * quantity
    }
    
    table.insert(self.items, new_item)
    self.total_price = self.total_price + new_item.subtotal
    print("已添加商品: " .. name .. " x" .. quantity)
end

function shopping_cart:remove_item(name, quantity)
    quantity = quantity or 99999  -- 默认移除全部
    
    for i, item in ipairs(self.items) do
        if item.name == name then
            local remove_qty = math.min(quantity, item.quantity)
            item.quantity = item.quantity - remove_qty
            item.subtotal = item.price * item.quantity
            self.total_price = self.total_price - item.price * remove_qty
            
            if item.quantity <= 0 then
                table.remove(self.items, i)
                print("已移除商品: " .. name)
            else
                print("已减少商品: " .. name .. " x" .. remove_qty .. "，剩余: x" .. item.quantity)
            end
            
            return
        end
    end
    
    print("商品不存在: " .. name)
end

function shopping_cart:show_cart()
    if #self.items == 0 then
        print("购物车为空")
        return
    end
    
    print("=== 购物车 ===")
    for i, item in ipairs(self.items) do
        print(string.format("%d. %-15s 单价: %6.2f 数量: %3d 小计: %8.2f",
              i, item.name, item.price, item.quantity, item.subtotal))
    end
    
    print(string.format("\n总计: %.2f 元", self.total_price))
end

function shopping_cart:clear()
    self.items = {}
    self.total_price = 0
    print("已清空购物车")
end

-- 测试购物车系统
print("=== 购物车系统 ===")
shopping_cart:add_item("苹果", 5.5, 2)
shopping_cart:add_item("香蕉", 3.2, 3)
shopping_cart:add_item("苹果", 5.5, 1)  -- 增加苹果数量

shopping_cart:show_cart()

shopping_cart:remove_item("香蕉", 1)  -- 减少香蕉数量

shopping_cart:show_cart()

shopping_cart:clear()
shopping_cart:show_cart()

--[[ 输出
== 购物车系统 ===
已添加商品: 苹果 x2
已添加商品: 香蕉 x3
已更新商品: 苹果 x1
=== 购物车 ===
1. 苹果          单价:   5.50 数量:   3 小计:    16.50
2. 香蕉          单价:   3.20 数量:   3 小计:     9.60

总计: 38.90 元
已减少商品: 香蕉 x1，剩余: x2
=== 购物车 ===
1. 苹果          单价:   5.50 数量:   3 小计:    16.50
2. 香蕉          单价:   3.20 数量:   2 小计:     6.40

总计: 35.70 元
已清空购物车
购物车为空
--]]
```

### 练习 8.1：简单的文本分析器
```lua
local analysis = {
    data = {}
}

function analysis:analyze_text(text)
    local data = self.data

    -- 基本统计
    data.total_chars = #text
    local _, lines = string.gsub(text, "\n", "")
    data.lines = lines + 1

    -- 单词统计
    local word_pattern = "[%a\128-\255]+[%w\128-\255%-']*"
    local words = {}

    for word in string.gmatch(text, word_pattern) do
        word = string.lower(word)
        words[word] = (words[word] or 0) + 1
    end

    data.word_count = 0
    data.most_frequent = {}

    for word, count in pairs(words) do
        data.word_count = data.word_count + count

        -- 记录最频繁的单词
        table.insert(data.most_frequent, { word = word, count = count })
    end

    -- 按频率排序
    table.sort(data.most_frequent, function(a, b)
        if a.count == b.count then
            return a.word < b.word
        end

        return a.count > b.count
    end)

    -- 只保留前 5 个
    if #data.most_frequent > 5 then
        for i = 6, #data.most_frequent do
            data.most_frequent[i] = nil
        end
    end
end

-- 测试文本分析器
local test_text = [[
Lua is a powerful, efficient, lightweight, embeddable scripting language.
It supports procedural programming, object-oriented programming, functional
programming, data-driven programming, and data description.

Lua combines simple procedural syntax with powerful data description
constructs based on associative arrays and extensible semantics.
Lua is dynamically typed, runs by interpreting bytecode with a
register-based virtual machine, and has automatic memory management with
incremental garbage collection, making it ideal for configuration,
scripting, and rapid prototyping.
]]

print("=== 文本分析器 ===")
analysis:analyze_text(test_text)

local data = analysis.data

print("基本统计:")
print("  总字符数: " .. data.total_chars)
print("  行数: " .. data.lines)
print("  单词数: " .. data.word_count)

print("\n 最频繁的单词:")
for i, item in ipairs(data.most_frequent) do
    print(string.format("  %2d. %-15s: %d 次", i, item.word, item.count))
end
--[[ 输出
基本统计:
  总字符数: 582
  行数: 11
  单词数: 70

 最频繁的单词:
   1. and            : 4 次
   2. programming    : 4 次
   3. lua            : 3 次
   4. with           : 3 次
   5. a              : 2 次
--]]
```

### 练习 9.1：创建一个日志模块
```lua
local log = {}

log.LEVEL_NAMES = {
    "INFO",
    "ERROR"
}

-- 创建新的日志实例
function log:new(name)
    local logger = {}

    -- 添加日志方法
    for _, level_name in ipairs(self.LEVEL_NAMES) do
        logger[string.lower(level_name)] = function(message, ...)
            log:_log(level_name, name, message, ...)
        end
    end

    return logger
end

-- 内部日志方法
function log:_log(level_name, name, message, ...)
    -- 格式化消息
    message = string.format(message, ...)

    -- 构建日志前缀
    local log_line = string.format("[%s] %s: %s", level_name, name, message)

    print(log_line)
end

return log
```

### 练习 10.1：模拟网络请求的错误处理
```lua
local error_types = {
    NETWORK = {
        code = 300,
        name = "NETWORK_ERROR",
        description = "网络通信失败"
    }
}

-- 错误创建函数
local function create_error(error_type, message, details)
    local error_info = error_types[error_type]
    if not error_info then
        error_info = error_types.INTERNAL
    end
    
    return {
        type = error_type,
        code = error_info.code,
        name = error_info.name,
        message = message or error_info.description,
        details = details,
        timestamp = os.time(),
        stack_trace = debug.traceback("", 2)
    }
end

-- 错误处理函数
local function handle_error(err, context)
    if type(err) == "table" and err.code then
        print(string.format("[ERROR] 类型: %s (%d)", err.name, err.code))
        print(string.format("          消息: %s", err.message))
        
        if err.details then
            print(string.format("          详情: %s", tostring(err.details)))
        end
        
        if context then
            print(string.format("          上下文: %s", context))
        end
        
        print(string.format("          调用栈: %s", err.stack_trace))
        
        if err.type == "NETWORK" then
            return nil, "网络错误，请稍后重试"
        else
            return nil, "系统错误，请联系技术支持"
        end
    else
        -- 其他类型的错误
        return nil, "未知错误: " .. tostring(err)
    end
end

-- 模拟HTTP客户端
local http_client = {}

function http_client.new(config)
    local instance = {
        max_retries = config.max_retries or 3,
        timeout = config.timeout or 10,  -- 秒
        base_url = config.base_url or "",
        retry_delay = config.retry_delay or 1  -- 秒
    }
    
    -- 模拟网络请求
    function instance:request(method, path, data, headers)
        method = method:upper()
        local url = self.base_url .. path
        
        print(string.format("  请求: %s %s", method, url))
        
        -- 模拟HTTP状态码错误
        local status_code
        if path:find("404") then
            status_code = 404
        elseif path:find("500") then
            status_code = 500
        else
            status_code = 200
        end
        
        if status_code >= 400 then
            local error_message
            if status_code == 404 then
                error_message = "资源未找到"
            elseif status_code == 500 then
                error_message = "系统错误"
            else
                error_message = "HTTP错误 " .. status_code
            end
            
            return nil, create_error("NETWORK", error_message,
                   {url = url, method = method, status = status_code})
        end
        
        -- 成功响应
        return {
            status = status_code,
            headers = {["Content-Type"] = "application/json"},
            body = string.format('{"success": true, "data": "%s", "method": "%s"}', 
                                 data or "default", method)
        }
    end
    
    -- 带重试的请求
    function instance:request_with_retry(method, path, data, headers)
        local last_error
        
        for attempt = 1, self.max_retries do
            print(string.format("  尝试 %d/%d...", attempt, self.max_retries))
            
            local response, err = self:request(method, path, data, headers)

            if response then
                if attempt > 1 then
                    print("  重试成功!")
                end

                return response
            end

            last_error = err
            
            -- 检查是否应该重试
            if err.type == "NETWORK" and attempt < self.max_retries then
                print(string.format("  等待 %.1f 秒后重试...", self.retry_delay))
            else
                break
            end
        end

        return nil, last_error
    end
    
    -- 批量请求，部分失败不影响其他
    function instance:batch_request(requests)
        local responses = {}
        local errors = {}
        
        for i, req in ipairs(requests) do
            print(string.format("\n批量请求 %d/%d:", i, #requests))
            
            local response, err = self:request_with_retry(
                req.method, req.path, req.data, req.headers)
            
            if response then
                responses[i] = response
            else
                errors[i] = err
                responses[i] = nil
            end
        end
        return responses, errors
    end
    
    return instance
end

-- 使用HTTP客户端
print("HTTP客户端测试:")
local client = http_client.new{
    max_retries = 2,
    timeout = 5,
    base_url = "https://api.example.com"
}

-- 测试单个请求
print("\n1. 测试单个请求:")
local response, err = client:request_with_retry("GET", "/users/404")
if response then
    print("  成功: " .. response.body)
else
    local _, user_msg = handle_error(err)
    print("  失败: " .. user_msg)
end

-- 测试批量请求
print("\n2. 测试批量请求:")
local requests = {
    {method = "GET", path = "/users/1"},
    {method = "GET", path = "/users/404"},  -- 会返回404
    {method = "POST", path = "/users", data = '{"name": "测试"}'},
    {method = "GET", path = "/users/500"},  -- 会返回500
}

local responses, errors = client:batch_request(requests)

print("\n批量请求结果:")
for i, response in pairs(responses) do
    print(string.format("  请求 %s 成功: %s", i, response.body))
end
for i, err in pairs(errors) do
    print(string.format("  请求 %s 失败: ", i))
    local _, user_msg = handle_error(err)
end
--[[ 输出
1. 测试单个请求:
  尝试 1/2...
  请求: GET https://api.example.com/users/404
  等待 1.0 秒后重试...
  尝试 2/2...
  请求: GET https://api.example.com/users/404
[ERROR] 类型: NETWORK_ERROR (300)
          消息: 资源未找到
          详情: table: 00F81980
          调用栈: 
stack traceback:
	test.lua:93: in function 'request'
	test.lua:113: in function 'request_with_retry'
	test.lua:170: in main chunk
	[C]: ?
  失败: 网络错误，请稍后重试

2. 测试批量请求:

批量请求 1/4:
  尝试 1/2...
  请求: GET https://api.example.com/users/1

批量请求 2/4:
  尝试 1/2...
  请求: GET https://api.example.com/users/404
  等待 1.0 秒后重试...
  尝试 2/2...
  请求: GET https://api.example.com/users/404

批量请求 3/4:
  尝试 1/2...
  请求: POST https://api.example.com/users

批量请求 4/4:
  尝试 1/2...
  请求: GET https://api.example.com/users/500
  等待 1.0 秒后重试...
  尝试 2/2...
  请求: GET https://api.example.com/users/500

批量请求结果:
  请求 1 成功: {"success": true, "data": "default", "method": "GET"}
  请求 3 成功: {"success": true, "data": "{"name": "测试"}", "method": "POST"}
  请求 2 失败: 
[ERROR] 类型: NETWORK_ERROR (300)
          消息: 资源未找到
          详情: table: 00F88238
          调用栈: 
stack traceback:
	test.lua:93: in function 'request'
	test.lua:113: in function 'request_with_retry'
	test.lua:144: in function 'batch_request'
	test.lua:187: in main chunk
	[C]: ?
  请求 4 失败: 
[ERROR] 类型: NETWORK_ERROR (300)
          消息: 系统错误
          详情: table: 00F88288
          调用栈: 
stack traceback:
	test.lua:93: in function 'request'
	test.lua:113: in function 'request_with_retry'
	test.lua:144: in function 'batch_request'
	test.lua:187: in main chunk
	[C]: ?
--]]
```

### 练习 10.2：模拟数据库操作错误处理
```lua
-- 创建结构化的错误类型，便于处理
-- 错误类型定义
local error_types = {
    VALIDATION = {
        code = 100,
        name = "VALIDATION_ERROR",
        description = "输入验证失败"
    },
    DATABASE = {
        code = 200,
        name = "DATABASE_ERROR",
        description = "数据库操作失败"
    },
    NETWORK = {
        code = 300,
        name = "NETWORK_ERROR",
        description = "网络通信失败"
    },
    PERMISSION = {
        code = 400,
        name = "PERMISSION_ERROR",
        description = "权限不足"
    },
    INTERNAL = {
        code = 500,
        name = "INTERNAL_ERROR",
        description = "内部服务器错误"
    }
}

-- 错误创建函数
local function create_error(error_type, message, details)
    local error_info = error_types[error_type]
    if not error_info then
        error_info = error_types.INTERNAL
    end

    return {
        type = error_type,
        code = error_info.code,
        name = error_info.name,
        message = message or error_info.description,
        details = details,
        timestamp = os.time(),
        stack_trace = debug.traceback("", 2)
    }
end

-- 错误抛出函数
local function throw_error(error_type, message, details)
    error(create_error(error_type, message, details), 2)
end

-- 错误处理函数
local function handle_error(err, context)
    -- 如果是我们的自定义错误
    if type(err) == "table" and err.code then
        print(string.format("[错误处理] 类型: %s (%d)", err.name, err.code))
        print(string.format("          消息: %s", err.message))

        if err.details then
            print(string.format("          详情: %s", tostring(err.details)))
        end

        if context then
            print(string.format("          上下文: %s", context))
        end

        print("          调用栈:")
        print(err.stack_trace)

        -- 根据错误类型采取不同措施
        if err.type == "VALIDATION" then
            return nil, "输入错误，请检查后重试"
        elseif err.type == "PERMISSION" then
            return nil, "权限不足，请联系管理员"
        elseif err.type == "NETWORK" then
            -- 可以尝试重试
            return nil, "网络错误，请稍后重试"
        else
            return nil, "系统错误，请联系技术支持"
        end
    else
        -- 其他类型的错误
        return nil, "未知错误: " .. tostring(err)
    end
end

-- 模拟数据库连接
local data_base = {}

function data_base.new(config)
    local instance = {
        host = config.host or "localhost",
        port = config.port or 3306,
        username = config.username or "root",
        password = config.password or "",
        database = config.database or "test",
        connected = false,
        transaction_active = false
    }

    -- 连接数据库
    function instance:connect()
        if self.connected then
            return true
        end

        print(string.format("  连接数据库 %s:%d...", self.host, self.port))

        -- 模拟连接错误
		throw_error("NETWORK", "数据库连接失败",
			{ host = self.host, port = self.port })

        self.connected = true
        print("  连接成功")
        return true
    end

    -- 执行查询
    function instance:query(sql, params)
        if not self.connected then
            throw_error("DATABASE", "数据库未连接")
        end

        print(string.format("  执行查询: %s", sql))
        if params then
            print("  参数: " .. tostring(params))
        end

        -- 模拟查询错误
        if sql:find("DROP TABLE") or sql:find("DELETE") then
            if not self.transaction_active then
                throw_error("DATABASE", "危险操作需要在事务中执行", { sql = sql })
            end
        end

        if sql:find("SELECT") and sql:find("nonexistent") then
            throw_error("DATABASE", "查询的表不存在", { sql = sql })
        end

        if sql:find("INSERT") and params and params.email then
            -- 模拟唯一约束冲突
            if params.email == "duplicate@example.com" then
                throw_error("DATABASE", "重复的邮箱地址",
                    { sql = sql, email = params.email })
            end
        end

        -- 模拟成功响应
        if sql:find("SELECT") then
            return {
                { id = 1, name = "用户1", email = "user1@example.com" },
                { id = 2, name = "用户2", email = "user2@example.com" }
            }
        elseif sql:find("INSERT") then
            return { affected_rows = 1, last_insert_id = 100 }
        elseif sql:find("UPDATE") then
            return { affected_rows = 1 }
        elseif sql:find("DELETE") then
            return { affected_rows = 1 }
        end

        return {}
    end

    -- 开始事务
    function instance:begin_transaction()
        if self.transaction_active then
            throw_error("DATABASE", "事务已在进行中")
        end
        self.transaction_active = true
        print("  开始事务")
        return true
    end

    -- 提交事务
    function instance:commit()
        if not self.transaction_active then
            throw_error("DATABASE", "没有活动的事务")
        end

        self.transaction_active = false
        print("  提交事务")
        return true
    end

    -- 回滚事务
    function instance:rollback()
        if not self.transaction_active then
            throw_error("DATABASE", "没有活动的事务")
        end
        self.transaction_active = false
        print("  回滚事务")
        return true
    end

    -- 断开连接
    function instance:disconnect()
        if self.transaction_active then
            self:rollback()
        end
        self.connected = false
        print("  断开数据库连接")
        return true
    end

    -- 安全执行（带错误处理）
    function instance:safe_execute(operation, ...)
        local success, result = pcall(operation, self, ...)

        if not success then
            -- 如果是数据库错误，尝试重连
            if type(result) == "table" and result.type == "DATABASE" then
                if result.message:find("连接") or result.message:find("断开") then
                    print("  检测到连接问题，尝试重连...")
                    self.connected = false
                    local reconnect_success = pcall(self.connect, self)
                    if reconnect_success then
                        print("  重连成功，重试操作...")
                        success, result = pcall(operation, self, ...)
                    end
                end
            end
        end

        if not success then
            return nil, result
        end

        return result
    end

    return instance
end

-- 使用数据库
print("数据库操作测试:")
local db = data_base.new {
    host = "localhost",
    database = "mydb",
    username = "admin",
    password = "secret"
}

-- 包装数据库操作为安全操作
function safe_database_operation(db, operation_name, operation, ...)
    print("\n操作: " .. operation_name)

    local result, err = db:safe_execute(operation, ...)

    if result then
        print("  成功")
        return result
    else
        local _, user_msg = handle_error(err, operation_name)
        print("  失败: " .. user_msg)
        return nil, err
    end
end

-- 测试各种操作
-- 连接数据库
safe_database_operation(db, "连接数据库", db.connect)

-- 查询数据
local users, err = safe_database_operation(db, "查询用户", function(self)
    return self:query("SELECT * FROM users WHERE status = 'active'")
end)

if users then
    print("  查询到 " .. #users .. " 个用户")
end

-- 测试插入重复数据
local insert_result, err = safe_database_operation(db, "插入用户", function(self)
    return self:query("INSERT INTO users (name, email) VALUES (?, ?)",
        { "测试用户", "duplicate@example.com" })
end)

-- 测试事务
print("\n测试事务操作:")
local transaction_success, transaction_err = pcall(function()
    db:begin_transaction()

    -- 多个操作
    db:query("UPDATE accounts SET balance = balance - 100 WHERE id = 1")
    db:query("UPDATE accounts SET balance = balance + 100 WHERE id = 2")

    db:commit()
    print("  事务执行成功")
end)

if not transaction_success then
    print("  事务失败: " .. tostring(transaction_err))
    if db.transaction_active then
        db:rollback()
    end
end

-- 断开连接
safe_database_operation(db, "断开连接", db.disconnect)
--[[ 输出
操作: 连接数据库
  连接数据库 localhost:3306...
[错误处理] 类型: NETWORK_ERROR (300)
          消息: 数据库连接失败
          详情: table: 00E5CEA0
          上下文: 连接数据库
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:114: in function <test.lua:104>
	[C]: in function 'pcall'
	test.lua:213: in function 'safe_execute'
	test.lua:253: in function 'safe_database_operation'
	test.lua:267: in main chunk
	[C]: ?
  失败: 网络错误，请稍后重试

操作: 查询用户
  检测到连接问题，尝试重连...
  连接数据库 localhost:3306...
[错误处理] 类型: DATABASE_ERROR (200)
          消息: 数据库未连接
          上下文: 查询用户
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:126: in function <test.lua:124>
	(tail call): ?
	[C]: in function 'pcall'
	test.lua:213: in function 'safe_execute'
	test.lua:253: in function 'safe_database_operation'
	test.lua:270: in main chunk
	[C]: ?
  失败: 系统错误，请联系技术支持

操作: 插入用户
  检测到连接问题，尝试重连...
  连接数据库 localhost:3306...
[错误处理] 类型: DATABASE_ERROR (200)
          消息: 数据库未连接
          上下文: 插入用户
          调用栈:

stack traceback:
	test.lua:51: in function 'throw_error'
	test.lua:126: in function <test.lua:124>
	(tail call): ?
	[C]: in function 'pcall'
	test.lua:213: in function 'safe_execute'
	test.lua:253: in function 'safe_database_operation'
	test.lua:279: in main chunk
	[C]: ?
  失败: 系统错误，请联系技术支持

测试事务操作:
  开始事务
  事务失败: table: 00E5CF68
  回滚事务

操作: 断开连接
  断开数据库连接
  成功
--]]
```

### 练习 11.1：实现一个数据管道系统
```lua
-- 定义管道操作
local pipeline_sys = {}

function pipeline_sys.new(source_iterator)
    local pipeline = {
        source = source_iterator,
        operations = {}
    }

    function pipeline:map(transform_func)
        table.insert(self.operations, {
            type = "map",
            func = transform_func
        })
        return self
    end

    function pipeline:filter(predicate_func)
        table.insert(self.operations, {
            type = "filter",
            func = predicate_func
        })
        return self
    end

    function pipeline:take(n)
        table.insert(self.operations, {
            type = "take",
            count = n
        })
        return self
    end

    function pipeline:skip(n)
        table.insert(self.operations, {
            type = "skip",
            count = n
        })
        return self
    end

    function pipeline:iterator()
        local source_iter = self.source
        local skip_count = 0
        local take_count = math.huge

        -- 从操作中获取初始的skip和take值
        for _, op in ipairs(self.operations) do
            if op.type == "skip" then
                skip_count = op.count
            elseif op.type == "take" then
                take_count = op.count
            end
        end

        -- 创建处理链
        return function()
            while true do
                if take_count <= 0 then
                    return nil
                end

                local values = { source_iter() }

                if values[1] == nil then
                    return nil
                end

                local processed = values
                local should_emit = true

                if skip_count > 0 then
                    skip_count = skip_count - 1
                    should_emit = false
                else
                    -- 应用所有操作
                    for _, op in ipairs(self.operations) do
                        if op.type == "map" then
                            processed = { op.func(unpack(processed)) }
                        elseif op.type == "filter" then
                            if not op.func(unpack(processed)) then
                                should_emit = false
                                break
                            end
                        end
                    end
                end

                if should_emit then
                    take_count = take_count - 1
                    return unpack(processed)
                end
            end
        end
    end

    return pipeline
end

-- 测试数据管道
print("数据管道测试:")

-- 创建数据源
function number_source(from, to)
    local current = from - 1
    return function()
        current = current + 1
        if current <= to then
            return current
        end
    end
end

-- 构建管道
local pipeline = pipeline_sys.new(number_source(1, 20))
pipeline:filter(function(x) return x % 2 == 0 end) -- 只保留偶数
pipeline:map(function(x) return x * 2 end)         -- 乘以2
pipeline:skip(3)                                   -- 跳过前3个
pipeline:take(5)                                   -- 取5个

print("管道处理结果:")
for value in pipeline:iterator() do
    io.write(value .. " ")
end
print()

-- 复杂管道示例
print("\n复杂管道示例:")

-- 模拟用户数据
function user_data_source()
    local users = {
        { id = 1, name = "张三", age = 25, score = 85 },
        { id = 2, name = "李四", age = 30, score = 92 },
        { id = 3, name = "王五", age = 22, score = 78 },
        { id = 4, name = "赵六", age = 35, score = 88 },
        { id = 5, name = "钱七", age = 28, score = 95 },
        { id = 6, name = "孙八", age = 19, score = 65 },
        { id = 7, name = "周九", age = 32, score = 82 },
        { id = 8, name = "吴十", age = 26, score = 90 },
    }

    local index = 0
    return function()
        index = index + 1
        local user = users[index]
        if user then
            return user.id, user.name, user.age, user.score
        end
    end
end

-- 用户数据处理管道
local user_pipeline = pipeline_sys.new(user_data_source())
user_pipeline:filter(function(id, name, age, score)
    return age >= 20 and age <= 30 -- 年龄在20-30之间
end)
user_pipeline:filter(function(id, name, age, score)
    return score >= 80 -- 分数80以上
end)
user_pipeline:map(function(id, name, age, score)
    -- 添加评级
    local rating
    if score >= 90 then
        rating = "优秀"
    elseif score >= 85 then
        rating = "良好"
    else
        rating = "合格"
    end

    return id, name, age, score, rating
end)

print("符合条件的用户:")
for id, name, age, score, rating in user_pipeline:iterator() do
    print(string.format("  ID: %d, 姓名: %s, 年龄: %d, 分数: %d, 评级: %s",
        id, name, age, score, rating))
end
--[[ 输出
数据管道测试:
管道处理结果:
8 12 16 20 24 

复杂管道示例:
符合条件的用户:
  ID: 1, 姓名: 张三, 年龄: 25, 分数: 85, 评级: 良好
  ID: 2, 姓名: 李四, 年龄: 30, 分数: 92, 评级: 优秀
  ID: 5, 姓名: 钱七, 年龄: 28, 分数: 95, 评级: 优秀
  ID: 8, 姓名: 吴十, 年龄: 26, 分数: 90, 评级: 优秀
--]]
```

### 练习 12.1：使用协程实现生成器
```lua
local function range(from, to, step)
    step = step or 1

    return coroutine.wrap(function()
        for i = from, to, step do
            coroutine.yield(i)
        end
    end)
end

-- 使用
for i in range(1, 10, 2) do
    print(i)
end
--[[ 输出
1
3
5
7
9
--]]
```