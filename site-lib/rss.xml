<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[王国保卫战修改教程]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>王国保卫战修改教程</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 26 Dec 2025 12:30:07 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 26 Dec 2025 12:28:11 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[index]]></title><description><![CDATA[最近更新：2025 年 12 月 26 日
相关链接：
<a data-tooltip-position="top" aria-label="https://github.com/MC123ACD/KR_modCourse" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/MC123ACD/KR_modCourse" target="_self">本文档 Github 仓库</a><br>
<a data-tooltip-position="top" aria-label="https://kingdomrush.huijiwiki.com/p/1" rel="noopener nofollow" class="external-link is-unresolved" href="https://kingdomrush.huijiwiki.com/p/1" target="_self">中文维基</a><br>
<a data-tooltip-position="top" aria-label="https://www.bilibili.com/read/readlist/rl141527" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.bilibili.com/read/readlist/rl141527" target="_self">中文百科全集</a><br>
<a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1yTBeBFEsi/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.bilibili.com/video/BV1yTBeBFEsi/" target="_self">王国保卫战1235代修改教程</a>
本文档适用于电脑版的一、二、三、五代，请注意版本（安卓版部分可用）
由于本人正处于学习阶段，所以错误在所难免，欢迎提出意见、提 request。由于五代过于臃肿，初学者推荐使用一代修改本文档具有少量练习，如有疑问建议先问 AI 再看答案，答案问题也可以问 AI。
国内免费 AI 链接：<br>
<a data-tooltip-position="top" aria-label="https://chat.deepseek.com/" rel="noopener nofollow" class="external-link is-unresolved" href="https://chat.deepseek.com/" target="_self">DeepSeek</a><br>
<a data-tooltip-position="top" aria-label="https://www.doubao.com/chat/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.doubao.com/chat/" target="_self">豆包</a>
问问题需要向 AI 提供信息：编程语言，目标，问题，具体代码 问题：Lua 我想检查表里面有没有元素应该怎么写 AI： 使用 next 函数 if not next(表) then
if #表 == 0 then（只对数组部分有效） 问题：我试了第一种，现在想检查表格是否有某个键，怎么写 AI： 使用 if 表.键 then
或者使用 if 表["键"] then 本文档使用伪代码类型注解：
该文档仅限学习交流，禁止用于商业用途，除商业用途之外可随意分发
请购买正版游戏后再进行修改。若修改盗版出现任何问题，均与作者以及文档无关
本文档可能具有编写错误导致的误导性内容请仔细甄别
本文档部分内容由其他文章二次修改而成，且均与作者取得授权
]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Fri, 26 Dec 2025 12:06:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[14. LuaJIT]]></title><description><![CDATA[LuaJIT 是一个高性能的 Lua 解释器和即时编译器（JIT），它完全兼容 Lua 5.1，但性能通常比标准 Lua 快得多。LuaJIT 的主要特性：
高性能 JIT 编译器
提供 FFI 允许直接调用 C 函数和使用 C 数据结构
内存使用更少
完全兼容 Lua 5.1
支持更多字节码指令
同 <a data-href="2. 基础语法规则#2 1 2 修复无法中文乱码" href="第-1-节-语法/2.-基础语法规则.html#2 1 2 修复无法中文乱码" class="internal-link" target="_self" rel="noopener nofollow">2. 基础语法规则 &gt; 2 1 2 修复无法中文乱码</a>
切换到 LuaJIT 运行程序即可。JIT 编译器用于将 Lua 字节码动态编译为本地机器码，提高 2-15 倍性能。-- 性能测试：标准Lua vs LuaJIT
local function benchmark_loop() local sum = 0 for i = 1, 10000000 do sum = sum + i end return sum
end local start1 = os.clock()
local result = benchmark_loop()
local time1 = os.clock() - start1 -- 启用 JIT 编译器
jit.on()
local start2 = os.clock()
local result = benchmark_loop()
local time2 = os.clock() - start2 print(string.format("Lua 执行时间: %.4f秒", time1))
print(string.format("JIT 执行时间: %.4f秒", time2))
print(string.format("性能提高: %.2f%%", (time1 - time2) / time2 * 100))
--[[ 输出
Lua 执行时间: 0.0410秒
JIT 执行时间: 0.0110秒
性能提高: 270%
--]]
goto&nbsp;语句提供了一种低级的控制流跳转机制，可以在代码块内直接跳转到指定标签位置。
可以使用 goto 来模拟 continue 跳过单次循环。::跳转标签名称::	-- 定义跳转位置 goto 跳转到的标签
-- Lua 没有 continue 关键字，用 goto 实现
for i = 1, 10 do if i % 2 == 0 then -- 跳过偶数 print("跳过偶数: " .. i) goto continue end print("处理奇数: " .. i) ::continue:: -- 循环末尾的标签
end
--[[ 输出
处理奇数: 1
跳过偶数: 2
处理奇数: 3
跳过偶数: 4
处理奇数: 5
跳过偶数: 6
处理奇数: 7
跳过偶数: 8
处理奇数: 9
跳过偶数: 10
--]]
for i = 1, 3 do for j = 1, 3 do if i == 2 and j == 2 then print("找到目标，跳出所有循环") goto exit_loops end print(i, j) end
end ::exit_loops::
print("继续执行后续代码")
--[[ 输出
1	1
1	2
1	3
2	1
找到目标，跳出所有循环
继续执行后续代码
--]]
-- 在非函数中模拟"提前返回"逻辑
local x = -1 ::validate::
if x &lt;= 0 then print("x 必须大于0") goto end_process
end if x &gt; 100 then print("x 不能超过100") goto end_process
end print("x 有效: " .. x) ::end_process::
print("验证完成")
--[[ 输出
x 必须大于0
验证完成
--]]
-- 不允许：跳进函数
local function test() ::inside_func::
end goto inside_func -- 不允许：跳进其他代码块
if condition then local x = 10 ::label3::
end goto label3 -- 不允许：跳过局部变量定义
goto lable1 local a = 123 ::lable1::
-- 合法标签名（字母、数字、下划线）
::valid_label::
::Label123::
::_start:: -- 不合法标签名
::123start:: -- 不能以数字开头
::my-label:: -- 不能包含连字符
::end:: -- 不能用保留字
-- 1. bit库 - 位运算
print("1. bit库 - 位运算:")
local bit = require("bit") local a = 0x0F -- 00001111
local b = 0xF0 -- 11110000 print(string.format("a = 0x%X (%d)", a, a))
print(string.format("b = 0x%X (%d)", b, b))
print(string.format("bit.band(a, b) = 0x%X", bit.band(a, b))) -- 与
print(string.format("bit.bor(a, b) = 0x%X", bit.bor(a, b))) -- 或
print(string.format("bit.bxor(a, b) = 0x%X", bit.bxor(a, b))) -- 异或
print(string.format("bit.bnot(a) = 0x%X", bit.bnot(a))) -- 非
print(string.format("bit.lshift(a, 2) = 0x%X", bit.lshift(a, 2))) -- 左移
print(string.format("bit.rshift(b, 2) = 0x%X", bit.rshift(b, 2))) -- 右移 -- 2. 表操作优化
-- jit.on()
print("\n2. 表操作优化:")
local large_table = {}
local start_time = os.clock() -- 插入大量数据
for i = 1, 1000000 do large_table[i] = i * 2
end local insert_time = os.clock() - start_time
print("插入100万条数据耗时: " .. string.format("%.3f", insert_time) .. "秒") -- 访问数据
start_time = os.clock()
local sum = 0
for i = 1, 1000000 do sum = sum + large_table[i]
end
local access_time = os.clock() - start_time
print("访问100万条数据耗时: " .. string.format("%.3f", access_time) .. "秒")
print("总和: " .. sum) -- 3. 协程优化
print("\n3. 协程优化:")
local sum = 0 local function coroutine_test() local co = coroutine.create(function() for i = 1, 5 do coroutine.yield(i) end end) for i = 1, 5 do local success, value = coroutine.resume(co) if success then sum = sum + value end end
end local start = os.clock()
for i = 1, 10000 do coroutine_test()
end
local elapsed = os.clock() - start
print(string.format("总和 %s", sum))
print(string.format("执行10000次协程测试耗时: %.3f秒", elapsed)) -- 4. 垃圾回收优化
print("\n4. 垃圾回收优化:") -- 显示GC统计
local gc_stats = { count = collectgarbage("count"), step = collectgarbage("step"), isrunning = collectgarbage("isrunning")
} print("GC统计:")
print(" 内存使用: " .. string.format("%.2f", gc_stats.count) .. " KB")
print(" GC是否运行: " .. tostring(gc_stats.isrunning)) -- 手动触发GC
collectgarbage("collect")
print("手动触发GC后内存: " .. string.format("%.2f", collectgarbage("count")) .. " KB")
--[[ 输出
1. bit库 - 位运算:
a = 0xF (15)
b = 0xF0 (240)
bit.band(a, b) = 0x0
bit.bor(a, b) = 0xFF
bit.bxor(a, b) = 0xFF
bit.bnot(a) = 0xFFFFFFFFFFFFFFF0
bit.lshift(a, 2) = 0x3C
bit.rshift(b, 2) = 0x3C 2. 表操作优化:
插入100万条数据耗时: 0.016秒
访问100万条数据耗时: 0.008秒
总和: 1000001000000 3. 协程优化:
总和 150000
执行10000次协程测试耗时: 0.006秒 4. 垃圾回收优化:
GC统计: 内存使用: 13410.04 KB GC是否运行: true
手动触发GC后内存: 8252.30 KB
--]]
FFI 是 LuaJIT 最强大的特性之一，允许直接调用 C 函数、使用 C 数据类型和内存操作，无需编写 C 扩展模块。
FFI 提供了 Lua 与 C 世界之间的桥梁，通过合理使用可以显著提升性能，但需要谨慎处理内存和类型安全问题。-- FFI使用示例
local ffi = require("ffi") -- 1. 声明C函数和类型
ffi.cdef [[ // 标准库函数 int strlen(const char *s); void *malloc(size_t size); void free(void *ptr); // 数学函数 double sin(double x); double cos(double x); double sqrt(double x); // 系统调用 int system(const char *command); // 自定义结构体 typedef struct { int x; int y; } Point; typedef struct { char name[32]; int age; float score; } Student;
]] -- 2. 调用C函数
print("调用C标准库函数:")
local str = "Hello, World!"
local length = ffi.C.strlen(str)
print("字符串长度: " .. length) -- 3. 使用数学函数
local angle = 45 * math.pi / 180
local sin_value = ffi.C.sin(angle)
local cos_value = ffi.C.cos(angle)
print(string.format("\n数学函数: sin(45°)=%.3f, cos(45°)=%.3f", sin_value, cos_value)) -- 4. 创建和使用C结构体
print("\nC结构体使用:")
-- 创建Point结构体
local point = ffi.new("Point")
point.x = 10
point.y = 20
print("Point: x=" .. point.x .. ", y=" .. point.y) -- 创建Student结构体
local student = ffi.new("Student")
ffi.copy(student.name, "张三")
student.age = 18
student.score = 95.5 print(string.format("Student: name=%s, age=%d, score=%.1f", ffi.string(student.name), student.age, student.score)) -- 5. 内存管理
print("\n内存管理:")
local size = 100 * ffi.sizeof("int")
local buffer = ffi.C.malloc(size)
print("分配内存: " .. size .. " 字节") if buffer ~= ffi.NULL then -- 将buffer转换为int数组 local int_array = ffi.cast("int*", buffer) -- 初始化数组 for i = 0, 99 do int_array[i] = i * 2 end -- 访问数组元素 print("int_array[50] = " .. int_array[50]) -- 释放内存 ffi.C.free(buffer) print("内存已释放")
end -- 6. 调用系统命令
print("\n系统调用:")
local result = ffi.C.system("echo 'Hello from system call'")
print("系统命令返回值: " .. result)
--[[ 输出
调用C标准库函数:
字符串长度: 13 数学函数: sin(45°)=0.707, cos(45°)=0.707 C结构体使用:
Point: x=10, y=20
Student: name=张三, age=18, score=95.5 内存管理:
分配内存: 400 字节
int_array[50] = 100
内存已释放 系统调用:
系统命令返回值: 0
'Hello from system call'
--]]
local ffi = require("ffi") 声明 C 类型和函数
调用 C 函数
管理 C 数据
ffi.cdef [[ // 基础类型 typedef int bool; typedef char int8_t; typedef short int16_t; typedef int int32_t; typedef long long int64_t; typedef unsigned char uint8_t; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef unsigned long long uint64_t; typedef float float32_t; typedef double float64_t; // 指针类型 typedef void* pointer; typedef const char* cstring; // 标准库类型 typedef long time_t; typedef struct tm tm_t;
]]
ffi.cdef [[ // 简单结构体 typedef struct { int x; int y; } Point; // 嵌套结构体 typedef struct { Point start; Point end; } Line; // 数组作为成员 typedef struct { char name[64]; int scores[10]; } Student; // 位字段 typedef struct { unsigned int flag1 : 1; unsigned int flag2 : 1; unsigned int : 6; // 未使用位 unsigned int value : 8; } BitField; // 联合体 typedef union { int i; float f; char bytes[4]; } DataUnion;
]]
ffi.cdef [[ // 标准库函数 // 字符串操作 size_t strlen(const char *s); char *strcpy(char *dest, const char *src); char *strcat(char *dest, const char *src); int strcmp(const char *s1, const char *s2); char *strstr(const char *haystack, const char *needle); // 内存操作 void *malloc(size_t size); void *calloc(size_t num, size_t size); void *realloc(void *ptr, size_t size); void free(void *ptr); void *memcpy(void *dest, const void *src, size_t n); void *memset(void *s, int c, size_t n); // 数学函数 double sin(double x); double cos(double x); double tan(double x); double sqrt(double x); double pow(double x, double y); double log(double x); double exp(double x); double fabs(double x); // 输入输出 int printf(const char *format, ...); int sprintf(char *str, const char *format, ...); int scanf(const char *format, ...); int puts(const char *s); // 系统调用 int system(const char *command); time_t time(time_t *t); char *ctime(const time_t *timer); // 自定义函数原型 double calculate_average(double *array, int length); void process_data(void *data, size_t size);
]]
-- 直接调用C标准库函数
print("字符串长度:", ffi.C.strlen("Hello, World!"))
print("正弦值:", ffi.C.sin(math.pi / 2))
print("平方根:", ffi.C.sqrt(2.0))
-- 调用系统命令
local result = ffi.C.system("ls -la")
print("命令返回值:", result) -- 获取当前时间
local time_ptr = ffi.new("time_t[1]")
ffi.C.time(time_ptr)
local time_str = ffi.C.ctime(time_ptr)
print("当前时间:", ffi.string(time_str))
-- 创建结构体（自动初始化为0）
local point = ffi.new("Point")
point.x = 10
point.y = 20
print("Point:", point.x, point.y) -- 创建并初始化
local point2 = ffi.new("Point", {x = 30, y = 40}) -- 创建结构体数组
local points = ffi.new("Point[5]")
points[0].x = 1
points[0].y = 2
points[1] = {x = 3, y = 4} -- 创建包含数组的结构体
local student = ffi.new("Student")
ffi.copy(student.name, "Alice")
for i = 0, 9 do student.scores[i] = math.random(60, 100)
end
-- 动态分配内存
local size = 100 * ffi.sizeof("int")
local buffer = ffi.C.malloc(size)
print("分配了", size, "字节内存") if buffer ~= ffi.NULL then -- 转换为特定类型指针 local int_array = ffi.cast("int*", buffer) -- 初始化数组 for i = 0, 99 do int_array[i] = i * i end -- 访问元素 print("int_array[50] =", int_array[50]) -- 重新分配内存 local new_size = 200 * ffi.sizeof("int") local new_buffer = ffi.C.realloc(buffer, new_size) -- 释放内存 ffi.C.free(new_buffer) print("内存已释放")
end -- 使用calloc（初始化为0）
local zero_buffer = ffi.C.calloc(10, ffi.sizeof("double"))
-- 创建C字符串
local cstr = ffi.new("char[64]")
ffi.copy(cstr, "Hello from C string") -- 转换为Lua字符串
local lua_str = ffi.string(cstr)
print("Lua字符串:", lua_str) -- 使用sprintf格式化
local buffer = ffi.new("char[256]")
ffi.C.sprintf(buffer, "格式化输出: %s, 数值: %d, 浮点数: %.2f", "测试", 123, 45.678)
print(ffi.string(buffer))
ffi.cdef [[ // 回调函数类型 typedef void (*callback_t)(int status, const char *message); // 接受回调的函数 void register_callback(callback_t cb); void trigger_event(int event_id);
]] -- Lua回调函数
local function lua_callback(status, message) print("回调被调用:") print(" 状态:", status) print(" 消息:", ffi.string(message))
end -- 将Lua函数转换为C回调
local cb = ffi.cast("callback_t", lua_callback) -- 注意：回调函数会被垃圾回收，需要保持引用
_G.keep_alive = cb
local var = ffi.new("int", 42) print("类型信息:")
print(" ffi.typeof(var):", ffi.typeof(var))
print(" ffi.istype('int', var):", ffi.istype('int', var))
print(" ffi.sizeof(var):", ffi.sizeof(var))
print(" ffi.alignof('int'):", ffi.alignof('int'))
print(" ffi.offsetof('Student', 'name'):", ffi.offsetof('Student', 'name'))
-- 基本类型转换
local int_val = ffi.new("int", 42)
local ptr = ffi.cast("void*", int_val)
local int_ptr = ffi.cast("int*", ptr) -- 指针算术
local array = ffi.new("int[10]")
for i = 0, 9 do array[i] = i * 10
end -- 获取元素指针
local elem_ptr = array + 5 -- 指向array[5]
print("array[5] =", elem_ptr[0])
local function vector_operations() ffi.cdef [[ typedef struct { double x, y, z; } Vector3; double dot_product(Vector3 a, Vector3 b); Vector3 cross_product(Vector3 a, Vector3 b); double vector_length(Vector3 v); ]] local vec1 = ffi.new("Vector3", {x=1, y=2, z=3}) local vec2 = ffi.new("Vector3", {x=4, y=5, z=6}) -- 点积（模拟） local dot = vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z print("点积:", dot) -- 叉积（模拟） local cross = ffi.new("Vector3") cross.x = vec1.y * vec2.z - vec1.z * vec2.y cross.y = vec1.z * vec2.x - vec1.x * vec2.z cross.z = vec1.x * vec2.y - vec1.y * vec2.x print("叉积:", cross.x, cross.y, cross.z)
end
local function binary_data_processing() -- 创建二进制缓冲区 local buffer_size = 1024 local buffer = ffi.new("uint8_t[?]", buffer_size) -- 填充数据 for i = 0, buffer_size - 1 do buffer[i] = math.random(0, 255) end -- 计算校验和 local checksum = 0 for i = 0, buffer_size - 1 do checksum = checksum + buffer[i] end checksum = checksum % 256 print("缓冲区大小:", buffer_size) print("校验和:", checksum) -- 查找特定字节 local target = 0xAA for i = 0, buffer_size - 1 do if buffer[i] == target then print("找到", string.format("0x%02X", target), "在位置", i) end end
end
local function system_interaction() -- 注意：这部分代码依赖于操作系统 ffi.cdef [[ // Windows API示例 #ifdef _WIN32 #include &lt;windows.h&gt; void Sleep(DWORD milliseconds); DWORD GetTickCount(); #endif // POSIX示例 #ifndef _WIN32 #include &lt;unistd.h&gt; unsigned int sleep(unsigned int seconds); #endif ]] -- 跨平台休眠 local function msleep(milliseconds) if ffi.os == "Windows" then ffi.C.Sleep(milliseconds) else ffi.C.usleep(milliseconds * 1000) end end print("开始休眠...") msleep(1000) -- 休眠1秒 print("休眠结束")
end 平台依赖性：FFI 代码可能在不同平台表现不同
类型安全：错误的类型使用可能导致崩溃
内存泄漏：需要手动管理内存
回调函数：Lua 回调可能被垃圾回收
-- 启用调试信息
ffi.cdef [[ // 添加详细的错误检查
]] -- 使用assert进行运行时检查
local ptr = ffi.C.malloc(100)
assert(ptr ~= ffi.NULL, "内存分配失败") -- 添加日志记录
local function debug_alloc(size) print("分配内存:", size, "字节") local ptr = ffi.C.malloc(size) print("返回指针:", tostring(ptr)) return ptr
end
-- 优先方案：使用函数和返回值
local function processItem(item) if not isValid(item) then return false -- 代替 goto end -- 正常处理 return true
end -- 次选方案：goto 用于简单循环控制
for i = 1, 10 do if shouldSkip(i) then goto continue end process(i) ::continue::
end
-- 难以理解：过度使用 goto
goto step1
::step3::
print("步骤3")
goto end
::step1::
print("步骤1")
goto step2
::step2::
print("步骤2")
goto step3
::end:: -- 清晰明了：限制使用范围
for i = 1, 5 do if i == 3 then goto skip_print end print("正常: " .. i) ::skip_print::
end
-- 1. 复用类型对象
local Point_type = ffi.typeof("Point")
local points = {}
for i = 1, 1000 do points[i] = Point_type() -- 比ffi.new更快
end -- 2. 批量操作
local function process_batch(data, count) local buffer = ffi.new("double[?]", count) for i = 0, count - 1 do buffer[i] = data[i + 1] * 2 end -- 批量处理buffer return buffer
end -- 3. 避免频繁的类型转换
local cached_type = ffi.typeof("int[100]")
local array = cached_type()
-- 1. 使用gc来管理内存
local function create_large_buffer() local buf = ffi.gc(ffi.C.malloc(1024 * 1024), ffi.C.free) -- buf会在垃圾回收时自动释放 return buf
end -- 2. 显式内存管理
local function manual_memory_management() local buffers = {} local function allocate(name, size) local buf = ffi.C.malloc(size) if buf == ffi.NULL then error("内存分配失败") end buffers[name] = buf return buf end local function cleanup() for name, buf in pairs(buffers) do ffi.C.free(buf) buffers[name] = nil end end -- 使用... local data = allocate("data", 1024) -- 清理... cleanup()
end LuaJIT 核心特性： 高性能 JIT 编译器 - 动态编译字节码为机器码
FFI（外部函数接口） - 直接调用 C 函数和使用 C 数据结构
完全兼容 Lua 5.1 - 无缝迁移现有代码
更低的内存占用 - 优化内存管理 JIT 编译器： jit.on() - 启用 JIT 编译
jit.off() - 禁用 JIT 编译
性能提升 2-15 倍 - 特别适合循环和数值计算
动态编译 - 运行时将热点代码编译为机器码 FFI 外部函数接口： ffi.cdef - 声明 C 函数和类型
ffi.C - 调用标准 C 库函数
ffi.new - 创建 C 结构体实例
ffi.cast - 类型转换
ffi.string - 转换 C 字符串为 Lua 字符串
ffi.copy - 复制数据到 C 缓冲区
直接内存管理 - 使用 malloc/free goto 语句： ::label:: - 定义标签
goto label - 跳转到标签
模拟 continue - Lua 原生无 continue
跳出多重嵌套 - 简化复杂控制流
卫语句模式 - 提前返回逻辑 其他增强功能： bit 库 - 位运算操作
表操作优化 - 大规模数据处理
协程优化 - 轻量级并发
垃圾回收优化 - 更高效的内存管理 完成本章后，你应该能够：
理解 LuaJIT 的性能优势和应用场景
启用和禁用 JIT 编译器
使用 FFI 调用 C 标准库函数
创建和使用 C 结构体
进行 C 风格的内存分配和管理
正确使用 goto 实现流程控制
理解 goto 的作用域限制
使用 bit 库进行位运算
利用 LuaJIT 优化大规模数据处理
手动控制垃圾回收机制 JIT 编译器在什么场景下性能提升最明显？什么场景下可能效果有限？
FFI 与传统的 Lua C API 扩展方式相比有什么优势和劣势？
为什么 goto 在大多数编程语言中都不推荐使用？Lua 中的 goto 有哪些特殊限制？
使用 FFI 直接操作内存时需要注意哪些安全问题？
如何平衡代码可读性和使用 goto 带来的便利性？
Q: 为什么 goto 有这么多限制？
A: 为了避免创建"面条代码"，确保程序结构清晰，防止跳过变量初始化等危险操作。Q: 什么时候应该使用 goto？
A: 仅当：
需要模拟 continue
简单跳出多重循环
没有更清晰的结构化替代方案
Q: goto 的性能影响？
A: Lua 的 goto 是编译期处理，运行时几乎没有性能开销。]]></description><link>第-1-节-语法/14.-luajit.html</link><guid isPermaLink="false">第 1 节 - 语法/14. LuaJIT.md</guid><pubDate>Fri, 26 Dec 2025 11:53:19 GMT</pubDate></item><item><title><![CDATA[10. 调试与错误处理]]></title><description><![CDATA[在程序开发过程中，调试是必不可少的一环。之前都是使用 print 语句进行调试，但随着程序复杂度增加，print 调试的局限性逐渐显现。print 调试的缺点：
效率低下：每次调试都需要手动添加 print 语句，调试完成后还需逐一清理
信息有限：只能显示特定变量的值，无法查看完整的调用链和执行上下文
表结构查看困难：需要手动拼接输出，复杂嵌套表需要递归处理
缺乏控制：无法暂停程序、单步执行，只能看到固定的输出结果
断点调试的优点：
高效便捷：设置一次断点，多次运行生效
信息全面：查看作用域内所有变量、调用堆栈、内存地址
可视化表结构：自动展开显示复杂嵌套表
完全控制：单步执行、条件断点、批量管理等高级功能
在代码行左侧增加断点
<img alt="Pasted image 20251225185539.png" src="site-lib/media/pasted-image-20251225185539.png" target="_self" style="width: 227px; max-width: 100%;">使用 DEBUG 模式运行<br>
<img alt="Pasted image 20251225185723.png" src="site-lib/media/pasted-image-20251225185723.png" target="_self" style="width: 375px; max-width: 100%;">可以看到程序在第一行中断了（DEBUG 模式默认在第一行打了断点）<br>
<img alt="Pasted image 20251225185853.png" src="site-lib/media/pasted-image-20251225185853.png" target="_self" style="width: 294px; max-width: 100%;">
可以在控制栏继续运行<br>
<img alt="Pasted image 20251225190026.png" src="site-lib/media/pasted-image-20251225190026.png" target="_self">继续后在运行与调试选项中可以查看变量值，或者鼠标光标悬停在变量上<br>
<img alt="Pasted image 20251225190451.png" src="site-lib/media/pasted-image-20251225190451.png" target="_self" style="width: 475px; max-width: 100%;">运行下一行代码，可以看到 a 变为了 2<br>
<img alt="Pasted image 20251225191640.png" src="site-lib/media/pasted-image-20251225191640.png" target="_self" style="width: 500px; max-width: 100%;">继续（快捷键 F5）：运行程序直到触发下一个断点
逐过程（快捷键 F10）：运行下一行代码，遇到函数直接执行整个函数
单步调试（快捷键 F11）：运行下一行代码，遇到函数进入函数内单步运行
单步跳出（快捷键 shift + F11）：跳出当前代码块local current_num = 0 local function third() current_num = 3 print("执行 third 函数") -- 断点打这里
end local function second() current_num = 2 print("执行 second 函数") third()
end local function first() current_num = 1 print("执行 first 函数") second()
end first()
可以在调用堆栈查看调用堆栈，点击 second 可以跳转到调用 third 的代码行查看其作用域内的变量<br>
<img alt="Pasted image 20251225195034.png" src="site-lib/media/pasted-image-20251225195034.png" target="_self">
调用堆栈解读：
最顶部：当前暂停位置 (third)
从上到下：函数调用顺序
每个层级：显示函数名、参数值、所在文件
点击任意层级：跳转到对应的代码位置，查看当时的变量状态
调试控制台可以直接执行 Lua 代码：-- 使用调试控制台进行交互
local inventory = { items = { { id = 1, name = "药水", count = 5 }, { id = 2, name = "武器", count = 2 }, { id = 3, name = "防具", count = 3 } }, gold = 1000
} local function find_item_by_name(name) for _, item in ipairs(inventory.items) do if item.name == name then return item end end return nil
end print("断点打这里")
-- 断点后在调试控制台中可以：
-- 1. 查看变量: &gt; inventory
-- 2. 调用函数: &gt; find_item_by_name("药水")
-- 3. 修改值: &gt; inventory.gold = 1500
-- 4. 执行表达式: &gt; #inventory.items
<br><img alt="Pasted image 20251225203906.png" src="site-lib/media/pasted-image-20251225203906.png" target="_self">监视变量用于在大量变量与复杂镶套中快速查看指定变量值-- 调试复杂表达式
local complex_data = { users = { {name = "Alice", scores = {85, 92, 78}}, {name = "Bob", scores = {88, 76, 95}}, {name = "Charlie", scores = {92, 89, 91}} }, config = { weights = {0.3, 0.4, 0.3}, threshold = 80 }
} local function calculate_weighted_scores() local results = {} for i, user in ipairs(complex_data.users) do -- 在调试时添加监视表达式： -- 1. user.name -- 2. #user.scores -- 3. complex_data.config.weights[1] local weighted_sum = 0 -- 断点打这里 for j, score in ipairs(user.scores) do weighted_sum = weighted_sum + score * complex_data.config.weights[j] end table.insert(results, { name = user.name, score = weighted_sum, passed = weighted_sum &gt;= complex_data.config.threshold }) end return results
end local results = calculate_weighted_scores()
<br><img alt="Pasted image 20251225201739.png" src="site-lib/media/pasted-image-20251225201739.png" target="_self">右键断点可以编辑断点设置其他类型的断点。<br>
<img alt="Pasted image 20251225202221.png" src="site-lib/media/pasted-image-20251225202221.png" target="_self" style="width: 725px; max-width: 100%;">条件断点允许输入条件来在指定条件下触发断点，适合过滤无关触发。-- 条件断点示例
local function find_special_num(num) for i = 1, num do local current_num = i if i == 100 then -- 可以设置条件断点：i == 99 提前一步暂停 print("找到特殊数字！") end end
end find_special_num(100)
命中断点允许在断点被触发特定次数后才暂停程序执行，适合调试循环或重复调用的情况。-- 调试循环中的特定迭代
local function process_items(items) local processed = {} local total_value = 0 for i, item in ipairs(items) do local value = item.price * item.quantity	-- 设置命中次数断点：== 3 在第3次迭代时暂停 total_value = total_value + value table.insert(processed, { id = item.id, name = item.name, value = value, cumulative = total_value }) print(string.format("处理第%d项: %s = %d", i, item.name, value)) end return processed, total_value
end local inventory = { {id = 1, name = "苹果", price = 5, quantity = 10}, {id = 2, name = "香蕉", price = 3, quantity = 15}, {id = 3, name = "橙子", price = 4, quantity = 8}, -- 我们想检查这一项 {id = 4, name = "葡萄", price = 8, quantity = 6}, {id = 5, name = "西瓜", price = 15, quantity = 3}
} local results, total = process_items(inventory)
print("总计价值:", total)
日志断点不会暂停程序，而是在触发时输出信息到控制台，适合在不中断流程的情况下跟踪程序状态。
日志断点类似于 print，花括号 {} 内可以输入变量。local a = 1 for i = 1, 10 do a = a + 1	-- 增加日志断点：触发断点 i = {i}
end
--[[ 输出
触发断点 i = 1.0
触发断点 i = 2.0
触发断点 i = 3.0
触发断点 i = 4.0
触发断点 i = 5.0
触发断点 i = 6.0
触发断点 i = 7.0
触发断点 i = 8.0
触发断点 i = 9.0
触发断点 i = 10.0
--]]
等待断点指定的另一个断点触发后，等待断点才会触发，适合在不重复设定复杂条件断点的情况下应用其条件。local a = 1 for i = 1, 100 do print(a)	-- 增加条件断点：i == 50 print(-a)	-- 增加等待断点：指定上面的断点 a = a + 1
end
-- 将会在 i = 50 时先后触发两个断点
local function debug_loop() local matrix = {} -- 初始化矩阵 for i = 1, 3 do matrix[i] = {} for j = 1, 3 do matrix[i][j] = i * j -- 在此行添加断点，观察循环变量 end end -- 处理矩阵 local sum = 0 for i = 1, #matrix do for j = 1, #matrix[i] do sum = sum + matrix[i][j] end end return matrix, sum
end debug_loop()
local function factorial(n) if n &lt;= 1 then return 1 end local v = n * factorial(n - 1) return v	-- 打断点观察阶乘值
end local function fibonacci(n) if n &lt;= 1 then return n end local v = fibonacci(n - 1) + fibonacci(n - 2) return v	-- 打断点观察数列值
end -- 测试递归函数
print("5的阶乘:", factorial(5))
print("斐波那契第6项:", fibonacci(6))
查看调用堆栈可方便查看调用链，在特定位置断点查看变量值可辅助理解代码含义，使用单步可让程序自动跳转到执行位置。-- 简单的购物车系统 - 通过断点理解代码逻辑 -- 1. 商品数据
-- 断点: 查看商品初始化
local products = { { id = 1, name = "苹果", price = 5.5, stock = 100 }, { id = 2, name = "香蕉", price = 3.2, stock = 80 }, { id = 3, name = "橙子", price = 4.8, stock = 60 }, { id = 4, name = "葡萄", price = 8.9, stock = 40 }
} -- 2. 购物车数据
-- 断点: 观察购物车初始化
local shopping_cart = { items = {}, -- 购买的商品 total = 0, -- 总金额 item_count = 0 -- 商品数量
} -- 3. 查找商品函数
-- 断点: 了解如何查找商品
local function find_product(product_id) for _, product in ipairs(products) do if product.id == product_id then return product end end return nil
end -- 4. 添加商品到购物车
-- 断点: 查看核心逻辑
local function add_to_cart(product_id, quantity) quantity = quantity or 1 -- 默认数量为1 -- 查找商品 local product = find_product(product_id) if not product then return false, "商品不存在" end -- 检查库存 if product.stock &lt; quantity then return false, "库存不足" end -- 更新购物车 local existing_item = shopping_cart.items[product_id] if existing_item then -- 已存在，增加数量 existing_item.quantity = existing_item.quantity + quantity existing_item.subtotal = existing_item.quantity * product.price else -- 新商品 shopping_cart.items[product_id] = { product_id = product_id, name = product.name, price = product.price, quantity = quantity, subtotal = product.price * quantity } shopping_cart.item_count = shopping_cart.item_count + 1 end -- 更新库存 product.stock = product.stock - quantity -- 更新总金额 shopping_cart.total = shopping_cart.total + (product.price * quantity) return true, "添加成功"
end -- 5. 从购物车移除商品
-- 断点: 理解移除逻辑
local function remove_from_cart(product_id, quantity) local item = shopping_cart.items[product_id] if not item then return false, "商品不在购物车中" end quantity = quantity or item.quantity -- 默认移除全部 if quantity &gt; item.quantity then quantity = item.quantity end -- 更新购物车 if quantity == item.quantity then -- 移除整个商品 shopping_cart.items[product_id] = nil shopping_cart.item_count = shopping_cart.item_count - 1 else -- 减少数量 item.quantity = item.quantity - quantity item.subtotal = item.quantity * item.price end -- 恢复库存 local product = find_product(product_id) if product then product.stock = product.stock + quantity end -- 更新总金额 shopping_cart.total = shopping_cart.total - (item.price * quantity) -- 如果总金额为负，设为0 if shopping_cart.total &lt; 0 then shopping_cart.total = 0 end return true, "移除成功"
end -- 6. 显示购物车
-- 断点: 查看显示逻辑
local function show_cart() if shopping_cart.item_count == 0 then print("购物车为空") return end print("\n=== 购物车内容 ===") print(string.format("%-5s %-10s %-8s %-8s %-8s", "ID", "商品名", "单价", "数量", "小计")) print(string.rep("-", 45)) local count = 0 for _, item in pairs(shopping_cart.items) do count = count + 1 print(string.format("%-5d %-10s %-8.2f %-8d %-8.2f", item.product_id, item.name, item.price, item.quantity, item.subtotal)) end print(string.rep("-", 45)) print(string.format("总计: %.2f 元", shopping_cart.total)) print(string.format("商品总数: %d 件", shopping_cart.item_count))
end -- 7. 显示商品列表
-- 断点: 查看商品展示
local function show_products() print("\n=== 商品列表 ===") print(string.format("%-5s %-10s %-8s %-8s", "ID", "商品名", "价格", "库存")) print(string.rep("-", 35)) for _, product in ipairs(products) do print(string.format("%-5d %-10s %-8.2f %-8d", product.id, product.name, product.price, product.stock)) end
end -- 8. 结算函数
-- 断点: 了解结算过程
local function checkout() if shopping_cart.item_count == 0 then return false, "购物车为空" end print("\n=== 结算 ===") show_cart() -- 应用折扣（满100减10） local discount = 0 if shopping_cart.total &gt;= 100 then discount = 10 print(string.format("\n折扣: -%.2f 元", discount)) end local final_total = shopping_cart.total - discount print(string.format("实付金额: %.2f 元", final_total)) -- 清空购物车 for product_id, item in pairs(shopping_cart.items) do shopping_cart.items[product_id] = nil end shopping_cart.total = 0 shopping_cart.item_count = 0 return true, "结算成功"
end -- 9. 主程序流程
-- 断点: 开始跟踪整个流程
local function main() print("欢迎使用购物车系统!") -- 初始状态 show_products() -- 测试购物车操作 print("\n[测试1] 添加商品到购物车") -- 断点: 跟踪添加过程 local success, message = add_to_cart(1, 3) -- 3个苹果 print("添加苹果:", message) success, message = add_to_cart(2, 2) -- 2个香蕉 print("添加香蕉:", message) success, message = add_to_cart(3, 5) -- 5个橙子 print("添加橙子:", message) -- 查看购物车 show_cart() print("\n[测试2] 再次添加相同商品") -- 断点: 观察重复添加 success, message = add_to_cart(1, 2) -- 再添加2个苹果 print("再添加苹果:", message) show_cart() show_products() -- 查看库存变化 print("\n[测试3] 移除部分商品") -- 断点: 跟踪移除过程 success, message = remove_from_cart(3, 2) -- 移除2个橙子 print("移除橙子:", message) show_cart() show_products() -- 查看库存恢复 print("\n[测试4] 尝试结算") -- 断点: 观察结算流程 success, message = checkout() print("结算结果:", message) print("\n[测试5] 结算后查看状态") show_cart() print("\n谢谢使用!")
end -- 10. 运行程序
main()
在现实的程序中，错误是不可避免的。没有错误处理的程序就像没有刹车的汽车一样危险。-- 没有错误处理的危险程序
local function get_table_value(t, k1, k2) return t[k1][k2]
end local t = {}
get_table_value(t, "key1", "key2")	-- t.key1 为 nil，t.key1.key2 会报错：尝试索引 nil 值
-- 程序会在这里抛出错误，程序终止
print("这行代码不会执行")
-- 1. 忘记写值
local x =
-- 错误: unexpected symbol near '&lt;eof&gt;' -- 2. 代码块没有闭合
local t = { 1, 2, 3
-- 错误: '}' expected (to close '{' at line 1)
if a then
-- 错误: 'end' expected (to close 'if' at line 1) near '&lt;eof&gt;'
-- 索引 nil 值
print(undefined_table.v)
-- 错误: attempt to index global 'undefined_table' (a nil value) 尝试索引 nil 值
-- 程序能运行，结果不对
local function calculate_average(numbers) local sum = 0 for i = 1, #numbers do sum = sum + numbers[i] end return sum / #numbers -- 如果numbers为空表，会除以0，返回 1.#INF
end
-- 1. 文件不存在
local file, err = io.open("nonexistent.txt", "r")
if not file then print(err) -- 输出: nonexistent.txt: No such file or directory
end -- 2. 内存不足
local huge_table = {}
for i = 1, math.huge do huge_table[i] = string.rep("x", 1000000)
end
-- 报错: not enough memory -- 3. 栈溢出
local function err_fn() err_fn()
end
err_fn()
-- 报错: stack overflow
local function test_fn() a.b.c = 123
end test_fn()
--[[ 输出
lua: test.lua:2: attempt to index global 'a' (a nil value)
stack traceback: test.lua:2: in function 'test_fn' test.lua:5: in main chunk [C]: ?
--]]
test.lua:2 为错误的路径模块与行数
attempt to index global 'a' (a nil value) 为错误信息：尝试索引 nil 值
stack traceback 调用堆栈（从下往上看）
test.lua:5: in main chunk 在主代码块先执行了第 5 行代码
test.lua:2: in function 'test_fn' 最后执行了 test_fn 函数中的第 2 行pcall (protected call) 是Lua最基本的错误处理机制，以保护模式调用函数。函数中的任何错误不会抛出；取而代之的是 pcall&nbsp;会将错误捕获。pcall(保护函数: func, 函数参数: any...) -&gt; 是否有错误: bool, 返回值|错误信息: any|str...
-- pcall处理多个返回值
local function multiple_returns() return 1, 2, 3, 4, 5
end local function failing_function() error("出错了！", 0)
end print("\n多返回值处理:")
success, a, b, c, d, e = pcall(multiple_returns)
if success then print(" 成功返回: " .. a .. ", " .. b .. ", " .. c .. ", " .. d .. ", " .. e)
else print(" 错误: " .. a) -- 注意：错误信息在第一个返回值
end success, err = pcall(failing_function)
if not success then print(" 捕获错误: " .. err)
end
--[[ 输出
成功返回: 1, 2, 3, 4, 5
捕获错误: 出错了！
--]]
xpcall 比 pcall 更强大，可以指定错误信息处理函数xpcall(保护函数: func, 信息处理函数: func, 函数参数: any...) -&gt; 是否有错误: bool, 返回值|处理后的信息: any|str...
-- 错误处理函数
local function error_handler(err) -- err参数是错误信息 local debug_info = debug.traceback("错误追踪:", 2) return string.format("发生错误: %s\n%s", err, debug_info)
end local function risky_operation() local t = {1, 2, 3} return t[10] * 2 -- t[10]是nil，nil * 2会出错
end print("xpcall示例1:")
local success, result = xpcall(risky_operation, error_handler)
if success then print(" 结果: " .. result)
else print(" 错误处理:\n" .. result)
end
--[[ 输出
发生错误: test.lua:10: attempt to perform arithmetic on field '?' (a nil value)
错误追踪:
stack traceback: test.lua:10: in function &lt;test.lua:8&gt; [C]: in function 'xpcall' test.lua:14: in main chunk [C]: ?
--]]
error(信息: str, 错误级别?: int) 错误级别默认为 1
-- 示例1：基本错误抛出
local function validate_age(age) if type(age) ~= "number" then error("年龄必须是数字", 2) -- level=2表示错误在调用者的位置 end if age &lt; 0 then error("年龄不能为负数", 2) end if age &gt; 150 or age == 0 then error("年龄不合理", 2) end return true
end print("年龄验证测试:")
local test_ages = {25, -5, "二十", 200, 0} for i, age in ipairs(test_ages) do local success, result = pcall(validate_age, age) if success then print(" 年龄 " .. age .. ": 有效") else print(" 年龄 " .. age .. ": " .. result) end
end
--[[ 输出
年龄 25: 有效
年龄 -5: 年龄不能为负数
年龄 二十: 年龄必须是数字
年龄 200: 年龄不合理
年龄 0: 有效
--]] -- 示例2：错误级别的作用
local function level_demo() print("\n错误级别演示:") local function inner_function() error("错误发生在inner_function", 0) -- level 0: 不添加位置信息 end local function middle_function() error("错误发生在middle_function", 1) -- level 1: 调用error的位置 end local function outer_function() error("错误发生在outer_function", 2) -- level 2: 调用者的位置 end -- 测试不同level local function test_error(func, level_desc) local success, err = pcall(func) if not success then print(" " .. level_desc .. ": " .. err) end end test_error(inner_function, "level 0") test_error(middle_function, "level 1") test_error(outer_function, "level 2")
end level_demo()
assert 用于检查条件，如果条件为假则抛出错误assert(条件: bool, 错误信息?: str, 参数?: any...) -&gt; 参数: any... 错误信息默认为 "assertion failed!"
-- 示例1：基本断言
function calculate_bmi(weight, height) -- 参数验证 assert(type(weight) == "number", "体重必须是数字") assert(type(height) == "number", "身高必须是数字") assert(weight &gt; 0, "体重必须大于0") assert(height &gt; 0, "身高必须大于0") return weight / (height * height)
end print("BMI计算测试:")
local test_cases = { {70, 1.75}, -- 有效 {-70, 1.75}, -- 无效体重 {70, -1.75}, -- 无效身高 {"70", 1.75}, -- 字符串体重
} for i, case in ipairs(test_cases) do local success, result = pcall(calculate_bmi, case[1], case[2]) if success then print(string.format(" 体重%.1fkg, 身高%.2fm -&gt; BMI: %.1f", case[1], case[2], result)) else print(" 错误: " .. result) end
end -- 示例2：assert与error的区别
print("\nassert vs error:") function using_assert(value) assert(value ~= nil, "值不能为nil") return value * 2
end function using_error(value) if value == nil then error("值不能为nil", 2) end return value * 2
end -- 两个函数的功能相同，但assert更简洁
local test_values = {5, nil} for i, value in ipairs(test_values) do print("\n测试值: " .. tostring(value)) local success1, result1 = pcall(using_assert, value) if success1 then print(" assert版本: " .. result1) else print(" assert版本错误: " .. result1) end local success2, result2 = pcall(using_error, value) if success2 then print(" error版本: " .. result2) else print(" error版本错误: " .. result2) end
end -- 示例3：在生产环境中禁用断言
-- 在开发时使用断言检查，发布时可以关闭
local DEBUG_MODE = true function release_assert(condition, message) if DEBUG_MODE then assert(condition, message) elseif not condition then -- 在生产环境中，记录错误但不抛出 print("[生产环境错误] " .. (message or "断言失败")) return false end return true
end print("\n生产环境断言:")
local function test_function(x) if not release_assert(x &gt; 0, "x必须大于0") then return nil end return x * 2
end -- 测试模式
DEBUG_MODE = true
print("调试模式:")
local success, result = pcall(test_function, -5)
if not success then print(" 错误: " .. result)
end -- 生产模式
DEBUG_MODE = false
print("\n生产模式:")
local result = test_function(-5)
if result then print(" 结果: " .. result)
else print(" 函数返回nil（不抛出错误）")
end
假设一切可能出错，并提前处理-- 示例1：安全的表访问
local function safe_table_access(t, key, default) if type(t) ~= "table" then return default end local value = t[key] if value == nil then return default end return value
end print("安全表访问:")
local config = {theme = "dark", language = "zh-CN"}
print(" 主题: " .. safe_table_access(config, "theme", "light"))
print(" 音量: " .. safe_table_access(config, "volume", 70)) -- 使用默认值
print(" 非表: " .. safe_table_access("不是表", "key", "默认"))
--[[ 输出
主题: dark
音量: 70
非表: 默认
--]] -- 示例2：安全的函数调用
local function safe_call(func, ...) if type(func) ~= "function" then return nil, "不是函数" end local success, result = pcall(func, ...) if not success then return nil, result end return result
end print("\n安全函数调用:")
local function add(a, b) return a + b
end
local result, err = safe_call(add, 5, 3)
if result then print(" 5 + 3 = " .. result)
else print(" 错误: " .. err)
end result, err = safe_call("不是函数", 5, 3)
if result then print(" 结果: " .. result)
else print(" 错误: " .. err)
end
--[[ 输出
5 + 3 = 8 错误: 不是函数
--]] -- 示例3：验证输入数据
local function validate_user_input(input) -- 多层验证 if not input then return nil, "输入不能为空" end if type(input) ~= "table" then return nil, "输入必须是表" end -- 验证必填字段 local required = {"username", "email", "password"} for _, field in ipairs(required) do if not input[field] or #tostring(input[field]) == 0 then return nil, "字段 '" .. field .. "' 不能为空" end end -- 验证邮箱格式 local email = input.email if not string.match(email, "^[%w%.%-]+@[%w%.%-]+%.[%a]+$") then return nil, "邮箱格式无效" end -- 验证密码强度 local password = input.password if #password &lt; 8 then return nil, "密码至少需要8个字符" end return true
end print("\n输入验证:")
local inputs = { {username = "user1", email = "test@example.com", password = "secure123"}, {username = "", email = "test@example.com", password = "short"}, -- 用户名为空 {username = "user2", email = "invalid-email", password = "password123"}, -- 邮箱无效 {username = "user3", email = "test@example.com", password = "123"}, -- 密码太短
} for i, input in ipairs(inputs) do local valid, err = validate_user_input(input) if valid then print(" 输入 " .. i .. ": 有效") else print(" 输入 " .. i .. ": 无效 - " .. err) end
end
--[[ 输出 输入 1: 有效 输入 2: 无效 - 字段 'username' 不能为空 输入 3: 无效 - 邮箱格式无效 输入 4: 无效 - 密码至少需要8个字符
--]]
-- 错误恢复：从错误中恢复并继续执行
-- 策略1：重试机制
local function retry_operation(operation, max_attempts, delay) max_attempts = max_attempts or 3 delay = delay or 1 -- 默认延迟1秒 for attempt = 1, max_attempts do local success, result = pcall(operation) if success then return result end print(string.format(" 尝试 %d/%d 失败: %s", attempt, max_attempts, result)) if attempt &lt; max_attempts then print(string.format(" 等待 %.1f 秒后重试...", delay)) -- 在实际应用中，这里应该使用 os.execute 或类似方法等待 -- 为了示例简化，我们只是打印 end end return nil, "所有重试尝试都失败"
end print("重试机制:")
local function unreliable_operation() math.randomseed(os.time()) if math.random() &lt; 0.7 then -- 70%失败率 error("操作失败: 随机错误") end return "操作成功"
end local result, err = retry_operation(unreliable_operation, 5, 0.5)
if result then print(" 最终结果: " .. result)
else print(" 最终错误: " .. err)
end -- 策略2：降级服务
print("\n降级服务:")
local function fetch_data(source, fallback_source) -- 尝试主数据源 local success, data = pcall(source.fetch) if success then print(" 使用主数据源") return data end print(" 主数据源失败: " .. data) print(" 尝试备用数据源...") -- 尝试备用数据源 success, data = pcall(fallback_source.fetch) if success then print(" 使用备用数据源") return data end print(" 备用数据源也失败: " .. data) -- 返回缓存或默认数据 print(" 返回缓存数据") return {cached = true, data = "默认数据"}
end -- 模拟数据源
local primary_source = { fetch = function() if math.random() &lt; 0.5 then error("主数据源不可用") end return {source = "primary", data = "新鲜数据"} end
} local fallback_source = { fetch = function() if math.random() &lt; 0.3 then error("备用数据源不可用") end return {source = "fallback", data = "稍旧的数据"} end
} for i = 1, 3 do print("\n尝试 " .. i .. ":") local data = fetch_data(primary_source, fallback_source) print(" 获取的数据: " .. data.data .. " (来源: " .. (data.source or "缓存") .. ")")
end -- 策略3：优雅降级
print("\n优雅降级:")
local function render_ui(use_advanced_features) local features = {} -- 基础功能总是可用的 features.basic = true -- 高级功能可能不可用 if use_advanced_features then local success = pcall(function() -- 模拟需要特定库或环境的功能 if not package.loaded["advanced_graphics"] then error("高级图形库未安装") end features.advanced_graphics = true end) if not success then print(" 警告: 高级图形功能不可用，使用基础渲染") features.advanced_graphics = false end else features.advanced_graphics = false end -- 根据可用功能渲染UI if features.advanced_graphics then print(" 使用高级UI渲染") else print(" 使用基础UI渲染") end return features
end print("渲染测试:")
render_ui(true)
render_ui(false) -- 策略4：隔离故障
print("\n故障隔离:")
local function isolated_operation(operation_name, operation_func) -- 在独立的协程中执行操作，防止一个操作失败影响其他操作 local co = coroutine.create(function() local success, result = pcall(operation_func) if not success then print(" 操作 '" .. operation_name .. "' 失败: " .. result) return nil, result end return result end) local success, result = coroutine.resume(co) if success and coroutine.status(co) == "dead" then return result else return nil, "操作未完成" end
end print("隔离执行:")
local results = {} results.op1 = isolated_operation("操作1", function() error("操作1故意失败")
end) results.op2 = isolated_operation("操作2", function() return "操作2成功"
end) results.op3 = isolated_operation("操作3", function() error("操作3也失败")
end) print("\n所有操作结果:")
for name, result in pairs(results) do if result then print(" " .. name .. ": " .. result) else print(" " .. name .. ": 失败") end
end
-- 创建结构化的错误类型，便于处理
-- 错误类型定义
local ErrorTypes = { VALIDATION = { code = 100, name = "VALIDATION_ERROR", description = "输入验证失败" }, DATABASE = { code = 200, name = "DATABASE_ERROR", description = "数据库操作失败" }, NETWORK = { code = 300, name = "NETWORK_ERROR", description = "网络通信失败" }, PERMISSION = { code = 400, name = "PERMISSION_ERROR", description = "权限不足" }, INTERNAL = { code = 500, name = "INTERNAL_ERROR", description = "内部服务器错误" }
} -- 错误创建函数
local function create_error(error_type, message, details) local error_info = ErrorTypes[error_type] if not error_info then error_info = ErrorTypes.INTERNAL end return { type = error_type, code = error_info.code, name = error_info.name, message = message or error_info.description, details = details, timestamp = os.time(), stack_trace = debug.traceback("", 2) }
end -- 错误抛出函数
local function throw_error(error_type, message, details) error(create_error(error_type, message, details), 2)
end -- 错误处理函数
local function handle_error(err, context) -- 如果是我们的自定义错误 if type(err) == "table" and err.code then print(string.format("[错误处理] 类型: %s (%d)", err.name, err.code)) print(string.format(" 消息: %s", err.message)) if err.details then print(string.format(" 详情: %s", tostring(err.details))) end if context then print(string.format(" 上下文: %s", context)) end print(" 调用栈:") print(err.stack_trace) -- 根据错误类型采取不同措施 if err.type == "VALIDATION" then return nil, "输入错误，请检查后重试" elseif err.type == "PERMISSION" then return nil, "权限不足，请联系管理员" elseif err.type == "NETWORK" then -- 可以尝试重试 return nil, "网络错误，请稍后重试" else return nil, "系统错误，请联系技术支持" end else -- 其他类型的错误 return nil, "未知错误: " .. tostring(err) end
end -- 使用自定义错误
print("自定义错误演示:") local function register_user(user_data) -- 验证输入 if not user_data or not user_data.username then throw_error("VALIDATION", "用户名不能为空", user_data) end if #user_data.username &lt; 3 then throw_error("VALIDATION", "用户名至少需要3个字符", {username = user_data.username, length = #user_data.username}) end -- 模拟数据库操作 local success, db_result = pcall(function() -- 模拟数据库错误 if user_data.username == "admin" then error("用户名已存在") end return {id = 123, username = user_data.username} end) if not success then throw_error("DATABASE", "创建用户失败", {error = db_result}) end -- 模拟权限检查 if user_data.username == "root" then throw_error("PERMISSION", "不允许注册root用户") end return db_result
end -- 测试不同的错误情况
local test_cases = { {username = ""}, -- 验证错误 {username = "ab"}, -- 用户名太短 {username = "admin"}, -- 数据库错误 {username = "root"}, -- 权限错误 {username = "正常用户"}, -- 成功
} for i, test_case in ipairs(test_cases) do print(string.format("\n测试用例 %d: 用户名='%s'", i, test_case.username)) local success, result = pcall(register_user, test_case) if success then print(" 成功: 用户ID = " .. result.id) else local _, user_message = handle_error(result, "用户注册") print(" 失败: " .. user_message) end
end
--[[ 输出
测试用例 1: 用户名=''
[错误处理] 类型: VALIDATION_ERROR (100) 消息: 用户名至少需要3个字符 详情: table: 00C22798 上下文: 用户注册 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:99: in function &lt;test.lua:92&gt; [C]: in function 'pcall' test.lua:136: in main chunk [C]: ? 失败: 输入错误，请检查后重试 测试用例 2: 用户名='ab'
[错误处理] 类型: VALIDATION_ERROR (100) 消息: 用户名至少需要3个字符 详情: table: 00C22B30 上下文: 用户注册 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:99: in function &lt;test.lua:92&gt; [C]: in function 'pcall' test.lua:136: in main chunk [C]: ? 失败: 输入错误，请检查后重试 测试用例 3: 用户名='admin'
[错误处理] 类型: DATABASE_ERROR (200) 消息: 创建用户失败 详情: table: 00C22C20 上下文: 用户注册 调用栈: stack traceback: test.lua:51: in function 'throw_error' est.lua:113: in function &lt;test.lua:92&gt; [C]: in function 'pcall' test.lua:136: in main chunk [C]: ? 失败: 系统错误，请联系技术支持 测试用例 4: 用户名='root'
[错误处理] 类型: PERMISSION_ERROR (400) 消息: 不允许注册root用户 上下文: 用户注册 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:118: in function &lt;test.lua:92&gt; [C]: in function 'pcall' test.lua:136: in main chunk [C]: ? 失败: 权限不足，请联系管理员 测试用例 5: 用户名='正常用户' 成功: 用户ID = 123
--]]
local GradeSystem = { students = {}, courses = {}, grades = {}, statistics = { total_students = 0, total_courses = 0, average_scores = {} }
} local function generate_id(prefix, existing_ids) local max_id = 0 for id, _ in pairs(existing_ids) do local num = tonumber(id:match("%d+$")) if num and num &gt; max_id then max_id = num end end return string.format("%s%04d", prefix, max_id + 1)
end local function calculate_weighted_average(scores, credits) local total_score = 0 local total_credit = 0 for course_id, score in pairs(scores) do local credit = credits[course_id] or 1 total_score = total_score + score * credit total_credit = total_credit + credit end return total_credit &gt; 0 and total_score / total_credit or 0
end function GradeSystem:add_student(name, major, class) local student_id = generate_id("STU", self.students) self.students[student_id] = { id = student_id, name = name, major = major or "未分配", class = class or "未知班级", enrolled_courses = {}, enroll_date = os.date("%Y-%m-%d") } self.statistics.total_students = self.statistics.total_students + 1 return student_id
end function GradeSystem:add_course(name, credit, teacher) local course_id = generate_id("COU", self.courses) self.courses[course_id] = { id = course_id, name = name, credit = credit or 1, teacher = teacher or "待分配", enrolled_students = {} } self.statistics.total_courses = self.statistics.total_courses + 1 return course_id
end function GradeSystem:enroll_course(student_id, course_id) local student = self.students[student_id] local course = self.courses[course_id] if not student or not course then return false, "学生或课程不存在" end if student.enrolled_courses[course_id] then return false, "该课程已选" end student.enrolled_courses[course_id] = true student.enrolled_courses[course.name] = course_id course.enrolled_students[student_id] = true self.grades[student_id] = self.grades[student_id] or {} self.grades[student_id][course_id] = nil return true, "选课成功"
end function GradeSystem:record_grade(student_id, course_id, score) local student = self.students[student_id] if (not self.grades[student_id] or not self.grades[student_id][course_id]) and (not student or not student.enrolled_courses[course_id]) then return false, "学生未选此课程" end if score &lt; 0 or score &gt; 100 then return false, "分数必须在0-100之间" end self.grades[student_id] = self.grades[student_id] or {} self.grades[student_id][course_id] = score self:update_statistics() return true, "成绩录入成功"
end function GradeSystem:update_statistics() local course_scores = {} local course_counts = {} for student_id, courses in pairs(self.grades) do for course_id, score in pairs(courses) do if score then course_scores[course_id] = (course_scores[course_id] or 0) + score course_counts[course_id] = (course_counts[course_id] or 0) + 1 end end end for course_id, total_score in pairs(course_scores) do local count = course_counts[course_id] or 1 self.statistics.average_scores[course_id] = total_score / count end
end function GradeSystem:get_student_report(student_id) local student = self.students[student_id] if not student then return nil, "学生不存在" end local report = { student_id = student_id, name = student.name, major = student.major, class = student.class, courses = {}, total_average = 0, weighted_average = 0 } local total_score = 0 local total_courses = 0 local scores_with_credits = {} local credits = {} for course_id, _ in pairs(student.enrolled_courses) do if type(course_id) == "string" and course_id:match("^COU") then local course = self.courses[course_id] local score = self.grades[student_id] and self.grades[student_id][course_id] if course then local course_info = { id = course_id, name = course.name, credit = course.credit, teacher = course.teacher, score = score or "未录入" } table.insert(report.courses, course_info) if score then total_score = total_score + score total_courses = total_courses + 1 scores_with_credits[course_id] = score credits[course_id] = course.credit end end end end if total_courses &gt; 0 then report.total_average = total_score / total_courses report.weighted_average = calculate_weighted_average(scores_with_credits, credits) end table.sort(report.courses, function(a, b) local score_a = a.score or 0 local score_b = b.score or 0 return score_a &gt; score_b end) return report
end function GradeSystem:get_course_report(course_id) local course = self.courses[course_id] if not course then return nil, "课程不存在" end local report = { course_id = course_id, name = course.name, credit = course.credit, teacher = course.teacher, enrolled_count = 0, graded_count = 0, average_score = 0, score_distribution = { excellent = { name = "优秀", count = 0 }, good = { name = "良好", count = 0 }, medium = { name = "中等", count = 0 }, pass = { name = "及格", count = 0 }, fail = { name = "不及格", count = 0 } }, student_list = {} } local total_score = 0 for student_id, _ in pairs(course.enrolled_students) do report.enrolled_count = report.enrolled_count + 1 local score = self.grades[student_id] and self.grades[student_id][course_id] if score then report.graded_count = report.graded_count + 1 total_score = total_score + score score_dis = report.score_distribution if score &gt;= 90 then score_dis.excellent.count = score_dis.excellent.count + 1 elseif score &gt;= 80 then score_dis.good.count = score_dis.good.count + 1 elseif score &gt;= 70 then score_dis.medium.count = score_dis.medium.count + 1 elseif score &gt;= 60 then score_dis.pass.count = score_dis.pass.count + 1 else score_dis.fail.count = score_dis.fail.count + 1 end local student = self.students[student_id] if student then table.insert(report.student_list, { student_id = student_id, name = student.name, score = score, grade = score &gt;= 90 and "优秀" or score &gt;= 80 and "良好" or score &gt;= 70 and "中等" or score &gt;= 60 and "及格" or "不及格" }) end end end if report.graded_count &gt; 0 then report.average_score = total_score / report.graded_count end table.sort(report.student_list, function(a, b) return a.score &gt; b.score end) return report
end function GradeSystem:find_top_students(min_average, limit) local qualified_students = {} for student_id, student in pairs(self.students) do local report = self:get_student_report(student_id) if report and report.weighted_average &gt;= (min_average or 85) then table.insert(qualified_students, { student_id = student_id, name = student.name, major = student.major, class = student.class, weighted_average = report.weighted_average, course_count = #report.courses }) end end table.sort(qualified_students, function(a, b) return a.weighted_average &gt; b.weighted_average end) if limit and limit &gt; 0 then qualified_students = { unpack(qualified_students, 1, limit) } end return qualified_students
end local function initialize_test_data(system) local math_id = system:add_course("高等数学", 4, "张教授") local english_id = system:add_course("大学英语", 3, "王老师") local programming_id = system:add_course("程序设计", 3, "李教授") local physics_id = system:add_course("大学物理", 3, "赵教授") local history_id = system:add_course("中国近代史", 2, "刘老师") local stu1 = system:add_student("张三", "计算机科学", "计科2001") local stu2 = system:add_student("李四", "软件工程", "软工2001") local stu3 = system:add_student("王五", "信息安全", "信安2001") local stu4 = system:add_student("赵六", "计算机科学", "计科2001") local stu5 = system:add_student("钱七", "软件工程", "软工2001") system:enroll_course(stu1, math_id) system:enroll_course(stu1, english_id) system:enroll_course(stu1, programming_id) system:enroll_course(stu2, math_id) system:enroll_course(stu2, english_id) system:enroll_course(stu2, physics_id) system:enroll_course(stu3, programming_id) system:enroll_course(stu3, physics_id) system:enroll_course(stu3, history_id) system:enroll_course(stu4, math_id) system:enroll_course(stu4, programming_id) system:enroll_course(stu4, physics_id) system:enroll_course(stu4, history_id) system:enroll_course(stu5, english_id) system:enroll_course(stu5, programming_id) system:enroll_course(stu5, history_id) local scores = { [stu1] = { [math_id] = 88, [english_id] = 92, [programming_id] = 95 }, [stu2] = { [math_id] = 76, [english_id] = 85, [physics_id] = 82 }, [stu3] = { [programming_id] = 91, [physics_id] = 78, [history_id] = 88 }, [stu4] = { [math_id] = 94, [programming_id] = 89, [physics_id] = 86, [history_id] = 92 }, [stu5] = { [english_id] = 79, [programming_id] = 83, [history_id] = 85 } } for student_id, course_scores in pairs(scores) do for course_id, score in pairs(course_scores) do system:record_grade(student_id, course_id, score) end end print(string.format("已添加 %d 名学生，%d 门课程", system.statistics.total_students, system.statistics.total_courses))
end local function demonstrate_system_workflow() initialize_test_data(GradeSystem) print("\n查询学生成绩单") local report, err = GradeSystem:get_student_report("STU0004") if report then print(string.format("学生: %s (%s - %s)", report.name, report.major, report.class)) print(string.format("加权平均分: %.2f, 简单平均分: %.2f", report.weighted_average, report.total_average)) print("各科成绩:") for i, course in ipairs(report.courses) do print(string.format(" %s (%s): %s (学分: %d)", course.name, course.teacher, course.score, course.credit)) end else print("错误:", err) end print("\n查询课程统计") local course_report, course_err = GradeSystem:get_course_report("COU0003") if course_report then print(string.format("课程: %s (%s)", course_report.name, course_report.teacher)) print(string.format("选课人数: %d, 已录入成绩: %d", course_report.enrolled_count, course_report.graded_count)) print(string.format("平均分: %.2f", course_report.average_score)) print("成绩分布:") local distribution = {} for _, dis in pairs(course_report.score_distribution) do if dis.count &gt; 0 then print(string.format(" %s: %d人", dis.name, dis.count)) end end print("成绩前3名:") for i = 1, math.min(3, #course_report.student_list) do local student = course_report.student_list[i] print(string.format(" %d. %s: %.1f (%s)", i, student.name, student.score, student.grade)) end else print("错误:", course_err) end print("\n查找成绩优异学生(平均分≥85)") local top_students = GradeSystem:find_top_students(85, 5) print(string.format("找到 %d 名符合条件的学生:", #top_students)) for i, student in ipairs(top_students) do print(string.format(" %d. %s (%s) - 平均分: %.2f, 已修课程: %d门", i, student.name, student.major, student.weighted_average, student.course_count)) end print("\n模拟新操作流程") local new_student_id = GradeSystem:add_student("孙八", "人工智能", "智能2001") print(string.format("添加新学生: %s", new_student_id)) local success, msg = GradeSystem:enroll_course(new_student_id, "COU0001") print(string.format("选课结果: %s - %s", success and "成功" or "失败", msg)) success, msg = GradeSystem:record_grade(new_student_id, "COU0001", 96) print(string.format("成绩录入: %s - %s", success and "成功" or "失败", msg)) local new_report, new_err = GradeSystem:get_student_report(new_student_id) if new_report then print(string.format("新学生成绩单: 平均分 %.2f, 已修 %d 门课", new_report.weighted_average, #new_report.courses)) end print("\n系统统计信息") print(string.format("系统概况: %d 名学生, %d 门课程", GradeSystem.statistics.total_students, GradeSystem.statistics.total_courses)) print("各课程平均分:") for course_id, avg_score in pairs(GradeSystem.statistics.average_scores) do local course = GradeSystem.courses[course_id] if course then print(string.format(" %s: %.2f", course.name, avg_score)) end end
end local function main() local start_time = os.clock() demonstrate_system_workflow() local end_time = os.clock() print(string.format("\n程序执行时间: %.3f 秒", end_time - start_time))
end -- 运行主程序
main()
<br>（答案见<a data-href="第 1 节 - 语法/参考答案#练习 10.2：模拟数据库操作错误处理" href="第-1-节-语法/参考答案.html#练习 10.2：模拟数据库操作错误处理" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 10.2：模拟数据库操作错误处理</a>）-- 模拟数据库操作的错误处理
-- 使用示例：
-- 使用数据库
print("数据库操作测试:")
local db = data_base.new { host = "localhost", database = "mydb", username = "admin", password = "secret"
} -- 包装数据库操作为安全操作
function safe_database_operation(db, operation_name, operation, ...) print("\n操作: " .. operation_name) local result, err = db:safe_execute(operation, ...) if result then print(" 成功") return result else local _, user_msg = handle_error(err, operation_name) print(" 失败: " .. user_msg) return nil, err end
end -- 测试各种操作
-- 连接数据库
safe_database_operation(db, "连接数据库", db.connect) -- 查询数据
local users, err = safe_database_operation(db, "查询用户", function(self) return self:query("SELECT * FROM users WHERE status = 'active'")
end) if users then print(" 查询到 " .. #users .. " 个用户")
end -- 测试插入重复数据
local insert_result, err = safe_database_operation(db, "插入用户", function(self) return self:query("INSERT INTO users (name, email) VALUES (?, ?)", { "测试用户", "duplicate@example.com" })
end) -- 测试事务
print("\n测试事务操作:")
local transaction_success, transaction_err = pcall(function() db:begin_transaction() -- 多个操作 db:query("UPDATE accounts SET balance = balance - 100 WHERE id = 1") db:query("UPDATE accounts SET balance = balance + 100 WHERE id = 2") db:commit() print(" 事务执行成功")
end) if not transaction_success then print(" 事务失败: " .. tostring(transaction_err)) if db.transaction_active then db:rollback() end
end -- 断开连接
safe_database_operation(db, "断开连接", db.disconnect)
--[[ 输出
操作: 连接数据库 连接数据库 localhost:3306...
[错误处理] 类型: NETWORK_ERROR (300) 消息: 数据库连接失败 详情: table: 00E5CEA0 上下文: 连接数据库 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:114: in function &lt;test.lua:104&gt; [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:267: in main chunk [C]: ? 失败: 网络错误，请稍后重试 操作: 查询用户 检测到连接问题，尝试重连... 连接数据库 localhost:3306...
[错误处理] 类型: DATABASE_ERROR (200) 消息: 数据库未连接 上下文: 查询用户 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:126: in function &lt;test.lua:124&gt; (tail call): ? [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:270: in main chunk [C]: ? 失败: 系统错误，请联系技术支持 操作: 插入用户 检测到连接问题，尝试重连... 连接数据库 localhost:3306...
[错误处理] 类型: DATABASE_ERROR (200) 消息: 数据库未连接 上下文: 插入用户 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:126: in function &lt;test.lua:124&gt; (tail call): ? [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:279: in main chunk [C]: ? 失败: 系统错误，请联系技术支持 测试事务操作: 开始事务 事务失败: table: 00E5CF68 回滚事务 操作: 断开连接 断开数据库连接 成功
--]] 断点的使用： 代码行左侧打断点
使用控制栏控制程序运行
使用调用堆栈查看函数调用链
在调试控制台执行 Lua 代码
使用监视变量快速查找指定变量 控制栏的使用： 继续：继续运行程序
逐过程：运行下一行代码
单步：运行下一行代码，包括函数内
单步跳出：跳出当前代码块 特殊断点： 条件断点：判断通过触发，过滤无关触发
命中断点：命中指定次数触发，适合递归与循环
日志断点：不中断程序，打印临时日志
等待断点：指定断点触发后触发 错误类型： 语法错误：代码块未闭合
运行错误：索引 nil
逻辑错误：结果错误
资源错误：未找到文件、内存不足、栈溢出 错误处理： pcall：保护调用，捕获错误
xpcall：带错误处理函数的保护调用
error：主动抛出错误
assert：条件断言，失败时抛出错误 错误处理策略： 防御性编程
错误恢复（重试、降级、隔离）
错误日志和监控
自定义错误类型 最佳实践： 输入验证
资源清理
错误传播
用户友好错误消息 -- 模式 1：立即返回错误
function process_data(data) if not data then return nil, "数据不能为空" end -- 处理数据... return result
end -- 模式 2：抛出异常
function validate_input(input) if not input then error("输入不能为空", 2) end -- 验证通过...
end -- 模式 3：使用断言
function critical_operation(param) assert(param ~= nil, "参数不能为 nil") -- 关键操作...
end -- 模式 4：错误转换
function api_wrapper(func) return function(...) local success, result = pcall(func, ...) if not success then -- 转换为 API 错误格式 return {success = false, error = result} end return {success = true, data = result} end
end
-- 陷阱 1：忽略错误
local file = io.open("missing.txt", "r")
local content = file:read("*all") -- 如果文件不存在，file 是 nil，这里会崩溃
file:close() -- 正确做法
local file, err = io.open("missing.txt", "r")
if not file then print("错误: " .. err) return
end -- 陷阱 2：错误信息不明确
local function bad_error_handling() local success, result = pcall(some_operation) if not success then print("错误") -- 不明确 end
end -- 正确做法
local function good_error_handling() local success, result = pcall(some_operation) if not success then print("操作失败: " .. result) print("调用栈: " .. debug.traceback()) end
end -- 陷阱 3：过度使用 pcall
local function overuse_pcall() -- 每个操作都用 pcall 包装，性能差且代码冗长 local s1, r1 = pcall(operation1) local s2, r2 = pcall(operation2) local s3, r3 = pcall(operation3) -- ...
end -- 正确做法：在合适的层级处理错误
local function proper_error_handling() local function inner() operation1() operation2() operation3() end local success, err = pcall(inner) if not success then -- 统一处理错误 handle_error(err) end
end -- 陷阱 4：资源泄漏
local function resource_leak() local file = io.open("test.txt", "w") file:write("数据") -- 忘记关闭文件！ -- 如果后面发生错误，文件永远不会关闭
end -- 正确做法：确保资源释放
local function proper_resource_handling() local file, err = io.open("test.txt", "w") if not file then return nil, err end local success, result = pcall(function() file:write("数据") -- 其他可能失败的操作... end) -- 无论如何都关闭文件 file:close() if not success then return nil, result end return true
end
-- 错误处理对性能的影响 -- 1. pcall 有一定开销，避免在紧循环中使用
local function benchmark_pcall() local start = os.clock() -- 直接调用 for i = 1, 100000 do local _ = math.sqrt(i) end local time1 = os.clock() - start start = os.clock() -- 使用 pcall for i = 1, 100000 do local success, result = pcall(math.sqrt, i) end local time2 = os.clock() - start print("直接调用: " .. time1 .. "秒") print("pcall 调用: " .. time2 .. "秒") print("开销: " .. (time2 - time1) .. "秒")
end -- 2. 在适当层级处理错误，避免不必要的包装
-- 不好：每个函数都用 pcall
local function process_data_unsafe(data) local s1, r1 = pcall(validate, data) local s2, r2 = pcall(transform, data) local s3, r3 = pcall(save, data) -- 检查每个结果...
end -- 好：在高层统一处理
local function process_data_safe(data) local function process() validate(data) transform(data) save(data) end local success, err = pcall(process) if not success then return nil, err end return true
end
（点击勾选框勾选）
完成本章后，你应该能够：
会使用各种调试功能
理解 Lua 的错误处理机制
使用 pcall 和 xpcall 保护代码执行
使用 error 和 assert 主动抛出错误
实现防御性编程策略
设计错误恢复机制
创建和使用自定义错误类型
记录和监控错误信息
避免常见的错误处理陷阱 为什么需要这么多调试功能？
什么时候应该返回错误码，什么时候应该抛出异常？
如何处理不可恢复的错误（如内存不足）？
如何在分布式系统中传播和处理错误？
错误处理策略如何影响代码的可读性和可维护性？
如何平衡错误处理的完整性和性能开销？ 实现一个完整的错误处理框架，支持错误分类，包括完整日志模块
实现一个智能重试机制，根据错误类型动态调整重试策略
下一章预告：在第 11 章中，我们将学习迭代器和泛型 for。这是 Lua 中非常强大的特性，让我们能够以统一的方式遍历各种数据结构，包括自定义的数据结构。我们将学习如何创建和使用迭代器，理解泛型 for 的工作原理，以及如何实现各种复杂的遍历模式。学习建议：
多使用断点，了解错误都会在什么情况下触发
在实际编码中养成错误处理的习惯
从简单错误处理开始，逐步实现更复杂的策略
注意区分可恢复错误和不可恢复错误
记录错误信息，便于调试和维护
定期审查错误处理代码，确保其正确性和完整性
]]></description><link>第-1-节-语法/10.-调试与错误处理.html</link><guid isPermaLink="false">第 1 节 - 语法/10. 调试与错误处理.md</guid><pubDate>Fri, 26 Dec 2025 10:27:58 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5. 科技树与难度设定]]></title><description><![CDATA[模块位置：kr/upgrades游戏设定用于存储关卡部分信息、游戏难度的差异、图鉴部分数据等模块位置：kr/game_settings难度设定用于设置不同难度下的实体模板数据模块位置：all/difficulty]]></description><link>第-2-节-修改基础/5.-科技树与难度设定.html</link><guid isPermaLink="false">第 2 节 - 修改基础/5. 科技树与难度设定.md</guid><pubDate>Fri, 26 Dec 2025 07:21:17 GMT</pubDate></item><item><title><![CDATA[1. 介绍]]></title><description><![CDATA[《王国保卫战》（Kingdom Rush）是由乌拉圭的 Ironhide Game Studio 游戏工作室于 2011 年制作的一款塔防类策略游戏。游戏使用 ECS（Entity-Component-System）实体-组件-系统架构它通过将数据（组件）和行为（系统）解耦，并用实体将它们灵活地组合起来，为游戏开发带来了一种高性能、高弹性且易于管理的代码组织方式。
table 库额外增加深浅拷贝、深浅合并、高阶函数等
增加 vector 向量库
增加 macros 宏指令库
增加 class 模拟类库
增加 signal 信号库
增加 timer 定时器库
增加 log 日志库
注：只有触发断点时监视才可用<img alt="Pasted image 20250621105918.png" src="site-lib/media/pasted-image-20250621105918.png" target="_self" style="width: 450px; max-width: 100%;">点击左上角金币图标，即可开启有 UI 的调试（功能与快捷键相同）<br>
<img alt="Pasted image 20250620190901.png" src="site-lib/media/pasted-image-20250620190901.png" target="_self" style="width: 600px; max-width: 100%;"><br><img alt="Pasted image 20251213194044.png" src="site-lib/media/pasted-image-20251213194044.png" target="_self" style="width: 900px; max-width: 100%;">
调试控制台会显示详细信息，比如加载资源，所有点击事件，操作实体（插入，移除）等点击代码行左侧即可增加断点。注：断点只有 Debug 模式可用<br>
<img alt="Pasted image 20251213173619.png" src="site-lib/media/pasted-image-20251213173619.png" target="_self" style="width: 281px; max-width: 100%;">运行过程可按 0 手动断点直接使用 Debug 模式进入游戏即可在 args 取消 screen 与 custom 的注释， custom 输入要编辑的关卡的编号运行后即可进入关卡编辑器<br>
<img alt="Pasted image 20250712192159.png" src="site-lib/media/pasted-image-20250712192159.png" target="_self" style="width: 500px; max-width: 100%;">游戏中报错通常会直接蓝屏，上面显示错误信息。<br>
<img alt="Pasted image 20250624161626.png" src="site-lib/media/pasted-image-20250624161626.png" target="_self" style="width: 400px; max-width: 100%;">游戏中协程错误会直接显示在调试控制台，通常某个实体卡住，无法移动与攻击就代表出现了协程错误<br>
<img alt="Pasted image 20251213194044.png" src="site-lib/media/pasted-image-20251213194044.png" target="_self" style="width: 900px; max-width: 100%;">
Error running coro: kr1/game_scripts.lua:1430: attempt to index global 'a' (a nil value) 如图关闭输入法即可<br><img alt="Pasted image 20250803203730.png" src="site-lib/media/pasted-image-20250803203730.png" target="_self" style="width: 750px; max-width: 100%;">
在 all/systems 搜索 main_script:on_update-- 将以下代码修改
if coroutine.status(s.co) == "dead" or error ~= nil then if error ~= nil then -- 修改为
if coroutine.status(s.co) == "dead" or (not success and error ~= nil) then if not success and error ~= nil then
<br><img alt="Pasted image 20250717091020.png" src="site-lib/media/pasted-image-20250717091020.png" target="_self" style="width: 975px; max-width: 100%;"> 游戏自带的几个库： 向量库：vector 宏指令库：macros 模拟类库：class 信号库：signal
定时器库：timer 日志库：log table 库扩展功能： 深浅拷贝
深浅合并
高阶函数 调试功能： 监视变量：在运行与调试监视变量
调试控制台：类似于输出
调试快捷键：m 增加金币、l 增加生命、z 加速、a 暂停等
断点：在代码行左侧打断点、游戏内按 0 手动断点、报错时自动断点
关卡编辑器：修改 args 进入关卡编辑器 两种报错形式： 蓝屏：一般报错
控制台的报错：协程报错等 下一章预告：在第 2 章中，我们将学习游戏实体数据的存储与修改，这是了解游戏系统的关键一步！]]></description><link>第-2-节-修改基础/1.-介绍.html</link><guid isPermaLink="false">第 2 节 - 修改基础/1. 介绍.md</guid><pubDate>Fri, 26 Dec 2025 07:00:16 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2. 基础语法规则]]></title><description><![CDATA[首先从最简单的程序开始，理解 Lua 的基本结构。1. 打开工作区文件夹
<img alt="Pasted image 20251206205112.png" src="site-lib/media/pasted-image-20251206205112.png" target="_self" style="width: 425px; max-width: 100%;">
2. 创建 Lua 文件 test.lua<br>
<img alt="Pasted image 20251206205740.png" src="site-lib/media/pasted-image-20251206205740.png" target="_self" style="width: 372px; max-width: 100%;">3. 输入代码print("Hello, Lua World!")
4. 运行<br>
<img alt="Pasted image 20251225155912.png" src="site-lib/media/pasted-image-20251225155912.png" target="_self" style="width: 650px; max-width: 100%;">可以看到成功输出 Hello, Lua World!
语句：print("Hello, Lua World!") 是一条语句
函数调用：print() 是调用一个函数
字符串："Hello, Lua World!" 是一个字符串值
print("你好，世界！")
-- 输出 浣犲ソ锛屼笘鐣岋紒
由于终端编码限制所以需要让文本输出到调试控制台上。<br>
<img alt="Pasted image 20251225194347.png" src="site-lib/media/pasted-image-20251225194347.png" target="_self" style="width: 775px; max-width: 100%;">将 integratedTerminal 修改为 internalConsole<br>
<img alt="Pasted image 20251225194118.png" src="site-lib/media/pasted-image-20251225194118.png" target="_self" style="width: 407px; max-width: 100%;">
Lua 版本修改为 5.1 即可<br>
<img alt="Pasted image 20251226133851.png" src="site-lib/media/pasted-image-20251226133851.png" target="_self"><br>
<img alt="Pasted image 20251225194600.png" src="site-lib/media/pasted-image-20251225194600.png" target="_self">注释用于解释代码，不会被 Lua 执行。Lua 有两种注释方式：-- 这是单行注释，直到行尾结束
local x = 10 -- 行尾注释，解释这行代码
--[[ 这是多行注释 可以跨越多行 常用于文档说明或临时禁用代码块
]]
print("这段代码会执行") --[[ 临时禁用一段代码： print("这行不会执行") local y = 20
]]
使用快捷键 ctrl + / 即可快速注释以及取消注释-- print("被注释的代码")	-- ctrl + / 快速注释
标识符是变量、函数、表等的名称。Lua 的命名规则很简单：player_name -- 蛇形命名法（使用下划线替代空格，全小写） PlayerName -- 帕斯卡命名法（使用大写替代空格，首字母大写） playerName -- 驼峰命名法（使用大写替代空格，首字母小写） _player -- 下划线开头
player1 -- 包含数字（但不能以数字开头）
-- 这些会导致错误：
变量名 -- 不能使用中文
1player -- 不能以数字开头
player-name -- 不能包含连字符
player name -- 不能包含空格
local -- 不能使用关键字
end
以下是 Lua 的保留字，不能用作标识符：-- 1. 变量使用蛇形命名法
local player_health = 100
local game_score = 0 -- 2. 常量使用全大写（虽然没有真正的常量，但约定俗成）
local MAX_PLAYERS = 4
local PI = 3.14159 -- 3. 函数名使用蛇形命名法
function calculate_damage() -- 函数体
end -- 4. 避免使用单个字母的变量名（除非是循环计数器）
for i = 1, 10 do -- i是习惯用法，可以接受 print(i)
end -- 5. 类名使用帕斯卡命名法
TowerMenu = class("TowerMenu")
Lua 中，语句可以用分号或换行分隔：-- 使用分号分隔（不常用）
local a = 1; local b = 2; print(a + b) -- 使用换行分隔（推荐）
local a = 1
local b = 2
print(a + b) -- 混合使用
local a = 1; local b = 2 -- 同一行用分号
print(a + b) -- 新一行不需要分号
良好的代码风格让程序更易读：-- 使用Tab缩进（不要用空格）
if condition then print("缩进的代码")
end -- 不好的缩进
if condition then
print("这样很难读") -- 没有缩进 print("缩进不一致") -- 突然缩进
end
-- 建议每行不超过80个字符
-- 太长的行可以这样拆分： -- 拆分字符串
local message = "这是一段非常非常非常非常非常" .. "非常非常非常非常长的字符串" -- 拆分函数传递
local result = calculate_total_score( player1_score, player2_score, bonus_points, difficulty_multiplier
)
-- 用空白行分隔逻辑块
local player_name = "小明"
local player_level = 1 -- 角色状态初始化
local health = 100
local mana = 50 -- 装备初始化
local weapon = "木剑"
local armor = "布衣" print("角色创建完成")
local t = { "箭塔", "兵营", "法师塔", "炮塔"
}
-- 运算符空格
local n = 100 + 50
-- local n=100+50 过于紧凑不好 if n == 150 then
...
end
-- if n==150 then 过于紧凑不好 -- 逗号空格
local function test(test1, test2, test3) ...
end test(1, 2, 3)
-- test(1,2,3) 过于紧凑不好
可以使用 vscode 的自动格式化功能来优化代码格式。使用快捷键：shift + alt + f-- 不好的格式
print(1,2,3,4,5) do
local a = 10 local b = 20
print(a+b)
end -- 按 shift + alt + f 格式化后
print(1, 2, 3, 4, 5)
do local a = 10 local b = 20 print(a + b)
end
-- 错误1：缺少引号
print("Hello World) -- 编译错误：未结束的字符串 -- 错误2：拼写错误
prin("Hello") -- 运行时错误：尝试调用nil值 -- 错误3：缺少end
if true then print("This is true")
-- 忘记写end -- 编译错误：'&lt;eof&gt;' expected near '&lt;eof&gt;' -- 错误4：中文标点（初学者常见）
print（"Hello"） -- 编译错误：使用中文括号
-- 1. 使用print调试
print("=== 程序开始 ===")
local x = 10
print("x的值为: " .. x) -- 2. 检查变量类型
local value = "100"
print(type(value)) -- 输出：string -- 3. 临时禁用代码块
-- print("这段代码暂时不需要")
-- 可以按快捷键 ctrl + / 快速注释掉
<br>（答案见 <a data-href="第 1 节 - 语法/参考答案#练习 2 2 ：判断以下哪些是合法的标识符：" href="第-1-节-语法/参考答案.html#练习 2 2 ：判断以下哪些是合法的标识符：" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 2 2 ：判断以下哪些是合法的标识符：</a>）
playerName
2ndPlayer
player_score
local
_internal
my-var
玩家1
<br>（答案见 <a data-href="第 1 节 - 语法/参考答案#练习 2 3：创建一个自我介绍程序" href="第-1-节-语法/参考答案.html#练习 2 3：创建一个自我介绍程序" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 2 3：创建一个自我介绍程序</a>）--[[
任务：创建一个程序，输出以下信息：
1. 你的名字
2. 年龄
3. 兴趣爱好
4. 学习Lua的目标
]] 注释：-- 单行注释，--[[ ... ]] 多行注释
标识符：字母、数字、下划线组成，不能以数字开头，区分大小写
关键字：避免使用 and、if、end 等保留字作为标识符
代码块：do...end 定义局部作用域
语句分隔：分号可选，通常用换行
代码风格：一致的缩进、命名、格式、表换行
自动格式化：使用快捷键 shift + alt + f （点击勾选框勾选）
完成本章后，你应该能够：
写出带注释的 Lua 程序
使用合法的标识符命名变量
识别常见的语法错误
遵循基本的代码风格规范 为什么良好的代码风格很重要？
如果程序中有一段暂时不需要的代码，应该怎么做？
以下哪个命名最好？为什么？ a
player1Health
player_health
PlayerHealth 下一章预告：在第 3 章中，我们将学习变量和数据类型，这是编程的基础。你会学到如何存储不同类型的数据。拓展阅读：
<br><a data-tooltip-position="top" aria-label="https://www.runoob.com/lua/lua-tutorial.html" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.runoob.com/lua/lua-tutorial.html" target="_self">Lua 教程 | 菜鸟教程</a>
<br><a data-tooltip-position="top" aria-label="http://www.lua.org/manual/5.1" rel="noopener nofollow" class="external-link is-unresolved" href="http://www.lua.org/manual/5.1" target="_self">Lua 官方手册</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/luarocks/lua-style-guide" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/luarocks/lua-style-guide" target="_self">代码风格指南</a>
常见问题解答：
Q: Lua 区分大小写吗？
A: 是的，myVar 和 myvar 是两个不同的变量。Q: 注释会影响程序性能吗？
A: 不会，注释在程序运行时会被完全忽略。Q: 一行代码可以写多个语句吗？
A: 可以，用分号分隔，但不推荐这样做。]]></description><link>第-1-节-语法/2.-基础语法规则.html</link><guid isPermaLink="false">第 1 节 - 语法/2. 基础语法规则.md</guid><pubDate>Fri, 26 Dec 2025 05:39:24 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[参考答案]]></title><description><![CDATA[ playerName ✓
2ndPlayer ✗（以数字开头）
player_score ✓
local ✗（关键字）
_internal ✓
my-var ✗（包含连字符）
玩家1 ✗（中文）
-- 基本信息
local name = "张三"
local age = 25
local interests = "编程、游戏、阅读"
local goal = "掌握Lua编程，开发自己的小游戏" -- 输出信息
print("姓名: " .. name)
print("年龄: " .. age .. "岁")
print("兴趣爱好: " .. interests)
print("学习目标: " .. goal)
local function describe_value(value) local t = type(value) local description if t == "nil" then description = "空值" elseif t == "boolean" then description = "布尔值" elseif t == "number" then description = "数字" elseif t == "string" then description = "字符串" elseif t == "table" then description = "表" elseif t == "function" then description = "函数" end print(description)
end -- 测试输出
describe_value(nil) -- 输出 空值
describe_value(true) -- 输出 布尔值
describe_value(123) -- 输出 数字
describe_value("string") -- 输出 字符串
describe_value({1, 2, 3}) -- 输出 表
describe_value(describe_value)	-- 输出 函数
local operator = "+"	-- 模拟用户输入
local a = 5
local b = 3 if operator == "+" then print(a + b)
elseif operator == "-" then print(a - b)
elseif operator == "*" then print(a * b)
elseif operator == "/" then print(a / b)
elseif operator == "%" then print(a % b)
elseif operator == "^" then print(a ^ b)
end
print("我已经想好了一个1-100之间的数字") -- 生成随机数
math.randomseed(os.time()) -- 设置随机种子
local random_number = math.random(1, 100)
local guess_count = 0
local max_guesses = 4 print("你有" .. max_guesses .. "次机会猜中这个数字") while guess_count &lt; max_guesses do guess_count = guess_count + 1 local remaining_guesses = max_guesses - guess_count + 1 print("\n第" .. guess_count .. "次尝试，还剩" .. remaining_guesses .. "次机会") print("请输入你的猜测（1-100）:") -- 模拟用户输入 local guess if guess_count == 1 then guess = 50 -- 第一次猜50 elseif guess_count == 2 then guess = 25 -- 第二次猜25 else guess = secret_number -- 第三次猜中 end print("你猜的是：" .. guess) if guess &lt; secret_number then print("太小了！") elseif guess &gt; secret_number then print("太大了！") else print("恭喜你！猜对了！") print("你用了" .. guess_count .. "次猜中数字" .. secret_number) break end if guess_count == max_guesses then print("\n很遗憾，你没有在" .. max_guesses .. "次内猜中") print("正确答案是：" .. secret_number) end
end print("游戏结束")
--[[ 输出
我已经想好了一个1-100之间的数字
你有4次机会猜中这个数字 第1次尝试，还剩10次机会
请输入你的猜测（1-100）:
你猜的是：50
太大了！ 第2次尝试，还剩9次机会
请输入你的猜测（1-100）:
你猜的是：25
太小了！ 第3次尝试，还剩8次机会
请输入你的猜测（1-100）:
你猜的是：26
恭喜你！猜对了！
你用了3次猜中数字26
游戏结束
--]]
-- 1. 打印直角三角形
print("\n1. 直角三角形:")
local height = 5
for i = 1, height do for j = 1, i do io.write("* ") end print()
end -- 2. 打印倒直角三角形
print("\n2. 倒直角三角形:")
for i = height, 1, -1 do for j = 1, i do io.write("* ") end print()
end -- 3. 打印等腰三角形
print("\n3. 等腰三角形:")
for i = 1, height do -- 打印空格 for j = 1, height - i do io.write(" ") end -- 打印星号 for j = 1, 2 * i - 1 do io.write("*") end print()
end -- 4. 打印空心菱形
print("\n4. 空心菱形:")
local diamond_height = 8
local half = diamond_height / 2 + 1 -- 上半部分
for i = 1, half do for j = 1, half - i do io.write(" ") end io.write("*") if i &gt; 1 then for j = 1, 2 * i - 3 do io.write(" ") end io.write("*") end print()
end -- 下半部分
for i = half - 1, 1, -1 do for j = 1, half - i do io.write(" ") end io.write("*") if i &gt; 1 then for j = 1, 2 * i - 3 do io.write(" ") end io.write("*") end print()
end
--[[ 输出
1. 直角三角形:
* * * * * * * * * * * * * * * 2. 倒直角三角形:
* * * * * * * * * * * * * * * 3. 等腰三角形: * *** ***** *******
********* 4. 空心菱形: * * * * * * *
* * * * * * * * *
--]]
-- 加法
local function add(a, b) return a + b
end -- 减法
local function subtract(a, b) return a - b
end -- 乘法
local function multiply(a, b) return a * b
end -- 除法（带错误检查）
local function divide(a, b) if b == 0 then return nil, "除数不能为 0" end return a / b
end -- 平均值
local function average(...) local numbers = {...} local sum = 0 for _, num in ipairs(numbers) do sum = sum + num end return sum / #numbers
end -- 使用函数库
print("5 + 3 = " .. add(5, 3))
print("10 - 4 = " .. subtract(10, 4))
print("6 * 7 = " .. multiply(6, 7)) local result, error_msg = divide(10, 0)
if error_msg then print("错误: " .. error_msg)
else print("10 / 2 = " .. result)
end print("平均值(1,2,3,4,5) = " .. average(1, 2, 3, 4, 5))
--[[ 输出
5 + 3 = 8
10 - 4 = 6
6 * 7 = 42
错误: 除数不能为 0
平均值(1,2,3,4,5) = 3
--]]
-- 模拟购买的物品
local function get_cart_item() return { { name = "苹果", price = 5, quantity = 3 }, { name = "香蕉", price = 3, quantity = 2 }, { name = "橙子", price = 6, quantity = 4 }, { name = "葡萄", price = 8, quantity = 1 } }
end -- 打印商品详细信息
local function print_item_info(cart) print("=== 商品详情 ===") for _, item in ipairs(cart) do local item_total = item.price * item.quantity print("商品: " .. item.name) print("单价: " .. item.price .. "元") print("数量: " .. item.quantity) print("小计: " .. item_total .. "元") print("------------") end
end -- 计算购物车总价
local function calculate_cart_info(cart) local total_price, total_quantity = 0, 0 for _, item in ipairs(cart) do total_price = total_price + (item.price * item.quantity) total_quantity = total_quantity + item.quantity end print("购物车总价: " .. total_price .. "元") return total_price, total_quantity
end -- 判断是否有优惠（满50减10，满100减25，买10个赠1个）
local function check_discount(total_price, total_quantity) if total_price &lt; 50 then print("未满50元，无优惠") return end if total_quantity &gt;= 10 then print("购物车物品总数：" .. total_quantity .. "个，赠品1个") end local discount_price = total_price if total_price &gt;= 100 then discount_price = total_price - 25 print("符合优惠条件，满100减25") elseif total_price &gt;= 50 then discount_price = total_price - 10 print("符合优惠条件，满50减10") end print("优惠后价格: " .. discount_price .. "元")
end local function rec_item(recommendations) for _, rec in ipairs(recommendations) do local rec_total = rec.price * 1 -- 假设推荐买1个 print(" " .. rec.name .. ": " .. rec.price .. "元/个") end
end -- 根据购物车推荐相关商品
local function recommendations_item(cart) print("\n=== 推荐商品 ===") local recommendations = { { name = "梨子", price = 6 }, { name = "芒果", price = 10 } } for _, cart_item in ipairs(cart) do if cart_item.name == "苹果" then print("您购买了苹果，可能也喜欢:") rec_item(recommendations) elseif cart_item.name == "香蕉" then print("您购买了香蕉，可能也喜欢:") rec_item(recommendations) elseif cart_item.name == "橙子" then print("您购买了橙子，可能也喜欢:") rec_item(recommendations) end end
end -- 主程序
local function main() -- 获取购物车物品 local cart = get_cart_item() -- 打印商品信息 print_item_info(cart) -- 计算总价和总数量 local total_price, total_quantity = calculate_cart_info(cart) -- 检查优惠 check_discount(total_price, total_quantity) -- 推荐相关商品 recommendations_item(cart)
end -- 运行主程序
main()
--[[ 输出
=== 商品详情 ===
商品: 苹果
单价: 5元
数量: 3
小计: 15元
------------
商品: 香蕉
单价: 3元
数量: 2
小计: 6元
------------
商品: 橙子
单价: 6元
数量: 4
小计: 24元
------------
商品: 葡萄
单价: 8元
数量: 1
小计: 8元
------------
购物车总价: 53元
购物车物品总数：10个，赠品1个
符合优惠条件，满50减10
优惠后价格: 43元 === 推荐商品 ===
您购买了苹果，可能也喜欢: 梨子: 6元/个 芒果: 10元/个
您购买了香蕉，可能也喜欢: 梨子: 6元/个 芒果: 10元/个
您购买了橙子，可能也喜欢: 梨子: 6元/个 芒果: 10元/个
--]]
local contacts = {} local function add_contact(name, phone, email) if contacts[name] then print("联系人 " .. name .. " 已存在") return false end contacts[name] = { phone = phone, email = email or "" } print("已添加联系人: " .. name) return true
end local function find_contact(name) local contact = contacts[name] if not contact then print("未找到联系人: " .. name) return nil end print("找到联系人 " .. name .. ":") print(" 电话: " .. contact.phone) print(" 邮箱: " .. (contact.email ~= "" and contact.email or "无")) return contact
end local function list_contacts() if #contacts == 0 then print("通讯录为空") return end print("=== 通讯录 ===") local count = 0 for name, info in pairs(contacts) do count = count + 1 print(count .. ". " .. name .. " - " .. info.phone) end print("总计: " .. count .. " 个联系人")
end local function remove_contact(name) if not contacts[name] then print("联系人不存在: " .. name) return false end contacts[name] = nil print("已删除联系人: " .. name) return true
end -- 测试联系人管理系统
add_contact("张三", "13800138000", "zhangsan@email.com")
add_contact("李四", "13900139000")
add_contact("王五", "13700137000", "wangwu@company.com") list_contacts() find_contact("张三")
find_contact("赵六") remove_contact("李四")
list_contacts() --[[ 输出
=== 联系人管理系统 ===
已添加联系人: 张三
已添加联系人: 李四
已添加联系人: 王五
通讯录为空
找到联系人 张三: 电话: 17300138000 邮箱: zhangsan@email.com
未找到联系人: 赵六
已删除联系人: 李四
通讯录为空
--]]
local shopping_cart = { items = {}, -- 商品列表 total_price = 0 -- 总价
} function shopping_cart:add_item(name, price, quantity) quantity = quantity or 1 -- 检查是否已存在 for _, item in ipairs(self.items) do if item.name == name then item.quantity = item.quantity + quantity item.subtotal = item.price * item.quantity self.total_price = self.total_price + price * quantity print("已更新商品: " .. name .. " x" .. quantity) return end end -- 新商品 local new_item = { name = name, price = price, quantity = quantity, subtotal = price * quantity } table.insert(self.items, new_item) self.total_price = self.total_price + new_item.subtotal print("已添加商品: " .. name .. " x" .. quantity)
end function shopping_cart:remove_item(name, quantity) quantity = quantity or 99999 -- 默认移除全部 for i, item in ipairs(self.items) do if item.name == name then local remove_qty = math.min(quantity, item.quantity) item.quantity = item.quantity - remove_qty item.subtotal = item.price * item.quantity self.total_price = self.total_price - item.price * remove_qty if item.quantity &lt;= 0 then table.remove(self.items, i) print("已移除商品: " .. name) else print("已减少商品: " .. name .. " x" .. remove_qty .. "，剩余: x" .. item.quantity) end return end end print("商品不存在: " .. name)
end function shopping_cart:show_cart() if #self.items == 0 then print("购物车为空") return end print("=== 购物车 ===") for i, item in ipairs(self.items) do print(string.format("%d. %-15s 单价: %6.2f 数量: %3d 小计: %8.2f", i, item.name, item.price, item.quantity, item.subtotal)) end print(string.format("\n总计: %.2f 元", self.total_price))
end function shopping_cart:clear() self.items = {} self.total_price = 0 print("已清空购物车")
end -- 测试购物车系统
print("=== 购物车系统 ===")
shopping_cart:add_item("苹果", 5.5, 2)
shopping_cart:add_item("香蕉", 3.2, 3)
shopping_cart:add_item("苹果", 5.5, 1) -- 增加苹果数量 shopping_cart:show_cart() shopping_cart:remove_item("香蕉", 1) -- 减少香蕉数量 shopping_cart:show_cart() shopping_cart:clear()
shopping_cart:show_cart() --[[ 输出
== 购物车系统 ===
已添加商品: 苹果 x2
已添加商品: 香蕉 x3
已更新商品: 苹果 x1
=== 购物车 ===
1. 苹果 单价: 5.50 数量: 3 小计: 16.50
2. 香蕉 单价: 3.20 数量: 3 小计: 9.60 总计: 38.90 元
已减少商品: 香蕉 x1，剩余: x2
=== 购物车 ===
1. 苹果 单价: 5.50 数量: 3 小计: 16.50
2. 香蕉 单价: 3.20 数量: 2 小计: 6.40 总计: 35.70 元
已清空购物车
购物车为空
--]]
local analysis = { data = {}
} function analysis:analyze_text(text) local data = self.data -- 基本统计 data.total_chars = #text local _, lines = string.gsub(text, "\n", "") data.lines = lines + 1 -- 单词统计 local word_pattern = "[%a\128-\255]+[%w\128-\255%-']*" local words = {} for word in string.gmatch(text, word_pattern) do word = string.lower(word) words[word] = (words[word] or 0) + 1 end data.word_count = 0 data.most_frequent = {} for word, count in pairs(words) do data.word_count = data.word_count + count -- 记录最频繁的单词 table.insert(data.most_frequent, { word = word, count = count }) end -- 按频率排序 table.sort(data.most_frequent, function(a, b) if a.count == b.count then return a.word &lt; b.word end return a.count &gt; b.count end) -- 只保留前 5 个 if #data.most_frequent &gt; 5 then for i = 6, #data.most_frequent do data.most_frequent[i] = nil end end
end -- 测试文本分析器
local test_text = [[
Lua is a powerful, efficient, lightweight, embeddable scripting language.
It supports procedural programming, object-oriented programming, functional
programming, data-driven programming, and data description. Lua combines simple procedural syntax with powerful data description
constructs based on associative arrays and extensible semantics.
Lua is dynamically typed, runs by interpreting bytecode with a
register-based virtual machine, and has automatic memory management with
incremental garbage collection, making it ideal for configuration,
scripting, and rapid prototyping.
]] print("=== 文本分析器 ===")
analysis:analyze_text(test_text) local data = analysis.data print("基本统计:")
print(" 总字符数: " .. data.total_chars)
print(" 行数: " .. data.lines)
print(" 单词数: " .. data.word_count) print("\n 最频繁的单词:")
for i, item in ipairs(data.most_frequent) do print(string.format(" %2d. %-15s: %d 次", i, item.word, item.count))
end
--[[ 输出
基本统计: 总字符数: 582 行数: 11 单词数: 70 最频繁的单词: 1. and : 4 次 2. programming : 4 次 3. lua : 3 次 4. with : 3 次 5. a : 2 次
--]]
local log = {} log.LEVEL_NAMES = { "INFO", "ERROR"
} -- 创建新的日志实例
function log:new(name) local logger = {} -- 添加日志方法 for _, level_name in ipairs(self.LEVEL_NAMES) do logger[string.lower(level_name)] = function(message, ...) log:_log(level_name, name, message, ...) end end return logger
end -- 内部日志方法
function log:_log(level_name, name, message, ...) -- 格式化消息 message = string.format(message, ...) -- 构建日志前缀 local log_line = string.format("[%s] %s: %s", level_name, name, message) print(log_line)
end return log
-- 创建结构化的错误类型，便于处理
-- 错误类型定义
local error_types = { VALIDATION = { code = 100, name = "VALIDATION_ERROR", description = "输入验证失败" }, DATABASE = { code = 200, name = "DATABASE_ERROR", description = "数据库操作失败" }, NETWORK = { code = 300, name = "NETWORK_ERROR", description = "网络通信失败" }, PERMISSION = { code = 400, name = "PERMISSION_ERROR", description = "权限不足" }, INTERNAL = { code = 500, name = "INTERNAL_ERROR", description = "内部服务器错误" }
} -- 错误创建函数
local function create_error(error_type, message, details) local error_info = error_types[error_type] if not error_info then error_info = error_types.INTERNAL end return { type = error_type, code = error_info.code, name = error_info.name, message = message or error_info.description, details = details, timestamp = os.time(), stack_trace = debug.traceback("", 2) }
end -- 错误抛出函数
local function throw_error(error_type, message, details) error(create_error(error_type, message, details), 2)
end -- 错误处理函数
local function handle_error(err, context) -- 如果是我们的自定义错误 if type(err) == "table" and err.code then print(string.format("[错误处理] 类型: %s (%d)", err.name, err.code)) print(string.format(" 消息: %s", err.message)) if err.details then print(string.format(" 详情: %s", tostring(err.details))) end if context then print(string.format(" 上下文: %s", context)) end print(" 调用栈:") print(err.stack_trace) -- 根据错误类型采取不同措施 if err.type == "VALIDATION" then return nil, "输入错误，请检查后重试" elseif err.type == "PERMISSION" then return nil, "权限不足，请联系管理员" elseif err.type == "NETWORK" then -- 可以尝试重试 return nil, "网络错误，请稍后重试" else return nil, "系统错误，请联系技术支持" end else -- 其他类型的错误 return nil, "未知错误: " .. tostring(err) end
end -- 模拟数据库连接
local data_base = {} function data_base.new(config) local instance = { host = config.host or "localhost", port = config.port or 3306, username = config.username or "root", password = config.password or "", database = config.database or "test", connected = false, transaction_active = false } -- 连接数据库 function instance:connect() if self.connected then return true end print(string.format(" 连接数据库 %s:%d...", self.host, self.port)) -- 模拟连接错误 throw_error("NETWORK", "数据库连接失败", { host = self.host, port = self.port }) self.connected = true print(" 连接成功") return true end -- 执行查询 function instance:query(sql, params) if not self.connected then throw_error("DATABASE", "数据库未连接") end print(string.format(" 执行查询: %s", sql)) if params then print(" 参数: " .. tostring(params)) end -- 模拟查询错误 if sql:find("DROP TABLE") or sql:find("DELETE") then if not self.transaction_active then throw_error("DATABASE", "危险操作需要在事务中执行", { sql = sql }) end end if sql:find("SELECT") and sql:find("nonexistent") then throw_error("DATABASE", "查询的表不存在", { sql = sql }) end if sql:find("INSERT") and params and params.email then -- 模拟唯一约束冲突 if params.email == "duplicate@example.com" then throw_error("DATABASE", "重复的邮箱地址", { sql = sql, email = params.email }) end end -- 模拟成功响应 if sql:find("SELECT") then return { { id = 1, name = "用户1", email = "user1@example.com" }, { id = 2, name = "用户2", email = "user2@example.com" } } elseif sql:find("INSERT") then return { affected_rows = 1, last_insert_id = 100 } elseif sql:find("UPDATE") then return { affected_rows = 1 } elseif sql:find("DELETE") then return { affected_rows = 1 } end return {} end -- 开始事务 function instance:begin_transaction() if self.transaction_active then throw_error("DATABASE", "事务已在进行中") end self.transaction_active = true print(" 开始事务") return true end -- 提交事务 function instance:commit() if not self.transaction_active then throw_error("DATABASE", "没有活动的事务") end self.transaction_active = false print(" 提交事务") return true end -- 回滚事务 function instance:rollback() if not self.transaction_active then throw_error("DATABASE", "没有活动的事务") end self.transaction_active = false print(" 回滚事务") return true end -- 断开连接 function instance:disconnect() if self.transaction_active then self:rollback() end self.connected = false print(" 断开数据库连接") return true end -- 安全执行（带错误处理） function instance:safe_execute(operation, ...) local success, result = pcall(operation, self, ...) if not success then -- 如果是数据库错误，尝试重连 if type(result) == "table" and result.type == "DATABASE" then if result.message:find("连接") or result.message:find("断开") then print(" 检测到连接问题，尝试重连...") self.connected = false local reconnect_success = pcall(self.connect, self) if reconnect_success then print(" 重连成功，重试操作...") success, result = pcall(operation, self, ...) end end end end if not success then return nil, result end return result end return instance
end -- 使用数据库
print("数据库操作测试:")
local db = data_base.new { host = "localhost", database = "mydb", username = "admin", password = "secret"
} -- 包装数据库操作为安全操作
function safe_database_operation(db, operation_name, operation, ...) print("\n操作: " .. operation_name) local result, err = db:safe_execute(operation, ...) if result then print(" 成功") return result else local _, user_msg = handle_error(err, operation_name) print(" 失败: " .. user_msg) return nil, err end
end -- 测试各种操作
-- 连接数据库
safe_database_operation(db, "连接数据库", db.connect) -- 查询数据
local users, err = safe_database_operation(db, "查询用户", function(self) return self:query("SELECT * FROM users WHERE status = 'active'")
end) if users then print(" 查询到 " .. #users .. " 个用户")
end -- 测试插入重复数据
local insert_result, err = safe_database_operation(db, "插入用户", function(self) return self:query("INSERT INTO users (name, email) VALUES (?, ?)", { "测试用户", "duplicate@example.com" })
end) -- 测试事务
print("\n测试事务操作:")
local transaction_success, transaction_err = pcall(function() db:begin_transaction() -- 多个操作 db:query("UPDATE accounts SET balance = balance - 100 WHERE id = 1") db:query("UPDATE accounts SET balance = balance + 100 WHERE id = 2") db:commit() print(" 事务执行成功")
end) if not transaction_success then print(" 事务失败: " .. tostring(transaction_err)) if db.transaction_active then db:rollback() end
end -- 断开连接
safe_database_operation(db, "断开连接", db.disconnect)
--[[ 输出
操作: 连接数据库 连接数据库 localhost:3306...
[错误处理] 类型: NETWORK_ERROR (300) 消息: 数据库连接失败 详情: table: 00E5CEA0 上下文: 连接数据库 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:114: in function &lt;test.lua:104&gt; [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:267: in main chunk [C]: ? 失败: 网络错误，请稍后重试 操作: 查询用户 检测到连接问题，尝试重连... 连接数据库 localhost:3306...
[错误处理] 类型: DATABASE_ERROR (200) 消息: 数据库未连接 上下文: 查询用户 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:126: in function &lt;test.lua:124&gt; (tail call): ? [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:270: in main chunk [C]: ? 失败: 系统错误，请联系技术支持 操作: 插入用户 检测到连接问题，尝试重连... 连接数据库 localhost:3306...
[错误处理] 类型: DATABASE_ERROR (200) 消息: 数据库未连接 上下文: 插入用户 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:126: in function &lt;test.lua:124&gt; (tail call): ? [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:279: in main chunk [C]: ? 失败: 系统错误，请联系技术支持 测试事务操作: 开始事务 事务失败: table: 00E5CF68 回滚事务 操作: 断开连接 断开数据库连接 成功
--]]
-- 定义管道操作
local pipeline_sys = {} function pipeline_sys.new(source_iterator) local pipeline = { source = source_iterator, operations = {} } function pipeline:map(transform_func) table.insert(self.operations, { type = "map", func = transform_func }) return self end function pipeline:filter(predicate_func) table.insert(self.operations, { type = "filter", func = predicate_func }) return self end function pipeline:take(n) table.insert(self.operations, { type = "take", count = n }) return self end function pipeline:skip(n) table.insert(self.operations, { type = "skip", count = n }) return self end function pipeline:iterator() local source_iter = self.source local skip_count = 0 local take_count = math.huge -- 从操作中获取初始的skip和take值 for _, op in ipairs(self.operations) do if op.type == "skip" then skip_count = op.count elseif op.type == "take" then take_count = op.count end end -- 创建处理链 return function() while true do if take_count &lt;= 0 then return nil end local values = { source_iter() } if values[1] == nil then return nil end local processed = values local should_emit = true if skip_count &gt; 0 then skip_count = skip_count - 1 should_emit = false else -- 应用所有操作 for _, op in ipairs(self.operations) do if op.type == "map" then processed = { op.func(unpack(processed)) } elseif op.type == "filter" then if not op.func(unpack(processed)) then should_emit = false break end end end end if should_emit then take_count = take_count - 1 return unpack(processed) end end end end return pipeline
end -- 测试数据管道
print("数据管道测试:") -- 创建数据源
function number_source(from, to) local current = from - 1 return function() current = current + 1 if current &lt;= to then return current end end
end -- 构建管道
local pipeline = pipeline_sys.new(number_source(1, 20))
pipeline:filter(function(x) return x % 2 == 0 end) -- 只保留偶数
pipeline:map(function(x) return x * 2 end) -- 乘以2
pipeline:skip(3) -- 跳过前3个
pipeline:take(5) -- 取5个 print("管道处理结果:")
for value in pipeline:iterator() do io.write(value .. " ")
end
print() -- 复杂管道示例
print("\n复杂管道示例:") -- 模拟用户数据
function user_data_source() local users = { { id = 1, name = "张三", age = 25, score = 85 }, { id = 2, name = "李四", age = 30, score = 92 }, { id = 3, name = "王五", age = 22, score = 78 }, { id = 4, name = "赵六", age = 35, score = 88 }, { id = 5, name = "钱七", age = 28, score = 95 }, { id = 6, name = "孙八", age = 19, score = 65 }, { id = 7, name = "周九", age = 32, score = 82 }, { id = 8, name = "吴十", age = 26, score = 90 }, } local index = 0 return function() index = index + 1 local user = users[index] if user then return user.id, user.name, user.age, user.score end end
end -- 用户数据处理管道
local user_pipeline = pipeline_sys.new(user_data_source())
user_pipeline:filter(function(id, name, age, score) return age &gt;= 20 and age &lt;= 30 -- 年龄在20-30之间
end)
user_pipeline:filter(function(id, name, age, score) return score &gt;= 80 -- 分数80以上
end)
user_pipeline:map(function(id, name, age, score) -- 添加评级 local rating if score &gt;= 90 then rating = "优秀" elseif score &gt;= 85 then rating = "良好" else rating = "合格" end return id, name, age, score, rating
end) print("符合条件的用户:")
for id, name, age, score, rating in user_pipeline:iterator() do print(string.format(" ID: %d, 姓名: %s, 年龄: %d, 分数: %d, 评级: %s", id, name, age, score, rating))
end
--[[ 输出
数据管道测试:
管道处理结果:
8 12 16 20 24 复杂管道示例:
符合条件的用户: ID: 1, 姓名: 张三, 年龄: 25, 分数: 85, 评级: 良好 ID: 2, 姓名: 李四, 年龄: 30, 分数: 92, 评级: 优秀 ID: 5, 姓名: 钱七, 年龄: 28, 分数: 95, 评级: 优秀 ID: 8, 姓名: 吴十, 年龄: 26, 分数: 90, 评级: 优秀
--]]
local function range(from, to, step) step = step or 1 return coroutine.wrap(function() for i = from, to, step do coroutine.yield(i) end end)
end -- 使用
for i in range(1, 10, 2) do print(i)
end
--[[ 输出
1
3
5
7
9
--]]
-- 向量类实现
Vector = {}
Vector.__index = Vector -- 构造函数
function Vector.new(x, y) local v = { x = x, y = y} setmetatable(v, Vector) return v
end -- 加法
function Vector.__add(a, b) if getmetatable(a) == Vector and getmetatable(b) == Vector then return Vector.new(a.x + b.x, a.y + b.y) end error("Cannot add non-vector values")
end -- 减法
function Vector.__sub(a, b) if getmetatable(a) == Vector and getmetatable(b) == Vector then return Vector.new(a.x - b.x, a.y - b.y) end error("Cannot subtract non-vector values")
end -- 乘法（点积）
function Vector.__mul(a, b) if getmetatable(a) == Vector and getmetatable(b) == Vector then return a.x * b.x + a.y * b.y end error("Cannot multiply non-vector values")
end -- 负号
function Vector.__unm(a) if getmetatable(a) == Vector then return Vector.new(-a.x, -a.y) end error("Cannot negate non-vector value")
end -- 字符串表示
function Vector.__tostring(self) return string.format("Vector(%d, %d)", self.x, self.y)
end -- 测试代码
local v1 = Vector.new(3, 4)
local v2 = Vector.new(1, 2) print("v1 = " .. tostring(v1)) -- Vector(3, 4)
print("v2 = " .. tostring(v2)) -- Vector(1, 2)
print("v1 + v2 = " .. tostring(v1 + v2)) -- Vector(4, 6)
print("v1 - v2 = " .. tostring(v1 - v2)) -- Vector(2, 2)
print("v1 * v2 = " .. (v1 * v2)) -- 11
print("-v1 = " .. tostring(-v1)) -- Vector(-3, -4)
-- 带日志功能的向量类
TrackedVector = {}
TrackedVector.__index = TrackedVector -- 构造函数
function TrackedVector.new(x, y) local v = { x = x, y = y, _log = {} -- 日志记录 } setmetatable(v, TrackedVector) -- 记录创建 table.insert(v._log, string.format("创建向量: Vector(%d, %d)", x, y)) return v
end -- 添加日志条目
function TrackedVector:_add_log(operation, operand, result) local entry = string.format("%s: ", operation) if operand then entry = entry .. string.format("与 %s ", tostring(operand)) end entry = entry .. string.format("运算, 结果: %s", tostring(result)) table.insert(self._log, entry)
end -- 加法（带日志）
function TrackedVector.__add(a, b) if getmetatable(a) == TrackedVector and getmetatable(b) == TrackedVector then local result = TrackedVector.new(a.x + b.x, a.y + b.y) -- 记录到两个向量的日志中 a:_add_log("被加", b, result) b:_add_log("加数", a, result) return result end error("Cannot add non-vector values")
end -- 减法（带日志）
function TrackedVector.__sub(a, b) if getmetatable(a) == TrackedVector and getmetatable(b) == TrackedVector then local result = TrackedVector.new(a.x - b.x, a.y - b.y) a:_add_log("被减", b, result) b:_add_log("减数", a, result) return result end error("Cannot subtract non-vector values")
end -- 乘法（点积，带日志）
function TrackedVector.__mul(a, b) if getmetatable(a) == TrackedVector and getmetatable(b) == TrackedVector then local result = a.x * b.x + a.y * b.y a:_add_log("点积", b, result) b:_add_log("点积", a, result) return result end error("Cannot multiply non-vector values")
end -- 负号（带日志）
function TrackedVector.__unm(a) if getmetatable(a) == TrackedVector then local result = TrackedVector.new(-a.x, -a.y) a:_add_log("取负", nil, result) return result end error("Cannot negate non-vector value")
end -- 获取日志
function TrackedVector.get_log(self) local logs = {} -- 添加向量基本信息 table.insert(logs, string.format("向量: %s", tostring(self))) -- 添加所有操作记录 for i, entry in ipairs(self._log) do table.insert(logs, string.format("%d. %s", i, entry)) end return logs
end -- 字符串表示（与普通向量兼容）
function TrackedVector.__tostring(self) return string.format("Vector(%d, %d)", self.x, self.y)
end -- 测试代码
print("\n\n=== 练习2：带日志的向量类测试 ===")
local v1 = TrackedVector.new(3, 4)
local v2 = TrackedVector.new(1, 2) print("v1 = " .. tostring(v1)) -- Vector(3, 4)
print("v2 = " .. tostring(v2)) -- Vector(1, 2) local sum = v1 + v2
print("v1 + v2 = " .. tostring(sum)) -- Vector(4, 6) local diff = v1 - v2
print("v1 - v2 = " .. tostring(diff)) -- Vector(2, 2) local dot = v1 * v2
print("v1 * v2 = " .. dot) -- 11 local neg = -v1
print("-v1 = " .. tostring(neg)) -- Vector(-3, -4) print("\n=== v1的操作日志 ===")
local v1_logs = v1:get_log()
print(table.concat(v1_logs, "\n")) print("\n=== v2的操作日志 ===")
local v2_logs = v2:get_log()
print(table.concat(v2_logs, "\n"))
--[[ 输出
=== 练习2：带日志的向量类测试 ===
v1 = Vector(3, 4)
v2 = Vector(1, 2)
v1 + v2 = Vector(4, 6)
v1 - v2 = Vector(2, 2)
v1 * v2 = 11
-v1 = Vector(-3, -4) === v1的操作日志 ===
向量: Vector(3, 4)
1. 创建向量: Vector(3, 4)
2. 被加: 与 Vector(1, 2) 运算, 结果: Vector(4, 6)
3. 被减: 与 Vector(1, 2) 运算, 结果: Vector(2, 2)
4. 点积: 与 Vector(1, 2) 运算, 结果: 11
5. 取负: 运算, 结果: Vector(-3, -4) === v2的操作日志 ===
向量: Vector(1, 2)
1. 创建向量: Vector(1, 2)
2. 加数: 与 Vector(3, 4) 运算, 结果: Vector(4, 6)
3. 减数: 与 Vector(3, 4) 运算, 结果: Vector(2, 2)
4. 点积: 与 Vector(3, 4) 运算, 结果: 11
--]]
]]></description><link>第-1-节-语法/参考答案.html</link><guid isPermaLink="false">第 1 节 - 语法/参考答案.md</guid><pubDate>Fri, 26 Dec 2025 05:36:58 GMT</pubDate></item><item><title><![CDATA[Local Lua Debugger 说明翻译]]></title><description><![CDATA[一个简单的 Lua 调试器，无需额外依赖。从 0.3.0 版本开始，对于使用 Sourcemap 来调试从其他语言（例如 TypescriptToLua）转译而来的代码的项目，必须在启动配置中指定 scriptFiles 选项，才能在原始源文件中使用断点。这允许在启动时（而非运行时）解析这些文件，从而显著提高性能。
使用独立解释器或自定义可执行文件调试 Lua
支持 Lua 5.1、5.2、5.3 版本以及 LuaJIT
基本调试功能（单步执行、检查变量、断点等）
条件断点
将协程作为独立线程进行调试
对 Source map 的基础支持（例如由 TypescriptToLua 生成的）
要使用独立解释器调试 Lua 程序，请在用户或工作区设置中设置 lua-local.interpreter："lua-local.interpreter": "lua5.1"或者，您也可以在 launch.json 中设置解释器和要运行的文件：{ "configurations": [ { "type": "lua-local", "request": "launch", "name": "Debug", "program": { "lua": "lua5.1", "file": "main.lua" } } ]
}
要使用自定义的 Lua 可执行文件进行调试，您必须在 launch.json 中设置可执行文件的名称/路径以及任何可能需要的额外参数。{ "configurations": [ { "type": "lua-local", "request": "launch", "name": "Debug Custom Executable", "program": { "command": "executable" }, "args": [ "${workspaceFolder}" ] } ]
}
然后您必须在您的 Lua 代码中手动启动调试器：require("lldebugger").start()请注意，lldebugger 的路径将自动附加到 LUA_PATH 环境变量中，因此 Lua 能够找到它。
Lua 环境必须支持通过 stdio 或管道进行通信（Windows 上为命名管道，Linux 上为 fifo）。
某些环境可能需要命令行选项来支持 stdio 通信（例如 Solar2D 需要 /no-console 标志）。
在 stdio 模式下，使用 io.read 或其他需要用户输入的函数调用会导致问题。可将 program.communication 设置为 pipe 来解决此问题。
Lua 环境必须内置 debug 库，且没有其他代码尝试设置调试钩子。
当程序正在运行时，您不能手动暂停调试。
在 Lua 5.1 和 LuaJIT 中，当在协程内部暂停时，无法访问主线程。 为了方便起见，调试器的全局引用始终以 lldebugger 的形式存储。
您可以通过检查环境变量 LOCAL_LUA_DEBUGGER_VSCODE 来检测调试器扩展是否已附加。这对于在自定义环境中条件性地启动调试器非常有用。
if os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" then require("lldebugger").start()
end 某些自定义环境不会在未捕获的运行时错误时中断。要捕获运行时错误，您可以使用 lldebugger.call() 包装代码：
lldebugger.call(function() -- 引发运行时错误的代码
end) 某些环境不会从标准文件系统加载所需的文件。在这种情况下，您可以使用存储在 LOCAL_LUA_DEBUGGER_FILEPATH 中的文件路径手动加载调试器：
package.loaded["lldebugger"] = assert(loadfile(os.getenv("LOCAL_LUA_DEBUGGER_FILEPATH")))()
require("lldebugger").start()
一个备用路径列表，用于查找 Lua 脚本。这对于像 LÖVE 这样的环境非常有用，它们使用自定义解析器来查找位于 package.config 指定路径之外的其他位置的脚本。一个 glob 模式列表，用于标识调试时在工作区中查找 Lua 脚本的位置。对于在 sourcemap 映射的文件（例如使用 TypescriptToLua 时的 'ts' 脚本）中放置断点是必需的，因为必须提前查找源文件以便解析断点。示例：scriptFiles: ["**/*.lua"]一个 Lua 模式列表，指定单步执行代码时要跳过的文件。示例：ignorePatterns: ["^/usr"]在单步执行 sourcemap 映射的代码且当前行没有可用映射时，单步进入 Lua 代码。当协程内部发生错误时中断进入调试器。
用 coroutine.wrap 创建的协程将始终中断，无论此选项如何设置。
在 Lua 5.1 中，中断将发生在协程被恢复的位置，并且消息将包含错误发生的实际位置。
在设置调试钩子后，自动在首行中断。指定启动可执行文件时的工作目录。默认为项目目录。启动时传递给 Lua 脚本或自定义环境的参数列表。指定启动可执行文件时要设置的环境变量。指定扩展程序与调试器通信的方式。可能的值：
stdio （默认）：消息嵌入在 stdin 和 stdout 中。
pipe：创建管道来传递消息（Windows 上为命名管道，Linux 上为 fifo）。如果您的环境在使用 stdio 通信时出现问题，请使用此方式。
启用调试器的详细输出。仅在尝试识别调试器本身的问题时有用。{ "version": "0.2.0", "configurations": [ { "name": "Debug Love", "type": "lua-local", "request": "launch", "program": { "command": "love" }, "args": [ "game" ], "scriptRoots": [ "game" ] } ]
}
if os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" then require("lldebugger").start()
end function love.load() ...
请注意，在 conf.lua 中 console 必须设置为 false（默认值），否则调试器将无法与运行中的程序通信。game/conf.luafunction love.conf(t) t.console = false
end
请注意，即使通过 Lua 解释器使用 busted，也必须将其设置为自定义环境才能正常工作。{ "version": "0.2.0", "configurations": [ { "name": "Debug Busted CLI", "type": "lua-local", "request": "launch", "program": { "command": "busted" }, "args": [ "test/start-cli.lua" ], "ignorePatterns": "^/usr" }, { "name": "Debug Busted via Lua Interpreter", "type": "lua-local", "request": "launch", "program": { "command": "lua" }, "args": [ "test/start-interpreter.lua" ], "ignorePatterns": "^/usr" } ]
}
test/start-cli.luaif os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" then require("lldebugger").start()
end describe("a test", function() ...
end)
test/start-interpreter.lua-- 应在挂钩调试器之前引入 busted，以避免双重挂钩
require("busted.runner")() if os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" then require("lldebugger").start()
end describe("a test", function() ...
end)
{ "version": "0.2.0", "configurations": [ { "name": "Debug", "type": "lua-local", "request": "launch", "program": { "command": "dmengine" }, "args": [ "./build/default/game.projectc" ], "scriptRoots": [ "." ] // 调试器查找脚本所必需 } ]
}
if os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" then local lldebugger = loadfile(os.getenv("LOCAL_LUA_DEBUGGER_FILEPATH"))() lldebugger.start()
end function init(self) ...
end
有关为您的平台下载 dmengine 的信息可以在[这里](Information on downloading dmengine for your platform can be found here.)找到。{ "version": "0.2.0", "configurations": [ { "name": "Debug", "type": "lua-local", "request": "launch", "windows": { "program": { "command": "C:\\Program Files (x86)\\Corona Labs\\Corona\\Corona Simulator.exe", }, "args": [ "/no-console", "/debug", "${workspaceFolder}\\main.lua" ] }, "osx": { "program": { "command": "/Applications/Corona/CoronaSimulator.app/Contents/MacOS/CoronaSimulator", }, "args": [ "-no-console""YES""-debug""1""-project""${workspaceFolder}/main.lua" ] } } ]
}
if os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" then local lldebugger = loadfile(os.getenv("LOCAL_LUA_DEBUGGER_FILEPATH"))() lldebugger.start()
end ...
{ "version": "0.2.0", "configurations": [ { "name": "Debug TSTL", "type": "lua-local", "request": "launch", "program": { "command": "my_custom_environment" }, "args": [ ... ], "scriptFiles": [ "**/*.lua" ] // 使 ts 文件中的断点正常工作所必需 } ]
}
if os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" then require("lldebugger").start()
end ...
tsconfig.json{ "compilerOptions": { "sourceMap": true, ... }, "tstl": { "noResolvePaths": [ "lldebugger" ] // 必需，以便 TSTL 忽略缺失的依赖项 }
}
]]></description><link>其他/local-lua-debugger-说明翻译.html</link><guid isPermaLink="false">其他/Local Lua Debugger 说明翻译.md</guid><pubDate>Fri, 26 Dec 2025 03:23:55 GMT</pubDate></item><item><title><![CDATA[5. 控制结构]]></title><description><![CDATA[控制结构是编程中实现逻辑决策和重复执行的关键。在 Lua 中，最基本的控制结构是 if 语句。if 条件 then -- 条件为真时执行的条件代码块
end
-- 示例：检查玩家生命值
local health = 75 if health &gt; 0 then print("玩家还活着")
end
还记得学过的 <a data-href="2. 基础语法规则#1 代码块" href="第-1-节-语法/2.-基础语法规则.html#1 代码块" class="internal-link" target="_self" rel="noopener nofollow">2. 基础语法规则 &gt; 1 代码块</a> 吗？这里条件语句中的条件代码块也是局部作用域错误 1：局部作用域内的局部变量外部不可见if true then local health = 999
end print(health)	-- 错误！
错误 2： 意外定义全局变量if true then health = 999
end print(health)	-- 错误！输出 999，虽然成功输出但是意外定义了全局变量，全局变量应避免滥用
正确方法：local health	-- 提前定义局部变量 if true then health = 999	-- 这里程序会优先查找有没有已定义的局部变量，所以是给上面定义的局部变量赋值
end print(health)	-- 正确！输出 999
if 条件 then -- 条件为真时执行的条件代码块
else -- 条件为假时执行的条件代码块
end
-- 示例：判断玩家是否存活
local health = 0 if health &gt; 0 then print("玩家还活着") print("当前生命值：" .. health)
else print("玩家已死亡") print("游戏结束")
end
if 条件1 then -- 条件1为真时执行的条件代码块
elseif 条件2 then -- 条件2为真时执行的条件代码块
elseif 条件3 then -- 条件3为真时执行的条件代码块
else -- 所有条件都为假时执行的条件代码块
end
-- 示例：游戏难度选择
local difficulty_level = "hard"
local enemy_health, player_health	-- 注意！：一定要提前定义局部变量，避免意外定义全局变量 if difficulty_level == "easy" then enemy_health = 50 player_health = 200
elseif difficulty_level == "normal" then enemy_health = 100 player_health = 150
elseif difficulty_level == "hard" then enemy_health = 150 player_health = 100
elseif difficulty_level == "insane" then enemy_health = 200 player_health = 50
else print("无效的难度设置，使用默认难度") enemy_health = 100 player_health = 150
end print("难度：" .. difficulty_level)
print("敌人生命值：" .. enemy_health)
print("玩家生命值：" .. player_health)
-- 示例：等级解锁关卡检查
local player_level = 10 local info_level = "森林"	-- 模拟玩家点击关卡
local level_mode = "夜晚模式" -- 外层检查
if info_level == "森林" then -- 内层检查 if player_level &gt;= 1 then	-- 玩家等级大于等于 1 print("玩家等级足够，可以进入森林") -- 更深层的检查 if level_mode == "夜晚模式" then	-- 判断关卡模式 print("玩家进入夜晚的森林") elseif level_mode == "白天模式" then print("玩家进入白天的森林") else print("未知模式") end else print("玩家等级不足，不能进入森林") end
elseif info_level == "雪地" then -- 内层检查 if player_level &gt;= 11 then	-- 玩家等级大于等于 11 print("玩家等级足够，可以进入雪地") -- 更深层的检查 if level_mode == "夜晚模式" then	-- 判断关卡模式 print("玩家进入夜晚的雪地") elseif level_mode == "白天模式" then print("玩家进入白天的雪地") else print("未知模式") end else print("玩家等级不足，不能进入雪地") end
else print("未知关卡")
end
local age = 25
local has_license = true if age &gt;= 18 and has_license then	-- 如果年龄大于等于 18，并且有驾驶证 print("可以驾驶")
else print("不能驾驶")
end
local is_weekend = false
local is_holiday = true if is_weekend or is_holiday then	-- 如果是周末，或者是节假日 print("今天是休息日")
else print("今天是工作日")
end
local is_raining = false if not is_raining then -- 如果没有下雨 print("天气晴朗，适合外出")
else print("下雨了，记得带伞")
end
local temperature = 28
local is_sunny = true
local has_umbrella = false -- 如果温度大于 25 度，并且是晴天，或者不是晴天，并且带了伞
if (temperature &gt; 25 and is_sunny) or (not is_sunny and has_umbrella) then print("适合去公园")
else print("最好待在家里")
end
local player_level = 15
local has_quest_item = true
local completed_prerequisite = false -- 如果玩家等级大于等于 10 并且有任务物品以及完成前置任务
if player_level &gt;= 10 and has_quest_item and completed_prerequisite then print("可以接受新任务")
else print("条件不足，无法接受任务") -- 提供具体反馈 if player_level &lt; 10 then print("需要达到10级") end if not has_quest_item then print("需要任务物品") end if not completed_prerequisite then print("需要完成前置任务") end
end
循环允许我们重复执行一段代码，直到满足特定条件为止。while 条件 do -- 循环体（条件为真时重复执行）
end
-- 示例：简单的计数器
local count = 1
while count &lt;= 5 do print("当前计数：" .. count) count = count + 1 -- 注意！：不要忘记改变循环条件
end
--[[ 输出
当前计数：1
当前计数：2
当前计数：3
当前计数：4
当前计数：5
--]] -- 注意：如果没有正确改变条件，可能导致无限循环！
-- local count = 1
-- while count &lt;= 5 do
-- print("无限循环？") -- count永远不大于5，所以会一直执行
-- -- 忘记写 count = count + 1
-- end
-- 实际应用：等待玩家准备
local is_player_ready = false
local wait_time = 0
local max_wait_time = 30 -- 最大等待30秒 print("等待玩家准备...")
-- 如果玩家没有准备，并且没有超过最大等待时间
while not is_player_ready and wait_time &lt; max_wait_time do print("等待中... 已等待" .. wait_time .. "秒") -- 模拟每秒检查一次 -- 在实际游戏中，这里可能会有网络检查或用户输入检查 wait_time = wait_time + 1 -- 模拟玩家在第5秒时准备好 if wait_time == 5 then is_player_ready = true print("玩家已准备好！") end
end if not is_player_ready then print("等待超时，开始游戏")
else print("游戏开始")
end
--[[ 输出
等待玩家准备...
等待中... 已等待0秒
等待中... 已等待1秒
等待中... 已等待2秒
等待中... 已等待3秒
等待中... 已等待4秒
玩家已准备好！
游戏开始
--]]
repeat -- 循环体
until 条件 -- 当条件为真时停止循环
-- 示例：密码验证（至少尝试一次）
local correct_password = "123456"
local user_password
local attempts = 0 repeat attempts = attempts + 1 -- 模拟用户输入 if attempts == 1 then user_password = "111111" -- 错误密码 elseif attempts == 2 then user_password = "654321" -- 错误密码 else user_password = "123456" -- 正确密码 end print("第" .. attempts .. "次尝试输入密码") if user_password ~= correct_password then print(user_password .. "密码错误，请重试") end
until user_password == correct_password print("密码正确，登录成功！")
print("总共尝试次数：" .. attempts)
--[[ 输出
第1次尝试输入密码
111111密码错误，请重试
第2次尝试输入密码
654321密码错误，请重试
第3次尝试输入密码
密码正确，登录成功！
总共尝试次数：3
--]] -- 游戏中的实际应用：玩家生命值恢复
local player_health = 30
local max_health = 60 print("初始生命值：" .. player_health) repeat -- 模拟每秒恢复一次 player_health = player_health + 10 if player_health &gt; max_health then player_health = max_health end print("血量恢复！当前生命值：" .. player_health) -- 直到血量回满
until player_health == max_health print("生命值已满！")
--[[ 输出
初始生命值：30
血量恢复！当前生命值：40
血量恢复！当前生命值：50
血量恢复！当前生命值：60
生命值已满！
--]]
首先需要明确语义：
while 循环：当条件为真时，继续执行循环体；当条件为假时，退出循环。
repeat-until 循环：重复执行循环体，直到条件为真时退出（即条件为真时结束循环）
即：在 repeat-until 循环中，设置的条件是退出循环的条件，而在 while 循环中，设置的条件是继续循环的条件。
所以：两个循环设置的条件完全相反-- while
local count = 10 while count &lt; 5 do -- 继续循环的条件：计数小于 5，一开始就不成立 print("while循环执行") -- 循环体不会执行 count = count + 1
end print("while循环结束，count = " .. count) -- 输出 10 -- repeat-until
local count = 10 repeat print("repeat-until循环执行") -- 循环体至少会执行一次 count = count + 1
until count &gt;= 5 -- 结束循环的条件：计算大于等于 5，检查在循环体之后 print("repeat-until循环结束，count = " .. count)	-- 输出 11
for 变量 = 起始值, 结束值, 步长 do -- 循环体
end
-- 步长可以省略，默认为1
print("=== 从1到5 ===")
for i = 1, 5 do print("i = " .. i)
end
--[[ 输出
i = 1
i = 2
i = 3
i = 4
i = 5
--]] print("\n=== 从5到1（递减）===")
for i = 5, 1, -1 do print("i = " .. i)
end
--[[ 输出
i = 5
i = 4
i = 3
i = 2
i = 1
--]] print("\n=== 从0到10，步长为2 ===")
for i = 0, 8, 2 do print("偶数: " .. i)
end
--[[ 输出
偶数: 0
偶数: 2
偶数: 4
偶数: 6
偶数: 8
--]] -- 注意：for循环变量是局部变量
for index = 1, 3 do print("循环内 index = " .. index)
end print("循环外 index = " .. index) -- 错误！index 在这里不可访问
-- 计算示例：累加和阶乘
local sum = 0
local factorial = 1 print("\n=== 计算1到10的和与10的阶乘 ===")
for i = 1, 10 do sum = sum + i factorial = factorial * i
end
print("1到10的和 = " .. sum)
print("10的阶乘 = " .. factorial)
--[[ 输出
1到10的和 = 55
10的阶乘 = 3628800
--]] -- 生成乘法表
print("\n=== 乘法表 ===")
for i = 1, 9 do for j = 1, i do print(j .. " × " .. i .. " = " .. i * j) end
end
--[[ 输出
1 × 1 = 1
1 × 2 = 2
...
--]]
break用于立即退出当前循环-- 示例：寻找第一个能被7整除的数
for i = 8, 100 do if i % 7 == 0 then print("找到第一个能被7整除的数：" .. i) break -- 找到后立即退出循环 end
end
-- 输出 找到第一个能被7整除的数：14 -- 游戏示例：搜索敌人直到找到首领
local enemies = {"小兵", "小兵", "小兵", "小兵", "首领", "小兵"}
local boss_found print("=== 搜索敌人 ===")
for index, enemy in ipairs(enemies) do print("遭遇：" .. enemy) if enemy == "首领" then print("找到首领！开始战斗") boss_found = true break end print("击败" .. enemy)
end if not boss_found then print("没有找到首领")
end
--[[ 输出
遭遇：小兵
击败小兵
遭遇：小兵
击败小兵
遭遇：小兵
击败小兵
遭遇：小兵
击败小兵
遭遇：首领
找到首领！开始战斗
--]] -- 注意：break只能用于循环中，不能用于if语句
-- if true then
-- break -- 错误：break不在循环内
-- end -- 多层循环中的break
print("\n=== 多层循环中的break ===")
for i = 1, 3 do print("外层循环 i = " .. i) for j = 1, 3 do print(" 内层循环 j = " .. j) if i == 2 and j == 2 then print(" 触发break，只退出内层循环") break end end
end
--[[ 输出
外层循环 i = 1 内层循环 j = 1 内层循环 j = 2 内层循环 j = 3
外层循环 i = 2 内层循环 j = 1 内层循环 j = 2 触发break，只退出内层循环
外层循环 i = 3 内层循环 j = 1 内层循环 j = 2 内层循环 j = 3
--]] -- 无限循环中的break
print("\n=== 无限循环与break ===")
local count = 0 while true do -- 故意创建无限循环 count = count + 1 print("无限循环计数：" .. count) if count &gt;= 5 then print("达到5次，使用break退出") break end
end print("成功退出无限循环")
--[[ 输出
无限循环计数：1
无限循环计数：2
无限循环计数：3
无限循环计数：4
无限循环计数：5
达到5次，使用break退出
成功退出无限循环
--]]
-- 与其他语言不同，Lua没有continue语句
-- 但我们可以用其他方法实现类似功能 -- 方法1：使用if语句包装
print("=== 方法1：使用if跳过单次循环 ===")
for i = 1, 10 do if i % 2 ~= 0 then -- 如果不是偶数 -- 执行代码（相当于跳过偶数） print("奇数：" .. i) end -- 如果是偶数，这里什么都不做，相当于continue
end
--[[ 输出
奇数：1
奇数：3
奇数：5
奇数：7
奇数：9
--]] -- 方法2：使用反向逻辑
print("\n=== 方法2：反向逻辑 ===")
for i = 1, 10 do if i % 2 == 0 then -- 如果是偶数 -- 直接进入下一次迭代 -- 在Lua中没有continue，所以我们用if的else部分 else print("奇数：" .. i) end
end
--[[ 输出
奇数：1
奇数：3
奇数：5
奇数：7
奇数：9
--]] -- 方法3：使用 goto（Lua 5.1不支持，但 LuaJIT 2.0+ 支持）
-- 注意：Lua 5.1 不支持 goto，这里仅能用于 LuaJIT，这里仅说明，后续 LuaJIT 篇详细说明
-- for i = 1, 10 do
-- if i % 2 == 0 then
-- goto continue -- 跳过后续代码
-- end -- print("处理奇数：" .. i) -- ::continue::
-- end -- 方法4：使用嵌套的if-else
print("\n=== 方法4：跳过特定条件的处理 ===")
for i = 1, 6 do if i == 5 then print("跳过数字5") -- 什么都不做，相当于continue else -- 正常处理 if i % 2 == 0 then print(i .. "是偶数") else print(i .. "是奇数") end end
end
--[[ 输出
1是奇数
2是偶数
3是奇数
4是偶数
跳过数字5
6是偶数
--]] -- 实际游戏示例：处理敌人列表，跳过已死亡的敌人
print("\n=== 敌人处理示例 ===")
local enemies = { {name = "敌人A", health = 50}, {name = "敌人B", health = 0}, -- 已死亡 {name = "敌人C", health = 30}, {name = "敌人D", health = 0}, -- 已死亡 {name = "敌人E", health = 80}
} for index, enemy in ipairs(enemies) do -- 跳过已死亡的敌人（模拟continue） if enemy.health &lt;= 0 then print("跳过已死亡的敌人：" .. enemy.name) -- 在Lua 5.1中，我们只能这样"跳过" -- 实际的代码应该放在else块中 else -- 处理存活的敌人 print("攻击敌人：" .. enemy.name) enemy.health = enemy.health - 20 print("敌人" .. enemy.name .. "剩余生命值：" .. enemy.health) end
end
--[[ 输出
攻击敌人：敌人A
敌人敌人A剩余生命值：30
跳过已死亡的敌人：敌人B
攻击敌人：敌人C
敌人敌人C剩余生命值：10
跳过已死亡的敌人：敌人D
攻击敌人：敌人E
敌人敌人E剩余生命值：60
--]]
-- 泛型for循环用于遍历表
-- 我们会在第7章详细学习表，这里先简单了解 -- 使用ipairs遍历数组部分（索引从1开始）
print("=== 使用ipairs遍历数组 ===")
local monsters = {"哥布林", "兽人", "骷髅", "僵尸"} for index, m in ipairs(monsters) do print("第" .. index .. "个怪物: " .. m)
end
--[[ 输出
第1个怪物: 哥布林
第2个怪物: 兽人
第3个怪物: 骷髅
第4个怪物: 僵尸
--]] -- 使用pairs遍历所有键值对
print("\n=== 使用pairs遍历表 ===")
local player = { name = "英雄", level = 10, health = 100, class = "hero"
} for key, value in pairs(player) do print(key .. ": " .. value)
end
--[[ 输出
class: hero
level: 10
name: 英雄
health: 100
--]]
-- 注：pairs的遍历顺序是无序的
<br>（答案见 <a data-href="第 1 节 - 语法/参考答案#练习 5 1：猜数字游戏" href="第-1-节-语法/参考答案.html#练习 5 1：猜数字游戏" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 5 1：猜数字游戏</a>）-- 使用以下代码生成 1 - 100 的随机数，设定一个最大尝试次数，模拟用户多次输入
-- 如果猜错了给出太小了还是太大了的提示，猜中数字或超过最大尝试次数退出循环
math.randomseed(os.time())
local random_number = math.random(1, 100)
<br>（答案见<a data-href="第 1 节 - 语法/参考答案#练习 5.2：打印图形" href="第-1-节-语法/参考答案.html#练习 5.2：打印图形" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 5.2：打印图形</a>）-- 使用 io.write("*") （不换行的 print）打印星号与 print() 换行打印以下图形
-- 1. 打印直角三角形
-- 2. 打印倒直角三角形
-- 3. 打印等腰三角形
-- 4. 打印空心菱形
--[[ 输出
1. 直角三角形:
* * * * * * * * * * * * * * * 2. 倒直角三角形:
* * * * * * * * * * * * * * * 3. 等腰三角形: * *** ***** *******
********* 4. 空心菱形: * * * * * * *
* * * * * * * * *
--]] 条件语句： if-then：基本条件判断
if-then-else：二选一分支
if-then-elseif-then-else：多分支选择
嵌套 if 语句：复杂条件逻辑 循环语句： while 循环：先判断条件，条件为真时执行循环体，设置的是继续循环的条件
repeat-until 循环：先执行循环体，然后判断条件，条件为真时停止，设置的是结束循环的条件
for 循环（数值）：精确控制循环次数，使用计数器
泛型 for 循环：用于遍历表（初步了解） 循环控制： break 语句：立即退出当前循环
Lua 没有 continue 语句，但可以通过 if 语句模拟 条件逻辑思维：学会将现实问题转化为条件判断
循环思维：识别需要重复执行的模式
边界思维：注意循环的起始、结束条件和边界情况
效率思维：避免无限循环，合理使用 break
-- 错误1：忘记改变循环条件（无限循环）
local i = 1
while i &lt;= 5 do print(i) -- 忘记写 i = i + 1
end -- 错误2：错误的条件表达式
local count = 0
while count ~= 10 do -- 如果count跳过10，可能成为无限循环 count = count + 2 print(count)
end -- 错误3：在for循环中修改循环变量（通常不是好主意）
for i = 1, 10 do print(i) i = i + 2 -- 不推荐，可能导致意外行为
end -- 调试技巧：添加打印语句
print("=== 开始循环 ===")
for i = 1, 5 do print("循环开始，i = " .. i) -- ... 其他代码 ... print("循环结束，i = " .. i)
end
print("=== 循环结束 ===")
-- 1. 总是使用局部变量作为循环计数器
for i = 1, 10 do -- i自动成为局部变量 print(i)
end -- 2. 复杂条件使用括号提高可读性
if (player_level &gt;= 10 and has_key) or is_admin then -- 清晰的逻辑
end -- 3. 避免过深的嵌套
-- 不好：嵌套太深
if condition1 then if condition2 then if condition3 then -- 条件代码块 end end
end -- 更好：使用逻辑运算符
if condition1 and condition2 and condition3 then -- 条件代码块
end -- 4. 避免短路求值失效，尤其是循环内
local n1, n2, n3 = 1, 2, 3
local s1, s2, s3 = "a", "b", "c" -- 计时
local start1 = os.clock()
for i = 1, 10000000 do -- 错误示例，循环内使用变量分组 local check_n = n1 == 1 and n2 == 2 and n3 == 3 local check_s = s1 == "a" and s2 == "b" and s3 == "c" -- 即使 n3 判断为假也会继续判断 s123 if check_n and check_s then	-- 可读性改善，代价是短路求值失效一半 end
end
local time1 = os.clock() - start1 local start2 = os.clock()
for i = 1, 10000000 do -- 正确示例，使用括号分组 -- n3 判断为假，直接停止判断，虽然可读性较差 if (n1 == 1 and n2 == 2 and n3 == 3) and (s1 == "a" and s2 == "b" and s3 == "c") then end
end
local time2 = os.clock() - start2 -- 或者在循环外部创建变量
local start3 = os.clock()
local check_n = n1 == 1 and n2 == 2 and n3 == 3
local check_s = s1 == "a" and s2 == "b" and s3 == "c"
for i = 1, 10000000 do if check_n and check_s then end
end
local time3 = os.clock() - start3 print(string.format("括号分组: %.4f 秒", time2))
print(string.format("变量分组: %.4f 秒", time1))
print(string.format("静态变量分组: %.4f 秒", time3))
print(string.format("动态变量分组开销: %.2f%%", (time1 - time2) / time2 * 100))
print(string.format("静态变量分组开销: %.2f%%", (time1 - time3) / time3 * 100))
--[[ 输出
变量分组: 0.1200 秒
括号分组: 0.1010 秒
静态变量分组: 0.0290 秒
动态变量分组开销: 18.81%
静态变量分组开销: -313.79%
--]]
（点击勾选框勾选）
完成本章后，你应该能够：
使用 if 语句实现条件分支
理解并使用各种循环结构
正确使用 break 退出循环
识别并避免无限循环
使用嵌套的控制结构解决复杂问题
理解 while 和 repeat-until 的区别
使用 for 循环处理计数任务 什么情况下应该使用 while 循环而不是 for 循环？
如果需要在循环中跳过某些迭代但不退出循环，有哪些方法？
如何设计一个程序，让用户可以多次尝试直到成功？
在什么情况下应该使用嵌套循环？有什么需要注意的？
如何确保循环能够正常结束，不会成为无限循环？ 编写一个程序，找出 100 以内所有的素数
创建一个简单的文字冒险游戏，使用条件语句控制游戏流程
实现一个模拟银行 ATM 机的程序，支持存款、取款、查询等功能
编写一个程序，打印出斐波那契数列的前 20 项
创建一个简单的成绩管理系统，可以输入多个学生成绩并统计平均分
下一章预告：在第 6 章中，我们将深入学习函数。函数是组织和重用代码的重要工具，它能将复杂问题分解为小的、可管理的部分。我们将学习如何定义函数、传递参数、返回值，以及更高级的函数概念。学习建议：
多做练习，特别是循环和条件组合的题目
尝试将日常生活中的决策过程用 if 语句描述
注意观察哪些任务适合用循环自动化
多调试，理解程序执行的流程
]]></description><link>第-1-节-语法/5.-控制结构.html</link><guid isPermaLink="false">第 1 节 - 语法/5. 控制结构.md</guid><pubDate>Fri, 26 Dec 2025 01:37:20 GMT</pubDate></item><item><title><![CDATA[4. 运算符]]></title><description><![CDATA[local a, b = 10, 3 print(a + b)	-- 加法：13
print(a - b)	-- 减法：7
print(a * b)	-- 乘法：30
print(a / b)	-- 除法：3.3333
print(a % b)	-- 取余：1
print(a ^ b)	-- 指数：1000（10³）
print(-a) -- 取负：-10 -- 取余运算的特殊用途
print("奇数判断: 15 % 2 = " .. (15 % 2)) -- 1为奇数，0为偶数
print("范围限制: 25 % 24 = " .. (25 % 24))	-- 结果在0-23之间
local x, y = 10, 20 print(x == y) -- 相等：false
print(x ~= y) -- 不相等：true（注意：不是!=）
print(x &lt; y) -- 小于：true
print(x &gt; y) -- 大于：false
print(x &lt;= y) -- 小于等于：true
print(x &gt;= y) -- 大于等于：false
print("apple" &lt; "banana") -- true
print("10" &lt; "2") -- true（字符串比较，不是数值）
local t1 = {1, 2, 3}
local t2 = {1, 2, 3}
local t3 = t1 print(t1 == t2) -- false（不同对象）
-- 注：比较的是引用，不是内容
print(t1 == t3) -- true（同一对象）
print(1 == "1") -- false（类型不同）
print(1 == tonumber("1"))	-- true
-- and：如果第一个操作数为真，返回第二个操作数；否则返回第一个操作数
print(true and false)	-- true 为真，输出 false
print(false and true)	-- false 为假，输出 false
print(true and "hello")	-- true 为真，输出 "hello"
print(nil and true) -- nil 为假，输出 nil
-- or：如果第一个操作数为真，返回第一个操作数；否则返回第二个操作数
print(true or false) -- true 为真，输出 true
print(false or true) -- false 为假，输出 true
print(nil or "default") -- nil 为假，输出 "default"
-- not：取反，总是返回布尔值
print(not true) -- false
print(not false)	-- true
print(not nil) -- true
print(not 0) -- false（0是真值）
local config = { volume = nil, -- 未设置 difficulty = "normal"
} -- 使用or提供默认值
local volume = config.volume or 50 -- 如果volume是nil，使用50
print("音量: " .. volume) -- 使用and进行条件赋值
local is_admin = true
local message = is_admin and "欢迎管理员" or "欢迎访客"
print("消息: " .. message) -- 如果其中一个判断为假，跳过后续运算
-- 第一个判断为假，跳过第二个 true 判断
if false and true then ...
end -- 示例
local function expensive_calculation() print("执行复杂计算...") return 42
end local should_calculate = false -- 不想进行计算
local result = should_calculate and expensive_calculation()
-- should_calculate 为假，expensive_calculation 函数不会被调用
-- 如果其中一个判断为真，跳过后续运算
-- 第一个判断为真，跳过第二个 false 判断
if true or false then ...
end -- 示例
-- 示例
local function say(s) if not s then print("s = false") else print("s = true") end -- 如果 s 为假（nil），将 s 赋值为 "hello world"，否则不变 s = s or "hello world" print(s)
end say()
say("hello")
--[[ 输出
s = false
hello world
s = true
hello
--]]
local name = "张三"
-- 使用 "#" 统计字符串长度
print("\"" .. name .. "\"的长度: " .. #name) -- 输出：6（中文一个字符等于 3 个字节）
local towers = {"箭塔", "兵营", "法师塔", "炮塔"}
print("防御塔数量: " .. #towers) -- 输出：4 -- 注意：无法使用 "#" 统计字典部分的长度
local tower = { name = "炮塔", level = 10, damage = 100
}
print("键数量: " .. #tower) -- 错误！输出：0
-- 使用 .. 连接字符串
local greeting = "你好" .. ", " .. "世界!"
print(greeting) -- 输出：你好, 世界! -- 如果操作数不是字符串，会自动转换
local age = 25
print("年龄: " .. age) -- 自动将25转换为"25"
算术运算符：print(2 + 3 * 4)	-- 3*4先计算，然后加2 = 14 -- 可以使用括号来指定优先级
print((2 + 3) * 4)	-- 2+3先计算，然后乘4 = 20
逻辑运算符：local x, y, z = true, 1, 2 print(x and y or z) -- 如果 x 为真输出 1，为假输出 2 print(x and (y and 3 or z))	-- 先判断 y 得到值，为真则值为 3，为假则值为 2，如果 x 为真输出 3
（答案见 <a data-href="第 1 节 - 语法/参考答案#练习 4.1：简单计算器" href="第-1-节-语法/参考答案.html#练习 4.1：简单计算器" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 4.1：简单计算器</a>）-- 实现一个简单的四则运算计算器 运算符： 算术：+ - * / % ^ -（负号）
关系：== ~= &lt; &gt; &lt;= &gt;=
逻辑：and or not
字符串：..（连接） 短路求值： and：其中一个为假跳过后续运算
or：其中一个为真跳过后续运算
短路求值失效：使用括号分组而不是变量 优先级： 指数 &gt; 负号 &gt; 乘除 &gt; 加减 &gt; 连接 &gt; 比较 &gt; 逻辑 -- 1. 错误：混淆 "="、 "=="
local x = 5 -- 错误示例，应该是 ==
if x = 10 then print("x是10")
end -- 正确示例
if x == 10 then print("x是10")
end -- 2. 技巧：使用 or 提供默认值
local sound_volume = user_setting.volume or 70 -- 3. 技巧：使用 and 简化条件判断
local player = get_player()
local name = player and player.name or "未知玩家" -- 注意：Lua 中只有 false 和 nil 是假值，其他任何值都是真
if 0 then -- 这个条件为真！ print("0在Lua中是真值")
end -- 4. 错误：将逻辑运算分组为多个变量
local n1, n2, n3 = 1, 2, 3
local s1, s2, s3 = "a", "b", "c" -- 错误示例，应使用括号分组，而不是分组为变量
local check_n = n1 == 1 and n2 == 2 and n3 == 3
local check_s = s1 == "a" and s2 == "b" and s3 == "c"	-- 即使 n3 判断为假也会继续判断 s123 if check_n and check_s then -- 可读性改善，代价是短路求值失效一半 print("检查通过")
end -- 正确示例，使用括号分组
-- n3 判断为假，直接停止判断，虽然可读性较差
if (n1 == 1 and n2 == 2 and n3 == 3) and (s1 == "a" and s2 == "b" and s3 == "c") then print("检查通过")
end
（点击勾选框勾选）
完成本章后，你应该能够：
使用各种运算符进行计算和比较
理解运算符优先级并正确使用括号
利用逻辑运算符实现条件默认值 为什么字符串连接使用 .. 而不是 +？
表达式 a and b or c 在什么情况下不能代替 a ? b : c 的三元运算？
下一章预告：在第 5 章中，我们将学习控制结构，包括条件判断和循环语句。这是让程序"有逻辑"的关键一步！拓展练习：
创建一个简单的配置系统，使用表存储配置，并提供默认值
实现一个类型安全的加法函数，只对数字进行加法运算
]]></description><link>第-1-节-语法/4.-运算符.html</link><guid isPermaLink="false">第 1 节 - 语法/4. 运算符.md</guid><pubDate>Fri, 26 Dec 2025 01:34:55 GMT</pubDate></item><item><title><![CDATA[8. 字符串]]></title><description><![CDATA[字符串是编程中最常用的数据类型之一。在 Lua 中，字符串是不可变的，但提供了丰富的操作函数。-- Lua有几种创建字符串的方式 -- 1. 双引号
local str1 = "Hello, Lua!"
print("双引号: " .. str1) -- 2. 单引号
local str2 = 'Hello, World!'
print("单引号: " .. str2) -- 3. 长括号（多行字符串）
local str3 = [[
这是多行字符串
可以包含换行和"各种引号"
而无需转义]]
print("长括号:\n" .. str3) -- 4. 带有等号的长括号（可以嵌套）
local str4 = [=[
多层嵌套 [[不会结束字符串]]
]=]
print("带等号的长括号: " .. str4)
-- 转义字符，用于输入特殊字符
local escaped = "第一行\n换行\t制表符（缩进）\"引号\\反斜杠"
print("转义字符示例:\n" .. escaped) -- 特殊字符的表示
print("Unicode字符: \u{4F60}\u{597D}") -- 你好
print("十六进制: \x48\x65\x6C\x6C\x6F") -- Hello
所有转义符见 <a data-href="6. 字符串#转义字符" href="总结/6.-字符串.html#转义字符" class="internal-link" target="_self" rel="noopener nofollow">6. 字符串 &gt; 转义字符</a>-- 重要概念：Lua字符串是不可变的
local original = "Hello"
print("原始字符串: " .. original)
print("原始字符串内存地址（通过tostring）: " .. tostring(original)) -- 看起来像是"修改"了字符串
original = original .. " World"
print("修改后: " .. original)
print("修改后内存地址: " .. tostring(original))
-- 注意：实际上是创建了一个新的字符串 -- 证明不可变性
local a = "Hello"
local b = "Hello"
print("\na和b相同吗？ " .. tostring(a == b)) -- true
print("a的内存地址: " .. tostring(a))
print("b的内存地址: " .. tostring(b))
-- Lua会复用相同的字符串，所以a和b可能指向同一内存 -- 实际影响：大量字符串操作时要注意性能
function slow_string_build() local result = "" for i = 1, 10000 do result = result .. "x" -- 每次都会创建新字符串 end return result
end -- 更好的方式：使用table.concat
function fast_string_build() local parts = {} for i = 1, 10000 do parts[i] = "x" end return table.concat(parts)
end print("\n字符串构建方式比较:")
-- 注意：在实际中，fast_string_build会比slow_string_build快得多
-- 使用 # 运算符符获取字符串长度
print("=== 字符串长度 ===") local str = "Hello, Lua!"
print("字符串: " .. str)
print("长度: " .. #str) -- 11（英文和标点）
print("长度: " .. string.len(str))	-- 使用 string.len，与上面等价，但是只能操作字符串 -- 中文字符
local chinese = "你好，世界！"
print("\n中文字符串: " .. chinese)
print("长度: " .. #chinese) -- 18（每个中文字符算三个长度）
print("长度: " .. string.len(chinese)) -- 包含特殊字符
local special = "Line1\nLine2\tTab"
print("\n特殊字符字符串: " .. special)
print("长度: " .. #special) -- 15（\n算一个字符，\t算一个字符）
print("长度: " .. string.len(special)) -- 空字符串
local empty = ""
print("\n空字符串长度: " .. #empty) -- 0
-- 使用 .. 连接字符串
-- 基本连接
local greeting = "Hello" .. ", " .. "World!"
print("连接结果: " .. greeting) -- 连接不同类型的值
local name = "小明"
local age = 18
local info = "姓名: " .. name .. ", 年龄: " .. age
print("信息: " .. info) -- 大量连接时的性能问题
local start_time = os.clock()
local result = "" for i = 1, 1000 do result = result .. "x" -- 每次创建新字符串
end local end_time = os.clock()
print("\n直接连接1000次耗时: " .. (end_time - start_time) .. "秒") -- 使用table.concat提高性能
start_time = os.clock()
local parts = {} for i = 1, 1000 do parts[i] = "x"
end result = table.concat(parts)
end_time = os.clock()
print("使用table.concat耗时: " .. (end_time - start_time) .. "秒") -- table.concat的高级用法
local words = {"Hello", "World", "from", "Lua"}
local sentence = table.concat(words, " ", 2, 4) -- 从第2个到第4个，用空格连接
print("\n部分连接: " .. sentence) -- "World from Lua" -- 实际应用：构建SQL查询
local conditions = {"age &gt; 18", "status = 'active'", "score &gt;= 60"}
local where_clause = "WHERE " .. table.concat(conditions, " AND ")
print("SQL查询: SELECT * FROM users " .. where_clause) -- 实际应用：构建URL
local base_url = "https://api.example.com"
local path = "users"
local query_params = {"limit=10", "offset=0", "sort=name"}
local url = base_url .. "/" .. path .. "?" .. table.concat(query_params, "&amp;")
print("URL: " .. url)
string.rep(重复的字符串: str, 重复次数: int) -&gt; 字符串结果: str
-- 基本重复
local stars = string.rep("*", 10)
print("10个星号: " .. stars)
-- 输出 10个星号: ********** -- 带分隔符的重复
local dashed_line = string.rep("-", 30)
print("分隔线: " .. dashed_line)
-- 输出 分隔线: ------------------------------ -- 重复多个字符
local pattern = string.rep("*-", 15)
print("模式: " .. pattern)
-- 输出 模式: *-*-*-*-*-*-*-*-*-*-*-*-*-*-*- -- 实际应用：进度条
local function create_progress_bar(percentage, width) local filled = math.floor(percentage * width / 100) local empty = width - filled local bar = "[" .. string.rep("=", filled) .. string.rep(" ", empty) .. "] " .. string.format("%3d%%", percentage) return bar
end print("\n进度条:")
for i = 0, 100, 10 do print(create_progress_bar(i, 20))
end
--[[ 输出
进度条:
[ ] 0%
[== ] 10%
[==== ] 20%
[====== ] 30%
[======== ] 40%
[========== ] 50%
[============ ] 60%
[============== ] 70%
[================ ] 80%
[================== ] 90%
[====================] 100%
--]] -- 实际应用：缩进文本
local function indent_text(text, indent_level) local indent = string.rep(" ", indent_level) return indent .. text
end print("\n缩进文本:")
local lines = { "第一级", "第二级", "第三级"
} for i, line in ipairs(lines) do print(indent_text(line, i-1))
end
--[[ 输出
缩进文本:
第一级 第二级 第三级
--]] -- 创建表格边框
local function create_table_border(width) local border = "+" .. string.rep("-", width-2) .. "+" return border
end print("\n表格边框:")
print(create_table_border(25))
print("| 内容 |")
print(create_table_border(25)) --[[ 输出
表格边框:
+-----------------------+
| 内容 |
+-----------------------+
--]]
string.find(字符串: str, 查找的字符串: str, 搜索位置?: int, 是否不使用正则模式?: bool) -&gt; 起始索引: int, 结束索引: int| nil 搜索位置可以一个负数，表示从后往前数的字符个数
local text = "Hello, Lua programming is fun!" -- 查找子串
local start_pos, end_pos = string.find(text, "Lua")
if start_pos then print("找到'Lua'在位置: " .. start_pos .. "-" .. end_pos) print("子串: " .. string.sub(text, start_pos, end_pos))
else print("未找到")
end -- 从指定位置开始查找
local pos = string.find(text, "o", 6) -- 从第5个字符开始找
print("\n从第5位开始找'o': " .. (pos or "未找到")) -- 14 -- 查找最后一个匹配
local function find_last(str, pattern) local last_pos local current_pos = 1 while true do local start, finish = string.find(str, pattern, current_pos) if not start then break end last_pos = start current_pos = start + 1 end return last_pos
end local last_o = find_last(text, "o")
print("最后一个'o'在位置: " .. (last_o or "未找到")) -- 查找所有匹配
local function find_all(str, pattern) local positions = {} local current_pos = 1 while true do local start, finish = string.find(str, pattern, current_pos) if not start then break end table.insert(positions, {start = start, finish = finish}) current_pos = start + 1 end return positions
end print("\n 查找所有'o':")
local all_o = find_all(text, "o")
for i, pos in ipairs(all_o) do print(" 匹配" .. i .. ": 位置" .. pos.start .. "-" .. pos.finish)
end -- 实际应用：查找邮箱地址
local email_text = "联系我: user@example.com 或 admin@test.org "
local email_pattern = "[%w%.%-]+@[%w%.%-]+%.[%w]+" local email_start, email_end = string.find(email_text, email_pattern)
if email_start then print("\n 找到邮箱: " .. string.sub(email_text, email_start, email_end))
end
string.sub(字符串: str, 截取起始位置: int, 截取结束位置?: int) -&gt; 字符串: str 截取结束位置默认为 -1（截取到最后一个）
local sentence = "The quick brown fox jumps over the lazy dog" -- 提取子串
local first_word = string.sub(sentence, 1, 3)
print("第一个单词: " .. first_word) -- The -- 使用负索引（从末尾开始）
local last_word = string.sub(sentence, -3) -- 最后 3 个字符
print("最后三个字符: " .. last_word) -- dog -- 提取中间部分
local middle = string.sub(sentence, 5, 14)
print("第 5-14 个字符: " .. middle) -- quick bro -- 实际应用：提取文件名和扩展名
local function find_last(str, pattern) local last_pos local current_pos = 1 while true do local start, finish = string.find(str, pattern, current_pos) if not start then break end last_pos = start current_pos = start + 1 end return last_pos
end local function split_filename(filename) local name_without_ext = filename local ext = "" -- 查找最后一个点 local dot_pos = find_last(filename, "%.") if dot_pos and dot_pos &gt; 1 then name_without_ext = string.sub(filename, 1, dot_pos - 1) ext = string.sub(filename, dot_pos + 1) end return name_without_ext, ext
end local files = {"document.pdf", "image.jpg", "no_extension", ".hidden", "archive.tar.gz"} print("\n 文件名分割:")
for _, filename in ipairs(files) do local name, ext = split_filename(filename) print(string.format(" %-20s -&gt; 名称: %-15s 扩展名: %s", filename, name, ext))
end -- 实际应用：提取 URL 各部分
function parse_url(url) local protocol, domain, path -- 查找协议 local protocol_end = string.find(url, "://") if protocol_end then protocol = string.sub(url, 1, protocol_end - 1) url = string.sub(url, protocol_end + 3) end -- 查找路径 local path_start = string.find(url, "/") if path_start then domain = string.sub(url, 1, path_start - 1) path = string.sub(url, path_start) else domain = url path = "/" end return protocol, domain, path
end print("\nURL 解析:")
local urls = { "https://www.example.com/path/to/page", "http://localhost:8080", "ftp://files.server.com/download/file.zip"
} for _, url in ipairs(urls) do local protocol, domain, path = parse_url(url) print(string.format(" %-40s -&gt; 协议: %-6s 域名: %-20s 路径: %s", url, protocol or "无", domain, path))
end
-- Lua 没有内置的字符串分割函数，需要自己实现
-- 按分隔符分割字符串
local function string_split(str, delimiter) local result = {} local pattern = string.format("([^%s]+)", delimiter) for match in string.gmatch(str, pattern) do table.insert(result, match) end return result
end -- 按空格分割
local sentence = "The quick brown fox jumps over the lazy dog"
local words = string_split(sentence, " ") print("\n 句子单词:") for i, word in ipairs(words) do print(" 单词" .. i .. ": " .. word)
end
--[[ 输出
句子单词: 单词1: The 单词2: quick 单词3: brown 单词4: fox 单词5: jumps 单词6: over 单词7: the 单词8: lazy 单词9: dog
--]] -- 按行分割
local multi_line = "第一行\n 第二行\n 第三行"
local lines = string_split(multi_line, "\n") print("\n 按行分割:") for i, line in ipairs(lines) do print(" 行" .. i .. ": " .. line)
end
--[[ 输出
按行分割: 行1: 第一行 行2: 第二行 行3: 第三行
--]]
Lua 的模式匹配（pattern matching）是一种轻量级的正则表达式，功能强大但语法更简单，使用具有特殊意义的符号（修饰符）表示各种字符。<br>所有模式匹配修饰符见 <a data-href="6. 字符串#模式匹配修饰符" href="总结/6.-字符串.html#模式匹配修饰符" class="internal-link" target="_self" rel="noopener nofollow">6. 字符串 &gt; 模式匹配修饰符</a>string.match(字符串: str, 匹配模式: pattern, 起始位置?: init) -&gt; 匹配结果: str
-- Lua 模式匹配的特殊字符 -- . 匹配任意字符
print("'.'匹配任意字符: " .. string.match("abc123", ".")) -- %a 匹配字母
print("'%a'匹配字母: " .. string.match("abc123!@#", "%a")) -- %d 匹配数字
print("'%d'匹配数字: " .. string.match("abc123!@#", "%d")) --[[ 输出
'.'匹配任意字符: a
'%a'匹配字母: a
'%d'匹配数字: 1
--]]
string.gmatch(字符串: str, 匹配模式: str) -&gt; 迭代器函数: func
-- . 匹配任意字符
local matches = {}
for match in string.gmatch("abc123", ".") do	-- 迭代器函数用于遍历，每次调用 string.match 匹配字符串中下一个结果 table.insert(matches, match)
end
print("'.'匹配任意字符: " .. table.concat(matches, ", ")) -- %a 匹配字母
matches = {}
for match in string.gmatch("abc123!@#", "%a") do table.insert(matches, match)
end
print("'%a'匹配字母: " .. table.concat(matches, ", ")) -- %d 匹配数字
matches = {}
for match in string.gmatch("abc123!@#", "%d") do table.insert(matches, match)
end
print("'%d'匹配数字: " .. table.concat(matches, ", ")) --[[ 输出
'.'匹配任意字符: a, b, c, 1, 2, 3
'%a'匹配字母: a, b, c
'%d'匹配数字: 1, 2, 3
--]]
-- 字符类：用 [] 定义自定义字符集
local text = "abc123!@ #DEF " -- [abc] 匹配 a、b 或 c
local matches = {}
for match in string.gmatch(text, "[abc]") do table.insert(matches, match)
end
print("[abc]匹配: " .. table.concat(matches, ", ")) -- [0-9] 匹配数字
matches = {}
for match in string.gmatch(text, "[0-9]") do table.insert(matches, match)
end
print("[0-9]匹配: " .. table.concat(matches, ", ")) -- [A-Z] 匹配大写字母
matches = {}
for match in string.gmatch(text, "[A-Z]") do table.insert(matches, match)
end
print("[A-Z]匹配: " .. table.concat(matches, ", ")) -- [^abc] 匹配除了 a、b、c 之外的字符
matches = {}
for match in string.gmatch(text, "[^abc]") do table.insert(matches, match)
end
print("[^abc]匹配: " .. table.concat(matches, ", ")) -- 组合字符类
matches = {}
for match in string.gmatch(text, "[a-z0-9]") do table.insert(matches, match)
end
print("[a-z0-9]匹配: " .. table.concat(matches, ", ")) -- 实际应用：验证用户名
function validate_username(username) -- 用户名要求：字母开头，只能包含字母、数字、下划线，长度 3-20 local pattern = "^[a-zA-Z][%w_]{2,19}$" return string.match(username, pattern) ~= nil
end print("\n 用户名验证:")
local test_usernames = {"abc", "123", "a_1", "a", "very_long_username_here", "user-name"}
for _, name in ipairs(test_usernames) do print(string.format(" %-25s -&gt; %s", name, validate_username(name) and "有效" or "无效"))
end -- 实际应用：提取颜色代码
function extract_color_codes(text) local colors = {} -- 匹配 #RRGGBB 或 #RGB 格式 for code in string.gmatch(text, "#[0-9a-fA-F]+") do if #code == 4 or #code == 7 then -- #RGB 或 #RRGGBB table.insert(colors, code) end end return colors
end local color_text = "背景色: #FFFFFF , 文字色: #000 , 高亮: #FF0000 , 无效: #12345 "
print("\n 提取颜色代码:")
local colors = extract_color_codes(color_text)
for _, color in ipairs(colors) do print(" 颜色: " .. color)
end
-- 重复修饰符控制匹配次数
local text = "aaabbcccddddeeee" -- * 匹配 0 次或多次（贪婪）
local matches = {}
for match in string.gmatch(text, "a*") do if #match &gt; 0 then table.insert(matches, "'" .. match .. "'") end
end
print("*匹配（贪婪）: " .. table.concat(matches, ", ")) -- + 匹配 1 次或多次
matches = {}
for match in string.gmatch(text, "a+") do table.insert(matches, "'" .. match .. "'")
end
print("+匹配: " .. table.concat(matches, ", ")) -- ? 匹配 0 次或 1 次
matches = {}
for match in string.gmatch(text, "a?") do table.insert(matches, "'" .. match .. "'")
end
print("?匹配: " .. table.concat(matches, ", ")) -- - 匹配 0 次或多次（非贪婪）
matches = {}
for match in string.gmatch("aaaa", "a-") do table.insert(matches, "'" .. match .. "'")
end
print("-匹配（非贪婪）: " .. table.concat(matches, ", "))
--[[ 输出
*匹配（贪婪）: 'aaa'
+匹配: 'aaa'
?匹配: 'a', 'a', 'a', '', '', '', '', '', '', '', '', '', '', '', '', '', ''
-匹配（非贪婪）: '', '', '', '', ''
--]] -- 实际应用：匹配浮点数
local function extract_numbers(text) local numbers = {} -- 匹配整数和浮点数 for num in string.gmatch(text, "[+-]?%d+%.?%d*") do -- 过滤掉单独的点和无效格式 if num ~= "." and num ~= "+" and num ~= "-" then table.insert(numbers, num) end end return numbers
end local number_text = "价格: 12.5, -3.14, +100, .5, 3., abc, 123"
print("\n 提取数字:")
local numbers = extract_numbers(number_text) for _, num in ipairs(numbers) do print(" 数字: " .. num)
end
--[[ 输出
提取数字: 数字: 12.5 数字: -3.14 数字: +100 数字: 5 数字: 3. 数字: 123
--]] -- 实际应用：匹配 HTML 标签
function extract_html_tags(html) local tags = {} -- 简单匹配标签（不包括属性） for tag in string.gmatch(html, "&lt;([^&gt;]+)&gt;") do table.insert(tags, tag) end return tags
end local html = "&lt;div class='container'&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;br/&gt;&lt;img src='test.jpg'&gt;&lt;/div&gt;"
print("\n 提取 HTML 标签:")
local tags = extract_html_tags(html) for _, tag in ipairs(tags) do print(" 标签: &lt;" .. tag .. "&gt;")
end
--[[ 输出
提取 HTML 标签: 标签: &lt;div class='container'&gt; 标签: &lt;p&gt; 标签: &lt;/p&gt; 标签: &lt;br/&gt; 标签: &lt;img src='test.jpg'&gt; 标签: &lt;/div&gt;
--]]
-- 使用()进行捕获
-- 基本捕获
local date = "2024-12-27"
local year, month, day = string.match(date, "(%d+)-(%d+)-(%d+)")
print("日期解析:")
print(" 年: " .. (year or "无"))
print(" 月: " .. (month or "无"))
print(" 日: " .. (day or "无"))
--[[ 输出
日期解析: 年: 2024 月: 12 日: 27
--]] -- 捕获邮箱的用户名和域名
local email = " user@example.com "
local username, domain = string.match(email, "([%w%.%-]+)@([%w%.%-]+%.[%w]+)")
print("\n 邮箱解析:")
print(" 用户名: " .. (username or "无"))
print(" 域名: " .. (domain or "无"))
--[[ 输出
邮箱解析: 用户名: user 域名: example.com
--]] -- 使用 gmatch 进行多次捕获
local text = "alice:18,jack:20,bob:22"
print("\n 解析键值对:") for name, age in string.gmatch(text, "([%u%l]+):(%d+)") do print(" 姓名: " .. name .. ", 年龄: " .. age)
end
--[[ 输出
解析键值对: 姓名: alice, 年龄: 18 姓名: jack, 年龄: 20 姓名: bob, 年龄: 22
--]] -- 捕获 URL 各部分
function parse_url_detail(url) local pattern = "^([%w]+)://([^/]+)(.*)$" local protocol, host, path = string.match(url, pattern) return protocol, host, path
end -- 实际应用：提取和格式化日期
local function reformat_date(date_str) -- 支持多种日期格式 local patterns = { "(%d%d%d%d)[-/](%d%d)[-/](%d%d)", -- YYYY-MM-DD "(%d%d)[-/](%d%d)[-/](%d%d%d%d)" -- MM-DD-YYYY } for _, pattern in ipairs(patterns) do local y, m, d = string.match(date_str, pattern) if y and m and d then -- 如果年份是 2 位数，假设是 19xx 或 20xx if #y == 2 then local temp = y y = d d = temp end return string.format("%s 年 %s 月 %s 日", y, m, d) end end return date_str -- 无法解析，返回原样
end print("\n 日期格式化:")
local dates = {"2024-12-27", "12/27/2024", "24-01-15", "无效日期"}
for _, date in ipairs(dates) do print(" " .. date .. " -&gt; " .. reformat_date(date))
end
--[[ 输出
日期格式化: 2024-12-27 -&gt; 2024 年 12 月 27 日 12/27/2024 -&gt; 2024 年 27 月 12 日 24-01-15 -&gt; 24-01-15 无效日期 -&gt; 无效日期
--]]
string.gsub(字符串: str, 匹配模式: str, 替换为: str, 替换次数?: int) -&gt; 替换后的字符串: str, 替换次数: int 不指定替换次数将会替换所有匹配的字符串
-- 基本替换
local text = "Hello World"
local replaced = string.gsub(text, "World", "Lua")
print("基本替换: " .. replaced)
-- 输出 基本替换: Hello Lua -- 限制替换次数
local text = "Hello World World World"
local replaced = string.gsub(text, "World", "Lua", 2)
print("替换两次: " .. replaced)
-- 输出 替换两次: Hello Lua Lua World -- 使用模式匹配替换
local text = "Price: $10.99, Discount: 20%"
local replaced = string.gsub(text, "%$%d+%.%d%d", "[价格隐藏]")
print("隐藏价格: " .. replaced)
-- 输出 隐藏价格: Price: [价格隐藏], Discount: 20% -- 使用函数进行替换
local text = "The temperature is 25C and humidity is 60%"
local replaced = string.gsub(text, "(%d+)(%a?)", function(value, unit) if unit == "C" then -- 摄氏度转华氏度 local f = tonumber(value) * 9/5 + 32 return string.format("%.1fF", f) end return value .. unit
end) print("单位转换: " .. replaced)
-- 输出 单位转换: The temperature is 77.0F and humidity is 60% -- 使用%n 引用捕获
-- %1, %2 等引用之前的捕获
local text = "Hello World"
local swapped = string.gsub(text, "(%S+)%s+(%S+)", "%2 %1")
print("\n 交换单词:")
print(" 原始: " .. text)
print(" 交换后: " .. swapped)
--[[ 输出
交换单词: 原始: Hello World 交换后: World Hello
--]] -- 实际应用：模板渲染（更好的方法是字符串格式化）
local function render_template(template, data) local result = string.gsub(template, "{{([%w_]+)}}", function(key) return data[key] or "" end) return result
end local template = "尊敬的 {{name}} ：您订购的 {{product}} 已发货，订单号： {{order_id}} "
local data = { name = "张三", product = "Lua 编程书籍", order_id = "20241227001"
} print("\n 模板渲染:")
print(" 模板: " .. template)
print(" 数据: " .. "name=" .. data.name .. ", product=" .. data.product .. ", order_id=" .. data.order_id)
print(" 结果: " .. render_template(template, data))
--[[ 输出
模板渲染: 模板: 尊敬的 {{name}} ：您订购的 {{product}} 已发货，订单号： {{order_id}} 数据: name=张三, product=Lua 编程书籍, order_id=20241227001 结果: 尊敬的 张三 ：您订购的 Lua 编程书籍 已发货，订单号： 20241227001 --]]
简单来说字符串格式化就是将占位符替换为实际值，同时替换时根据占位符来对实际值进行额外处理。string.format(被格式化的字符串: str, 替换值: str...) -&gt; 格式化后的字符串: str
<br>所有格式化修饰符见 <a data-href="6. 字符串#格式化修饰符" href="总结/6.-字符串.html#格式化修饰符" class="internal-link" target="_self" rel="noopener nofollow">6. 字符串 &gt; 格式化修饰符</a>-- 基本格式化，%s 表示替换值是字符串，%d 表示替换值是数字
local name = "小明"
local age = 18
local formatted = string.format("姓名: %s, 年龄: %d", name, age)
print("基本格式化: " .. formatted)
-- 输出 姓名: 小明, 年龄: 18
local price = 19.99
print("\n 数字格式化:")
-- %f 表示浮点数（小数）默认小数精度 6 位
print(" 默认: " .. string.format("%f", price))
-- %.nf 表示小数精度
print(" 两位小数: " .. string.format("%.2f", price))
-- %d 表示整数，与替换值类型不符会自动转化，如果替换值为浮点会截断小数部分，数字字符串自动转化为数字
print(" 整数: " .. string.format("%d", price))
-- %e 对替换值进行处理，改为科学计数法表示
print(" 科学计数法: " .. string.format("%e", price))
-- %nd 组合使用：整数 %d + n 右对齐
print(" 宽度 10，右对齐: " .. string.format("%10d", price))
-- %-nd 组合使用：整数 %d + -n 左对齐
print(" 宽度 10，左对齐: " .. string.format("%-10d", price))
-- %0nd 前导零
print(" 前导零: " .. string.format("%04d", price))
--[[ 输出 默认: 19.990000 两位小数: 19.99 整数: 19 科学计数法: 1.999000e+001 宽度 10，右对齐: 19 宽度 10，左对齐: 19 前导零: 0019
]]
local text = "Hello"
print("\n 字符串格式化:")
-- %s 表示字符串，同上与替换值类型不符会自动转化，数字自动转化为数字字符串
print(" 默认: " .. string.format("%s", text))
-- 同上
print(" 宽度 10，右对齐: " .. string.format("%10s", text))
print(" 宽度 10，左对齐: " .. string.format("%-10s", text))
-- %.ns 字符串截断
print(" 截断为 3 字符: " .. string.format("%.3s", text))
--[[ 输出 默认: Hello 宽度 10，右对齐: Hello 宽度 10，左对齐: Hello 截断为 3 字符: Hel
--]]
-- 实际应用：创建表格
function create_table(data) local rows = {} -- 表头 table.insert(rows, string.format("%-20s %-10s %-10s", "姓名", "年龄", "分数")) table.insert(rows, string.rep("-", 42)) -- 数据行 for _, student in ipairs(data) do local row = string.format("%-20s %-10d %-10.1f", student.name, student.age, student.score) table.insert(rows, row) end return table.concat(rows, "\n")
end local students = { {name = "张三", age = 18, score = 85.5}, {name = "李四", age = 19, score = 92.0}, {name = "王五", age = 20, score = 78.5}
} print("\n 学生表格:")
print(create_table(students))
--[[ 输出 学生表格:
姓名 年龄 分数 ------------------------------------------
张三 18 85.5 李四 19 92.0 王五 20 78.5 --]]
tostring(值: any) -&gt; 字符串:str
local num = 123.456
local str_num = tostring(123.456)
print("数字转字符串:")
print(string.format(" 数字: %.3f，类型： %s", num, type(num)))
print(string.format(" 字符串: \"%s\"，类型：%s", str_num, type(str_num)))
--[[ 输出
数字: 123.456，类型： number
字符串: "123.456"，类型：string
--]] -- 连接或格式化时自动会将数字转化为字符串
print("连接自动转化字符串：" .. num)
print(string.format("格式化自动转化字符串：%.3f", num))
--[[ 输出
连接自动转化字符串：123.456
格式化自动转化字符串：123.456000
--]] -- 可以查看内存地址
print("表的内存地址：" .. tostring({123, 10}))
print("函数的内存地址：" .. tostring(function() return 123, 10
end))
--[[ 输出
表的内存地址：table: 00D49D00
函数的内存地址：function: 00D4C390
--]]
tonumber(要转化的字符串: str, 转化的基数?: 2-36) -&gt; 字符串: str
local str = "123.456"
local num = tonumber(str)
print("字符串转数字:")
print(string.format(" 字符串: \"%s\"，类型：%s", str, type(str)))
print(string.format(" 数字: %.3f，类型： %s", num, type(num)))
--[[ 输出 字符串: "123.456"，类型：string 数字: 123.456，类型： number
--]] -- 转换基数
print("\n 不同基数的转换:")
local hex_str = "FF"
local dec_num = tonumber(hex_str, 16)
print(" 十六进制 " .. hex_str .. " -&gt; 十进制 " .. dec_num)
local bin_str = "1010"
local bin_num = tonumber(bin_str, 2)
print(" 二进制 " .. bin_str .. " -&gt; 十进制 " .. bin_num)
--[[ 输出 十六进制 FF -&gt; 十进制 255 二进制 1010 -&gt; 十进制 10
--]] -- 解析字符串中的数字
local function extract_numbers_from_string(str) local numbers = {} for num_str in string.gmatch(str, "[+-]?%d+%.?%d*") do local num = tonumber(num_str) if num then table.insert(numbers, num) end end return numbers
end local mixed_text = "攻击 10 次，伤害 25 点"
print("\n 从字符串提取数字:")
local numbers = extract_numbers_from_string(mixed_text) for i, num in ipairs(numbers) do print(" 数字" .. i .. ": " .. num)
end
--[[ 输出
数字1: 10
数字2: 25
--]]
-- 错误1：混淆模式匹配修饰符 %、格式化修饰符 % 以及转义符 /
local wrong = string.format("文件名: %s, 模式: %d+", s1, s2) -- 错误：这里 %d+ 与模式匹配混淆了，+ 不是有效格式符
<br>（答案见<a data-href="第 1 节 - 语法/参考答案#练习 8 1：简单的文本分析器" href="第-1-节-语法/参考答案.html#练习 8 1：简单的文本分析器" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 8 1：简单的文本分析器</a>）-- 写一个文本分析器，可以分析给定的字符串有几行文本，有多少个单词，总字符数，统计最频繁的单词
-- 使用示例：
-- 测试文本分析器
local test_text = [[
Lua is a powerful, efficient, lightweight, embeddable scripting language.
It supports procedural programming, object-oriented programming, functional
programming, data-driven programming, and data description. Lua combines simple procedural syntax with powerful data description
constructs based on associative arrays and extensible semantics.
Lua is dynamically typed, runs by interpreting bytecode with a
register-based virtual machine, and has automatic memory management with
incremental garbage collection, making it ideal for configuration,
scripting, and rapid prototyping.
]] print("=== 文本分析器 ===")
analysis:analyze_text(test_text) local data = analysis.data print("基本统计:")
print(" 总字符数: " .. data.total_chars)
print(" 行数: " .. data.lines)
print(" 单词数: " .. data.word_count) print("\n 最频繁的单词:")
for i, item in ipairs(data.most_frequent) do print(string.format(" %2d. %-15s: %d 次", i, item.word, item.count))
end
--[[ 输出
基本统计: 总字符数: 582 行数: 11 单词数: 70 最频繁的单词: 1. and : 4 次 2. programming : 4 次 3. lua : 3 次 4. with : 3 次 5. a : 2 次
--]] 字符串基础： 三种字符串字面量：双引号、单引号、长括号
字符串是不可变的，操作会创建新字符串
使用 # 获取长度，注意多字节字符
使用 \ 转义字符 字符串操作： 连接：.. 运算符
重复：string.rep
性能优化：大量连接时使用 table.concat 字符串查找和提取： string.find：查找子串位置
string.sub：提取子串 字符串模式匹配： 字符类：%a（字母）、%d（数字）、%s（空白）等
重复修饰符：*、+、?、-、{n,m}
捕获和分组：()
string.match：单次模式匹配和捕获
string.gmatch：多次模式匹配和捕获
string.gsub：模式匹配替换 字符串格式化： string.format：格式化字符串
格式修饰符：%s（字符串）、%d（整数）、%f（浮点数）等 字符串转换： tostring：转换为字符串
tonumber：转换为数字，支持指定基数 -- 1. 对于大量字符串使用表连接
-- 不好
local result = "" for i = 1, 1000 do result = result .. "x" -- 创建 1000 个新字符串
end -- 好
local parts = {} for i = 1, 1000 do parts[i] = "x"
end local result = table.concat(parts) -- 2. 对于少量字符串连接使用字符串格式化 -- 不好
local current_path = "D/Program Files/"
local filepath = current_path .. "steam/" .. "common/" .. "game" -- 好
local current_path = "D/Program Files"
local filepath = string.format("%s/%s/%s/%s", current_path, "steam", "common", "game") -- 3. 重用模式对象（对于频繁使用的模式）
local pattern = "[%w%.%-]+@[%w%.%-]+%.[%w]+"
-- 然后多次使用这个 pattern -- 4. 使用 string.gmatch 代替多次 string.find
-- 当需要找到所有匹配时
for match in string.gmatch(text, pattern) do -- 处理每个匹配
end
-- 错误 1：误用 string.len 和 #操作符
local str = "你好"
print( #str ) -- 2（正确）
print(string.len(str)) -- 6（UTF-8 字节数） -- 错误 2：忘记字符串不可变
local s = "Hello"
s = string.gsub(s, "H", "J") -- 正确：创建新字符串并赋值
-- string.gsub(s, "H", "J") -- 错误：不会修改原字符串 -- 错误 3：模式匹配中的贪婪匹配
local text = "&lt;div&gt;content&lt;/div&gt;"
-- 贪婪匹配
local greedy = string.match(text, "&lt;.-&gt;") -- 整个字符串
-- 非贪婪匹配
local non_greedy = string.match(text, "&lt;.- &gt;") -- &lt;div&gt; -- 错误 4：转义特殊字符
local pattern = "10.5" -- .在模式中匹配任意字符
local text = "10x5"
print(string.match(text, pattern)) -- 会匹配！
-- 应该转义
pattern = "10\.5" -- 错误 5：忽略多行字符串的换行符
local str = [[第一行
第二行]]
print( #str ) -- 注意：包含换行符
（点击勾选框勾选）
完成本章后，你应该能够：
理解字符串的不可变性及其影响
使用各种方式创建字符串
进行字符串的连接、重复和长度计算
查找、提取和分割字符串
使用 Lua 模式匹配进行复杂的字符串操作
进行字符串的替换和格式化
在字符串和数字之间进行转换
编写性能良好的字符串处理代码 为什么 Lua 选择使用不可变字符串？这种设计有什么优缺点？
Lua 的模式匹配和正则表达式有什么区别？各有什么适用场景？
在处理大量文本数据时，如何优化字符串操作的性能？
如何正确处理包含多字节字符（如中文、emoji）的字符串？
在什么情况下应该使用 string.gsub 的函数替换功能？ 编写一个 JSON 解析器（简化版），将 JSON 字符串转换为 Lua 表
开发一个数据验证库，验证各种格式的数据（邮箱、URL、日期等）
下一章预告：在第 9 章中，我们将学习模块和包。模块是组织和重用代码的重要方式，我们将学习如何创建模块、使用模块、管理依赖，以及了解 Lua 的标准库。学习建议：
多练习模式匹配，这是 Lua 字符串处理的精华
理解字符串不可变性的影响，编写性能良好的代码
熟悉常用的字符串操作函数
尝试用字符串处理解决实际问题，如文本分析、数据提取等
注意处理多字节字符时的特殊考虑
]]></description><link>第-1-节-语法/8.-字符串.html</link><guid isPermaLink="false">第 1 节 - 语法/8. 字符串.md</guid><pubDate>Thu, 25 Dec 2025 10:40:48 GMT</pubDate></item><item><title><![CDATA[9. 模块]]></title><description><![CDATA[当一个 Lua 文件被另一个 Lua 文件加载，并且返回一个表或其他值时这个 Lua 文件被称为模块（Module）模块主要用于：
分类，将相关函数与变量组织在一个模块，避免将所有代码写到同一个文件内
便于模块化代码复用
独立命名空间，避免命名冲突
在编写大型程序时，将所有代码放在一个文件中会变得难以管理。模块系统可以帮助我们管理：-- 不使用模块的问题示例
-- 假设我们在开发一个游戏，所有代码都在一个文件里： -- main.lua（糟糕的代码组织）
-- 游戏配置
local game_config = { width = 800, height = 600 } -- 玩家相关函数
local player_name = "英雄"
local player_health = 100 local function take_damage(amount) player_health = player_health - amount if player_health &lt; 0 then player_health = 0 end
end local function heal(amount) player_health = player_health + amount
end -- 怪物相关函数
local monsters = {} local function create_monster(name, health) table.insert(monsters, {name = name, health = health})
end local function attack_monster(index, damage) if monsters[index] then monsters[index].health = monsters[index].health - damage end
end -- UI相关函数
local function show_hud() print("生命值: " .. player_health)
end -- 游戏循环
local function game_loop() -- 很多代码...
end -- 问题：
-- 1. 所有代码混在一起，难以维护
-- 2. 命名冲突风险高
-- 3. 无法重用代码
-- 4. 多人协作困难
-- 创建一个 Lua 文件：math_utils.lua
-- 数学工具模块 local math_utils = {} -- 模块表，最后返回 -- 1. 定义模块函数
function math_utils.add(a, b) return a + b
end function math_utils.subtract(a, b) return a - b
end function math_utils.multiply(a, b) return a * b
end function math_utils.divide(a, b) if b == 0 then return nil, "除数不能为0" end return a / b
end -- 2. 模块常量
math_utils.PI = 3.1415926535898
math_utils.E = 2.7182818284590 -- 3. 内部辅助函数（不对外暴露）
local function check_number(value) return type(value) == "number"
end -- 4. 复杂的模块函数
function math_utils.average(...) local numbers = {...} local sum = 0 local count = 0 for i, num in ipairs(numbers) do if check_number(num) then sum = sum + num count = count + 1 end end if count == 0 then return nil, "没有有效数字" end return sum / count
end -- 5. 返回模块，一个模块可以也理解为一个函数，注意：一定要最后返回，与函数相同返回后后面的代码不会执行
return math_utils
-- 创建一个 Lua 文件在里面中使用刚刚创建的模块 -- 使用 require 加载模块
local math_utils = require("math_utils") -- 使用模块函数
print("5 + 3 = " .. math_utils.add(5, 3))
print("10 - 4 = " .. math_utils.subtract(10, 4))
print("6 × 7 = " .. math_utils.multiply(6, 7)) local result, err = math_utils.divide(10, 2) if err then print("错误: " .. err)
else print("10 ÷ 2 = " .. result)
end -- 使用模块常量
print("π ≈ " .. math_utils.PI)
print("自然常数 e ≈ " .. math_utils.E) -- 使用复杂函数
local avg, avg_err = math_utils.average(10, 20, 30, "无效", 40) if avg_err then print("平均值错误: " .. avg_err)
else print("平均值: " .. avg) -- (10+20+30+40)/4 = 25
end
--[[ 输出
5 + 3 = 8
10 - 4 = 6
6 × 7 = 42
10 ÷ 2 = 5
π ≈ 3.1415926535898
自然常数 e ≈ 2.718281828459
平均值: 25
--]] -- 尝试访问内部函数（会失败）
-- local result = math_utils.check_number(5) -- 错误：nil值
require(模块名: str) -&gt; any
require&nbsp;会执行以下步骤：
在 package.loaded 中检查模块是否已加载
如果已加载，直接返回缓存
否则在&nbsp;package.path 指定的路径按从左到右的顺序查找指定名字的模块
加载并执行该文件，并返回返回值
以 package.loaded[模块名] = 返回值 缓存
-- package.path 具有默认值，通常在 main 模块中增加额外路径
-- 查看package.path
print("Lua模块路径: " .. package.path)
-- 输出 Lua模块路径: ;.\?.lua;C:\Program Files (x86)\Lua\5.1\lua\?.lua;C:\Program Files (x86)\Lua\5.1\lua\?\init.lua;C:\Program Files (x86)\Lua\5.1\?.lua;C:\Program Files (x86)\Lua\5.1\?\init.lua;C:\Program Files (x86)\Lua\5.1\lua\?.luac
-- “?” 加载模块时会格式化为加载的模块名称，用 “;” 分隔每个路径，“.” 会格式化为加载模块的 Lua 文件的目录 -- require的缓存机制演示
local module1 = require("math_utils")
local module2 = require("math_utils") print("两个require返回的是同一个表吗？ " .. tostring(module1 == module2)) -- true -- 手动清除缓存
package.loaded.math_utils = nil
local module3 = require("math_utils")	-- 重新加载，此时会创建一个新表 print("清除缓存后重新加载，是同一个表吗？ " .. tostring(module1 == module3)) -- false
-- 模块可以有多种返回方式 -- 方式1：直接返回表（最常见）
-- module1.lua
local M = {}
M.version = "1.0" return M -- 方式2：返回函数
-- module2.lua
return function(config) local module = {} module.config = config module.run = function() print("运行中...") end return module
end -- 使用：
-- local create_module = require("module2")
-- local my_module = create_module({setting = "value"}) -- 方式3：在模块中设置全局变量（不推荐，但某些情况需要）
-- module3.lua
GLOBAL_MODULE = {}
GLOBAL_MODULE.name = "全局模块"
return GLOBAL_MODULE -- 方式4：修改传入的表
-- module4.lua
return function(t) t.add = function(a, b) return a + b end t.version = "1.0" return t -- 通常返回修改后的表
end -- 使用：
-- local mod = require("module4")({})
Lua 中所有全局变量，与 Lua 的内置函数都存储在一个名叫 _G 的全局表（Global Table）中
所有模块的默认环境&nbsp;（Environment）都是指向 _G 表。可以通过 setfenv 修改指针将环境指向另一个表。-- 使用setfenv控制模块环境（Lua 5.1特性） -- 创建一个干净的模块环境
local module_env = {} -- 设置环境的基本函数
module_env.print = print -- 创建待编译模块
local my_module_code = [[
-- 在这个环境中，只有环境设定的函数可用
local M = {} function M.say_hello() print("Hello World!")	-- 这里如果没有给环境设定 print 将会报错
end return M
]] -- 加载并执行代码
-- 使用 loadstring 将以上字符串编译为可调用的函数
local chunk = loadstring(my_module_code)
-- 使用 setfenv 设定环境，将这个模块内的环境从 _G 修改为 module_env
setfenv(chunk, module_env) -- 执行被编译后的模块
local module = chunk() module.say_hello()
-- 模块可以依赖其他模块 -- 创建一个日志模块
-- logger.lua
local logger = {} function logger.info(msg) print("[INFO] " .. msg)
end function logger.warn(msg) print("[WARN] " .. msg)
end function logger.error(msg) print("[ERROR] " .. msg)
end return logger -- 创建一个数据库模块，依赖日志模块
-- database.lua
local logger = require("logger") local database = {} function database.connect(connection_string) logger.info("连接到数据库: " .. connection_string) -- 模拟连接逻辑 return {connected = true}
end function database.query(conn, sql) logger.info("执行查询: " .. sql) -- 模拟查询 return {{id = 1, name = "测试数据"}}
end function database.disconnect(conn) logger.info("断开数据库连接") conn.connected = false
end return database -- 主程序使用有依赖的模块
local db = require("database") local conn = db.connect("server=localhost;database=test")
local results = db.query(conn, "SELECT * FROM users")
db.disconnect(conn) -- 环形依赖问题
-- module_a.lua 需要 module_b
-- module_b.lua 需要 module_a
-- 这会导致问题！应该避免环形依赖
Lua 自带了一些非常有用的标准库模块。-- 基本数学函数
print("绝对值: math.abs(-10) = " .. math.abs(-10))
print("平方根: math.sqrt(16) = " .. math.sqrt(16))
print("幂运算: math.pow(2, 3) = " .. math.pow(2, 3)) -- 也可以用 2^3
print("指数: math.exp(1) = " .. math.exp(1)) -- e^1
print("自然对数: math.log(math.exp(1)) = " .. math.log(math.exp(1))) -- 三角函数（参数为弧度）
local angle = math.pi / 4 -- 45度
print("\n三角函数（45度）:")
print(" sin: " .. math.sin(angle))
print(" cos: " .. math.cos(angle))
print(" tan: " .. math.tan(angle)) -- 反三角函数
print("\n反三角函数:")
print(" asin(0.5): " .. math.asin(0.5))
print(" acos(0.5): " .. math.acos(0.5))
print(" atan(1): " .. math.atan(1)) -- 取整函数
local num = 3.7
print("\n取整函数:")
print(" 原始值: " .. num)
print(" math.floor: " .. math.floor(num)) -- 向下取整
print(" math.ceil: " .. math.ceil(num)) -- 向上取整
print(" math.modf: " .. select(1, math.modf(num))) -- 返回整数和小数部分 -- 随机数
print("\n随机数:")
math.randomseed(os.time()) -- 设置随机种子
print(" 随机整数(1-100): " .. math.random(1, 100))
print(" 随机小数[0-1): " .. math.random()) -- 最大值和最小值
print("\n极值:")
print(" 最大值: " .. math.max(10, 20, 5, 30, 15))
print(" 最小值: " .. math.min(10, 20, 5, 30, 15)) -- 常量
print("\n数学常量:")
print(" π: " .. math.pi)
print(" 无穷大: " .. math.huge) -- 弧度与角度转换
print("\n角度弧度转换:")
local degrees = 180
local radians = math.rad(degrees)
print(" " .. degrees .. "度 = " .. radians .. "弧度")
print(" " .. radians .. "弧度 = " .. math.deg(radians) .. "度")
我们之前学过的字符串操作函数其实都是使用的这个库，这里仅补充。-- string.byte 和 string.char
local str = "ABC"
print("string.byte:")
for i = 1, #str do print(" 位置 " .. i .. ": " .. string.byte(str, i))
end print("\nstring.char:")
print(" 65,66,67 -&gt; " .. string.char(65, 66, 67)) -- string.reverse 反转字符串
print("\nstring.reverse:")
print(" 'hello' -&gt; '" .. string.reverse("hello") .. "'") -- string.lower 和 string.upper
print("\n大小写转换:")
print(" 'Hello World' -&gt; 小写: '" .. string.lower("Hello World") .. "'")
print(" 'Hello World' -&gt; 大写: '" .. string.upper("Hello World") .. "'") -- string.dump 函数序列化
print("\nstring.dump（函数序列化）:")
local func = function(x) return x * 2 end
local dumped = string.dump(func)
print(" 函数序列化后长度: " .. #dumped) -- 重新加载函数
local loaded_func = loadstring(dumped)
print(" 重新加载后执行: loaded_func(5) = " .. loaded_func(5))
-- 我们已经学过table.insert, table.remove, table.concat, table.sort
-- 这里补充其他函数 -- table.maxn (Lua 5.1特有，返回最大数字索引)
local t = {1, 2, 3}
t[10] = 10
print("table.maxn: " .. table.maxn(t)) -- 10 -- 自带的库功能较少一些函数需要自行实现
-- table.copy 浅复制
function table.shallow_copy(original) local copy = {} for k, v in pairs(original) do copy[k] = v end return copy
end -- table.deep_copy 深复制
function table.deep_copy(original, seen) seen = seen or {} if type(original) ~= "table" then return original end if seen[original] then return seen[original] end local copy = {} seen[original] = copy for k, v in pairs(original) do copy[table.deep_copy(k, seen)] = table.deep_copy(v, seen) end return copy
end -- table.merge 合并表
function table.merge(t1, t2) local result = {} for k, v in pairs(t1) do result[k] = v end for k, v in pairs(t2) do result[k] = v end return result
end -- table.keys 获取所有键
function table.keys(t) local keys = {} for k in pairs(t) do table.insert(keys, k) end return keys
end -- table.values 获取所有值
function table.values(t) local values = {} for _, v in pairs(t) do table.insert(values, v) end return values
end
-- os.time 获取当前时间
local current_time = os.time()
print("当前时间戳: " .. current_time) -- os.date 格式化时间
print("\nos.date格式化:")
print(" 默认格式: " .. os.date())
print(" 自定义格式: " .. os.date("%Y-%m-%d %H:%M:%S"))
print(" 只获取年份: " .. os.date("%Y"))
print(" 星期几: " .. os.date("%A"))
print(" 月份: " .. os.date("%B")) -- 时间戳转换
print("\n时间戳转换:")
local timestamp = os.time({year=2024, month=12, day=27, hour=14, min=30, sec=0})
print(" 2024-12-27 14:30:00 的时间戳: " .. timestamp)
print(" 转换回来: " .. os.date("%Y-%m-%d %H:%M:%S", timestamp)) -- os.difftime 时间差
local start_time = os.time()
-- 模拟耗时操作
for i = 1, 1000000 do end
local end_time = os.time()
print("\n时间差: " .. os.difftime(end_time, start_time) .. "秒") -- os.execute 执行系统命令
print("\nos.execute执行命令:")
-- 注意：在某些环境中，这个可能被禁用
local result = os.execute("echo Hello from OS")
print(" 返回值: " .. tostring(result)) -- os.getenv 获取环境变量
print("\nos.getenv环境变量:")
local path = os.getenv("PATH")
print(" PATH长度: " .. (path and #path or "无"))
print(" HOME: " .. (os.getenv("HOME") or "无")) -- os.remove 删除文件
print("\nos.remove删除文件:")
-- 先创建测试文件
local test_file = "test_temp.txt"
local file = io.open(test_file, "w")
if file then file:write("测试内容") file:close() print(" 创建测试文件: " .. test_file) local success, err = os.remove(test_file) if success then print(" 删除成功") else print(" 删除失败: " .. tostring(err)) end
end -- os.rename 重命名文件
print("\nos.rename重命名文件:")
-- 类似操作，这里省略 -- os.tmpname 生成临时文件名
local temp_name = os.tmpname()
print("临时文件名: " .. temp_name)
-- 文件操作
print("文件操作示例:") -- 写入文件
local filename = "test_output.txt"
local file = io.open(filename, "w") if file then file:write("第一行\n") file:write(string.format("第二行: 数字 %d\n", 42)) file:write("第三行\n") file:close() print(" 写入文件: " .. filename)
else print(" 无法打开文件: " .. filename)
end -- 读取文件
print("\n读取文件:")
file = io.open(filename, "r") if file then print(" 整个文件内容:") local content = file:read("*all") print(content) file:close()
else print(" 无法打开文件")
end -- 逐行读取
print("\n逐行读取:")
file = io.open(filename, "r") if file then local line_number = 1 for line in file:lines() do print(" 行" .. line_number .. ": " .. line) line_number = line_number + 1 end file:close()
end -- 标准输入输出
print("\n标准输入输出:")
-- io.write 不会自动添加换行
io.write("请输入你的名字: ")
-- 在实际环境中，这里可以读取用户输入
-- local name = io.read()
local name = "测试用户" -- 模拟输入
print("你好, " .. name .. "!") -- 文件位置操作
print("\n文件位置操作:")
file = io.open(filename, "r")
if file then -- 读取前10个字符 local first_10 = file:read(10) print(" 前10字符: " .. first_10) -- 获取当前位置 local pos = file:seek() print(" 当前位置: " .. pos) -- 跳转到文件开始 file:seek("set", 0) -- 再次读取 local again = file:read(10) print(" 跳转后读取: " .. again) file:close()
end -- 清理测试文件
os.remove(filename)
print("\n清理测试文件")
-- debug库主要用于调试和元编程
-- 注意：在生产代码中应谨慎使用 -- debug.getinfo 获取函数信息
local function test_function(x, y) local sum = x + y return sum
end local info = debug.getinfo(test_function)
print("函数信息:")
print(" 名称: " .. (info.name or "匿名"))
print(" 定义位置: " .. info.source)
print(" 当前行: " .. info.currentline)
print(" 参数数量: " .. info.nparams)
print(" 是否可变参数: " .. tostring(info.isvararg)) -- debug.getlocal 获取局部变量
local function test_locals() local a = 10 local b = "hello" local c = {1, 2, 3} -- 获取局部变量信息 print("\n局部变量:") for i = 1, math.huge do local name, value = debug.getlocal(2, i) -- 2表示上一层调用栈 if not name then break end print(" " .. name .. " = " .. tostring(value)) end
end test_locals() -- debug.traceback 获取调用栈
local function function_a() function_b()
end local function function_b() function_c()
end local function function_c() print("\n调用栈追踪:") print(debug.traceback("错误发生位置", 2))
end function_a() -- debug.sethook 设置钩子（用于调试）
print("\n调试钩子示例:")
local hook_calls = 0 -- 设置一个简单的钩子，统计函数调用次数
debug.sethook(function(event, line) if event == "call" then hook_calls = hook_calls + 1 end
end, "c") -- 'c' 表示在函数调用时触发 -- 执行一些函数调用
local function recursive_func(n) if n &gt; 0 then recursive_func(n - 1) end
end recursive_func(5)
print(" 函数调用次数: " .. hook_calls) -- 清除钩子
debug.sethook()
print(" 钩子已清除") -- debug.upvalue 访问闭包的上值
print("\n闭包上值访问:")
local function create_counter() local count = 0 return function() count = count + 1 return count end
end local counter = create_counter()
counter() -- count = 1
counter() -- count = 2 -- 获取上值
local name, value = debug.getupvalue(counter, 1)
print(" 上值 '" .. name .. "' = " .. value) -- 修改上值
debug.setupvalue(counter, 1, 100)
print(" 修改后: " .. counter()) -- 101
LuaRocks 是 Lua 的包管理器，类似于Python的pip
LuaRocks 官网：
<a data-tooltip-position="top" aria-label="https://luarocks.org/" rel="noopener nofollow" class="external-link is-unresolved" href="https://luarocks.org/" target="_self">LuaRocks - The Lua package manager</a>
luarocks install 库名
<br><img alt="Pasted image 20251210202636.png" src="site-lib/media/pasted-image-20251210202636.png" target="_self" style="width: 675px; max-width: 100%;">
以上命令会将 Lua 库安装到 C:/Users/用户名/AppData/Local/VirtualStore/Program Files (x86)/Lua/5.1/lua
由于服务器位于国外，下载较慢耐心等待即可-- 以 dkjson 库为例
-- 需要确保安装此库： luarocks install dkjson
local dkjson = require("dkjson") -- 将 lua 表编译为 json
print(dkjson.encode({foo = "bar", baz = 123}))
-- 输出 {"baz":123,"foo":"bar"}
单例模式：确保一个类只有一个实例-- 配置管理器（单例）
local config_manager = {}
config_manager.__index = config_manager function config_manager.get_instance() if not config_manager.instance then local instance = setmetatable({}, config_manager) instance.settings = {} config_manager.instance = instance end return config_manager.instance
end function config_manager:set(key, value) self.settings[key] = value
end function config_manager:get(key) return self.settings[key]
end -- 测试单例
local config1 = config_manager.get_instance()
config1:set("volume", 80) local config2 = config_manager.get_instance()
print("config1 音量: " .. config1:get("volume"))
print("config2 音量: " .. config2:get("volume"))
print("是同一个实例吗？ " .. tostring(config1 == config2))
--[[ 输出
config1 音量: 80
config2 音量: 80
是同一个实例吗？ true
--]] -- 尝试直接创建新实例（会失败）
-- local config3 = config_manager:new() -- 错误：没有new方法
工厂模式：通过工厂函数创建对象-- 形状工厂
local shape_factory = {} function shape_factory.create_circle(radius) local circle = { type = "circle", radius = radius, area = function(self) return math.pi * self.radius * self.radius end, draw = function(self) print("绘制圆形，半径: " .. self.radius) end } return circle
end function shape_factory.create_rectangle(width, height) local rectangle = { type = "rectangle", width = width, height = height, area = function(self) return self.width * self.height end, draw = function(self) print("绘制矩形，宽: " .. self.width .. ", 高: " .. self.height) end } return rectangle
end function shape_factory.create_square(side) -- 复用createRectangle return shape_factory.create_rectangle(side, side)
end -- 使用工厂
local shapes = { shape_factory.create_circle(5), shape_factory.create_rectangle(4, 6), shape_factory.create_square(3)
} for i, shape in ipairs(shapes) do print("形状" .. i .. " (" .. shape.type .. "):") print(" 面积: " .. shape:area()) shape:draw()
end
--[[ 输出
形状1 (circle): 面积: 78.539816339745
绘制圆形，半径: 5
形状2 (rectangle): 面积: 24
绘制矩形，宽: 4, 高: 6
形状3 (rectangle): 面积: 9
绘制矩形，宽: 3, 高: 3
--]]
观察者模式：对象间的一对多依赖关系-- 事件管理器
local event_manager = {}
event_manager.__index = event_manager function event_manager.new() local instance = setmetatable({}, event_manager) instance.listeners = {} return instance
end function event_manager:subscribe(event, callback) if not self.listeners[event] then self.listeners[event] = {} end table.insert(self.listeners[event], callback)
end function event_manager:unsubscribe(event, callback) if self.listeners[event] then for i, cb in ipairs(self.listeners[event]) do if cb == callback then table.remove(self.listeners[event], i) break end end end
end function event_manager:publish(event, ...) if self.listeners[event] then for _, callback in ipairs(self.listeners[event]) do callback(...) end end
end -- 使用观察者模式
local events = event_manager.new() -- 定义观察者
local function player_joined(player_name) print("系统: 玩家 " .. player_name .. " 加入了游戏")
end local function player_left(player_name) print("系统: 玩家 " .. player_name .. " 离开了游戏")
end local function achievement_unlocked(player_name, achievement) print("成就: " .. player_name .. " 解锁了 '" .. achievement .. "'")
end -- 订阅事件
events:subscribe("player_join", player_joined)
events:subscribe("player_leave", player_left)
events:subscribe("achievement", achievement_unlocked) -- 发布事件
events:publish("player_join", "小明")
events:publish("player_join", "小红")
events:publish("achievement", "小明", "首次登录")
events:publish("player_leave", "小红") -- 取消订阅
events:unsubscribe("player_leave", player_left)
events:publish("player_leave", "小明") -- 这个不会触发回调
--[[ 输出
系统: 玩家 小明 加入了游戏
系统: 玩家 小红 加入了游戏
成就: 小明 解锁了 '首次登录'
系统: 玩家 小红 离开了游戏
--]]
模块配置模式：灵活的模块配置-- 灵活的日志模块
local logger = {} function logger.new(config) config = config or {} local instance = { level = config.level or "INFO", output = config.output or function(msg) print(msg) end, format = config.format or "[%LEVEL%] %MESSAGE%" } function instance:log(level, message) -- 检查日志级别 local levels = {DEBUG = 1, INFO = 2, WARN = 3, ERROR = 4} if levels[level] &lt; levels[self.level] then return end -- 格式化消息 local formatted = self.format formatted = string.gsub(formatted, "%%LEVEL%%", level) formatted = string.gsub(formatted, "%%MESSAGE%%", message) -- 输出 self.output(formatted) end function instance:debug(msg) self:log("DEBUG", msg) end function instance:info(msg) self:log("INFO", msg) end function instance:warn(msg) self:log("WARN", msg) end function instance:error(msg) self:log("ERROR", msg) end return instance
end -- 使用不同配置
print("控制台日志:")
local console_logger = logger.new()
console_logger:info("系统启动")
console_logger:debug("详细调试信息") -- 默认级别为INFO，DEBUG不会输出 print("\n文件日志:")
local file_logger = logger.new{ level = "DEBUG", output = function(msg) -- 模拟写入文件 print("[文件] " .. msg) end, format = "%LEVEL% - %MESSAGE%"
}
file_logger:debug("详细调试信息") -- 这次会输出
file_logger:error("发生错误") print("\n自定义格式:")
local fancy_logger = logger.new{ format = "✨ %LEVEL% ✨ =&gt; %MESSAGE%"
}
fancy_logger:info("系统运行正常")
--[[ 输出
控制台日志:
[INFO] 系统启动 文件日志:
[文件] DEBUG - 详细调试信息
[文件] ERROR - 发生错误 自定义格式:
✨ INFO ✨ =&gt; 系统运行正常
--]]
<br>（答案见<a data-href="第 1 节 - 语法/参考答案#练习 9 1：创建一个日志模块" href="第-1-节-语法/参考答案.html#练习 9 1：创建一个日志模块" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 9 1：创建一个日志模块</a>）-- 创建一个调试用的日志模块，增加多个打印模式，错误、信息等，同时可以自动格式化 -- 示例：
local log = require("log"):new("module_name") log.error("无法加载模块 %s", "log")
-- 输出 [ERROR] module_name: 无法加载模块 log log.info("加载模块中...")
-- 输出 [INFO] module_name: 加载模块中... 模块基础： 使用 local M = {} 创建模块表
通过 return M 导出模块
使用 require 加载模块 模块机制： package.path 定义模块搜索路径
package.loaded 缓存已加载模块 标准库模块： math：数学运算
string：字符串处理
table：表操作
os：操作系统接口
io：输入输出
debug：调试工具 LuaRocks 包管理器： 在终端使用 luarocks install 安装包
安装到 C:/Users/用户名/AppData/Local/VirtualStore/Program Files (x86)/Lua/5.1/lua 模块设计模式： 单例模式
工厂模式
观察者模式
模块配置模式 -- 1. 清晰的模块结构
-- module/
-- ├── init.lua -- 模块入口
-- ├── core.lua -- 核心功能
-- ├── utils.lua -- 工具函数
-- └── constants.lua -- 常量定义 -- 2. 良好的命名规范
local MyModule = {} -- 模块表
local private_var -- 局部变量（私有）
MyModule.PUBLIC_CONSTANT = 100 -- 公共常量 -- 3. 错误处理
function MyModule.safe_operation() local success, result = pcall(function() -- 可能失败的操作 return risky_operation() end) if not success then return nil, result -- 返回错误信息 end return result
end -- 4. 文档化
--- 计算两个数的和
-- @param a 第一个数
-- @param b 第二个数
-- @return 两数之和
function MyModule.add(a, b) return a + b
end -- 5. 版本控制
MyModule.VERSION = "1.0.0"
MyModule.AUTHOR = "Your Name"
-- 错误 1：忘记 return 模块
local M = {}
-- 做一些设置...
-- 忘记写: return M -- 错误 2：污染全局命名空间
-- 在模块中直接创建全局变量
GLOBAL_VAR = 100 -- 不好！ -- 错误 3：循环依赖
-- module_a.lua 需要 module_b
-- module_b.lua 需要 module_a
-- 解决方案：重构代码，提取公共部分 -- 错误 4：过度使用 require
-- 在循环中反复 require 同一个模块
for i = 1, 100 do local mod = require("some_module") -- 每次都会检查缓存，但仍然有开销
end -- 错误 5：模块路径问题
-- 不设置正确的 package.path
-- 解决方案：在程序开始时设置
package.path = package.path .. ";./lib/?.lua"
-- 1. 延迟加载（Lazy Loading）
local LazyModule = {}
local _loaded_module = nil function LazyModule.do_something() if not _loaded_module then _loaded_module = require("heavy_module") end return _loaded_module:do_work()
end -- 2. 模块缓存
local cached_modules = {} function get_module(name) if not cached_modules[name] then cached_modules[name] = require(name) end return cached_modules[name]
end -- 3. 避免在模块初始化时做太多工作
-- 不好：模块加载时连接数据库
local db = connect_to_database() -- 模块加载变慢 -- 好：需要时再连接
local function get_db() if not _db then _db = connect_to_database() end return _db
end
（点击勾选框勾选）
完成本章后，你应该能够：
创建和使用 Lua 模块
理解模块加载机制
使用 Lua 标准库模块
使用 LuaRocks 管理第三方包
设计良好的模块结构
实现常见的模块设计模式
处理模块依赖和循环引用
创建可配置的模块系统 Lua 模块系统和面向对象语言（如 Java、Python）的包系统有什么异同？
什么时候应该将代码拆分为多个模块？模块划分的原则是什么？
如何处理模块间的循环依赖问题？
Lua 的require机制如何避免重复加载同一模块？
在设计一个库时，如何平衡灵活性和易用性？ 实现一个国际化的模块，支持多语言文本
创建一个数据验证模块，支持各种数据格式验证
实现一个事件总线系统，支持跨模块通信
下一章预告：在第 10 章中，我们将学习调试与错误处理。编写健壮的程序需要妥善调试并处理错误和异常，我们将学习 Lua 的调试技巧与错误处理机制，包括断点、 pcall、xpcall、error、assert 等，以及如何创建自定义错误类型和错误处理策略。学习建议：
多实践模块的创建和使用，理解模块化编程的好处
熟悉标准库模块，它们能解决很多常见问题
学习使用 LuaRocks 管理依赖
尝试重构现有代码，将其模块化
注意模块设计的边界和接口设计
]]></description><link>第-1-节-语法/9.-模块.html</link><guid isPermaLink="false">第 1 节 - 语法/9. 模块.md</guid><pubDate>Thu, 25 Dec 2025 08:06:56 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[11. 工具使用方法]]></title><description><![CDATA[
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://wwuk.lanzouo.com/b007u3i2jg" target="_self">https://wwuk.lanzouo.com/b007u3i2jg</a>
密码:fv51
]]></description><link>第-2-节-修改基础/11.-工具使用方法.html</link><guid isPermaLink="false">第 2 节 - 修改基础/11. 工具使用方法.md</guid><pubDate>Thu, 25 Dec 2025 07:22:33 GMT</pubDate></item><item><title><![CDATA[0. 配置环境]]></title><description><![CDATA[
<a data-tooltip-position="top" aria-label="https://code.visualstudio.com/" rel="noopener nofollow" class="external-link is-unresolved" href="https://code.visualstudio.com/" target="_self">下载链接</a>
<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://wwuk.lanzouo.com/b007u3i2jg" target="_self">https://wwuk.lanzouo.com/b007u3i2jg</a>
密码:fv51
可以放到其他地方，但要保证没有中文路径，也可以重命名，请改一个便于找到的位置与名字<br>
<img alt="Pasted image 20250706200745.png" src="site-lib/media/pasted-image-20250706200745.png" target="_self" style="width: 395px; max-width: 100%;">
此文件夹包含配置文件、Love 2d 引擎，以及用于推荐插件与使用预先修改的设置<br><img alt="Pasted image 20250710092722.png" src="site-lib/media/pasted-image-20250710092722.png" target="_self" style="width: 525px; max-width: 100%;">
包含 Lua 代码补全、诊断、格式化、用于调试的扩展
所有插件均配置完毕，无需自行配置
<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://wwuk.lanzouo.com/b007u3i2jg" target="_self">https://wwuk.lanzouo.com/b007u3i2jg</a>
密码:fv51
<br><img alt="Pasted image 20251206202705.png" src="site-lib/media/pasted-image-20251206202705.png" target="_self" style="width: 425px; max-width: 100%;">注：不是直接解压，而是解压到当前位置后续 exe 本体可自行删除
使用 VSCode 打开文件夹
双击工作区文件夹的 VScode_KR_workspace 文件即可<br>
<img alt="Pasted image 20250716131909.png" src="site-lib/media/pasted-image-20250716131909.png" target="_self" style="width: 325px; max-width: 100%;"> 设置与配置均已在 .vscode 内设置完毕，为了性能部分游戏资源文件已被排除（图像等）
<br><img alt="Pasted image 20251115141653.png" src="site-lib/media/pasted-image-20251115141653.png" target="_self" style="width: 425px; max-width: 100%;">]]></description><link>第-1-节-语法/0.-配置环境.html</link><guid isPermaLink="false">第 1 节 - 语法/0. 配置环境.md</guid><pubDate>Thu, 25 Dec 2025 07:22:03 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. 实体函数]]></title><description><![CDATA[tt.main_script.insert = 函数: func
tt.main_script.update = 函数: func
tt.hero.fn_level_up = 函数: func
-- 这些都是实体函数 存储位置：实体函数通常存储在 kr/game_scripts 与 all/scripts 中
作用：实体函数通常用于 main_script 系统，为实体增加逻辑
每次创建实体都会调用一次的函数，称为插入函数（insert script）首先在模板找到函数，并在 kr/game_scripts 搜索-- 艾莉丹插入函数
function scripts.hero_elves_archer.insert(this, store) -- this 表示调用插入函数的实体 ... local d = E:create_entity("damage")	-- 造成伤害 d.value = 233666 -- 伤害 d.target_id = this.id -- 目标 id 设置为当前英雄 id queue_damage(store, d) -- 插入伤害队列
end
使用修改的英雄进入关卡，英雄掉血，成功造成效果同上，不过要插入实体队列（queue_insert）local mod = E:create_entity(效果模板名: str)	-- 造成效果
mod.modifier.target_id = this.id -- 目标
queue_insert(store, mod) -- 插入实体队列
-- 沙王插入函数，给沙王增加死亡骑士光环
function scripts.hero_alric.insert(this, store, script) ... if this.hero.skills.toughness.level &gt; 0 then -- 若坚韧技能等级大于 0，可选 local e = E:create_entity("death_rider_aura")	-- 创建死亡骑士光环 e.aura.source_id = this.id -- 来源设置为沙王 queue_insert(store, e) -- 将 e 插入实体队列 end
end -- 进入游戏后发现光环显示位置错误，在模板移除偏移即可（与修改效果同理）
-- 创建新模板，续承死亡骑士光环
tt = RT("death_rider_aura_alric", "death_rider_aura")
tt.aura.use_mod_offset = nil	-- 移除偏移 -- 插入函数创建新的光环即可：E:create_entity("death_rider_aura_alric")
E:create_entity(实体模板名: str) -&gt; 实体引用: table 创建实体后需要插入实体队列才会正式创建实体
store 位于 game 表中，用于存储临时数据，如实体、玩家拥有的金币、生命、游戏时间、实体与伤害队列等所有创建的实体都会存储在 store.entities 表中，每个实体都有独立 ID，ID 只增不减。每次实体升级时调用的函数，称为升级函数（level up script）-- 模板内
-- 艾莉丹的双刀跳斩
tt.hero.skills.double_strike = CC("hero_skill")
tt.hero.skills.double_strike.cooldown = {	-- 冷却时间随等级变化（原版 12 秒） 12,	-- 一级 12 秒 10,	-- 二级 10 秒 8	-- 三级 8 秒
} -- 艾莉丹升级函数
function scripts.hero_elves_archer.level_up(this, store, initial)
... s = this.hero.skills.double_strike if initial and s.level &gt; θ then local a = this.melee.attacks[2] -- 近战攻击 2 为双刀跳斩 a.disabled = nil a.damage_min = s.damage_min[s.level] a.damage_max = s.damage_max[s.level] a.cooldown = s.cooldown[s.level]	-- 增加代码 end
...
随着游戏逻辑时间更新而调用的函数，称为更新函数（update script）找到技能造成伤害的部分，在后面加上造成效果的逻辑即可以给火男烈焰冲击增加燃烧效果为例-- 火男模板
tt = RT("hero_ignus", "hero")
tt.timed_attacks.list[1].mod = "mod_lava_ignus"	-- 造成这个效果 local tt = E:register_t("mod_lava_ignus", "mod_lava")
tt.dps.damage_inc = 2	-- 翻倍燃烧伤害 -- 更新函数内
function scripts.hero_ignus.update(this, store) ... a = this.timed_attacks.list[1] skill = this.hero.skills.flaming_frenzy if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts &gt;= a.cooldown then	-- 计算冷却时间 ... targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)	-- 索敌 if targets then for _, t in pairs(targets) do -- 造成伤害 local d = E:create_entity("damage") d.damage_type = a.damage_type d.source_id = this.id d.target_id = t.id d.value = math.random(a.damage_min, a.damage_max) queue_damage(store, d) -- 造成效果 local mod = E:create_entity(a.mod) mod.modifier.target_id = t.id mod.modifier.source_id = this.id queue_insert(store, mod) end ... end ... ...
end
计算时间常用到 store.tick_ts （游戏时间）与 ts（时间戳）a = this.timed_attacks.list[1]	-- 某个技能 if store.tick_ts - a.ts &gt; a.cooldown then a.ts = store.tick_ts	-- 刷新 a 的时间戳 ...
end
表示如果当前时间与上次释放技能 a 的时间戳之差大于冷却时间，执行条件代码块
换句话说就是上次释放技能过去的时间大于冷却时间通常所有函数的调用源头都是 Love 2D 引擎的 love.update 回调函数。按照以下调用链通过模拟器（simulation）协调系统，通过系统（sys.main_script）来调用实体的更新函数与插入函数
<img alt="Pasted image 20251215185551.png" src="site-lib/media/pasted-image-20251215185551.png" target="_self" style="width: 1200px; max-width: 100%;">游戏内置了一套完整的日志系统，用于开发调试和问题排查。日志系统采用分级机制，便于控制不同开发阶段的输出信息量。log:new(打印的日志前缀: str, 日志等级?: int) -&gt; 日志实例: table 推荐在 args 修改全局日志等级
log.debug("load atlas: %s,%s-%.6f", path, name, ref_scale) --[[ 输出
[22841.0227] image_db.DEBUG preload_atlas() - load atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000
--]] [22841.0227] 为时间信息
image_db 为前缀
DEBUG 为等级，调试五级
preload_atlas 调用的函数
load atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000 信息
-- 打印最详细的调试信息
log.paranoid("实体 %d 当前状态: pos=(%.1f, %.1f), hp=%d/%d", this.id, this.pos.x, this.pos.y, this.health.hp, this.health.hp_max) 用途：深度跟踪复杂逻辑的执行流程
特点：信息量极大，仅在调试特定问题时开启
示例场景： 追踪 AI 决策过程
监控每帧的状态变化
调试复杂的协程逻辑 -- 打印开发调试信息
log.debug("技能 %s 触发，目标=%d，伤害=%d", skill_name, target.id, damage_value) 用途：开发阶段的主要调试工具
特点：包含详细的过程信息，但比偏执级简洁
示例场景： 技能释放和冷却
伤害计算过程
实体创建和销毁 -- 标记需要完成的功能
log.todo("TODO: 为英雄 %s 实现连击系统", this.hero.name)
-- 或标记已知问题
log.todo("FIXME: 当敌人被冰冻时，伤害计算有误") 用途：标记开发中的待办事项和已知问题
特点：便于团队协作和任务跟踪
最佳实践： 描述清晰的问题或功能需求
包含解决建议（如果有）
定期清理已完成的待办事项 -- 打印正常的游戏流程信息
log.info("关卡 %d 开始，初始金币=%d，生命=%d", store.wave, store.gold, store.lives) 用途：记录正常的游戏运行信息
特点：适合玩家可见的进度信息
示例场景： 关卡开始/结束
英雄升级
重要游戏事件 -- 打印潜在问题警告
log.warning("实体 %d 的 hp=%d，但 hp_max=%d，血量数据异常", this.id, this.health.hp, this.health.hp_max) 用途：提示潜在问题或不规范情况
特点：程序能继续运行，但可能存在风险
示例场景： 数据范围异常
资源加载失败但有备用方案
预期外的游戏状态 -- 打印错误信息
log.error("无法找到实体 %d 的目标 %d，技能释放失败", this.id, target_id) 用途：报告程序错误和异常情况
特点：通常伴随功能失效
示例场景： 空指针访问
资源加载完全失败
关键逻辑无法执行 -- 使用格式化字符串提高可读性
local hit_count = #targets
local total_damage = 0
for _, dmg in pairs(damages) do total_damage = total_damage + dmg.value
end log.info("范围攻击命中 %d 个目标，总伤害 %d", hit_count, total_damage)
-- 只在特定条件下输出日志
if DEBUG_MODE then log.debug("详细状态: %s", inspect(this))
end -- 或者在开发阶段使用
if store.tick_ts &lt; 10 then -- 只在游戏前10秒输出 log.paranoid("初始状态跟踪: %s", this.id)
end
function scripts.new_hero.insert(this, store) log.todo("实现新英雄的插入函数") log.debug("新英雄创建，ID=%d，位置=(%.1f,%.1f)", this.id, this.pos.x, this.pos.y) -- 开发过程中的调试 log.paranoid("初始组件状态: %s", inspect(this)) -- 实现逻辑...
end function scripts.new_hero.update(this, store) log.todo("实现新英雄的更新函数") -- 跟踪特定问题 if this.some_problem then log.warning("检测到问题状态: %s", this.some_problem) end -- 实现逻辑...
end
function scripts.problem_skill.update(this, store) local skill = this.hero.skills.problem_skill -- 逐步添加日志定位问题 log.debug("技能检查: level=%d, cooldown=%f", skill.level, skill.cooldown) if store.tick_ts - skill.last_use &gt; skill.cooldown then log.paranoid("技能可用，开始索敌...") local target = U.find_foremost_enemy(store.entities, this.pos, 0, 100) if target then log.paranoid("找到目标: ID=%d, hp=%d", target.id, target.health.hp) -- 检查目标状态 if target.health.hp &lt;= 0 then log.warning("目标已死亡但仍被选中，ID=%d", target.id) return end -- 执行技能... else log.debug("未找到有效目标") end end
end
function scripts.heavy_function.update(this, store) local start_time = os.clock() -- 执行复杂计算... local end_time = os.clock() local duration = end_time - start_time if duration &gt; 0.016 then -- 超过一帧时间（30fps） log.warning("函数执行时间过长: %.3f秒，实体ID=%d", duration, this.id) log.paranoid("详细状态: %s", inspect(this)) elseif duration &gt; 0.001 then -- 超过1毫秒 log.debug("函数执行时间: %.3f秒", duration) end
end
几乎所有索敌本质都是在一定范围索敌，然后根据条件过滤目标。U.find_enemies_in_range( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func
) -&gt; 范围内所有敌人: list e 参数通常为 store.entities
为过滤函数传递：实体、原点
过滤函数用于筛选目标，返回假的目标将会被筛选
U.find_foremost_enemy( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 预判时间: num, 标签: int, 禁止标签: int, 过滤函数?: func, 禁用最小半径的标签: int
) -&gt; 首个敌人: table, 范围内所有敌人: list{敌人: table...}, 预判位置: vec2 禁用最小半径的标签：拥有此标签的目标不受搜索最小半径限制
<br>所有索敌见<a data-href="9. 工具函数#一、索敌" href="总结/9.-工具函数.html#一、索敌" class="internal-link" target="_self" rel="noopener nofollow">9. 工具函数 &gt; 一、索敌</a>local target = U.find_foremost_enemy(..., function(v, origin)	-- v 为实体，origin 为原点 ...	-- 函数体 return v.health.hp &gt;= 1000	-- 筛选掉血量小于 1000 的敌人
end, ...) local targets = U.find_enemies_in_range(store.entities, hero.pos, 0, a.radius, a.vis_flags, a.vis_bans) if targets then table.sort(targets, function(e1, e2) return e1.health.hp &gt; e2.health.hp	-- 根据血量排序，血量最高的排序在最前 end) local target = targets[1]	-- 取血量最高目标 ...
end
给近战攻击的 fn_can 指定条件函数即可。tt.melee.attacks[1].fn_can = 条件函数: func 为条件函数传递： store、攻击、目标
条件函数返回真表示可以攻击
以给鬼侍灭魂斩增加条件为例：-- 模板
tt.melee.attacks[2].trigger_min_hp = 150	-- 释放条件：目标血量大于等于 150
tt.melee.attacks[2].fn_can = scripts.hero_oni.update -- game_scripts
function scripts.hero_oni.update(this, store) ...
end -- 写在更新函数下面
function scripts.hero_oni.melee_fn_can_2(this, store, a, target) return target.health.hp &gt;= a.trigger_min_hp
end
给远程攻击的 filter_fn 指定条件函数即可。tt.ranged.attacks[1].filter_fn = 条件函数: func 为条件函数传递：目标、原点
条件函数返回真表示可以攻击
以小公主为例：tt.ranged.attacks[1].trigger_min_hp = 150 tt.ranged.attacks[1].filter_fn = scripts.hero_alleria.ranged_filter_fn_1 -- game_scripts
function scripts.hero_alleria.ranged_filter_fn_1(v, origin) return v.health.hp &gt; trigger_min_hp
end
给攻击的 fn_chance 指定条件函数即可。tt.melee.attacks[1].fn_chance = 条件函数: func 为条件函数传递：当前实体、store、攻击、目标
以使鬼侍灭魂斩 100% 秒杀处于流血效果的目标为例：-- 鬼侍近战攻击 2 是灭魂斩的秒杀，3 则是灭魂斩不秒杀的真伤
tt.melee.attacks[2].instakill_mod_type = MOD_TYPE_BLEED	-- 效果类型：流血类型
tt.melee.attacks[2].fn_chance = scripts.hero_oni.fn_chance_death_strike -- game_scripts
function scripts.hero_oni.fn_chance_death_strike(this, store, a, target) return U.has_modifier_types(store, target, a.instakill_mod_type) or math.random() &lt; attack.chance
end
U.has_modifiers(store: table, 实体: table, 效果模板名: str) -&gt; 是否拥有: bool, 找到的效果实体: table 若不传递效果模板名称则返回所有效果
U.has_modifier_types(store: table, 实体: table, 效果类型: int...) -&gt; 是否拥有: bool, 所有找到的效果实体: table
tt.melee.attacks[2] = table.deepclone(tt.melee.attacks[1]) -- 深拷贝的攻击
tt.melee.attacks[2].chance = 概率: num
tt.melee.attacks[2].mod = 效果模板名: str
以火男普攻概率造成燃烧效果为例：-- 模板
tt.melee.attacks[2] = table.deepclone(tt.melee.attacks[1]) -- 深拷贝近战普攻
tt.melee.attacks[2].chance = 0.5
tt.melee.attacks[2].mod = "mod_lava" -- 升级函数，只有能升级（有升级函数）的单位才需要修改升级函数
...
this.melee.attacks[1].damage_min = ls.melee_damage_min[hl]
this.melee.attacks[1].damage_max = ls.melee_damage_max[hl]
-- 同时将伤害赋值到新攻击上
this.melee.attacks[2].damage_min = ls.melee_damage_min[hl]
this.melee.attacks[2].damage_max = ls.melee_damage_max[hl]
...
防御塔的攻击需要自己写逻辑。以地震普攻概率造成眩晕效果为例：-- 模板
local tower_dwaarp = RT("tower_dwaarp", "tower")
tower_dwaarp.attacks.list[4] = table.deepclone(tower_dwaarp.attacks.list[1])
tower_dwaarp.attacks.list[4].mod = "mod_stun"
tower_dwaarp.attacks.list[4].chance = 0.5 -- 更新函数
function scripts.tower_dwaarp.update(this, store, script) ... local aa_m = this.attacks.list[4] while true do if this.tower.blocked then coroutine.yield() else ... if store.tick_ts - aa.ts &gt; aa.cooldown then ... -- 若进行攻击 1 则计算概率，然后将攻击 1 改成攻击 4 if math.random() &lt;= aa_m.chance then aa = aa_m end end ... if not drill_ready and not lava_ready and not std_ready then coroutine.yield() else ... if std_ready and trigger_enemy then -- 更新两个时间戳 aa.ts = store.tick_ts this.attacks.list[1].ts = store.tick_ts ... -- 还原 aa = this.attacks.list[1] std_ready = false lava_ready = false ... end ... end ... end ... end ...
end
以爵士为例：-- 模板
tt = RT("hero_gerald", "hero")
AC(tt, "melee", "timed_attacks", "dodge", "ranged")
...
tt.ranged.attacks[1].bullet = "gerald_arrow"
tt.ranged.attacks[1].bullet_start_offset = { v(0, 12)
}
tt.ranged.attacks[1].cooldown = 1
tt.ranged.attacks[1].max_range = 150
tt.ranged.attacks[1].min_range = 25
tt.ranged.attacks[1].shoot_time = fts(6)
tt.ranged.attacks[1].animation = "idle" -- 使用待机时的动画 tt = RT("gerald_arrow", "arrow")
tt.bullet.damage_min = 10
tt.bullet.damage_max = 25
tt.bullet.prediction_error = false -- 更新函数
function scripts.hero_gerald.update(this, store) ... brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)	-- 调用近战攻击函数 -- brk 就是 break，sta 就是 status if brk or sta ~= A_NO_TARGET then	-- 删除 sta ~= A_NO_TARGET 条件即可让近战攻击与远程攻击同时进行 -- block empty else brk, sta = SU.y_soldier_ranged_attacks(store, this)	-- 调用远程攻击函数 if brk then -- block empty elseif SU.soldier_go_back_step(store, this) then	-- 前往集结点 -- block empty else SU.soldier_idle(store, this) SU.soldier_regen(store, this) end end ...
end
以利维坦为例：tt = RT("eb_leviathan", "boss")
AC(tt, "attacks", "ranged")
...
tt.ranged.attacks[1].bullet = "bolt_blazefang_eb_leviathan"
tt.ranged.attacks[1].bullet_start_offset = { v(25, 10), v(12, 22), v(6, 4)
}
tt.ranged.attacks[1].cooldown = 1
tt.ranged.attacks[1].hold_advance = true
tt.ranged.attacks[1].max_range = 150
tt.ranged.attacks[1].min_range = 25
tt.ranged.attacks[1].shoot_time = fts(24)
tt.ranged.attacks[1].animation = "idle" -- 使用待机时的动画
tt.ranged.attacks[1].shared_cooldown = true
... tt = E:register_t("bolt_blazefang_eb_leviathan", "bolt_blazefang")	-- 续承蜥蜴人未来战士子弹
tt.bullet.damage_max = 1000
tt.bullet.damage_min = 600 -- 更新函数
function scripts.eb_leviathan.update(this, store, script) ... local a = this.ranged.attacks[1] ::label_244_0:: while true do ... if this.unit.is_stunned then coroutine.yield() else local ranged = U.find_nearest_soldier(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans) -- 如果找到士兵目标 if ranged then -- 如果可以远程攻击，并且没有被拦截一直进行远程攻击 while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do if not SU.y_enemy_range_attacks(store, this, ranged) then goto label_244_0 end coroutine.yield() end end ... end end
end
以给尼鲁增加一个技能：每 275 秒增加 1 生命（升级二技能翠绿迸发解锁）为例：-- 模板
tt.hero.skills.heal_live = CC("hero_skill")	-- 防御塔与其他单位技能组件是 power
tt.hero.skills.heal_live.cooldown = { 275,	-- 一级冷却时间 275 秒 245,	-- 三级冷却时间 245 秒 210 -- 三级冷却时间 210 秒
}
...
tt.timed_attacks.list[5] = CC("custom_attack")
tt.timed_attacks.list[5].animation = "fairy_dust"	-- 动画套用四技能衰弱咒语
tt.timed_attacks.list[5].sound = "HeroNyruFairyDustCast"	-- 音效，也是借用衰弱咒语
tt.timed_attacks.list[5].cooldown = nil
tt.timed_attacks.list[5].disabled = true
tt.timed_attacks.list[5].heal_live = 1 -- 升级函数
function scripts.hero_muyrn.level_up(this, store, initial) s = this.hero.skills.verdant_blast sl = s.level ... if sl &gt; 0 and initial then ... local a = this.timed_attacks.list[5] a.cooldown = this.hero.skills.heal_live.cooldown[sl] a.disabled = nil ... end ...
end -- 更新函数
function scripts.hero_muyrn.update(this, store) ... if this.unit.is_stunned then SU.soldier_idle(store, this) else ... a = this.timed_attacks.list[5] skill = this.hero.skills.heal_live if not a.disabled and store.tick_ts - a.ts &gt; a.cooldown then a.ts = store.tick_ts U.animation_start(this, a.animation, nil, store.tick_ts) S:queue(a.sound)	-- 播放音效 store.lives = store.lives + a.heal_live	-- 增加生命 SU.y_hero_animation_wait(this)	-- 等待动画完成 ... end
end
为闪避组件的 counter_attack 指定攻击即可。以爵士格挡为例：-- 模板
tt.dodge.counter_attack = CC("melee_attack")
tt.dodge.counter_attack.damage_type = bor(DAMAGE_TRUE, DAMAGE_NO_DODGE)
tt.dodge.counter_attack.reflected_damage_factor = 0.5
tt.dodge.counter_attack.reflected_damage_factor_inc = 0.5	-- 技能升级提升系数
tt.dodge.counter_attack.hit_time = fts(5)
tt.dodge.counter_attack.animation = "counter"
tt.dodge.counter_attack.sound = "HeroPaladinDeflect" -- 更新函数
function scripts.hero_gerald.update(this, store) ... local d = this.dodge while true do ... if this.unit.is_stunned then SU.soldier_idle(store, this) else ... skill = this.hero.skills.block_counter if skill.level &gt; 0 and d and d.active then d.active = false -- 闪避后 dodge.active 会被赋值为真 d.counter_attack_pending = true	-- counter_attack_pending 为真表示将下次的普攻改成闪避反击 local la = d.last_attack local ca = d.counter_attack if la then local counter_damage = ca.reflected_damage_factor + ca.reflected_damage_factor_inc * skill.level ca.damage_max = la.damage_max * counter_damage ca.damage_min = la.damage_min * counter_damage end ... end ... end ... end ...
end
给闪避的 can_dodge 指定条件函数即可。tt.dodge.can_dodge = 条件函数: func 为条件函数传递 store 当前实体、远程攻击、攻击、来源
条件函数返回真表示可以闪避
以爵士格挡为例：-- 模板
tt.dodge.can_dodge = scripts.hero_gerald.fn_can_dodge -- game_scripts
function scripts.hero_gerald.fn_can_dodge(store, this, ranged_attack, attack, source) if (attack and attack.type == "area" or source and source.vis and band(source.vis.flags, F_BOSS) ~= 0) and math.random() &gt; this.dodge.low_chance_factor then -- 如果攻击为范围伤害，或为 Boss 计算闪避概率（Boss 闪避概率为三分之一） return false end return true
end
攻击优先级存储于攻击的 order 中，通过 U.attack_order 自动排序。攻击概率造成效果也是通过其排序方法实现的。
释放概率不同，释放概率低者在前
释放概率相同，冷却时间长者在前
所有条件相同，攻击索引低者在前
-- 雷格森插入函数
function scripts.hero_regson.insert(this, store) ... this.melee.order = U.attack_order(this.melee.attacks)	-- 删除这个 ...
end -- 直接在模板指定攻击优先级
tt.melee.order = { 2, -- 优先释放近战攻击 2 1, -- 之后释放近战攻击 1 ... -- 注：必须填写所有的攻击，没填写的攻击将永不释放
} -- 远程攻击同理
this.ranged.order = U.attack_order(this.ranged.attacks)	-- 删除这个 tt.ranged.order = { 2, -- 优先释放远程攻击 2 1, -- 之后释放远程攻击 1 ...
}
以利维坦为例：-- 模板
tt = E:register_t("eb_leviathan", "boss")
...
tt.second_phase = {}
tt.second_phase.wait_time = 5 -- 死亡后进入二阶段等待时间
tt.second_phase.hp_max = 10000 -- 二阶段血量
tt.second_phase.armor = 0.5 -- 二阶段护甲 -- 更新函数
function scripts.eb_leviathan.update(this, store, script)
... ::label_244_0:: while true do if this.health.dead then if not this.is_second_phase then this.ui.can_click = false -- 进入二阶段等待时禁止玩家点击，避免显示状态栏 this.health_bar.hidden = true	-- 进入二阶段等待时隐藏血条 U.animation_start(this, "death", nil, store.tick_ts, false) -- 播放死亡动画 U.y_wait(store, this.second_phase.wait_time)	-- 等待 5 秒 this.ui.can_click = true -- 重新启用，允许玩家点击 this.health_bar.hidden = false	-- 重新显示血条 this.is_second_phase = true this.health.dead = false this.health.hp_max = this.second_phase.hp_max -- 设置新的最大血量 this.health.hp = this.second_phase.hp_max -- 设置新的血量 this.health.armor = this.second_phase.armor -- 设置新的护甲 goto label_244_0 -- 直接跳出，避免进入死亡移除环节（正式死亡） end -- 二阶段死亡则进入死亡移除环节（正式死亡） this.phase = "dead" LU.kill_all_enemies(store, true) for _, t in pairs(tentacles) do t.interrupt = true end do_death() queue_remove(store, this) signal.emit("boss-killed", this) return end ... end ...
end
<br>根据 <a data-href="3. 实体函数#3 5 谁在调用插入与更新函数" href="第-2-节-修改基础/3.-实体函数.html#3 5 谁在调用插入与更新函数" class="internal-link" target="_self" rel="noopener nofollow">3. 实体函数 &gt; 3 5 谁在调用插入与更新函数</a> 阅读代码了解驱动函数是怎么调用实体函数的要点：
系统存储位置：系统存储于 all/systems
协程机制：更新函数使用协程（coroutine）管理与控制执行流程
队列：使用多个队列（实体队列、伤害队列）批量处理操作
<br>（答案见<a data-href="第 2 节 - 修改基础/参考答案#练习 3 2：日志与调试实践" href="第-2-节-修改基础/参考答案.html#练习 3 2：日志与调试实践" class="internal-link" target="_self" rel="noopener nofollow">第 2 节 - 修改基础/参考答案 &gt; 练习 3 2：日志与调试实践</a>）-- 假设你正在为英雄 "暗影刺客" 实现一个新技能 "暗影突袭"
-- 技能效果：对范围内血量最低的敌人造成伤害并附加流血效果 -- 已有代码框架：
function scripts.hero_shadow_assassin.update(this, store) local skill = this.hero.skills.shadow_assault local attack = this.timed_attacks.list[3] -- 第3个是暗影突袭 while true do if skill.level &gt; 0 and not attack.disabled then if store.tick_ts - attack.ts &gt;= attack.cooldown then -- 技能可用，开始索敌... -- TODO: 在这里实现技能逻辑 -- 要求： -- 1. 找到范围内血量最低的敌人 -- 2. 造成伤害 (伤害值 = 基础伤害 + 技能等级 * 伤害成长) -- 3. 附加流血效果 -- 4. 刷新技能时间戳 -- 5. 播放动画和音效 -- 技能参数： -- attack.radius = 200 -- 技能范围 -- attack.damage_base = 50 -- 基础伤害 -- attack.damage_per_level = 30 -- 每级伤害成长 -- attack.mod = "mod_bleed_v2" -- 流血效果模板 end end coroutine.yield() end
end -- 要求：
-- 1. 实现上述TODO部分的技能逻辑
-- 2. 在关键位置添加适当的日志：
-- - 使用 log.debug 记录技能触发和目标选择
-- - 使用 log.info 记录技能释放成功
-- - 使用 log.warning 处理边界情况（如无目标）
-- - 使用 log.error 处理严重错误
-- - 使用 log.paranoid 记录详细的计算过程（可选）
-- 3. 确保代码有良好的错误处理 -- 提示函数：
-- U.find_enemies_in_range -- 范围内所有敌人
-- table.sort -- 对表排序
-- E:create_entity("damage")-- 创建伤害实体
-- E:create_entity -- 创建效果实体
-- queue_damage -- 排队伤害
-- queue_insert -- 排队插入实体
-- U.animation_start -- 播放动画
-- S:queue -- 播放音效 实体函数概述 定义：存储在 kr/game_scripts 和 all/scripts 中的逻辑函数
作用：为 main_script 系统增加实体逻辑
插入函数（insert）：实体创建时调用一次
更新函数（update）：每帧调用，管理实体持续行为
升级函数（level up）：实体升级时调用 存储位置 实体存储：所有实体存储在 store.entities 表中
临时存储：store 用于存储游戏临时数据 核心技能实现 造成伤害：E:create_entity("damage") + queue_damage
造成效果：E:create_entity + queue_insert
增加光环：创建光环实体并设置 source_id
修改攻击优先级：直接在模板攻击指定 order 数组 时间与状态管理 游戏时间：store.tick_ts
时间戳：a.ts（攻击的时间戳）
冷却计算：store.tick_ts - a.ts &gt;= a.cooldown
效果判断：U.has_modifiers 和 U.has_modifier_types 打印日志 详细：log.paranoid 打印最详细的跟踪信息
调试：log.debug 打印开发过程中的详细调试信息
代办：log.todo 打印标记需要完成的功能或修复的问题
信息：log.info 打印正常的游戏流程信息
警告：log.warning 打印潜在问题或不规范使用
错误：log.error 打印程序错误和异常情况 索敌与目标选择 范围索敌：U.find_enemies_in_range
首个敌人：U.find_foremost_enemy
过滤函数：可自定义条件筛选目标
特殊筛选：如按血量排序找到最高血量目标 攻击条件控制 近战条件：fn_can 函数
远程条件：filter_fn 函数
释放概率：fn_chance 函数 扩展攻击与技能 新增攻击：使用 table.deepclone 复制攻击
概率效果：设置 chance 和 mod 属性
士兵新增远程攻击：需在更新函数中调用远程攻击 y_soldier_ranged_attacks 函数
敌人新增远程攻击：需在逻辑循环中集成远程攻击检与 y_enemy_range_attacks 函数
新增技能：在 timed_attacks 中添加，配合升级函数解锁
闪避机制：counter_attack 和 can_dodge 函数 特殊机制实现 二阶段机制：通过状态标志和血量重置实现 架构与调用机制 ECS 架构：实体-组件-系统的分离设计
调用链：Love2D → 游戏层 → 模拟器 → 实体函数
协程管理：更新函数使用协程实现复杂逻辑控制 （点击勾选框勾选）
完成本章后，你应该能够：
理解插入、更新、升级三种实体函数的作用和调用时机
在插入函数中实现伤害、效果、光环等基础功能
使用 store.tick_ts 和 a.ts 计算时间和冷却
使用日志库打印日志
实现各种索敌逻辑和目标筛选
为攻击添加释放条件和概率控制
通过深拷贝和组件配置新增攻击和技能
实现闪避和反击机制
创建复杂的多阶段机制
理解实体函数的调用链和协程机制 为什么实体函数要分为插入、更新、升级三种类型？这种分离设计如何提高代码的可维护性和性能？
如果要为一个英雄添加一个新的召唤技能，需要考虑哪些方面？
ECS 架构如何支持游戏中复杂的行为组合？
协程在游戏逻辑管理中有哪些优势和局限性？
当多个实体需要共享某种行为时，如何设计避免代码重复？
如何处理实体之间的复杂交互（如连锁反应）？ 代码复用： 观察现有英雄的实现，提取通用模式
创建可复用的辅助函数库 文档习惯： 为自定义函数添加清晰文档注释
记录重要的设计决策和实现细节 下一章预告：在第 4 章中，我们将学习修改游戏的关卡，包括路径、网格、出怪等，为更复杂的修改做准备。]]></description><link>第-2-节-修改基础/3.-实体函数.html</link><guid isPermaLink="false">第 2 节 - 修改基础/3. 实体函数.md</guid><pubDate>Thu, 25 Dec 2025 07:18:06 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[13. 元表]]></title><description><![CDATA[元表（Metatable）是 Lua 中一种特殊的表，可以定义其他表的"行为"。它允许我们改变表的默认操作，比如加法、减法、索引访问等。
运算符重载：让表支持算术运算
自定义行为：改变表的索引和赋值
面向对象：实现继承、私有性等特性
保护数据：创建只读表、受限表
local vector1 = {x = 10, y = 20}
local vector2 = {x = 5, y = 15} -- 尝试相加两个表（会报错）
local sum = vector1 + vector2 -- 错误！table 不支持加法
print(sum) -- 尝试比较两个表（比较的是引用，不是值）
print(vector1 == vector2) -- false（即使值相同也是false）
print(tostring(vector1)) -- table: 0x000001（不是我们想要的格式）
setmetatable(表: table, 元表: table) -&gt; 设置元表后的表: table
-- 创建一个普通表
local mytable = {} -- 创建一个元表
local metatable = { __add = function() return "add" end
} -- 设置元表
setmetatable(mytable, metatable) -- 可简化为
local mytable = setmetatable({}, { __add = function() return "add" end
})
getmetatable(表: table) -&gt; 元表: table
local mytable = {} local metatable = { __add = function() return "add" end
} setmetatable(mytable, metatable) local mt = getmetatable(mytable)
print(mt == metatable) -- true
元方法分为以下几类：
算术元方法：__add、__sub 、__mul、__div、__mod、__pow、__unm（负号）
关系元方法：__eq、__lt、__le
库元方法：__tostring、__concat
索引元方法：__index、__newindex
调用元方法：__call
local Vector = {}
Vector.__index = Vector function Vector.new(x, y) local v = { x = x, y = y } setmetatable(v, Vector) return v
end -- 定义 __add 元方法
function Vector.__add(a, b) return Vector.new(a.x + b.x, a.y + b.y)
end -- 定义 __tostring 元方法
function Vector.__tostring(self) return string.format("Vector(%d, %d)", self.x, self.y)
end -- 使用示例
local v1 = Vector.new(10, 20)
local v2 = Vector.new(5, 15)
local v3 = v1 + v2 -- 现在可以相加了！ print(v1) -- Vector(10, 20)
print(v2) -- Vector(5, 15)
print(v3) -- Vector(15, 35)
-- 复数类示例
local Complex = {}
Complex.__index = Complex function Complex.new(real, imag) local c = {real = real, imag = imag} setmetatable(c, Complex) return c
end -- 加法
function Complex.__add(a, b) return Complex.new(a.real + b.real, a.imag + b.imag)
end -- 减法
function Complex.__sub(a, b) return Complex.new(a.real - b.real, a.imag - b.imag)
end -- 乘法
function Complex.__mul(a, b) -- (a+bi)(c+di) = (ac-bd) + (ad+bc)i local real = a.real * b.real - a.imag * b.imag local imag = a.real * b.imag + a.imag * b.real return Complex.new(real, imag)
end -- 负号
function Complex.__unm(a) return Complex.new(-a.real, -a.imag)
end -- 字符串表示
function Complex.__tostring(self) if self.imag &gt;= 0 then return string.format("(%d+%di)", self.real, self.imag) else return string.format("(%d%di)", self.real, self.imag) end
end -- 使用示例
local c1 = Complex.new(3, 4) -- 3+4i
local c2 = Complex.new(1, 2) -- 1+2i print(c1) -- (3+4i)
print(c2) -- (1+2i)
print(c1 + c2) -- (4+6i)
print(c1 - c2) -- (2+2i)
print(c1 * c2) -- (-5+10i)
print(-c1) -- (-3-4i)
-- 分数类示例
local Fraction = {}
Fraction.__index = Fraction function Fraction.new(numerator, denominator) local f = { num = numerator, den = denominator or 1 } setmetatable(f, Fraction) return f
end -- 相等判断（约分后比较）
function Fraction.__eq(a, b) return a.num * b.den == b.num * a.den
end -- 小于判断
function Fraction.__lt(a, b) return a.num * b.den &lt; b.num * a.den
end -- 小于等于判断
function Fraction.__le(a, b) return a.num * b.den &lt;= b.num * a.den
end function Fraction.__tostring(self) return string.format("%d/%d", self.num, self.den)
end -- 使用示例
local f1 = Fraction.new(1, 2) -- 1/2
local f2 = Fraction.new(2, 4) -- 2/4
local f3 = Fraction.new(3, 4) -- 3/4 print(f1 == f2) -- true（1/2 == 2/4）
print(f1 &lt; f3) -- true（1/2 &lt; 3/4）
print(f3 &lt;= f2) -- false（3/4 &lt;= 1/2）
print(f1 &lt;= f2) -- true（1/2 &lt;= 1/2）
不存在大于关系元方法，但是可以通过交换小于关系原方法的操作数来巧妙实现。我们这里不用实现，因为 Lua 已经帮我们实现了：-- 理解大于关系原理
local debugFraction = {}
debugFraction.__index = debugFraction function debugFraction.new(value) local f = {value = value} setmetatable(f, debugFraction) return f
end function debugFraction.__lt(a, b) print(string.format("调用 __lt: %s &lt; %s, 结果: %s", a.value, b.value, tostring(a.value &lt; b.value)))
end function debugFraction.__le(a, b) print(string.format("调用 __le: %s &lt;= %s, 结果: %s", a.value, b.value, tostring(a.value &lt;= b.value)))
end local a = debugFraction.new(1)
local b = debugFraction.new(2) _ = a &lt; b
_ = a &lt;= b
_ = a &gt; b
_ = a &gt;= b
--[[ 输出
调用 __lt: 1 &lt; 2, 结果: true
调用 __le: 1 &lt;= 2, 结果: true
调用 __lt: 2 &lt; 1, 结果: false
调用 __le: 2 &lt;= 1, 结果: false
--]]
索引表中不存在键时调用元表中的 __index 函数，如果 __index 是一个表将会在这个表中索引键。-- 示例1：使用函数作为 __index
local john = {name = "John", age = 25}
setmetatable(john, { __index = function(table, key) if key == "birthYear" then return 2025 - table.age elseif key == "info" then return table.name .. ", " .. table.age .. " years old" else return nil -- 返回nil表示不存在 end end
}) print(john.name) -- John（直接访问）
print(john.age) -- 25（直接访问）
print(john.birthYear) -- 2000（不存在，调用 __index）
print(john.info) -- John, 25 years old（不存在，调用 __index）
print(john.sayHello) -- nil -- 示例2：使用表作为 __index（实现继承）
local Animal = { sound = "???", makeSound = function(self) return self.sound end
} local Dog = setmetatable({}, { __index = Animal
}) -- Dog继承Animal Dog.sound = "Woof!"
Dog.bark = function(self) return self:makeSound() .. " " .. self:makeSound()
end print(Dog:makeSound()) -- Woof!
print(Dog:bark()) -- Woof! Woof!
给表中不存在的键赋值时调用-- 示例1：限制特定键的赋值
local Config = {} local metatable = { __newindex = function(table, key, value) if key == "version" then print("Cannot modify version!") elseif key == "author" then print("Cannot modify author!") else rawset(table, key, value) -- 使用rawset绕过元方法 end end
} setmetatable(Config, metatable) Config.version = "2.0" -- Cannot modify version!
Config.port = 8080 -- 成功添加新字段
print(Config.port) -- 8080 -- 示例2：自动类型检查
local Student = {} local student_meta = { __newindex = function(table, key, value) if key == "grade" then if type(value) ~= "number" or value &lt; 0 or value &gt; 100 then print("Grade must be a number between 0 and 100") end elseif key == "name" then if type(value) ~= "string" then print("Name must be a string") end end rawset(table, key, value) end
} local s1 = {}
setmetatable(s1, student_meta) s1.grade = "A" -- Grade must be a number between 0 and 100
s1.name = 123 -- Name must be a string
rawget(表: table, 索引: any)
local DangerTable = setmetatable({}, { __index = function(table, key) return table[key] end
}) -- print(DangerTable.v)	-- 栈会溢出 -- 使用rawget绕过元方法，避免栈溢出
print(rawget(DangerTable, "v")) -- nil
rawset(表: table, 索引: any, 值: any)
local SecureTable = setmetatable({}, { __newindex = function(table, key, value) if key == "ban_key" then print(string.format("Cannot set key: %s!", key)) end end
}) SecureTable.ban_key = "new" -- Cannot set key: ban_key!
print(SecureTable.ban_key) -- nil -- 使用rawset绕过元方法，为被禁止键赋值
rawset(SecureTable, "ban_key", "new")
print(SecureTable.ban_key) -- new
不存在索引元方法，但是可以通过代理表来巧妙实现。local function createTable(t) local new_table = t local proxy = setmetatable({}, { __index = function(table, key) print(string.format("索引: %s", key)) return new_table[key] end, __newindex = function(table, key, value) print(string.format("赋值: %s", value)) new_table[key] = value end }) return proxy
end local new_table = createTable() -- 实际在操作 proxy 空表
new_table.a = 1
new_table.b = 2
_ = new_table.a
b = new_table.b
--[[ 输出
赋值: 1
赋值: 2
索引: a
索引: b
--]]
让表可以像函数一样被调用。-- 示例1：函数对象
local Counter = { count = 0
} local counter_meta = { __call = function(self, increment) self.count = self.count + increment return self.count end
} setmetatable(Counter, counter_meta) print(Counter()) -- 1
print(Counter(5)) -- 6
print(Counter(2)) -- 8 -- 示例2：带参数的构造函数
local Point = { x = 0, y = 0
} local point_meta = { __call = function(self, x, y) local p = { x = x or self.x, y = y or self.y } setmetatable(p, getmetatable(self)) return p end, __tostring = function(self) return string.format("Point(%d, %d)", self.x, self.y) end
} setmetatable(Point, point_meta) local p1 = Point() -- 使用默认值
local p2 = Point(10, 20) -- 指定值
local p3 = Point(30) -- 只指定x print(p1) -- Point(0, 0)
print(p2) -- Point(10, 20)
print(p3) -- Point(30, 0)
自定义表的字符串表示。local Book = { title = "", author = "", pages = 0
} local book_meta = { __tostring = function(self) return string.format('"%s" by %s (%d pages)', self.title, self.author, self.pages) end
} function Book.new(title, author, pages) local book = { title = title, author = author, pages = pages } setmetatable(book, book_meta) return book
end local book1 = Book.new("Lua Programming", "John Doe", 350)
local book2 = Book.new("Metatables Guide", "Jane Smith", 200) print(book1) -- "Lua Programming" by John Doe (350 pages)
print(book2) -- "Metatables Guide" by Jane Smith (200 pages)
自定义连接操作符(..)。local StringWrapper = {} function StringWrapper.new(str) local wrapper = {value = str or ""} setmetatable(wrapper, { __concat = function(a, b) local a_val = type(a) == "table" and a.value or a local b_val = type(b) == "table" and b.value or b return StringWrapper.new(a_val .. b_val) end, __tostring = function(self) return self.value end }) return wrapper
end local s1 = StringWrapper.new("Hello")
local s2 = StringWrapper.new(" World")
local s3 = s1 .. s2 .. "!" print(s3) -- Hello World!
print(type(s3)) -- table（仍然是StringWrapper对象）
-- 实现一个简单的类系统
local Class = {} function Class.create(name, super) local class = {} class.name = name class.super = super -- 设置继承链 if super then setmetatable(class, { __index = super }) end -- 类构造函数 class.new = function(...) local instance = {} setmetatable(instance, { __index = class }) -- 调用初始化方法 if instance.init then instance:init(...) end return instance end return class
end -- 基类：Animal
local Animal = Class.create("Animal") function Animal:init(name) self.name = name
end function Animal:speak() return "???"
end function Animal:introduce() return "I am " .. self.name .. ", I say " .. self:speak()
end -- 派生类：Dog
local Dog = Class.create("Dog", Animal) function Dog:speak() return "Woof!"
end function Dog:wagTail() return self.name .. " is wagging tail"
end -- 派生类：Cat
local Cat = Class.create("Cat", Animal) function Cat:speak() return "Meow!"
end function Cat:purr() return self.name .. " is purring"
end -- 使用示例
local dog = Dog.new("Buddy")
local cat = Cat.new("Whiskers") print(dog:introduce()) -- I am Buddy, I say Woof!
print(cat:introduce()) -- I am Whiskers, I say Meow!
print(dog:wagTail()) -- Buddy is wagging tail
print(cat:purr()) -- Whiskers is purring -- 调用父类的函数
print(cat.super:speak())-- ??? -- 检查继承关系
print(getmetatable(Dog).__index == Animal) -- true local function readOnly(t) local proxy = {} local metatable = { __index = t, __newindex = function(table, key, value) print("Attempt to modify read-only table", 2) end, __metatable = "Read-only table" -- 保护元表本身 } setmetatable(proxy, metatable) return proxy
end local config = { version = "1.0", port = 8080, host = "localhost"
} local readOnlyConfig = readOnly(config) print(readOnlyConfig.version) -- 1.0
print(readOnlyConfig.port) -- 8080 readOnlyConfig.port = 9090 -- Attempt to modify read-only table
readOnlyConfig.newKey = "test" -- Attempt to modify read-only table -- 尝试获取元表
print(getmetatable(readOnlyConfig)) -- Read-only table
function createDefaultTable(defaultValue) local t = {} local metatable = { __index = function(table, key) return defaultValue end } setmetatable(t, metatable) return t
end -- 示例1：默认值为0
local scores = createDefaultTable(0)
scores.Alice = 95
scores.Bob = 87 print(scores.Alice) -- 95
print(scores.Bob) -- 87
print(scores.Charlie) -- 0（默认值）
print(scores.David) -- 0（默认值） -- 示例2：默认值为空表
local groups = createDefaultTable({})
groups.admin = { "Alice", "Bob" }
table.insert(groups.users, "Charlie") print(#groups.admin) -- 2
print(#groups.users) -- 1
print(type(groups.guests)) -- table（默认空表）
-- 错误1：递归调用导致的栈溢出
local t = {}
local mt = { __index = function(table, key) return table[key] -- 错误！递归调用 end
}
setmetatable(t, mt)
-- print(t.x) -- 栈溢出 -- 正确做法
local t2 = {}
local mt2 = { __index = function(table, key) return rawget(table, key) -- 使用rawget避免递归 end
} -- 错误2：忘记表传递的是引用，修改元表影响所有实例
local A = {x = 1}
local mt = {}
setmetatable(A, mt) local B = {x = 2}
setmetatable(B, mt) -- 和A共享元表 mt.__index = function() return 100 end print(A.y) -- 100（可能不是期望的行为）
print(B.y) -- 100 -- 正确做法：每个实例使用独立的元表
local function createInstance(value) local obj = {x = value} setmetatable(obj, { __index = function(self, key) if key == "double" then return self.x * 2 end end }) return obj
end local a = createInstance(10)
local b = createInstance(20) print(a.double) -- 20
print(b.double) -- 40
-- 性能测试：元表访问 vs 直接访问
local iterations = 10000000 -- 直接访问
local directTable = { value = 42 }
local start1 = os.clock()
for i = 1, iterations do local v = directTable[i]
end
local time1 = os.clock() - start1 -- 通过元表访问
local metaTable = {}
local proxiedTable = { value = 42 }
setmetatable(proxiedTable, { __index = function(t, k) return rawget(t, k) end
}) local start2 = os.clock()
for i = 1, iterations do local v = proxiedTable[i]
end
local time2 = os.clock() - start2 print(string.format("直接访问: %.4f 秒", time1))
print(string.format("元表访问: %.4f 秒", time2))
print(string.format("开销: %.2f%%", (time2 - time1) / time1 * 100))
--[[ 输出
直接访问: 0.1740 秒
元表访问: 0.8650 秒
开销: 370%
--]]
-- 要求：
-- 1. 实现 Vector 类，支持 x, y 坐标
-- 2. 支持加法、减法、乘法（点积）
-- 3. 支持负号操作
-- 4. 支持字符串表示 -- 使用示例：
local v1 = Vector.new(3, 4)
local v2 = Vector.new(1, 2) print(v1) -- Vector(3, 4)
print(v2) -- Vector(1, 2)
print(v1 + v2) -- Vector(4, 6)
print(v1 - v2) -- Vector(2, 2)
print(v1 * v2) -- 11 (点积)
print(-v1) -- Vector(-3, -4)
-- 要求：
-- 1. 跟踪以上向量类的各种访问，加减点积等
-- 2. 可打印访问历史记录 -- 使用示例：
print("\n\n=== 练习2：带日志的向量类测试 ===")
local v1 = TrackedVector.new(3, 4)
local v2 = TrackedVector.new(1, 2) print("v1 = " .. tostring(v1)) -- Vector(3, 4)
print("v2 = " .. tostring(v2)) -- Vector(1, 2) local sum = v1 + v2
print("v1 + v2 = " .. tostring(sum)) -- Vector(4, 6) local diff = v1 - v2
print("v1 - v2 = " .. tostring(diff)) -- Vector(2, 2) local dot = v1 * v2
print("v1 * v2 = " .. dot) -- 11 local neg = -v1
print("-v1 = " .. tostring(neg)) -- Vector(-3, -4) print("\n=== v1的操作日志 ===")
local v1_logs = v1:get_log()
print(table.concat(v1_logs, "\n")) print("\n=== v2的操作日志 ===")
local v2_logs = v2:get_log()
print(table.concat(v2_logs, "\n"))
--[[ 输出
=== 练习2：带日志的向量类测试 ===
v1 = Vector(3, 4)
v2 = Vector(1, 2)
v1 + v2 = Vector(4, 6)
v1 - v2 = Vector(2, 2)
v1 * v2 = 11
-v1 = Vector(-3, -4) === v1的操作日志 ===
向量: Vector(3, 4)
1. 创建向量: Vector(3, 4)
2. 被加: 与 Vector(1, 2) 运算, 结果: Vector(4, 6)
3. 被减: 与 Vector(1, 2) 运算, 结果: Vector(2, 2)
4. 点积: 与 Vector(1, 2) 运算, 结果: 11
5. 取负: 运算, 结果: Vector(-3, -4) === v2的操作日志 ===
向量: Vector(1, 2)
1. 创建向量: Vector(1, 2)
2. 加数: 与 Vector(3, 4) 运算, 结果: Vector(4, 6)
3. 减数: 与 Vector(3, 4) 运算, 结果: Vector(2, 2)
4. 点积: 与 Vector(3, 4) 运算, 结果: 11
--]] 元表基础： setmetatable(t, mt) - 设置元表
getmetatable(t) - 获取元表
元表可以改变表的默认行为 算术和关系元方法： __add 加、__sub 减、__mul 乘、__div 除 - 四则运算
__eq、__lt、__le - 等于与小于关系比较
__unm - 负号操作
__mod、__pow - 取模和幂运算
大于关系的原理：交换操作数 索引相关元方法： __index - 索引不存在的键时调用，如果是表则在该表索引
__newindex - 给不存在的键赋值时调用
rawget - 绕过 __index 索引
rawset - 绕过 __newindex 赋值
使用代理表在每次索引时调用元方法 其他元方法： __tostring - 自定义字符串表示
__call - 让表可被调用
__concat - 连接操作符 高级应用： 面向对象编程（继承、多态）
只读表和受保护表
默认值表
访问跟踪和日志 完成本章后，你应该能够：
理解元表的作用和原理
设置和获取元表
实现基本的算术和关系运算重载
理解大于关系原理
使用 __index、__newindex 和代理表控制索引与赋值
实现表的只读保护
使用元表实现简单的类继承
理解 rawget 和 rawset 的作用
实现表的自定义字符串表示
让表可以像函数一样被调用 元表和原型继承有什么关系？
为什么 Lua 使用元表而不是传统的类继承？
如何实现多重继承？
元表和协程结合可以解决什么问题？
]]></description><link>第-1-节-语法/13.-元表.html</link><guid isPermaLink="false">第 1 节 - 语法/13. 元表.md</guid><pubDate>Wed, 24 Dec 2025 03:59:35 GMT</pubDate></item><item><title><![CDATA[9. 系统]]></title><description><![CDATA[系统模块位于 all/systems 是游戏运行逻辑的关键部分。整个系统又分为多个子系统：
关卡系统 level
波次生成系统 wave_spawn
防御塔升级系统 tower_upgrade
科技树系统 game_upgrades
实体函数系统 main_script
血量系统 health
精灵系统 render
...
而子系统的函数又分为：
初始化 init
入列 on_queue
出列 on_dequeue
插入 on_insert
更新 on_update
移除 on_remove
-- 实体函数系统
sys.main_script = {}
sys.main_script.name = "main_script" -- 入列
function sys.main_script:on_queue(entity, store, insertion) ...
end -- 出列
function sys.main_script:on_dequeue(entity, store, insertion) ...
end -- 插入
function sys.main_script:on_insert(entity, store) ...
end -- 更新
function sys.main_script:on_update(dt, ts, store) ...
end -- 移除
function sys.main_script:on_remove(entity, store) ...
end
]]></description><link>第-2-节-修改基础/9.-系统.html</link><guid isPermaLink="false">第 2 节 - 修改基础/9. 系统.md</guid><pubDate>Wed, 24 Dec 2025 03:58:47 GMT</pubDate></item><item><title><![CDATA[7. 界面]]></title><description><![CDATA[进入关卡后的所有界面，能力按钮、英雄肖像等，统称为关卡界面（game gui）地图界面的相关类都在 all-desktop/game_gui 中（五代为 sequels/game_gui）。防御塔菜单的数据位于 kr/data/tower_menus_data 中。防御塔菜单数据通常用于 TowerMenu 与 TowerMenuButton 类中{ {	-- 二级的按钮 check = 用于安卓的二次确认图标: str action_arg = 动作参数: any action = 动作名称: str halo = 边框名称: str image = 图标名称: str place = 位置索引: int tt_title = 标题文本: str tt_desc = 描述文本: str sounds = 播放的声音名称: str }, {} -- 三级的按钮...
} place 读取 kr1-desktop/data/game_gui_data 中的 tower_menu_button_places 的位置信息
地图上的所有界面，英雄殿堂，科技等，统称为地图界面（screen map）地图界面的相关类都在 all-desktop/screen_map 中（五代为 sequels/screen_map）。注：本篇为五代特有修改 kr/data/kui_templates/group_towers_wheel 增加一个新防御塔选择槽位{ template_name = "button_tower_ring_sel",	-- kui模板 class = "TowerRingItemButton",	-- 续承的类 r = 0,	-- 旋转 id = "button_tower_ring_sel_06",	-- 序号 pos = v(150, 250.5),	-- 位置 scale = v(0.9999, 0.9999)	-- 缩放
}
修改 sequels/kviews_screen_map_sequels.TowerRoomView:initialize 函数增加槽位按钮...
-- 通关第5关后将树灵增加选择的塔中，用于解锁额外选择槽位
if #user_data.towers.selected &lt; 6 and #user_data.levels &gt; 5 then table.insert(user_data.towers.selected, "arborean_emissary")	-- 填写模板名（无tower_前缀） storage:save_slot(user_data)
end
... -- 正式创建槽位
self.roster_sel_items = { self:ci("button_tower_ring_sel_01"), ... self:ci("button_tower_ring_sel_06")	-- 创建第六个防御塔选择槽位
}
self.roster_sel_positions = { V.vclone(self.roster_sel_items[1].pos), ... V.vclone(self.roster_sel_items[6].pos)	-- 槽位位置
}
...
修改 sequels/kviews_screen_map_sequels.game_gui:init 函数部分，增加防御塔建造按钮for i = 1, 6 do	-- 5改为6 local tower_found = selected_holders[i] if tower_found then for _, holder in ipairs(tower_menus.holder[1]) do if holder.type == tower_found then holder.place = index index = index + 1
...
修改 kr-desktop/data/game_gui_data 的 tower_menu_button_places 键，修改防御塔建造按钮位置其每个子键索引对应相应按钮的位置tower_menu_button_places = { v(-92 * ring_scale, -146 * ring_scale),	-- 第一个按钮位置 v(92 * ring_scale, -146 * ring_scale),	-- 第二个按钮位置... v(-153 * ring_scale, 31 * ring_scale), v(153 * ring_scale, 31 * ring_scale), v(0 * ring_scale, 155 * ring_scale), v(-150 * ring_scale, 165 * ring_scale),	-- 第六个按钮位置，修改这个
} 指定切换的界面：切换界面时会调用 director:item_done_callback 回调函数指定切换的界面
进入加载界面中转：然后在 director:update 更新函数内检查有没有要切换的界面如果有则调用 director:queue_load_item_named 函数进入加载界面中转
调用初始化函数：最后调用相应界面的 init 初始化函数并加载需要的资源
]]></description><link>第-2-节-修改基础/7.-界面.html</link><guid isPermaLink="false">第 2 节 - 修改基础/7. 界面.md</guid><pubDate>Wed, 24 Dec 2025 03:58:37 GMT</pubDate></item><item><title><![CDATA[6. 精灵与声音]]></title><description><![CDATA[可在屏幕上移动具有坐标，可变化的图像，称为精灵（sprite）精灵通过计算自身的时间戳（timestamp，缩写 ts）控制其显示的图像所有美术资源都存于 _assets 目录中，其中 images 子目录为图像资源。images 目录中的文件分为两种：图集与相应的图像数据name_1 = { -- 图像名称 a_name = "abc-1.dds",	-- 图集名称 size = { -- 图像原始大小（未裁剪透明边） 200, -- 长度 100 -- 高度 }, trim = { -- 裁剪的透明边 10, -- 左侧裁剪的长度 20, -- 上方裁剪的长度 15, -- 右侧裁剪的长度 25 -- 下方裁剪的长度 }, a_size = { -- 图集大小 2048, -- 长度 2048 -- 高度 }, f_quad = { -- 从图集指定位置得到图像 1000, -- x 500, -- y 175, -- 长度 55 -- 高度 }, alias = { -- 别名 "name_2"	-- 也可以通过name_2找到这个图像 }
}
以上完整含义为：
定义一个名叫 name_1 或 name_2 的图像
原始大小 200x100 像素
从左边裁去 10 像素，再从右边裁去 15 像素，最后再从上下裁去 20 和 25 像素
图集名称 abc-1.dds
图集大小 2048x2048
这个图像位于图集的 [1000, 500] 到 [1175, 555] 处
示意图：
<img alt="Pasted image 20251109133154.png" src="site-lib/media/pasted-image-20251109133154.png" target="_self" style="width: 1000px; max-width: 100%;">所有动画数据都存于 kr/data/animations 目录中.animation_a_name = { -- 动画名称 prefix = "name", -- 图像名称前缀（不带_x序号） to = 10, -- 动画结束时的图像序号（结束帧） from = 1 -- 动画开始时的图像序号（开始帧）
}
以上完整含义为：
定义动画名称为 animation_a_name
图像名称 name，用于与当前帧拼接（例如：动画结束帧的图像为 name_10）
动画从图像序号 1 开始到序号 10 结束（即 name_1 到 name_10）
tt.render.sprites[1].scale = v(2, 2)	-- 缩放到此前的两倍
<br>所有键见 <a data-href="7. 键#精灵" href="总结/7.-键.html#精灵" class="internal-link" target="_self" rel="noopener nofollow">7. 键 &gt; 精灵</a>U.animation_start( 实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 是否循环播放: bool, 精灵索引?: int, 强制重置时间戳: bool
) 后续动画名将与精灵的 prefix 前缀拼接
精灵索引默认为 1
<br>所有动画函数见 <a data-href="9. 工具函数#动画" href="总结/9.-工具函数.html#动画" class="internal-link" target="_self" rel="noopener nofollow">9. 工具函数 &gt; 动画</a>-- 模板
tt.render.sprites[1].prefix = "hero_muyrn"
tt.melee.attacks[1] = CC("melee_attack")
tt.melee.attacks[1].hit_time = fts(9)
tt.melee.attacks[1].animation = "melee_attack" -- 更新函数中
local ma = this.melee.attacks[1]
-- 实际播放动画 hero_muyrn .. melee_attack = hero_muyrn_melee_attack
U.animation_start(this, ma.animation, nil, store.tick_ts)
-- 播放后等待攻击前摇的时间（9帧）
U.y_wait(store, ma.hit_time) -- 也可以使用 U.y_animation_wait(this) 等待动画播放完成
U.y_wait(store, 等待时间: num, 中断函数?: func) -&gt; 是否被中断: bool 在指定时间内循环挂起协程
中断函数用于提前终止暂停
U.y_animation_wait(实体: table, 精灵索引?: int, 播放次数?: int) 精灵索引默认为 1
播放次数默认为 1
-- 更新函数中
local ma = this.melee.attacks[1]
U.animation_start(this, ma.animation, nil, store.tick_ts) -- 播放后等待动画播放完成
U.y_animation_wait(this) U.y_animation_play(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数?: int, 精灵索引?: int) 是 animation_start 与 y_animation_wait 的结合
精灵索引默认为 1
播放次数默认值为 1
-- 更新函数中
local ma = this.melee.attacks[1]
U.y_animation_play(this, ma.animation, nil, store.tick_ts)
根据精灵起点与终点的参数补足中间过渡帧的动画，称为补间动画（Tween Animation）
补间动画可当做关键帧，用于过渡，淡出淡入、平滑移动等首先增加 tween 补间动画组件，在 keys 指定关键帧，在 name 指定精灵键，在 sprite_id 指定目标精灵。默认值：
name：alpha
sprite_id：1
-- 透明度
AC(tt, "tween")	-- 增加组件
tt.tween.props[1].keys = { { 0, 255	-- 默认不透明 }, { 1, 0	-- 1 秒时完全透明 }
}
tt.tween.props[1].sprite_id = 2	-- 补间的精灵，支持数字或表 -- 缩放
tt.tween.props[1].name = "scale"	-- 缩放
tt.tween.props[1].keys = { { 0, v(1, 1) }, { 5, -- 从 0 秒到 5 秒缓慢放大精灵到此前的两倍 v(2, 2) }
}
AC(tt, "tween")
tt.tween.props[1].keys = { { 0,	-- 默认透明度 0 255 }, { 1,	-- 1 秒时完全淡出 0 }, { 2,	-- 2 秒时完全淡入 255 }
}
tt.tween.props[1].sprite_id = {	-- 补间的精灵，可以直接用数字或表 1, 2, ...
}
tt.tween.remove = false -- 禁用播放后移除
tt.tween.props[1].loop = true	-- 循环播放
声音资源位于 _assets/kr-desktop/sounds 目录中。其中：
groups 为声音组
settings 用于指定声音最大来源
sounds 用于指定声音数据，声音资源位置，是否循环播放等
files 声音资源
声音函数位于 all/sound_db （缩写 S）中S:queue(声音名称: str, 声音参数?: table) 同样会分配唯一 ID
1. gain: 声音大小: num|list{最小范围: num, 最大范围: num}
2. seek: 从指定位置开始播放（秒）: num
3. delay: 延迟（秒）: num
4. chance: 播放概率: num
5. every: 每N次请求播放一次: int
6. ignore: 播放声音间隔: num
7. ref_counted: 是否引用计数: bool
8. mode: 播放模式: 按顺序播放: "sequence"|随机选择一个播放: "random"|同时播放所有: "concurrent" 引用计数用于管理多个相同声音实例
-- 模板
tt.melee.attacks[1] = CC("melee_attack")
tt.melee.attacks[1].sound = "HeroNyruBasicAttackMelee"
tt.melee.attacks[1].sound_args = { delay = 1	-- 延迟 1 秒播放
} -- 更新函数中
local ma = this.melee.attacks[1]
S:queue(ma.sound, ma.sound_args)
S:stop(声音名称: str)
]]></description><link>第-2-节-修改基础/6.-精灵与声音.html</link><guid isPermaLink="false">第 2 节 - 修改基础/6. 精灵与声音.md</guid><pubDate>Wed, 24 Dec 2025 03:56:06 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[12. 协程]]></title><description><![CDATA[协程是 Lua 中强大的协作式多任务处理机制。与线程不同，协程是用户态的任务，由代码显式控制切换。协程可理解为有一台机器可以进行各种任务，但是一次只能进行一个任务（单线程），如果正在进行某个任务，此时要想进行另一个任务就需要暂停当前任务（让出），转而执行另一个任务，执行完毕后继续此前的任务（进度不丢失）不用协程时机器执行任务时，会一直等待直到任务完成（阻塞）才会进行下一个任务，期间什么别的都不能做。效率极低。使用协程执行任务时可随意切换任务，不至于阻塞程序。local enemy = {} function enemy.update() while true do	-- 游戏中敌人的更新函数通常为死循环 if enemy.dead then print("敌人已死亡") break end if enemy.walk then print("敌人移动中...") end print("死循环中...") end
end enemy.update()
-- 由于程序一直在死循环检测敌人，程序完全被阻塞，任何其他代码无法执行
print("这行代码无法执行到")
--[[ 输出
死循环中...
...
--]]
使用协程即可解决以上问题。协程 Coroutine：
协作式（非抢占式）：由代码控制切换（主动让出）
资源开销：轻量级，创建开销小
单线程：同一时间只有一个协程执行
可暂停：可以在任意点暂停和恢复
可预测性：可阅读代码了解执行顺序
线程 Thread：
抢占式多任务：操作系统控制（强制切换）
资源开销：内核态实现，较重
操作系统调度
可以并行执行
不可预测性
-- 创建协程
local co = coroutine.create(function() print("协程开始") coroutine.yield() -- 让出 print("协程继续")
end) -- 启动/恢复协程
coroutine.resume(co) -- 获取状态
print(coroutine.status(co)) -- suspended
local enemy = {} function enemy.update() while true do	-- 游戏中敌人的更新函数通常为死循环 if enemy.dead then print("敌人已死亡") break end if enemy.walk then print("敌人移动中...") end print("死循环中...") coroutine.yield() end
end local co = coroutine.create(enemy.update)
coroutine.resume(co) -- 现在不会阻塞程序了
print("这行代码无法执行到")
-- 通常游戏有个主循环每帧重启所有协程
coroutine.resume(co)
--[[ 输出
死循环中...
这行代码无法执行到
死循环中...
--]] suspended：挂起（创建后或让出后）
running：运行中
normal：正常（恢复其他协程时）
dead: 结束（函数执行完毕）
<img alt="Pasted image 20251215100819.png" src="site-lib/media/pasted-image-20251215100819.png" target="_self" style="width: 750px; max-width: 100%;">coroutine.create(主体函数: func) -&gt; 创建的协程: thread 创建的协程默认状态为挂起
运行时函数报错时不会抛出
local function simple_task(name) print(" 协程 " .. name .. " 开始执行") print(" 第一步: 处理数据") coroutine.yield() -- 让出执行权 print(" 第二步: 保存结果") coroutine.yield() -- 再次让出 print(" 第三步: 清理资源") return "任务完成"
end -- 创建协程（此时是挂起状态）
local co1 = coroutine.create(simple_task)
print(" 协程已创建，状态: " .. coroutine.status(co1)) -- suspended -- 运行协程
local success, result = coroutine.resume(co1, "任务A")
print(" 第一次resume结果: success=" .. tostring(success) .. ", result=" .. tostring(result))
print(" 协程状态: " .. coroutine.status(co1)) -- suspended -- 继续运行
success, result = coroutine.resume(co1)
print(" 第二次resume结果: success=" .. tostring(success))
print(" 协程状态: " .. coroutine.status(co1)) -- suspended success, result = coroutine.resume(co1)
print(" 第三次resume结果: success=" .. tostring(success) .. ", result=" .. tostring(result))
print(" 协程状态: " .. coroutine.status(co1)) -- dead
--[[ 输出
协程已创建，状态: suspended
协程 任务A 开始执行
第一步: 处理数据
第一次resume结果: success=true, result=nil
协程状态: suspended
第二步: 保存结果
第二次resume结果: success=true
协程状态: suspended
第三步: 清理资源
第三次resume结果: success=true, result=任务完成
协程状态: dead
--]]
coroutine.resume(协程: thread, 传递的参数: any...) -&gt; 是否成功: bool, 主体函数返回值|或让出时传递的参数: any
coroutine.yield(参数: any...) -&gt; 传递的参数: any...
coroutine.status(协程: thread) -&gt; 协程状态: "dead"|"normal"|"running"|"suspended"
local function status_example() print(" 协程内部状态: " .. coroutine.status(coroutine.running())) coroutine.yield() print(" 恢复执行")
end local co = coroutine.create(status_example) print(" 创建后状态: " .. coroutine.status(co))
coroutine.resume(co)
print(" 第一次yield后状态: " .. coroutine.status(co))
coroutine.resume(co)
print(" 完成后状态: " .. coroutine.status(co))
--[[ 输出 创建后状态: suspended 协程内部状态: running 第一次yield后状态: suspended 恢复执行 完成后状态: dead
--]]
创建一个新协程。返回一个函数，每次调用该函数都会运行该协程。coroutine.wrap(主体函数: func) -&gt; 包装后的函数: func
local function counter(max) for i = 1, max do print(" 计数: " .. i) coroutine.yield(i) end return "计数完成"
end -- wrap返回一个函数，而不是协程对象
local count_func = coroutine.wrap(counter) print(" 第一次调用:")
local result1 = count_func(5) -- 相当于 resume
print(" 结果: " .. tostring(result1)) print("\n 第二次调用:")
local result2 = count_func()
print(" 结果: " .. tostring(result2)) print("\n 继续调用直到完成:")
for i = 3, 6 do local result = count_func() print(" 第" .. i .. "次结果: " .. tostring(result))
end
--[[ 输出
第一次调用:
计数: 1
结果: 1 第二次调用:
计数: 2
结果: 2 继续调用直到完成:
计数: 3
第3次结果: 3
计数: 4
第4次结果: 4
计数: 5
第5次结果: 5
第6次结果: 计数完成
--]]
coroutine.running() -&gt; 当前协程: thread 如果在主线程调用将会返回 nil
local function get_current_coroutine() local running_co = coroutine.running() print(" 当前协程: " .. tostring(running_co)) if not running_co then print(" 在主线程中运行") else print(" 在协程中运行") end
end print(" 直接调用函数（在主线程）:")
get_current_coroutine() print("\n 在协程中调用:")
local co_test = coroutine.create(get_current_coroutine)
coroutine.resume(co_test)
--[[ 输出 直接调用函数（在主线程）: 当前协程: nil 在主线程中运行 在协程中调用: 当前协程: thread: 0x00d51d78 在协程中运行
--]]
print("协程的参数传递")
local function parameter_example(name, count) print(" 接收参数: name=" .. name .. ", count=" .. count) for i = 1, count do print(" 处理第" .. i .. "项") local received = coroutine.yield("进度: " .. i .. "/" .. count) if received then print(" 收到外部数据: " .. received) end end return "处理完成: " .. name
end local co_param = coroutine.create(parameter_example) -- 第一次resume传递参数
print(" 第一次resume:")
local success, progress = coroutine.resume(co_param, "数据导入", 3)
print(" 结果: success=" .. tostring(success) .. ", progress=" .. tostring(progress)) -- 后续resume传递数据给yield
print("\n 第二次resume（带数据）:")
success, progress = coroutine.resume(co_param, "继续处理")
print(" 结果: success=" .. tostring(success) .. ", progress=" .. tostring(progress)) print("\n 第三次resume（带数据）:")
success, progress = coroutine.resume(co_param, "最后一步")
print(" 结果: success=" .. tostring(success) .. ", progress=" .. tostring(progress)) print("\n 第四次resume（获取最终结果）:")
success, progress = coroutine.resume(co_param)
print(" 结果: success=" .. tostring(success) .. ", progress=" .. tostring(progress))
--[[ 输出
第一次resume:
接收参数: name=数据导入, count=3
处理第1项
结果: success=true, progress=进度: 1/3 第二次resume（带数据）:
收到外部数据: 继续处理
处理第2项
结果: success=true, progress=进度: 2/3 第三次resume（带数据）:
收到外部数据: 最后一步
处理第3项
结果: success=true, progress=进度: 3/3 第四次resume（获取最终结果）:
结果: success=true, progress=处理完成: 数据导入
--]]
一般协程之间的通信都是使用通道作为中介传递参数。-- 使用通道进行协程通信
local channels = {} local function create_channel(name) channels[name] = {} local queue = channels[name] return { send = function(value) table.insert(queue, value) coroutine.yield() -- 发送后让出 end, receive = function() while #queue == 0 do coroutine.yield() -- 等待数据 end return table.remove(queue, 1) end }
end local ch = create_channel("comm") local sender = coroutine.create(function() for i = 1, 3 do print("发送: 消息" .. i) ch.send("消息" .. i) end
end) local receiver = coroutine.create(function() for i = 1, 3 do local msg = ch.receive() print("接收: " .. msg) end
end) -- 交替执行
for i = 1, 6 do coroutine.resume(sender) coroutine.resume(receiver)
end
--[[ 输出
发送: 消息1
接收: 消息1
发送: 消息2
接收: 消息2
发送: 消息3
接收: 消息3
--]]
print("协程的处理")
local function error_example() print(" 开始执行") coroutine.yield("第一步正常") error("故意出错！") -- 抛出错误 print(" 这行不会执行")
end local co_error = coroutine.create(error_example) print(" 第一次resume（正常）:")
local success, result = coroutine.resume(co_error)
print(" 结果: success=" .. tostring(success) .. ", result=" .. tostring(result)) print("\n 第二次resume（触发错误）:")
success, result = coroutine.resume(co_error)
if not success then print(" 错误发生: " .. result)
end
print(" 协程状态: " .. coroutine.status(co_error)) -- dead
--[[ 输出 第一次resume（正常）: 开始执行 结果: success=true, result=第一步正常 第二次resume（触发错误）: 错误发生: d:\KR\VScode_KR_workspace\test.lua:4: 故意出错！ 协程状态: dead
--]] -- 安全执行模式，捕获错误
local function safe_execute(co, ...) local ok, err = coroutine.resume(co, ...) if not ok then print("协程错误: " .. err) print("协程状态: " .. coroutine.status(co)) return false, err end return true, err
end local function risky_task() error("错误！") return "成功"
end local co = coroutine.create(risky_task)
local ok, result = safe_execute(co)
print("执行结果: " .. tostring(result))
--[[ 输出
协程错误: test.lua:15: 错误！
协程状态: dead
执行结果: test.lua:15: 错误！
--]]
-- 生产者
local function producer(items) for i = 1, items do print("生产: 产品" .. i) coroutine.yield("产品" .. i) -- 生产一个就让出 end return "生产完成"
end -- 消费者
local function consumer(co) while true do local success, product = coroutine.resume(co, 5) if not success or product == "生产完成" then break end print("消费: " .. product) end print("消费完成")
end local producer_co = coroutine.create(producer)
consumer(producer_co)
--[[ 输出
生产: 产品1
消费: 产品1
生产: 产品2
消费: 产品2
生产: 产品3
消费: 产品3
生产: 产品4
消费: 产品4
生产: 产品5
消费: 产品5
消费完成
--]]
local tasks = {} -- 任务队列 local function add_task(func, ...) local co = coroutine.create(func) table.insert(tasks, {co = co, args = {...}})
end local function scheduler() while #tasks &gt; 0 do local task = table.remove(tasks, 1) local ok, result = coroutine.resume(task.co, unpack(task.args)) if coroutine.status(task.co) == "suspended" then -- 任务还未完成，放回队列 table.insert(tasks, task) end end
end -- 添加任务
add_task(function(name) print("任务 " .. name .. " 开始") coroutine.yield() print("任务 " .. name .. " 继续") coroutine.yield() print("任务 " .. name .. " 完成")
end, "A") add_task(function(name) print("任务 " .. name .. " 步骤1") coroutine.yield() print("任务 " .. name .. " 步骤2")
end, "B") -- 运行调度器
scheduler()
--[[ 输出
任务 A 开始
任务 B 步骤1
任务 A 继续
任务 B 步骤2
任务 A 完成
--]]
-- 使用协程实现迭代器
local function walk_list(list) return coroutine.wrap(function() for i = 1, #list do coroutine.yield(i, list[i]) end end)
end -- 使用示例
local list = { "a", "b", "c"
} for i, v in walk_list(list) do print(i .. ": " .. v)
end
--[[ 输出
1: a
2: b
3: c
--]]
<br>（答案见<a data-href="第 1 节 - 语法/参考答案#练习 12 1：使用协程实现生成器" href="第-1-节-语法/参考答案.html#练习 12 1：使用协程实现生成器" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 12 1：使用协程实现生成器</a>）-- 使用协程实现一个范围生成器
-- 使用示例：
for i in range(1, 10, 2) do print(i)
end
--[[ 输出
1
3
5
7
9
--]] 协程核心概念： 协作式多任务：由程序控制切换（主动让出）
四种状态：suspended、running、normal、dead
轻量级：比线程轻量，适合 I/O 密集型任务
可预测性：可阅读代码预测执行顺序 核心函数： coroutine.create - 创建协程
coroutine.resume - 启动/恢复执行
coroutine.yield - 让出执行权
coroutine.status - 获取状态
coroutine.wrap - 包装为函数
coroutine.running - 获取当前协程 数据传递： resume 参数传递给函数或 yield
yield 返回值给 resume
支持多值传递
协程之间的通信 错误处理： resume 返回 success 标志
协程内错误不会影响主线程 实用模式： 生产者-消费者模式
异步任务调度
迭代器实现 -- 错误：resume 重启已结束的协程
local co = coroutine.create(function() return "done"
end)
coroutine.resume(co) -- 正确
coroutine.resume(co) -- 错误！协程已dead -- 技巧：使用wrap简化调用
local gen = coroutine.wrap(function() for i = 1, 3 do coroutine.yield(i) end
end)
print(gen(), gen(), gen()) -- 1, 2, 3 -- 注意：yield不能在某些C函数中使用
local function bad_example() table.sort({}, function() coroutine.yield() -- 错误！ end)
end -- 技巧：使用协程实现状态保持
local function counter() local count = 0 return coroutine.wrap(function() while true do count = count + 1 coroutine.yield(count) end end)
end local c = counter()
print(c(), c(), c()) -- 1, 2, 3
（点击勾选框勾选）
完成本章后，你应该能够：
理解协程与线程的区别
创建、启动和暂停协程
在协程间传递数据
使用协程实现生产者-消费者模式
处理协程执行中的错误
使用协程创建迭代器 为什么 Lua 选择使用协程，而不是线程？
协程的 "协作式" 与线程的 "抢占式" 有什么根本区别？
协程的 yield 和 return 在数据传递上有什么不同？
如何用协程实现一个简单的状态机？
下一章预告：在第 13 章中，我们将学习元表，让我们能够控制其他表的各种行为，实现面向对象编程，向量加减等。]]></description><link>第-1-节-语法/12.-协程.html</link><guid isPermaLink="false">第 1 节 - 语法/12. 协程.md</guid><pubDate>Wed, 24 Dec 2025 03:20:28 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[15. Love 2D]]></title><description><![CDATA[Love 2D 是一个免费的开源 2D 游戏引擎，使用 Lua 作为脚本语言。Love 2D 主要特性:
简单易用的 API
跨平台支持（Windows, macOS, Linux, Android, iOS）
内置物理引擎（Box2D）
支持多种图像、音频格式
强大的着色器支持
网络功能
文件系统访问
-- LOVE2D 基础示例 -- LOVE2D 回调函数结构
print("\nLOVE2D 主要回调函数:")
print(" love.load() -- 游戏初始化")
print(" love.update(dt) -- 游戏逻辑更新")
print(" love.draw() -- 游戏渲染")
print(" love.keypressed() -- 键盘按下")
print(" love.mousepressed() -- 鼠标按下") -- 简单的 LOVE2D 程序结构
local function love_template() return [[
function love.load() -- 初始化代码 print("游戏加载完成!")
end function love.update(dt) -- 每帧更新逻辑 -- dt 是帧时间（秒）
end function love.draw() -- 每帧绘制 love.graphics.print("Hello LOVE2D!", 400, 300)
end function love.keypressed(key) if key == "escape" then love.event.quit() end
end
]]
end print("\n 基本程序结构示例:")
print(love_template())
]]></description><link>第-1-节-语法/15.-love-2d.html</link><guid isPermaLink="false">第 1 节 - 语法/15. Love 2D.md</guid><pubDate>Tue, 23 Dec 2025 10:09:28 GMT</pubDate></item><item><title><![CDATA[5. 路径]]></title><description><![CDATA[P:path_width(路径: int, 子路径: int, 节点: int) -&gt; 宽度: int
P:node_pos(路径: int, 子路径: int, 节点: int, 是否返回引用?: bool) -&gt; 节点坐标: vec2
P:node_offset_pos(偏移量: int, 路径: int, 子路径: int, 节点: int) -&gt; 节点坐标: vec2
P:get_start_node(路径: int) -&gt; 节点: int
P:get_end_node(路径: int) -&gt; 节点: int
P:get_defend_point_node(路径: int) -&gt; 节点: int
P:nodes_from_start(路径: int, 子路径: int, 节点: int) -&gt; 节点距离: int
P:nodes_to_goal(路径: int, 子路径: int, 节点: int) -&gt; 节点距离: int
P:nodes_to_defend_point(路径: int, 子路径: int, 节点: int) -&gt; 节点距离: int
P:get_visible_end_node(路径: int) -&gt; 节点: int
P:get_visible_start_node(路径: int) -&gt; 节点: int
P:point_within_distance(x, y, 距离: num) -&gt; 是否存在: bool
P:nearest_nodes( x, y, 路径?: list{ 路径: int... }, 子路径?: list{ 子路径: int... }, 是否仅有效节点: bool, 节点标签: int, 过滤函数?: func, 步长: int
) -&gt; 节点列表: list{list{ 路径: int, 子路径: int, 节点: int, 距离: num }...} 返回一个根据距离排序的节点列表
不指定路径将会在所有路径查找节点
子路径默认值 { 1 }
P:path_terrain_types(路径: int) -&gt; 地形: int
P:path_terrain_props(路径: int) -&gt; 地形属性: int
P:is_path_active(路径: int) -&gt; 是否启用: bool
P:activate_path(路径: int)
P:deactivate_path(路径: int)
P:add_invalid_range(路径: int, 最小范围: int, 最大范围: int, 标签: int)
P:remove_invalid_range(路径: int, 最小范围: int, 最大范围: int)
P:is_node_valid(路径: int, 节点: int, 节点标签: int) -&gt; 是否有效: bool
P:get_valid_nodes(路径: int, 节点标签: int) -&gt; 有效节点列表: list{ 节点: int... }
P:valid_node_nearby(x, y, 路径宽度乘数: num, 节点标签: int) -&gt; 是否存在: bool
P:get_random_position( 边距: int | list{ 前边距: int, 后边距: int }, 地形: int, 节点标签: int, 边距是否从防守点开始计算: bool
) -&gt; 节点坐标: vec2, 路径: int, 子路径: int, 节点: int
P:get_next_pi(路径: int) -&gt; 连接的下一路径: int
P:get_connected_paths(路径: int) -&gt; 连接路径列表: list{ 路径: int... }
P:get_all_valid_pos( x, y, 最小距离: num, 最大距离: num, 地形: int, 过滤函数: func, 标签: int, 子路径: list{ 子路径: int }
) -&gt; 有效节点列表: list{ 节点: int... }
]]></description><link>总结/5.-路径.html</link><guid isPermaLink="false">总结/5. 路径.md</guid><pubDate>Tue, 23 Dec 2025 03:05:12 GMT</pubDate></item><item><title><![CDATA[9. 工具函数]]></title><description><![CDATA[U.find_enemies_in_range( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func
) -&gt; 范围内所有敌人: list 实体列表通常为 store.entities
为过滤函数传递：实体、原点
过滤函数用于筛选目标，返回假的目标将会被筛选
U.find_foremost_enemy( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 预判时间: num, 标签: int, 禁止标签: int, 过滤函数?: func, 禁用最小半径的标签: int
) -&gt; 首个敌人: table, 范围内所有敌人: list{敌人: table...}, 预判位置: vec2 禁用最小半径的标签：拥有此标签的目标不受搜索最小半径限制
U.find_nearest_enemy( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func
) -&gt; 最近敌人: table, 范围内所有敌人: list{敌人: table...}
U.find_random_enemy( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func
) -&gt; 随机敌人: table
U.find_soldiers_in_range( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func
) -&gt; 范围内所有士兵: list{士兵: table...}
U.find_nearest_soldier( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func
) -&gt; 最近士兵: table
U.find_targets_in_range( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func
) -&gt; 范围内所有目标: list{目标: table...} 目标包含敌人与士兵
U.find_first_target( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func
) -&gt; 首个目标: table
U.find_random_target( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func
) -&gt; 随机目标: table
U.find_towers_in_range( 实体列表: list, 原点: vec2, 攻击: table, 过滤函数?: func
) -&gt; 范围内所有防御塔: list
U.find_enemies_in_paths( 实体列表: list, 原点: vec2, 最小节点距离: int, 最大节点距离: int, 最大距离: num, 标签: int, 禁止标签: int, 是否仅上游: bool, 过滤函数?: func
) -&gt; 排序后的敌人列表: list{{敌人: table, 节点: int}...} 返回根据到终点距离排序的列表
是否仅上游: 指定是否只筛选位于当前节点上游或下游的敌人
U.find_paths_with_enemies(实体列表: list, 标签: int, 禁止标签: int, 过滤函数?: func) -&gt; 所有路径列表: list
U.find_entity_at_pos(实体列表: list, x: num, y: num, 过滤函数?: func) -&gt; 实体: table
U.get_modifiers(store, 实体: table, 效果表: table) -&gt; 拥有的效果实体: table 若不传递效果表则返回所有拥有的效果实体
U.has_modifiers(store, 实体: table, 效果模板名: str) -&gt; 是否拥有: bool, 找到的效果实体: table 若不传递效果模板名称则返回所有效果
U.has_modifier_in_list(store, 实体: table, 效果表: table) -&gt; 是否拥有: bool
U.has_modifier_types(store, 实体: table, 效果类型: int...) -&gt; 是否拥有: bool, 所有找到的效果实体: table
U.get_blocker(store, 被拦截者: table) -&gt; 拦截者: table
U.get_blocked(store, 拦截者: table) -&gt; 被拦截者: table
U.blocker_rank(store, 拦截者: table) -&gt; 索引: int
U.is_blocked_valid(store, 拦截者: table) -&gt; 是否可被拦截: bool
U.unblock_all(store, 被拦截者: table)
U.unblock_target(store, 拦截者: table)
U.block_enemy(store, 拦截者: table, 被拦截者: table)
U.replace_blocker(store, 原拦截者: table, 新拦截者: table)
U.cleanup_blockers(store, 被拦截者: table)
U.y_wait(store, 等待时间: num, 中断函数?: func) -&gt; 是否被中断: bool 在指定时间内循环挂起协程
中断函数用于提前终止暂停
U.animation_start( 实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 是否循环播放: bool, 精灵索引?: int, 强制重置时间戳: bool
) 不指定精灵索引将会使所有精灵播放动画
U.animation_finished(实体: table, 精灵索引?: int, 播放次数?: int) -&gt; 是否完成: bool 精灵索引默认为 1
播放次数默认为 1
循环动画将根据播放完成次数判断
U.y_animation_wait(实体: table, 精灵索引?: int, 播放次数?: int) 精灵索引默认为 1
播放次数默认为 1
若动画没有完成则循环挂起函数，直到动画播放完成
循环动画将根据播放完成次数判断
U.y_animation_play(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数?: int, 精灵索引?: int) 是 animation_start 与 y_animation_wait 的结合
精灵索引默认为 1
播放次数默认值为 1
U.animation_start_group(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 是否循环: bool, 组名: str)
U.animation_finished_group(实体: table, 组名: str, 播放次数?: int) -&gt; 是否完成: bool 播放次数默认值为 1
U.y_animation_wait_group(实体: table, 组名: str, 播放次数?: int) 播放次数默认值为 1
U.y_animation_play_group(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数?: int, 组: int) 是 animation_start_group 与 y_animation_wait_group 的结合
播放次数默认值为 1
U.animation_name_for_angle( 实体: table, 组名: str, 角度: num, 精灵索引?: int
) -&gt; 动画名: str, 是否水平翻转: bool, 象限索引: int 精灵索引默认值为 1
在精灵的 angles 键中选择动画
U.animation_name_facing_point( 实体: table, 组名: str, 目标点: vec2, 精灵索引?: int, 偏移: vec2, 是否使用路径: bool
) -&gt; 动画名: str, 是否水平翻转: bool, 象限索引: int 精灵索引默认为 1
在精灵的 angles 键中选择动画
U.get_animation_ts(实体: table, 组: int) -&gt; 时间戳: num
U.sprites_hide(实体: table, 起始索引: int, 结束索引: int, 是否计数: bool) 计数存入精灵 hidden_count 键
U.sprites_show(实体: table, 起始索引: int, 结束索引: int, 是否计数: bool)
]]></description><link>总结/9.-工具函数.html</link><guid isPermaLink="false">总结/9. 工具函数.md</guid><pubDate>Tue, 23 Dec 2025 03:04:00 GMT</pubDate></item><item><title><![CDATA[6. 网格]]></title><description><![CDATA[GR:get_coords(x, y) -&gt; 网格x坐标: int, 网格y坐标: int
GR:cell_type(x, y) -&gt; 地形: int, 网格x坐标: int, 网格y坐标: int
GR:cell_is(x, y, 地形: int) -&gt; 是否包含: bool
GR:cell_is_only(x, y, 地形: int) -&gt; 是否仅包含: bool
GR:set_cell_type(x, y, 地形: int) -&gt; 地形: int
GR:set_cell(网格x坐标: int, 网格y坐标: int, 地形: int)
GR:get_cell(网格x坐标: int, 网格y坐标: int) -&gt; 地形: int
GR:cell_pos(网格x坐标: int, 网格y坐标: int) -&gt; x, y 返回单元格中心位置
GR:set_grid_size(新长度: int, 新高度: int) 保持原有数据居中，新增单元格填充默认值 0
GR:set_grid_offset(x, y)
GR:print_cell(地形: int) -&gt; 字符串: str
GR:find_waypoints(起点: vec2, 备用起点?: vec2, 终点: vec2, 有效地形: int, 是否不读取缓存: bool) -&gt; 点位: list{vec2...}
GR:find_line_waypoints(起点: vec2, 终点: vec2, 有效地形: int)
-&gt; 点位: list{vec2...}, 网格坐标: list{vec2...}
]]></description><link>总结/6.-网格.html</link><guid isPermaLink="false">总结/6. 网格.md</guid><pubDate>Tue, 23 Dec 2025 02:42:16 GMT</pubDate></item><item><title><![CDATA[4. 关卡]]></title><description><![CDATA[关卡中所有数据存储于 kr/data/levels 中其中：
无后缀为关卡的函数
_data 为关卡参数
_paths 为路径数据
_gird 为网格数据
locked_hero = 是否锁定英雄: bool,
max_upgrade_level = 科技最大等级: int,
locked_towers = { -- 锁定的防御塔 防御塔模板名 1: str, -- 防御塔模板名 2...
},
available_towers = { -- 可用的防御塔（五代可用） 防御塔模板名 1: str, -- 防御塔模板名 2...
},
locked_powers { -- 锁定的能力 是否锁定对应索引的能力: bool
},
entities_list = { -- 进入关卡创建的实体 { -- 实体 1 template = 创建的实体模板名: str, pos = 实体位置: vec2, }, -- 实体 2...
},
level_mode_overrides = {	-- 不同模式覆盖的键（战役模式索引为 1、英雄为 2、钢铁为 3） {}, -- 战役模式 { -- 英雄模式 max_upgrade_level = 2	-- 英雄模式下科技最大等级 2 }
},
required_sounds = { -- 加载的音效资源 资源 1 名称: str, -- 资源 2 名称...
},
required_textures = { -- 加载的美术资源 资源 1 名称: str, -- 资源 2 名称...
}
required_exoskeletons = {	-- 加载的骨骼动画资源 资源 1 名称: str, -- 资源 2 名称...
}
路径用于规定怪物的行走路线，缩写为 P存储位置：all/path_db 的 paths 表中
读取位置：读取 kr/data/levels 中的关卡路径数据（_paths）路径中：
ni 为节点索引（node index），即一条路径中的位置
pi 为路径索引（path index），即不同路径
spi 为子路径索引（subpath index），即路径中的三个分支
<img alt="Pasted image 20250812125430.png" src="site-lib/media/pasted-image-20250812125430.png" target="_self">
如图所示一条路径有三条子路径，白点为节点，关卡内按 H 即可显示路径
在 level_data 的 entities_list 增加一个实体，在这个实体更新函数写召唤逻辑即可-- 模板
tt = RT("s_spawner_entities")
AC(tt, "main_script", "editor")
tt.main_script.update = scripts.s_spawner_entities.update
tt.ts = 0
tt.entity = "enemy_halloween_zombie"	-- 召唤的实体
tt.spawn_margin = { 30,	-- 距离起点边距 60	-- 距离终点边距
}
tt.spawn_cooldown = 3	-- 召唤间隔
tt.spawn_count = 1 -- 召唤数量
tt.spawn_wave = 1 -- 开始召唤的波次
tt.spawn_path = { -- 生成的路径 1, 2, 3
}
tt.enemy_gold = 0.5	-- 召唤的敌人赏金乘数 -- 函数
scripts.s_spawner_entities = {}
function scripts.s_spawner_entities.update(this, store) local pi, spi, ni local p_pi, p_spi = this.spawn_path, { 1, 2, 3 } local start_margin, end_margin = unpack(this.spawn_margin) while true do if store.waves_finished then break end -- 计算召唤间隔 if store.wave_group_number &gt;= this.spawn_wave and this.spawn_cooldown &lt; store.tick_ts - this.ts then this.ts = store.tick_ts for i = 1, this.spawn_count do -- 取随机路径上随机节点 pi, spi = table.random(p_pi), table.random(p_spi) ni = math.random(P:get_start_node(pi) + start_margin, P:get_end_node(pi) - end_margin) -- 召唤实体 local e = E:create_entity(this.entity) e.pos = P:node_pos(pi, spi, ni) e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = pi, spi, ni e.render.sprites[1].name = "raise" e.enemy.gold = e.enemy.gold * this.enemy_gold queue_insert(store, e) end end coroutine.yield() end queue_remove(store, this)
end -- 关卡数据
entities_list = { { template = "s_spawner_entities", pos = { x = 0, y = 0 } } ...
}
波次的所有数据存储于 kr/data/waves 中其中：
_campaign 为战役模式（1）
_heroic 为英雄模式（2）
_iron 为钢铁模式（3） 时间单位为游戏帧
所有出怪组都是并发的，使用出怪组延迟控制
出怪组一般用于多个怪物组合进攻与进攻不同路径
交替出怪用于两个怪物轮流进攻
每个组的怪物只有前一个出完才会出下一个
cash = 初始金币: int,
groups = { -- 所有波次 { -- 第 1 波 interval = 下一波到来时间: num, waves = { -- 出怪组 { -- 第 1 组 delay = 延迟: num, path_index = 出怪路径: int, spawns = { -- 生成的怪物 { -- 怪物 1 interval = 生成间隔: num, creep = 怪物模板名: str, creep_aux = 交替怪物模板名: str,	-- 每次出 max_same 数量的怪交替怪物 max_same = 交替数量: int, max = 出怪总数量: int, -- 包含交替的怪物 fixed_sub_path = 出怪子路径: int,	-- 0 为随机 1-3，1 为 path 指定的子路径 path = 子路径: int, -- 用于 fixed_sub_path interval_next = 下一个怪物的延迟: num }, -- 怪物 2... } }, -- 第 2 组... } }, -- 第 2 波...
}
由于出怪数据的表不易于查看修改，推荐使用附件的波次生成脚本修改<br>
<img alt="Pasted image 20250828164236.png" src="site-lib/media/pasted-image-20250828164236.png" target="_self" style="width: 750px; max-width: 100%;"><br><img alt="Pasted image 20250828164839.png" src="site-lib/media/pasted-image-20250828164839.png" target="_self" style="width: 550px; max-width: 100%;">
数字改成你修改的关卡编号，然后直接替换波次数据即可.在关卡数据的 required_textures 键增加对应资源即可。required_textures = { "go_enemies_bandits",	-- 强盗支线的所有怪物资源 ...
}
图像资源基本都在 _assets/kr-desktop/images/fullhd 内注：有些实体的资源在关卡资源内特殊出怪数据位于 kr/data/levels/levelxx_spawner 中groups = { -- 组 { -- 组 1 可能出怪点位 1: int, -- 可能出怪点位 2... }, -- 组 2...
},
points = { -- 出怪点位 { -- 点位 1 path = int, -- 生成路径 from = vec2,	-- 生成位置 to = vec2 -- 实际生成节点位置 }, -- 点位 2...
},
waves = {	-- 生成的波次 { -- 战役模式（战役 1，英雄 2，钢铁 3）的生成 {	-- 第 1 波 {	-- 出怪 1 延迟: num, 延迟随机变化值: num, 组: int, 生成子路径: int, 生成数量: int, 是否所有点位同时出怪: bool, 顺序生成/并行生成: bool, 出怪随机间隔最小值: num, 出怪随机间隔最大值: num, 生成怪物模板名: str, 自定义参数: any }, -- 出怪 2... }, -- 第二波... }, -- 英雄模式的生成...
}
-- 关卡数据
entities_list = { {	-- 加载的特殊出怪数据 template = "mega_spawner", load_file = "level417_spawner",	-- 特殊出怪文件名 }
} -- 特殊出怪数据
groups = { -- 组 { 1 -- 组 1 生成在点位 1 }
},
points = { -- 点位 { -- 点位 1 path = 3,	-- 位于路径 3 from = {	-- 点位坐标 x = 260, y = 147 }, to = { x = 260, y = 147 } }
},
waves = { -- 生成的波次 [1] = { -- 战役模式 [3] = { -- 第 3 波 { 2.6, -- 延迟 2.6 秒 0, -- 延迟不随机变化 1, -- 组 1 1, -- 生成到子路径 1 1, -- 生成 1 个 false, -- 所有点位不同时出怪 true, -- 顺序出怪 4, -- 出怪随机间隔最小值 4, -- 出怪随机间隔最大值 "enemy_chaser"	-- 怪物模板名 } } }
}
包可以理解为模板，提前创建，后续快速使用。缺点是无法指定点位，只能生成在起点节点packs = { -- 包 包 1 名称 = { {	-- 出怪 1 延迟: num, 延迟随机变化值: num, nil, 生成子路径: int, 生成数量: int, nil, nil, 出怪随机间隔最小值: num, 出怪随机间隔最大值: num, 生成怪物模板名: str } -- 出怪 2... }, -- 包 2...
},
waves = {	-- 生成的波次 { -- 战役模式（战役 1，英雄 2，钢铁 3）的生成 {	-- 第 1 波 {	-- 出怪 1 nil, nil, nil, nil, nil, nil, nil, nil, nil, "PACK", -- 生成怪物模板名改为 "PACK" { spawnPackId = 生成的包名: str, path = 生成路径: int } }, -- 出怪 2... }, -- 第二波... }, -- 英雄模式的生成...
}
-- 关卡数据
entities_list = { {	-- 加载的特殊出怪数据 template = "mega_spawner", load_file = "level417_spawner", }
} -- 特殊出怪数据
packs = { -- 包 frogs = { { 0, -- 延迟 0 帧 0, -- 延迟不随机变化 nil, 1, -- 生成到子路径 1 1, -- 生成 1 个 nil, nil, 4, -- 4, -- 出怪随机间隔 4 ~ 4 "enemy_chaser"	-- 怪物模板名 "enemy_chaser" }, { 2, -- 延迟 2 帧 0, -- 延迟不随机变化 nil, 1, -- 生成到子路径 1 10, -- 生成 10 个 nil, nil, 4, -- 4, -- 出怪随机间隔 4 ~ 4 "enemy_chaser"	-- 怪物模板名 "enemy_chaser" }, }
}
waves = { -- 生成的波次 [1] = { -- 战役模式 [3] = { -- 第 3 波 { nil, nil, nil, nil, nil, nil, nil, nil, nil, "PACK",	-- 出怪包模式 { spawnPackId = "frogs",	-- 生成包 "frogs" 的怪物 path = 1 -- 生成路径 } } } }
}
通常用于给一些生成器实体发送出怪信号，用于检查是否正在出怪，播放动画等groups = { -- 组 组名 = { 生成器名称1: str, -- 生成器名称2... }
},
waves = {	-- 生成的波次 { -- 战役模式（战役 1，英雄 2，钢铁 3）的生成 {	-- 第一波 {	-- 出怪 1 延迟: num, 延迟随机变化值: num, 组: int, nil, nil, nil, nil, nil, nil, "CUSTOM", -- 生成怪物模板名改为 "CUSTOM" 为生成器的 spawner.spawn_data 键传递的数据: any }, -- 出怪 2... }, -- 第二波... }, -- 英雄模式的生成
}
-- 关卡数据
entities_list = { { template = "bullywag_spawner", pos = { x = 260, y = 147 }, ["spawner.name"] = "object1" }, {	-- 加载的特殊出怪数据 template = "mega_spawner", load_file = "level417_spawner", },
}, -- 特殊出怪数据
groups = { -- 组 { 1 -- 组 1 生成在点位 1 }, som1 = { "object1",	-- 组 "som1" 为 "object1" 也就是 "bullywag_spawner" 传递数据 }
},
points = { -- 点位 { -- 点位 1 path = 3,	-- 位于路径 3 from = {	-- 点位坐标 x = 260, y = 147 }, to = { x = 260, y = 147 } }
},
waves = { -- 生成的波次 [1] = { -- 战役模式 [3] = { -- 第 3 波 { -- 出怪前 1.6 秒（动画时间）给 "som1" 组内的所有生成器传递 true 1, -- 延迟 0, -- 延迟随机变化值 "som1", -- 组 "som1" nil, nil, nil, nil, nil, nil, "CUSTOM",	-- 生成器模式 true -- 为生成器的 spawner.spawn_data 键传递的数据 }, { 2.6, -- 延迟 2.6 帧 0, -- 延迟不随机变化 1, -- 组 1 1, -- 生成子路径 1, -- 生成 1 个 false, -- 所有点位不同时出怪 true, -- 顺序出怪 4, -- 4, -- 出怪随机间隔 4 ~ 4 "enemy_chaser"	-- 怪物模板名 "enemy_chaser" } } }
} -- 生成器实体更新函数
function scripts.basic_spawner.update(this, store, script) while true do if this.spawner.spawn_data then print("当前生成器生成怪物") this.spawner.spawn_data = nil else print("当前生成器未生成怪物") end coroutine.yield() end queue_remove(store, this)
end 网格用于通过设定单元格类型来设定地形，例如水路、冰面等。实体可以通过判断地形来进行一些逻辑，例如判断脚下地形如果是冰面则开始滑冰增加移动速度。网格同时也会规范寻路。网格缩写为 GR<br><img alt="Pasted image 20251223100412.png" src="site-lib/media/pasted-image-20251223100412.png" target="_self" style="width: 600px; max-width: 100%;">
如图所示绿色部分的单元格类型为不可移动，也就是说修改英雄集结点英雄只会在灰色部分寻路，关卡内按 g 显示网格存储位置：all/grid_db 的 grid 表中
读取位置：读取 kr/data/levels 中的关卡网格数据（_grid）]]></description><link>第-2-节-修改基础/4.-关卡.html</link><guid isPermaLink="false">第 2 节 - 修改基础/4. 关卡.md</guid><pubDate>Tue, 23 Dec 2025 02:41:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. 常量]]></title><link>总结/3.-常量.html</link><guid isPermaLink="false">总结/3. 常量.md</guid><pubDate>Tue, 23 Dec 2025 02:40:51 GMT</pubDate></item><item><title><![CDATA[4. 关卡]]></title><link>总结/4.-关卡.html</link><guid isPermaLink="false">总结/4. 关卡.md</guid><pubDate>Tue, 23 Dec 2025 02:11:56 GMT</pubDate></item><item><title><![CDATA[参考答案]]></title><description><![CDATA[ -- 模板内：
tt = RT("hero_alleria", "hero")
AC(tt, "melee", "ranged", "timed_attacks", "dodge")
...
tt.dodge.chance = 0.5
tt.dodge.silent = false
tt.melee.attacks[1].mod = "mod_poison" tt = RT("arrow_hero_alleria", "arrow")
tt.bullet.mod = "mod_lava"
tt = RT("mod_deadly_poison", "mod_poison")
tt.modifier.duration = 5
tt.dps.damage_inc = 1
tt.dps.damage_min = 10
tt.dps.damage_max = 15
tt.dps.damage_every = 0.5
tt.dps.damage_type = DAMAGE_TRUE
tt.modifier.bans = { "mod_freeze"
}
tt.modifier.remove_banned = true
function scripts.hero_shadow_assassin.update(this, store) local skill = this.hero.skills.shadow_assault local attack = this.timed_attacks.list[3] while true do if skill.level &gt; 0 and not attack.disabled then if store.tick_ts - attack.ts &gt;= attack.cooldown then -- 记录技能检查通过 log.debug("暗影突袭技能检查: 等级=%d, 冷却=%f, 剩余冷却=%f", skill.level, attack.cooldown, store.tick_ts - attack.ts) -- 1. 索敌：找到范围内所有敌人 local enemies = U.find_enemies_in_range( store.entities, this.pos, 0, attack.radius, attack.vis_flags, attack.vis_bans ) if not enemies or #enemies == 0 then -- 没有找到目标，记录警告但不中断游戏流程 log.warning("暗影突袭未找到目标: 实体ID=%d, 位置=(%.1f,%.1f), 范围=%d", this.id, this.pos.x, this.pos.y, attack.radius) return end log.debug("找到 %d 个潜在目标", #enemies) -- 2. 找到血量最低的敌人 -- 首先过滤掉无效或已死亡的敌人 local valid_enemies = {} for _, enemy in ipairs(enemies) do if enemy and enemy.health and enemy.health.hp &gt; 0 then table.insert(valid_enemies, enemy) end end if #valid_enemies == 0 then log.warning("所有目标都已死亡或无效") return end -- 按血量排序（升序） table.sort(valid_enemies, function(a, b) return a.health.hp &lt; b.health.hp end) local target = valid_enemies[1] log.info("选择目标: ID=%d, 血量=%d/%d, 位置=(%.1f,%.1f)", target.id, target.health.hp, target.health.hp_max, target.pos.x, target.pos.y) -- 偏执级日志：记录详细选择过程 log.paranoid("目标选择详情:") for i, enemy in ipairs(valid_enemies) do log.paranoid(" [%d] ID=%d, 血量=%d, 距离=%.1f", i, enemy.id, enemy.health.hp, V.dist(this.pos, enemy.pos)) end -- 3. 计算伤害 local damage = attack.damage_base + attack.damage_per_level * skill.level log.debug("伤害计算: 基础=%d, 等级加成=%d, 总伤害=%d", attack.damage_base, attack.damage_per_level * skill.level, damage) -- 4. 创建并排队伤害实体 local d = E:create_entity("damage") d.value = damage d.source_id = this.id d.target_id = target.id d.damage_type = attack.damage_type log.paranoid("伤害实体创建成功: 值=%d, 来源=%d, 目标=%d", d.value, d.source_id, d.target_id) queue_damage(store, d) -- 5. 创建并排队流血效果 local mod = E:create_entity(attack.mod) mod.modifier.target_id = target.id mod.modifier.source_id = this.id queue_insert(store, mod) log.debug("流血效果已应用: 模板=%s, 目标=%d", attack.mod, target.id) -- 6. 刷新技能时间戳 attack.ts = store.tick_ts log.debug("技能时间戳更新: %f -&gt; %f", attack.ts - attack.cooldown, attack.ts) -- 7. 播放动画和音效 U.animation_start(this, attack.animation, nil, store.tick_ts) log.paranoid("播放动画: %s", attack.animation) S:queue(attack.sound) log.paranoid("播放音效: %s", attack.sound) -- 8. 记录技能释放成功 log.info("暗影突袭释放成功: 实体ID=%d -&gt; 目标ID=%d, 伤害=%d", this.id, target.id, damage) -- 9. 等待动画完成（如果需要） U.y_animation_wait(this, store.tick_ts) log.paranoid("动画播放完成") else -- 技能冷却中，偶尔记录调试信息 if math.random() &lt; 0.01 then -- 1%的概率记录，避免日志过多 local remaining = attack.cooldown - (store.tick_ts - attack.ts) log.paranoid("技能冷却中: 剩余 %.2f秒", remaining) end end else -- 技能未解锁或已禁用 if not attack.disabled and math.random() &lt; 0.001 then log.todo("检查技能解锁条件: 当前等级=%d, 需要等级=1", skill.level) end end coroutine.yield() end
end
]]></description><link>第-2-节-修改基础/参考答案.html</link><guid isPermaLink="false">第 2 节 - 修改基础/参考答案.md</guid><pubDate>Mon, 22 Dec 2025 12:06:27 GMT</pubDate></item><item><title><![CDATA[9. 闪避逻辑]]></title><description><![CDATA[攻击者攻击时调用 SU.unit_dodges 闪避函数若目标闪避此次攻击，则将目标的 dodge.active 设为真闪避：没有被眩晕、闪避冷却完毕...进行闪避反击]]></description><link>总结/逻辑/9.-闪避逻辑.html</link><guid isPermaLink="false">总结/逻辑/9. 闪避逻辑.canvas</guid><pubDate>Mon, 22 Dec 2025 11:50:03 GMT</pubDate></item><item><title><![CDATA[7. 近战攻击逻辑]]></title><description><![CDATA[在实体插入函数调用 U.attack_order 函数排序攻击遍历攻击表，根据以下条件排序其概率不同，释放概率低者在前概率相同，冷却时间长者在前所有条件相同，攻击表索引低者在前排序后返回到实体攻击的 order在实体更新函数调用 SU.y_soldier_melee_block_and_attacks 函数进行近战攻击调用 SU.soldier_pick_melee_target 函数寻找拦截范围内的目标调用 SU.soldier_pick_melee_attack 函数得到可用攻击根据攻击类型：单体攻击、多次攻击、范围攻击，调用对应攻击类型的函数按顺序遍历攻击的 order 表闪避反击可用优先返回其基础造成伤害，不进行赘叙可用攻击：攻击没有禁用、攻击冷却完毕、标签没有被禁用...]]></description><link>总结/逻辑/7.-近战攻击逻辑.html</link><guid isPermaLink="false">总结/逻辑/7. 近战攻击逻辑.canvas</guid><pubDate>Mon, 22 Dec 2025 11:49:52 GMT</pubDate></item><item><title><![CDATA[12. 库]]></title><description><![CDATA[log:new(打印的日志前缀: str, 日志等级?: int) -&gt; 日志实例: table 推荐在 args 修改全局日志等级
[22841.0227] image_db.DEBUG preload_atlas() - load atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000 [22841.0227] 为时间信息
image_db 为前缀
DEBUG 为等级，调试五级
preload_atlas 调用的函数
load atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000 信息
log.paranoid(信息: str, 用于格式化的参数: any...)
log.debug(信息: str, 用于格式化的参数: any...)
log.todo(信息: str, 用于格式化的参数: any...)
log.info(信息: str, 用于格式化的参数: any...)
log.warning(信息: str, 用于格式化的参数: any...)
log.error(信息: str, 用于格式化的参数: any...)
log.assert(条件: bool, 信息: str, 用于格式化的参数: any...)
log.traceall(信息?: str)
log.traceall(显示的调用栈深度: int)
macros.pi = 3.1415926535898 -- 圆周率 π
macros.twopi = 6.2831853071796 -- 2π
macros.pi_2 = 1.5707963267949 -- π/2
macros.pi_4 = 0.78539816339745 -- π/4
macros.unroll(角度: num) -&gt; 归一化后的角度: num 将任意弧度角归一化到 [0, 2π] 范围内
macros.unroll_deg(角度: num) -&gt; 归一化后的角度: num 将任意角度制角度归一化到 [0, 360] 范围内
macros.signed_unroll(角度: num) -&gt; 归一化后的角度: num 使用 macros.fmod 进行归一化，保持符号信息
macros.signed_unroll_deg(角度: num) -&gt; 归一化后的角度: num 使用 math.fmod 进行角度制归一化，保持符号信息
macros.short_angle(起始角: num, 目标角: num) -&gt; 最短角度差: num 计算从 起始角 到 目标角 的最短弧度差，结果在 [-π, π] 范围内
macros.short_angle_deg(起始角: num, 目标角: num) -&gt; 最短角度差: num 计算从 起始角 到 目标角 的最短角度差，结果在 [-180, 180] 范围内
macros.clamp_signed(最小值: num, 最大值: num, 数值: num) -&gt; 限制后的值: num 将数值限制在指定范围内（要求最小值 ≤ 最大值）
macros.clamp(边界1: num, 边界2: num, 数值: num) -&gt; 限制后的值: num 使用 macros.clamp_signed 将数值限制在指定范围内，自动处理边界顺序
macros.zmod(值: num, 模数: num) -&gt; 取模结果: num 返回 ((值 - 1) % 模数) + 1，常用于数组索引循环
macros.round(数值: num) -&gt; 取整结果: num 返回 math.floor(数值 + 0.5) 的四舍五入结果
macros.sign(数值: num) -&gt; 符号: num 返回数值的符号：负数为 -1，非负数为 1
macros.rand_sign(正号概率?: num) -&gt; 符号: num 返回随机符号：-1 或 1。正号概率 默认为 0.5，表示返回 1 的概率
macros.deg2rad(角度: num) -&gt; 弧度: num
macros.rad2deg(弧度: num) -&gt; 角度: num
V.v(x, y) -&gt; 向量: vec2
V.vv(值: num) -&gt; 向量: vec2
V.vclone(向量: vec2) -&gt; 深拷贝的向量: vec2
V.veq(向量1: vec2, 向量2: vec2) -&gt; 是否相等: bool
V.v2c(向量: vec2) -&gt; x: int, y: int
V.vsnap(向量: vec2) -&gt; 取整后的向量: vec2
V.csnap(x, y) -&gt; x: int, y: int
V.r(x, y, 长: num, 高: h) -&gt; 矩形: rect
V.rclone(矩形: rect) -&gt; 深拷贝的矩形: rect
V.is_inside(点位: vec2, 矩形: rect) -&gt; 是否在矩形内: bool 包含边界
V.overlap(矩形: rect, 矩形: rect) -&gt; 是否重叠: bool 包括边缘接触
]]></description><link>总结/12.-库.html</link><guid isPermaLink="false">总结/12. 库.md</guid><pubDate>Mon, 22 Dec 2025 09:20:44 GMT</pubDate></item><item><title><![CDATA[2. 实体与模板]]></title><description><![CDATA[开始之前我们需要先了解 ECS（Entity-Component-System）实体-组件-系统是什么ECS 是一种游戏编程架构模式，核心思想是将数据与逻辑分离，强调组合优于继承。
一个唯一的标识符（通常就是一个 ID），它不是游戏对象本身，而是一个“容器”。
类比：就像一张空白的身份证，上面只有一个身份证号码。这张证本身没有任何信息（没有名字、年龄、职业），但它可以用来关联各种信息卡片。
作用：它的唯一作用是将不同的 z 组件组合在一起，形成一个有意义的游戏对象。例如，一个“玩家”实体，可能是 entity #1，它关联了 位置、精灵、生命值、控制器 等组件。 纯数据的容器。它只包含属性，绝对不包含任何逻辑或方法。
类比：一张张信息卡片。比如“位置卡”只记录 (x, y, z) 坐标；“生命值卡”只记录 当前血量 和 最大血量；“渲染卡”只记录 纹理ID 和 颜色。
作用：定义实体的特征。一个实体拥有哪些组件，就具备了哪些能力。想给实体添加新功能？只需挂载一个新的组件即可，无需修改复杂的类继承树。 纯逻辑的执行者。它只包含行为和方法，不持有自己的状态（数据来自组件）。
类比：一个个专业的处理部门。比如“移动部门”只关心所有带有 位置 和 速度 组件的实体，并根据速度更新它们的位置；“渲染部门”只关心所有带有 位置 和 精灵 组件的实体，并把它们画到屏幕上。
作用：驱动游戏世界的运转。系统遍历所有拥有特定组件的实体，并对这些组件的数据进行操作。
假设我们要创建一个可以移动和渲染的“玩家”。
创建实体：生成一个 entity #1（只是一个 ID）。
添加组件：为 entity #1 添加： position (x: 0, y: 0)
velocity (vx: 1, vy: 0)
sprite (texture: “player.png”) 系统运作： 移动系统 每帧运行。寻找所有同时拥有 position 和 velocity 的实体。找到 entity #1，读取其速度数据，更新其位置数据。
渲染系统 每帧运行。寻找所有同时拥有 position 和 velocity 的实体。找到 entity #1，读取其位置和纹理数据，将其绘制在屏幕正确位置。 实体发生了什么、看起来什么样，完全由它身上挂载的组件组合决定，而行为则由系统统一驱动。all/entity_db 模块简称为 E
定义： E.entities&nbsp;表中包含的子表，称为实体模板
作用：使用模板创建各种实体，用于存储实体的数据
读取位置：kr/game_templates 与 all/templates、 kr/data/balance
模板的表无实际作用，仅用于存储数据，数据传递过程： balance → 模板 → 实体 → 函数 位置：E.components
读取位置：all/components 位置：game.store.entities
英雄：具有 hero 组件
士兵：具有 soldier 组件
敌人：具有 enemy 组件
防御塔：具有 tower 组件 位置：all/systems
首先使用搜索功能在 kr/game_templates 任意找到一个英雄模板，所有模板名见 <a data-href="1. 模板名" href="总结/1.-模板名.html" class="internal-link" target="_self" rel="noopener nofollow">1. 模板名</a>如图以小公主（hero_alleria）为例：<br>
<img alt="Pasted image 20251212181056.png" src="site-lib/media/pasted-image-20251212181056.png" target="_self" style="width: 346px; max-width: 100%;">tt = RT("hero_alleria", "hero") -- tt 指的是 hero_alleria 模板，E:register_t 函数会返回创建的模板的引用
AC(tt, "melee", "ranged", "timed_attacks")	-- 增加组件 melee、ranged、timed_attacks
tt.hero.level_stats.armor = {...} -- hero 组件的 level_stats.armor，物理护甲
tt.hero.level_stats.hp_max = {...} -- 最大血量
tt.hero.level_stats.regen_health = {...}	-- 脱战回血
tt.hero.level_stats.melee_damage_max = {...}	-- 近战普攻最大伤害
tt.hero.level_stats.melee_damage_min = {...}	-- 近战普攻最小伤害
tt.hero.level_stats.ranged_damage_max = {...}	-- 远程普攻最大伤害
tt.hero.level_stats.ranged_damage_min = {...}	-- 远程普攻最小伤害
...
展开的 10 个值为索引所对应等级的属性tt.hero.level_stats.hp_max = { 250,	-- 索引 1 表示 1 级血量为 250 270,	-- 索引 2 表示 2 级血量为 270 290,	-- ... 310, 330, 350, 370, 390, 410, 430
}
将第十行血量修改为 666，然后点击运行和调试，运行游戏<br>
<img alt="Pasted image 20250626192149.png" src="site-lib/media/pasted-image-20250626192149.png" target="_self" style="width: 377px; max-width: 100%;"><br>
<img alt="Pasted image 20250626191819.png" src="site-lib/media/pasted-image-20250626191819.png" target="_self" style="width: 541px; max-width: 100%;">
如图血量变为 666 成功tt.hero.level_stats.armor = b.armor
tt.hero.level_stats.hp_max = b.hp_max
tt.hero.level_stats.melee_damage_max = b.basic_melee.damage_max
tt.hero.level_stats.melee_damage_min = b.basic_melee.damage_min
tt.hero.level_stats.ranged_damage_max = b.basic_ranged.damage_max
tt.hero.level_stats.ranged_damage_min = b.basic_ranged.damage_min
通过查看模板的定义知道：这里是索引的 balance在 balance 搜索要改的英雄，同样可以找到基础属性，修改即可hero_muyrn = { -- 尼鲁 ... armor = {...}, -- 物理护甲 hp_max = {...}, -- 最大血量 regen_health = {...},	-- 脱战回血 basic_melee = { -- 近战普攻 ... damage_max = {...},	-- 近战普攻最大伤害 damage_min = {...}	-- 近战普攻最小伤害 ... }, basic_ranged = { -- 远程普攻 ... damage_max = {...},	-- 远程普攻最大伤害 damage_min = {...}	-- 远程普攻最大伤害 ... }, ...
}
hero 组件的 skills 通常用于存储会根据等级提高的属性。以艾莉丹（hero_elves_archer）为例：tt = E:register_t("hero_elves_archer", "hero")
E:add_comps(tt, "melee", "ranged", "dodge") tt.hero.skills.double_strike = E:clone_c("hero_skill")	-- E:clone_c 函数用于返回深拷贝的组件
tt.hero.skills.double_strike.damage_max = {...} -- 双刀跳斩最大伤害
tt.hero.skills.double_strike.damage_min = {...} -- 双刀跳斩最小伤害
tt.hero.skills.multishot = E:clone_c("hero_skill")
tt.hero.skills.multishot.loops = {...} -- 凌空飞箭射击次数
tt.hero.skills.nimble_fencer = E:clone_c("hero_skill")
tt.hero.skills.nimble_fencer.chance = {...} -- 敏捷游侠闪避概率
tt.hero.skills.porcupine = E:clone_c("hero_skill")
tt.hero.skills.porcupine.damage_inc = {...} -- 箭靶最大叠层次数
假设要修改艾莉丹的四技能；双刀跳斩的伤害：<br>
首先查资料（见<a data-href="1. 模板名" href="总结/1.-模板名.html" class="internal-link" target="_self" rel="noopener nofollow">1. 模板名</a> ）知道：四技能的名称是 double_strikett.hero.skills.double_strike.damage_max = { 80, -- 3 个值意义同上，索引 1 表示 1 级的伤害 140,	-- ... 200
}
还是与基础属性相同在 balancehero_muyrn = { ... sentinel_wisps = {	-- 哨兵仙灵 cooldown = {	-- 冷却时间 25, 25, 25 }, max_summons = {	-- 生成数量 1, 2, 3 } ... } ...
}
拦截后的攻击，称为近战攻击。近战攻击通常位于 melee 组件的 attacks 列表中tt.melee.attacks[1] = E:clone_c("melee_attack")	-- 返回深拷贝的组件
tt.melee.attacks[1].cooldown = 1 -- 冷却时间
tt.melee.attacks[1].hit_time = fts(8) -- 攻击前摇
tt.melee.attacks[1].sound = "MeleeSword" -- 攻击声音
tt.melee.attacks[1].xp_gain_factor = 2.5 -- 获得的经验
tt.melee.range = 45	-- 拦截范围
如代码所示，一般第一个攻击 attacks[1] 都是普攻，其他都是相应行为的技能注：有的攻击可能会占有多个攻击，可以通过 table.deepclone 复制的攻击来分辨
其用于播放不同动画，与增加额外效果tt.melee.attacks[1].animation = "attack"
tt.melee.attacks[1].hit_time = fts(14)
tt.melee.attacks[1].shared_cooldown = true
tt.melee.attacks[1].sound = "MeleeSword"
tt.melee.attacks[2] = table.deepclone(tt.melee.attacks[1])
tt.melee.attacks[2].animation = "attack2"
tt.melee.attacks[2].chance = 0.5	-- 50 % 近战普攻播放 "attack2" 动画
召唤子弹作为中介的攻击，称为远程攻击（ranged）因为是召唤子弹所以远程攻击的伤害和伤害类型等数据都是写在子弹上的，可以搜索子弹（bullet）模板来找到子弹的数据-- 艾莉丹远程普攻
tt.ranged.attacks[1] = E:clone_c("bullet_attack")
tt.ranged.attacks[1].bullet = "arrow_hero_alleria"	-- 子弹
tt.ranged.attacks[1].bullet_start_offset = { v(0, 12)
}
tt.ranged.attacks[1].max_range = 150
tt.ranged.attacks[1].min_range = 45
tt.ranged.attacks[1].shoot_time = fts(6)
tt.ranged.attacks[1].cooldown = 0.6 -- 子弹模板
tt = RT("arrow_hero_alleria", "arrow")	-- arrow_hero_alleria 续承自 arrow 模板
-- 注：一些属性会在 hero.skills 中
tt.bullet.xp_gain_factor = 2.875
tt.bullet.prediction_error = false -- 由于续承关系所以搜索 arrow 模板
-- all/templates 的 arrow 模板
local arrow = E:register_t("arrow", "bullet")
...
arrow.bullet.damage_type = DAMAGE_PHYSICAL	-- 默认伤害类型：物伤
不属于以上两种攻击的攻击，称为技能（timed_attacks），例如：召唤实体、给予 buff 等-- 熊人模板
tt.timed_attacks.list[1] = CC("spawn_attack")
tt.timed_attacks.list[1].animation = "ancestors"
tt.timed_attacks.list[1].cooldown = 14 + fts(40)
tt.timed_attacks.list[1].cast_time = fts(15)
tt.timed_attacks.list[1].disabled = true
tt.timed_attacks.list[1].entity = "soldier_ingvar_ancestor" -- 召唤这个实体 -- 维京先祖模板
tt = RT("soldier_ingvar_ancestor", "soldier_militia") -- E:register_t
AC(tt, "reinforcement", "melee") -- E:add_comps
...
tt.health.armor = 0.25
tt.health.hp_max = nil -- 升级技能后动态赋值
tt.melee.attacks[1].damage_max = nil
tt.melee.attacks[1].damage_min = nil
tt.melee.attacks[1].cooldown = 1
tt.melee.attacks[1].hit_time = fts(15)
tt.melee.attacks[1].sound = "MeleeSword"
在 melee.attacks 可能找不到伤害类型，可以搜索增加的 melee 组件看看有没有默认值在 components 搜索 melee 组件local melee = register_c("melee")
...
melee.attacks = {}
melee.attacks[1] = CC("melee_attack") -- 继续搜索 melee_attack 组件
local melee_attack = E:register_c("melee_attack")
...
melee_attack.damage_type = DAMAGE_PHYSICAL -- 默认伤害类型：物伤 -- 模板内修改
tt.melee.attacks[1].damage_type = DAMAGE_TRUE	-- 修改为真伤
四个常用伤害类型：
DAMAGE_TRUE 真伤
DAMAGE_PHYSICAL 物伤
DAMAGE_MAGICAL 法伤
DAMAGE_EXPLOSION 炮伤
<br>所有伤害类型见<a data-href="总结/3. 常量#伤害类型" href="总结/3.-常量.html#伤害类型" class="internal-link" target="_self" rel="noopener nofollow">总结/3. 常量 &gt; 伤害类型</a>register_t 全称 register template 简称 RT。E:register_t(模板名: str, 续承模板名?: str) -&gt; 模板表的引用: table
a = RT("a")	-- 创建一个名为 “a” 的模板
a.has_a = true
a.num = 1 template = RT("template", "a")	-- 创建一个名为 “template” 的模板，同时续承 “a” 模板
template.n = 123
-- “template” 模板具有 “a” 模板所有键，修改对应键不影响模板 “a”
-- 也就是 template = { n = 123, has_a = true, num = 1 }
add_comps 全称 add components 简称 AC。E:add_comps(模板: table, 组件名: str...)
component = AC("component")	-- 创建组件 “component”
component.num = 123
component.is_component = true template = RT("template")
AC(template, "component") -- 增加组件 “component”
template.n = 1
-- 此时 template = { component = { num = 123, is_component = true }, n = 1}
clone_c 全称 clone componets 简称 CCE:clone_c(组件名: str) -&gt; 深拷贝的表: table
component = RT("component")
component.num = 123
component.is_component = true template = RT("template")
template.cc = CC("component")	-- 深拷贝组件，此时 cc 就是组件 component
template.num = 1
-- 此时 template = { cc = { num = 123, is_component = true }, num = 1 }
register_c 全称 register componentE:register_c(组件: str) -&gt; 组件索引: table
a = E:register_c("a")	-- 创建一个名为 “a” 的组件
造成的所有正面以及负面效果统称为状态效果（modifiers，缩写 mod）
近战攻击直接在攻击后面增加 mod 键
远程攻击增加到子弹模板的 bullet 键上，个别子弹无效（函数无实现）
-- 单位模板内
tt.melee.attacks[1].mod = 效果模板名: str
-- 子弹模板内
tt.bullet.mod = 效果模板名: str
-- 单位模板内
tt.melee.attacks[1].mod = "mod_lava"	-- 普通近战攻击造成燃烧效果 -- 子弹模板内
tt.bullet.mod = "mod_lava"	-- 子弹造成燃烧效果
几个基础效果（位于 template 中）
mod_stun 眩晕
mod_slow 减速
mod_freeze 冻结
mod_lava 燃烧
mod_poison 中毒
mod_blood 流血
状态效果数据也是通过模板存储的，不能直接修改基础效果模板，由于续承关系直接修改会影响其他效果，所以我们需要创建一个新模板续承基础效果。-- mod_lava（燃烧效果）模板
local mod_lava = RT("mod_lava", "modifier")
AC(mod_lava, "dps", "render")
mod_lava.modifier.duration = 2 -- 持续时间
mod_lava.dps.damage_min = 1 -- 最小伤害
mod_lava.dps.damage_max = 1 -- 最大伤害
mod_lava.dps.damage_inc = 3 -- 伤害系数
mod_lava.dps.damage_every = 0.2 -- 伤害频率
mod_lava.dps.damage_type = DAMAGE_TRUE	-- 伤害类型
... -- 创建新模板 new_mod_lava 续承 mod_lava
tt = RT("new_mod_lava", "mod_lava")
tt.modifier.duration = 10 -- 持续时间 10 秒
tt.dps.damage_min = 5 -- 最小伤害 5
tt.dps.damage_max = 10 -- 最大伤害 10
-- 其他使用默认值 -- 单位模板内
tt.melee.attacks[1].mod = "new_mod_lava"	-- 使用新创建的效果 -- 子弹模板内
tt.bullet.mod = "new_mod_lava"	-- 使用新创建的效果
注：并非所有效果都要这样改，如果效果没有其他地方在用可以直接修改。-- balance 内
hero_spider = { basic_melee = { -- 近战普攻 mod = "mod_lava",	-- 增加 mod 键值对 ... }
} -- 模板内
tt.melee.attacks[1].mod = b.basic_melee.mod	-- 读取 balance 内的表
效果互斥用于防止一些效果同时出现在同一个目标上。tt.modifier.bans = { -- 禁止的效果模板名 效果模板名: str...
}
tt.modifier.ban_types = {	-- 禁止的效果类型，可选 效果类型: str...
}
几个效果类型：
MOD_TYPE_BLEED 流血
MOD_TYPE_POISON 中毒
MOD_TYPE_FREEZE 冻结
MOD_TYPE_STUN 眩晕
<br>所有效果类型见<a data-href="总结/3. 常量#效果类型" href="总结/3.-常量.html#效果类型" class="internal-link" target="_self" rel="noopener nofollow">总结/3. 常量 &gt; 效果类型</a>tt.modifier.bans = { -- 禁止的效果模板名 "mod_freeze", -- 若目标上有燃烧效果，目标将不会被冻结 ...
}
tt.modifier.ban_types = {	-- 禁止的效果类型 MOD_TYPE_FREEZE, -- 若目标上有燃烧效果，目标将不会被冻结类型的所有效果冻结 ...
}
tt.modifier.remove_banned = 是否移除禁止的效果: bool
-- 燃烧效果模板内
tt.modifier.remove_banned = true
tt.modifier.bans = { "mod_freeze", -- 如果目标上有冻结效果，移除其 ...
} tt.modifier.ban_types = { MOD_TYPE_FREEZE,	-- 如果目标上有冻结类型的效果，移除其 ...
}
三种模式（三选一）：tt.modifier.allows_duplicates = 是否允许叠加: bool
tt.modifier.replaces_lower = 是否替换低级效果: bool
tt.modifier.resets_same = 是否仅重置持续时间: bool
-- 燃烧效果模板内
tt.modifier.allows_duplicates = true	-- 可叠加多个燃烧效果
-- 或
tt.modifier.replaces_lower = true	-- 替换低级燃烧效果
-- 或
tt.modifier.resets_same = true -- 仅重置持续时间
给攻击初始化为范围攻击 area_attack，增加伤害范围即可。tt.melee.attacks[1] = CC("area_attack")
tt.melee.attacks[1].damage_radius = 伤害范围: num
tt.melee.attacks[1].count = 最大目标数?: int
tt.melee.attacks[1].min_count = 释放限制，敌人数量?: int
tt.melee.attacks[1] = CC("area_attack")
tt.melee.attacks[1].damage_radius = 25	-- 伤害范围 25
tt.melee.attacks[1].count = 3 -- 最多对三名敌人造成伤害
tt.melee.attacks[1].min_count = 2 -- 需要两名敌人才能进行这个攻击
给攻击增加 loops 键，设定攻击次数即可。-- 近战攻击
tt.melee.attacks[1].animations = { 开始时的动画名: str|nil, 连续攻击时的动画: str|nil, 结束时的动画名: str|nil
}
tt.melee.attaks[1].loops = 连续攻击次数: int
tt.melee.attaks[1].hit_times = 一次攻击的次数（可指定间隔）: table{ 间隔: num, ... }
-- 可以理解成乘算，loops 为 0 不攻击： 攻击次数 = loops * hit_times -- 远程攻击，同上 hit_times 变为 shoot_times
tt.ranged.attaks[1].shoot_times = 一次攻击的次数（可指定间隔）: table{ 间隔: num, ... }
-- 近战攻击
tt.melee.attacks[1].animations = { nil, -- 开始动画 "attack",	-- 连续攻击时的动画，复用普通近战攻击动画 nil -- 结束动画
}
tt.melee.attaks[1].loops = 2	-- 连续攻击 2 次
tt.melee.attaks[1].hit_times = { fts(10), fts(15) }	-- 一次攻击两次，第一次间隔 10 帧，第二次间隔 15 帧 -- 远程攻击
tt.ranged.attacks[1].animations = { nil, "shoot",	-- 复用普通远程攻击动画 nil
}
tt.ranged.attaks[1].loops = 2
tt.ranged.attaks[1].shoot_times = { fts(10), fts(15) }	-- 一次攻击两次，第一次间隔 10 帧，第二次间隔 15 帧
给子弹的 bullet.hit_payload 设定实体模板名，即可让子弹落地后生成实体。tt.bullet.hit_payload = 实体模板名: str
tt.bullet.hit_payload = "decal_bolin_mine" -- 波林扔地雷
AC(tt, "dodge") -- 增加闪避组件
tt.dodge.chance = 闪避概率: num
tt.dodge.silent = 是否有动画?: bool
AC(tt, "dodge") -- 增加闪避组件
tt.dodge.chance = 0.25	-- 闪避概率 25 %
tt.dodge.silent = true	-- 无动画
给单位的 vis.bans 让单位不会被某些标签的攻击攻击-- 单位模板
tt.vis.bans = 单位禁止的标签: int
tt.vis.flags = 单位的标签: int
tt.ranged.attacks[1].vis_bans = 攻击禁止的标签: int
tt.ranged.attacks[1].vis_flags = 攻击的标签: int
每个单位有自己的“身份证”（标签），攻击也有自己的“许可证”（标签）。双方互相检查，匹配不上就不能攻击。只看两个条件：
攻击的 vis_bans&nbsp;不能包含&nbsp;目标的标签
目标的 vis_bans&nbsp;不能包含&nbsp;攻击的标签
-- 单位模板
tt.vis.bans = F_RANGED	-- 不会被远程攻击
tt.ranged.attacks[1].vis_bans = bor(F_BOSS, F_FLYING)	-- 远程攻击不攻击拥有 boss 标签与飞行标签的敌人
tt.ranged.attacks[1].vis_flags = F_RANGED -- 远程攻击标签
由于标签本质上是数字（通常为二次幂），可以通过 bit.bor 来增加多个标签。bit.bor(十进制数字: int...) -&gt; 合并后的十进制数字: int
常用标签：
F_BLOCK 近战攻击
F_RANGED 远程攻击
F_HERO 英雄
F_BOSS Boss
F_FLYING 飞行
F_INSTAKILL 秒杀
<br>所有标签见<a data-href="总结/3. 常量#标签" href="总结/3.-常量.html#标签" class="internal-link" target="_self" rel="noopener nofollow">总结/3. 常量 &gt; 标签</a>-- 修改小公主（hero_alleria）模板，要求：
-- 1. 将远程普攻的子弹改为造成燃烧效果
-- 2. 让近战攻击造成中毒效果
-- 3. 增加 50% 闪避率
-- 创建一个新的中毒效果 "剧毒"，要求：
-- 1. 继承 mod_poison 模板
-- 2. 持续时间为 5 秒
-- 3. 每 0.5 秒造成 10-15 点真伤
-- 4. 禁止冻结效果叠加
-- 5. 如果目标已有冻结效果，则移除冻结 核心概念： 模板：实体的数据蓝图，读取 kr/game_templates 和 all/templates
组件：为模板添加功能模块，读取在 all/components
实体：使用模板创建的容器
E.entities：存放所有实体模板
E.components：存放所有组件
数据流程：balance → 模板 → 实体 → 函数 单位分类： 英雄：具有 hero 组件
士兵：具有 soldier 组件的友方
敌人：具有 enemy 组件
防御塔：具有 tower 组件 攻击类型： 近战攻击：拦截后的攻击，使用 melee 组件
远程攻击：召唤子弹作为中介，使用 ranged 组件
技能：特殊攻击，使用 timed_attacks 组件 效果： 造成效果：给攻击或子弹的 mod 设定效果模板名
修改效果：增加一个新模板并续承原效果
效果互斥：给 bans 设定效果模板名
移除被禁止效果：remove_banned 设为真
效果叠加：allows_duplicates 允许叠加，replaces_lower 替换低级效果，resets_same 仅重置持续时间 特殊效果 范围攻击：使用 area_attack 组件，并设定范围
多次攻击：增加 loops 与 hit_times（对于近战攻击） 或 shoot_times（对于远程攻击）
子弹携带实体：给 hit_payload 设定实体模板名
闪避：增加 dodge 组件并增加概率
标签：使用 bans 与 flags 来过滤目标，使用 bit.bor 合并位运算增加多个标签 （点击勾选框勾选）
完成本章后，你应该能够：
理解 ECS 架构的理念
理解实体、模板、组件三者的关系
查找并修改英雄的基础属性和等级属性
理解并修改近战、远程、技能三种攻击类型
修改伤害类型和状态效果
使用模板函数创建和修改模板
配置标签系统
实现范围攻击、多次攻击等特殊效果 为什么模板系统要采用 "模板 → 实体 " 的数据传递流程？这样做有什么优势？
组件系统如何实现代码的复用性和模块化？
目标过滤系统中的 "标签" 和 "禁止标签" 是如何工作的？这种设计有什么好处？
下一章预告：在第 3 章中，我们将学习实体函数，为更复杂的修改打下基础！]]></description><link>第-2-节-修改基础/2.-实体与模板.html</link><guid isPermaLink="false">第 2 节 - 修改基础/2. 实体与模板.md</guid><pubDate>Mon, 22 Dec 2025 08:46:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[13. 类]]></title><link>总结/13.-类.html</link><guid isPermaLink="false">总结/13. 类.md</guid><pubDate>Sun, 21 Dec 2025 02:52:11 GMT</pubDate></item><item><title><![CDATA[1. 模板名]]></title><description><![CDATA[
详细请查阅 @杨叔伟大无需多言的文档：
<a data-tooltip-position="top" aria-label="https://www.bilibili.com/read/readlist/rl141527" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.bilibili.com/read/readlist/rl141527" target="_self">《王国保卫战》Kingdom Rush 中文百科全集</a>
所有附属模板请自行搜索，例如 tower_barrack 兵营召唤的士兵模板所有基础塔模板名都是相同的，n 后缀为等级
tower_archer + _n 箭塔
tower_barrack + _n 兵营
tower_mage + _n 法师
tower_engineer + _n 炮塔
所有英雄大招模板名都是：英雄模板名 + _ultimate所有关卡自带塔的塔位模板名都是：自带塔模板名 + _holder部分防御塔四级名字略有不同好的，这是根据您提供的场景单位信息整理的表格：]]></description><link>总结/1.-模板名.html</link><guid isPermaLink="false">总结/1. 模板名.md</guid><pubDate>Thu, 18 Dec 2025 11:08:41 GMT</pubDate></item><item><title><![CDATA[7. 键]]></title><link>总结/7.-键.html</link><guid isPermaLink="false">总结/7. 键.md</guid><pubDate>Wed, 17 Dec 2025 11:59:55 GMT</pubDate></item><item><title><![CDATA[11. 迭代器与泛型for]]></title><description><![CDATA[在编程中，我们经常需要遍历集合中的元素。迭代器提供了一种统一的方式来访问各种数据结构。-- 不使用迭代器的问题
local fruits = {"苹果", "香蕉", "橙子", "葡萄"} -- 方式1：使用数值for循环
print("方式1 - 数值for循环:")
for i = 1, #fruits do print(" 水果" .. i .. ": " .. fruits[i])
end -- 问题：需要知道数据结构（是数组），需要知道长度
-- 对于不是数组的表，这种方法无效 local student = { name = "小明", age = 18, grade = "高三"
} -- 方式2：使用pairs（但不是标准迭代器方式）
print("\n方式2 - 使用pairs:")
for k, v in pairs(student) do print(" " .. k .. ": " .. v)
end -- 问题：顺序不确定，不能控制遍历逻辑 -- 迭代器可以解决这些问题！
print("\n使用迭代器的优势:")
print(" 1. 统一的遍历接口")
print(" 2. 封装遍历逻辑")
print(" 3. 支持复杂遍历模式")
print(" 4. 惰性求值（需要时才计算）")
迭代器是一个能够生成序列中下一个值的函数。在 Lua 中，迭代器通常遵循以下模式：-- 迭代器三要素：
-- 1. 迭代器函数：每次调用返回下一个值
-- 2. 不可变状态：遍历过程中不变的数据
-- 3. 控制变量：当前遍历位置 -- 简单的迭代器示例：生成数字序列
local function number_iterator(max) local i = 0 -- 控制变量（初始值） -- 迭代器函数 return function() i = i + 1 if i &lt;= max then return i -- 返回下一个值 end -- 返回nil表示结束 end
end print("数字序列迭代器:")
local iter = number_iterator(5) print(" 第一次调用: " .. (iter() or "nil"))
print(" 第二次调用: " .. (iter() or "nil"))
print(" 第三次调用: " .. (iter() or "nil"))
print(" 第四次调用: " .. (iter() or "nil"))
print(" 第五次调用: " .. (iter() or "nil"))
print(" 第六次调用: " .. (iter() or "nil")) -- 超过范围，返回nil
--[[ 输出
第一次调用: 1
第二次调用: 2
第三次调用: 3
第四次调用: 4
第五次调用: 5
第六次调用: nil
--]]
泛型 for 循环是 Lua 中使用迭代器的主要方式：for -&gt;迭代器返回的参数: any... in 迭代器函数: func, 不可变状态: any, 控制变量: any do -- 循环体
end
-- 基本示例
print("基本示例 - 遍历数组:")
local colors = {"红色", "绿色", "蓝色", "黄色"} for i, color in ipairs(colors) do print(" 颜色" .. i .. ": " .. color)
end
--[[ 输出
颜色1: 红色
颜色2: 绿色
颜色3: 蓝色
颜色4: 黄色
--]] -- ipairs实际上是一个迭代器工厂，返回上述三个值
print("\nipairs的工作原理:")
local iter, t, i = ipairs(colors)
print(" 迭代器函数: " .. type(iter))
print(" 不可变状态: " .. tostring(t))
print(" 控制变量: " .. tostring(i))
--[[ 输出
迭代器函数: function
不可变状态: table: 00D99EA0
控制变量: 0
--]] -- 手动模拟泛型for循环
print("\n手动模拟泛型for循环:")
local iterator_func, invariant_state, control_var = ipairs(colors)
local var1, var2 = iterator_func(invariant_state, control_var) while var1 do print(" 索引: " .. var1 .. ", 值: " .. var2) var1, var2 = iterator_func(invariant_state, var1)
end
--[[ 输出
索引: 1, 值: 红色
索引: 2, 值: 绿色
索引: 3, 值: 蓝色
索引: 4, 值: 黄色
--]]
-- 这等价于：
-- for i, color in ipairs(colors) do
-- print(" 索引: " .. i .. ", 值: " .. color)
-- end
-- 1. 初始化：获取三要素
local iterator_func, state, control_var = ipairs(colors) -- 2. 第一次调用，为迭代器函数传递不可变状态与控制变量
control_var, value... = iterator_func(state, control_var) -- control_var = 0 -&gt; 1 -- 3. 循环直到返回 nil
while control_var do -- 使用控制变量和其他返回值 print(control_var, value...) -- 下一次调用，更新控制变量和其他返回值，注意：不可变状态依旧使用第一次调用时的，不会更新！ control_var, value... = iterator_func(state, control_var)
end
示意图：
<img alt="Pasted image 20251211142754.png" src="site-lib/media/pasted-image-20251211142754.png" target="_self" style="width: 1125px; max-width: 100%;">-- 泛型 for（简洁、安全）
for i, v in ipairs(t) do print(i, v)
end -- 手动实现（理解原理）
local iter, state, var = ipairs(t)
local var1, var2 = iter(state, var)
while var1 do print(var1, var2) var1, var2 = iter(state, var1)
end
ipairs 用于遍历数组部分（索引从 1 开始）for -&gt;索引: int, -&gt;值: any in ipairs(表: table) do -- 循环体
end
-- 基本用法
local numbers = {10, 20, 30, 40, 50}
print("遍历数组:")
for i, num in ipairs(numbers) do print(" numbers[" .. i .. "] = " .. num)
end -- ipairs的特性
print("\nipairs的特性:")
local mixed_table = { "第一个", -- 索引1 "第二个", -- 索引2 name = "小明", -- 键值对，不在数组部分 "第三个", -- 索引3 age = 18 -- 键值对
} print("混合表的ipairs遍历:")
for i, value in ipairs(mixed_table) do print(" 索引 " .. i .. ": " .. value)
end
-- 注意：只遍历数组部分（索引1, 2, 3），跳过键值对
--[[ 输出
混合表的ipairs遍历: 索引 1: 第一个 索引 2: 第二个 索引 3: 第三个
--]] -- 有"洞"的数组
print("\n有洞数组的ipairs:")
local array_with_holes = {"A", nil, "C", "D"}
for i, value in ipairs(array_with_holes) do print(" 索引 " .. i .. ": " .. (value or "nil"))
end
--[[ 输出 索引 1: A
--]]
-- 注意：遇到第一个nil就停止，所以只输出索引1
-- 实现自定义的ipairs（理解原理）
local function my_ipairs(t) local function iterator(state, index) index = index + 1 local value = state[index] if value ~= nil then return index, value end end return iterator, t, 0
end print("\n自定义ipairs测试:")
for i, value in my_ipairs(numbers) do print(" numbers[" .. i .. "] = " .. value)
end
--[[ 输出
numbers[1] = 10
numbers[2] = 20
numbers[3] = 30
numbers[4] = 40
numbers[5] = 50
--]]
pairs用于遍历表的所有键值对。for -&gt;键: any, -&gt;键值: any in ipairs(表: table) do -- 循环体
end
-- 基本用法
local student = { name = "李雷", age = 16, grade = "高一", class = "1班", scores = {85, 92, 78}
} print("遍历学生信息:")
for key, value in pairs(student) do if type(value) == "table" then print(" " .. key .. ": [表]") else print(" " .. key .. ": " .. tostring(value)) end
end -- pairs的特性
print("\npairs的特性:")
print(" 1. 遍历所有键值对（包括数组部分和字典部分）")
print(" 2. 遍历顺序不确定（依赖表的实现）")
print(" 3. 可以遍历任何类型的键（除了nil）") -- 包含各种类型键的表
local complex_table = { [1] = "数字键1", ["1"] = "字符串键1", [true] = "布尔键", [function() end] = "函数键", -- 不常见但可能 normal = "普通键"
} print("\n复杂键表的pairs遍历:")
for k, v in pairs(complex_table) do local key_type = type(k) if key_type == "function" then print(" 函数键: " .. v) else print(" " .. key_type .. "键 '" .. tostring(k) .. "': " .. v) end
end
local function my_pairs(t) local function iterator(state, key) -- 获取下一个键值对 local next_key, next_value = next(state, key) return next_key, next_value end return iterator, t, nil
end print("\n自定义pairs测试:")
local count = 0
for key, value in my_pairs(student) do if count &lt; 3 then -- 只显示前3个 print(" " .. key .. ": " .. tostring(value)) end count = count + 1
end
print(" 总键值对数: " .. count)
--[[ 输出
scores: table: 00E09E50
name: 李雷
class: 1班
总键值对数: 5
--]]
-- next函数的使用
print("\nnext函数演示:")
local t = {a = 1, b = 2, c = 3}
local key, value = next(t) -- 第一个键值对
print(" 第一个: " .. key .. " = " .. value) key, value = next(t, key) -- 第二个键值对
print(" 第二个: " .. key .. " = " .. value) key, value = next(t, key) -- 第三个键值对
print(" 第三个: " .. key .. " = " .. value) key, value = next(t, key) -- 没有更多，返回nil
print(" 第四个: " .. tostring(key) .. " = " .. tostring(value))
--[[ 输出
第一个: a = 1
第二个: c = 3
第三个: b = 2
第四个: nil = nil
--]]
string.gmatch 用于匹配多个模式。string.gmatch(字符串: str, 匹配模式: str) -&gt; 迭代器函数: func
-- 基本用法：遍历单词
local sentence = "The quick brown fox jumps over the lazy dog"
print("句子: " .. sentence)
print("\n遍历单词:") for word in string.gmatch(sentence, "%a+") do print(" 单词: " .. word)
end -- 提取特定模式
local data = "姓名: 张三, 年龄: 25, 城市: 北京, 职业: 工程师"
print("\n提取键值对:") for key, value in string.gmatch(data, "(%a+):%s*([^,]+)") do print(" " .. key .. ": " .. value)
end -- 解析CSV行
local csv_line = "苹果,5,2.5,12.5"
print("\n解析CSV:")
local index = 1
for field in string.gmatch(csv_line, "([^,]+)") do print(" 字段" .. index .. ": " .. field) index = index + 1
end -- 解析多行文本
local multiline_text = [[
第一行内容
第二行内容
第三行内容
第四行内容
]] print("\n遍历文本行:")
local line_number = 1
for line in string.gmatch(multiline_text, "([^\n]+)") do print(" 行" .. line_number .. ": " .. line) line_number = line_number + 1
end -- 提取URL参数
local url = "https://example.com/search?q=lua&amp;page=2&amp;sort=recent"
print("\n提取URL参数:") -- 找到查询字符串部分
local query_string = string.match(url, "%?(.+)") or ""
for param in string.gmatch(query_string, "([^&amp;]+)") do local key, value = string.match(param, "([^=]+)=?(.*)") print(" 参数: " .. key .. " = " .. (value ~= "" and value or "true"))
end -- 实现自定义的字符串分割迭代器
local function split_string(str, delimiter) delimiter = delimiter or " " local pattern = string.format("([^%s]+)", delimiter) return string.gmatch(str, pattern)
end print("\n自定义字符串分割:")
local text = "苹果 香蕉 橙子 葡萄 西瓜"
for fruit in split_string(text) do print(" 水果: " .. fruit)
end
--[[ 输出
水果: 苹果
水果: 香蕉
水果: 橙子
水果: 葡萄
水果: 西瓜
--]]
-- 更高级的字符串迭代器：逐字符遍历
local function chars(str) local chars = {} local i = 1 local len = #str while i &lt;= len do local b = string.byte(str, i) local char_len -- UTF-8 字符长度检测 if b &lt; 128 then -- ASCII char_len = 1 elseif b &gt;= 194 and b &lt;= 223 then char_len = 2 elseif b &gt;= 224 and b &lt;= 239 then char_len = 3 elseif b &gt;= 240 and b &lt;= 244 then char_len = 4 else char_len = 1 -- 无效字节 end table.insert(chars, string.sub(str, i, i + char_len - 1)) i = i + char_len end return chars
end local chars = chars("你好 Hello 世界!")
for i, char in ipairs(chars) do print(" 字符 " .. i .. ": '" .. char .. "' (字节长度: " .. #char .. ", ASCII: " .. string.byte(char) .. ")")
end
--[[ 输出
字符 1: '你' (字节长度: 3, ASCII: 228)
字符 2: '好' (字节长度: 3, ASCII: 229)
字符 3: ' ' (字节长度: 1, ASCII: 32)
字符 4: 'H' (字节长度: 1, ASCII: 72)
字符 5: 'e' (字节长度: 1, ASCII: 101)
字符 6: 'l' (字节长度: 1, ASCII: 108)
字符 7: 'l' (字节长度: 1, ASCII: 108)
字符 8: 'o' (字节长度: 1, ASCII: 111)
字符 9: ' ' (字节长度: 1, ASCII: 32)
字符 10: '世' (字节长度: 3, ASCII: 228)
字符 11: '界' (字节长度: 3, ASCII: 231)
字符 12: '!' (字节长度: 1, ASCII: 33)
--]]
无状态迭代器不保存任何状态，所有状态都通过参数传递。-- 示例：遍历数组的无状态迭代器
local function array_iterator(t, index) index = index + 1 local value = t[index] if value then return index, value end
end local function iter_array(t) return array_iterator, t, 0
end -- 使用
local fruits = {"苹果", "香蕉", "橙子"}
print("无状态迭代器遍历数组:")
for i, fruit in iter_array(fruits) do print(" fruits[" .. i .. "] = " .. fruit)
end -- 对比：有状态迭代器（使用闭包）
local function stateful_array_iterator(t) local i = 0 return function() i = i + 1 local value = t[i] if value then return i, value end end
end print("\n有状态迭代器遍历数组:")
for i, fruit in stateful_array_iterator(fruits) do print(" fruits[" .. i .. "] = " .. fruit)
end -- 无状态迭代器的优势
print("\n无状态迭代器优势:")
print(" 1. 更高效：不创建闭包")
print(" 2. 可复用：相同的迭代器函数可用于多个表")
print(" 3. 更简单：状态管理由泛型for处理") -- 实现一个无状态迭代器来遍历表的键值对
local function next_pair(t, key) return next(t, key)
end local function iter_pairs(t) return next_pair, t, nil
end print("\n无状态pairs迭代器:")
local colors = {red = "红色", green = "绿色", blue = "蓝色"}
for key, value in iter_pairs(colors) do print(" " .. key .. ": " .. value)
end
-- 创建各种无状态迭代器 -- 1. 数字范围迭代器
local function range_iterator(limit, current) current = current + 1 if current &lt;= limit then return current end
end local function range(from, to) return range_iterator, to, from - 1 -- 注意：控制变量初始化为from-1
end print("数字范围迭代器:")
for i in range(5, 10) do print(" i = " .. i)
end
--[[ 输出
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
--]] -- 2. 质数迭代器
local function is_prime(n) if n &lt; 2 then return false end if n == 2 then return true end if n % 2 == 0 then return false end for i = 3, math.sqrt(n), 2 do if n % i == 0 then return false end end return true
end local function prime_iterator(limit, current) -- 找到下一个质数 repeat current = current + 1 if current &gt; limit then return nil end until is_prime(current) return current
end local function primes(limit) return prime_iterator, limit, 1 -- 从1开始（实际从2开始检查）
end print("\n质数迭代器（小于50的质数）:")
for prime in primes(50) do io.write(prime .. " ")
end
print()
-- 输出 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 -- 3. 文件行迭代器
local function lines_iterator(file, lines) return table.remove(file, 1)
end local function lines(file) -- 返回迭代器函数、文件和nil（初始控制变量） return lines_iterator, file, nil
end print("\n文件行迭代器（模拟）:")
-- 为了演示，我们模拟文件内容
local mock_file_content = { "第一行内容", "第二行内容", "第三行内容", nil -- 文件结束
} for line in lines(mock_file_content) do print(" " .. line)
end
--[[ 输出
第一行内容
第二行内容
第三行内容
--]] -- 4. 表格行迭代器
local function table_rows_iterator(t, row_index) row_index = row_index + 1 local row = t[row_index] if row then return row_index, unpack(row) end
end local function table_rows(t) return table_rows_iterator, t, 0
end local data_table = { { "张三", 18, "男" }, { "李四", 19, "女" }, { "王五", 20, "男" }
} print("\n表格行迭代器:")
for row_index, name, age, gender in table_rows(data_table) do print(string.format(" 行%d: 姓名=%s, 年龄=%d, 性别=%s", row_index, name, age, gender))
end
--[[ 输出
行1: 姓名=张三, 年龄=18, 性别=男
行2: 姓名=李四, 年龄=19, 性别=女
行3: 姓名=王五, 年龄=20, 性别=男
--]]
有状态迭代器使用闭包来保存状态，更灵活但可能效率稍低。-- 有状态迭代器：使用闭包保存状态 -- 1. 计数器迭代器
local function counter(max) local count = 0 return function() count = count + 1 if count &lt;= max then return count end end
end print("计数器迭代器:")
for num in counter(5) do print(" 计数: " .. num)
end
--[[ 输出 计数: 1 计数: 2 计数: 3 计数: 4 计数: 5
--]] -- 2. 斐波那契数列迭代器
local function fibonacci_iterator(limit) local a, b = 0, 1 local count = 0 return function() if count &gt;= limit then return nil end local result = a a, b = b, a + b count = count + 1 return result end
end print("\n斐波那契数列迭代器（前10项）:")
for num in fibonacci_iterator(10) do io.write(num .. " ")
end
print()
-- 输出
0 1 1 2 3 5 8 13 21 34 -- 3. 随机数迭代器
local function random_iterator(count, min, max) math.randomseed(os.time()) local generated = 0 return function() if generated &gt;= count then return nil end generated = generated + 1 return math.random(min, max) end
end print("\n随机数迭代器（5个1-100的随机数）:")
for num in random_iterator(5, 1, 100) do io.write(num .. " ")
end
print()
-- 输出 68 74 70 95 72（以实际为准） -- 4. 目录遍历迭代器（模拟）
local function directory_iterator(dir_path) -- 模拟的目录内容 local mock_files = { {name = "file1.txt", type = "file", size = 1024}, {name = "file2.txt", type = "file", size = 2048}, {name = "subdir1", type = "dir", size = 0}, {name = "file3.txt", type = "file", size = 3072}, } local index = 0 return function() index = index + 1 local item = mock_files[index] if item then return item.name, item.type, item.size end end
end print("\n目录遍历迭代器:")
for filename, filetype, filesize in directory_iterator("/mock/path") do local type_desc = filetype == "dir" and "目录" or "文件" print(string.format(" %s (%s, %d 字节)", filename, type_desc, filesize))
end
--[[ 输出
file1.txt (文件, 1024 字节)
file2.txt (文件, 2048 字节)
subdir1 (目录, 0 字节)
file3.txt (文件, 3072 字节)
--]] -- 5. 数据库查询结果迭代器（模拟）
local function db_query_iterator(query) -- 模拟查询结果 local mock_results = { {id = 1, name = "张三", age = 25}, {id = 2, name = "李四", age = 30}, {id = 3, name = "王五", age = 28}, {id = 4, name = "赵六", age = 35}, } local index = 0 return function() index = index + 1 local row = mock_results[index] if row then return row.id, row.name, row.age end end
end print("\n数据库查询迭代器:")
for id, name, age in db_query_iterator("SELECT * FROM users") do print(string.format(" ID: %d, 姓名: %s, 年龄: %d", id, name, age))
end
--[[ 输出
ID: 1, 姓名: 张三, 年龄: 25
ID: 2, 姓名: 李四, 年龄: 30
ID: 3, 姓名: 王五, 年龄: 28
ID: 4, 姓名: 赵六, 年龄: 35
--]]
-- 1. 分页数据迭代器
local function paged_data_iterator(page_size, total_items) local current_page = 0 local current_item = 0 return function() -- 计算当前页 if current_item % page_size == 0 then current_page = current_page + 1 print(string.format(" 加载第%d页...", current_page)) end current_item = current_item + 1 if current_item &gt; total_items then return nil end -- 模拟数据项 return current_item, "项目" .. current_item end
end print("分页数据迭代器（每页3项，共10项）:")
for id, name in paged_data_iterator(3, 10) do print(string.format(" ID: %d, 名称: %s", id, name))
end
--[[ 输出
加载第1页... ID: 1, 名称: 项目1 ID: 2, 名称: 项目2 ID: 3, 名称: 项目3
加载第2页... ID: 4, 名称: 项目4 ID: 5, 名称: 项目5 ID: 6, 名称: 项目6
加载第3页... ID: 7, 名称: 项目7 ID: 8, 名称: 项目8 ID: 9, 名称: 项目9
加载第4页... ID: 10, 名称: 项目10
--]] -- 2. 过滤器迭代器
local function filtered_iterator(original_iterator, filter_func) return function() while true do local values = {original_iterator()} if values[1] == nil then return nil -- 原始迭代器结束 end if filter_func(unpack(values)) then return unpack(values) end -- 如果不满足条件，继续下一个 end end
end print("\n过滤器迭代器:")
local numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} function number_iterator_from_table(t) local index = 0 return function() index = index + 1 return t[index] end
end -- 只返回偶数
local even_filter = function(num) return num % 2 == 0
end print("偶数过滤器:")
for num in filtered_iterator(number_iterator_from_table(numbers), even_filter) do io.write(num .. " ")
end
print()
-- 输出 2 4 6 8 10 -- 3. 转换迭代器
local function transformed_iterator(original_iterator, transform_func) return function() local values = {original_iterator()} if values[1] == nil then return nil end return transform_func(unpack(values)) end
end print("\n转换迭代器:")
-- 将数字转换为平方
local square_transform = function(num) return num, num * num
end print("平方转换:")
for num, square in transformed_iterator(number_iterator_from_table(numbers), square_transform) do print(string.format(" %d² = %d", num, square))
end
--[[ 输出
1² = 1
2² = 4
3² = 9
4² = 16
5² = 25
6² = 36
7² = 49
8² = 64
9² = 81
10² = 100
--]] -- 4. 组合多个迭代器
local function zip_iterators(...) local iterators = {...} local current_values = {} return function() -- 收集每个迭代器的下一个值 for i, iter in ipairs(iterators) do current_values[i] = {iter()} -- 如果任何一个迭代器结束，就全部结束 if current_values[i][1] == nil then return nil end end -- 返回所有值 local result = {} for i, values in ipairs(current_values) do for j, value in ipairs(values) do table.insert(result, value) end end return unpack(result) end
end print("\n组合迭代器（zip）:")
local names = {"张三", "李四", "王五"}
local ages = {25, 30, 28}
local cities = {"北京", "上海", "广州"} local name_iter = number_iterator_from_table(names)
local age_iter = number_iterator_from_table(ages)
local city_iter = number_iterator_from_table(cities) for name, age, city in zip_iterators(name_iter, age_iter, city_iter) do print(string.format(" 姓名: %s, 年龄: %d, 城市: %s", name, age, city))
end
--[[ 输出
姓名: 张三, 年龄: 25, 城市: 北京
姓名: 李四, 年龄: 30, 城市: 上海
姓名: 王五, 年龄: 28, 城市: 广州
--]]
-- 树结构的迭代器
-- 定义树节点
local tree_node = {} function tree_node.new(value) local node = { value = value, children = {}, add_child = tree_node.add_child } return node
end function tree_node:add_child(child) table.insert(self.children, child) return self
end -- 创建一棵树
local root = tree_node.new("root")
local node_a = tree_node.new("A")
local node_b = tree_node.new("B")
local node_a1 = tree_node.new("a1")
local node_a2 = tree_node.new("a2")
local node_b1 = tree_node.new("b1")
local node_b2 = tree_node.new("b2") root:add_child(node_a):add_child(node_b)
node_a:add_child(node_a1):add_child(node_a2)
node_b:add_child(node_b1):add_child(node_b2)
print([[ 创建树： root / \ A B / \ / \
a1 a2 b1 b2
--]]) -- 先序遍历迭代器（沿着一个分支走到底，再遍历下一个分支）
local function preorder_iterator(node) local stack = { node } local index = 1 return function() if index &gt; #stack then return nil end local current = stack[index] index = index + 1 -- 将子节点逆序加入栈（保证左子节点先处理） for i = #current.children, 1, -1 do table.insert(stack, index, current.children[i]) end return current.value end
end print("先序遍历:")
for value in preorder_iterator(root) do io.write(value .. " ")
end
print() -- 广度优先遍历迭代器（按层级遍历，先访问同一层的所有节点）
local function bfs_iterator(node) local queue = { node } local index = 1 return function() if index &gt; #queue then return nil end local current = queue[index] index = index + 1 -- 将子节点加入队列 for _, child in ipairs(current.children) do table.insert(queue, child) end return current.value end
end print("广度优先遍历:")
for value in bfs_iterator(root) do io.write(value .. " ")
end
print()
--[[ 输出
创建树： root / \ A B / \ / \
a1 a2 b1 b2 先序遍历:
root A a1 a2 B b1 b2 广度优先遍历:
root A B a1 a2 b1 b2 --]]
-- 图结构的迭代器
-- 定义图
local Graph = {} function Graph.new() local graph = { vertices = {}, edges = {}, add_vertex = Graph.add_vertex, add_edge = Graph.add_edge } return graph
end function Graph:add_vertex(name) self.vertices[name] = { name = name, neighbors = {} } return self.vertices[name]
end function Graph:add_edge(v1_name, v2_name, weight) weight = weight or 1 local v1 = self.vertices[v1_name] local v2 = self.vertices[v2_name] if v1 and v2 then table.insert(v1.neighbors, { vertex = v2, weight = weight }) table.insert(v2.neighbors, { vertex = v1, weight = weight }) -- 无向图 return true end return false
end -- 创建图
local graph = Graph.new()
graph:add_vertex("A")
graph:add_vertex("B")
graph:add_vertex("C")
graph:add_vertex("D")
graph:add_vertex("E") graph:add_edge("A", "B", 1)
graph:add_edge("A", "C", 2)
graph:add_edge("B", "D", 3)
graph:add_edge("C", "D", 1)
graph:add_edge("D", "E", 2)
print([[创建图：
A -- B (1)
| |
C D (3) \ / D (1) | E (2)
]]) -- 深度优先遍历图的迭代器
local function graph_dfs_iterator(graph, start_vertex_name) local visited = {} local stack = { graph.vertices[start_vertex_name] } return function() while #stack &gt; 0 do local current = table.remove(stack) if not visited[current.name] then visited[current.name] = true -- 将未访问的邻居加入栈 for i = #current.neighbors, 1, -1 do local neighbor = current.neighbors[i].vertex if not visited[neighbor.name] then table.insert(stack, neighbor) end end return current.name end end return nil end
end print("图的深度优先遍历（从A开始）:")
for vertex_name in graph_dfs_iterator(graph, "A") do io.write(vertex_name .. " ")
end
print() -- 广度优先遍历图的迭代器
local function graph_bfs_iterator(graph, start_vertex_name) local visited = {} local queue = { graph.vertices[start_vertex_name] } local index = 1 return function() while index &lt;= #queue do local current = queue[index] index = index + 1 if not visited[current.name] then visited[current.name] = true -- 将未访问的邻居加入队列 for _, neighbor_info in ipairs(current.neighbors) do local neighbor = neighbor_info.vertex if not visited[neighbor.name] then table.insert(queue, neighbor) end end return current.name end end return nil end
end print("图的广度优先遍历（从A开始）:")
for vertex_name in graph_bfs_iterator(graph, "A") do io.write(vertex_name .. " ")
end
print() -- 最短路径迭代器（Dijkstra算法简化版）
local function shortest_path_iterator(graph, start_vertex_name, end_vertex_name) local distances = {} local previous = {} local unvisited = {} -- 初始化 for name, vertex in pairs(graph.vertices) do distances[name] = math.huge -- 无穷大 previous[name] = nil table.insert(unvisited, name) end distances[start_vertex_name] = 0 return function() while #unvisited &gt; 0 do -- 找到未访问节点中距离最小的 local min_distance = math.huge local min_vertex = nil local min_index = 0 for i, name in ipairs(unvisited) do if distances[name] &lt; min_distance then min_distance = distances[name] min_vertex = graph.vertices[name] min_index = i end end if not min_vertex or min_distance == math.huge then break -- 没有可达的节点了 end -- 从unvisited中移除 table.remove(unvisited, min_index) -- 如果到达目标节点，构建路径并返回 if min_vertex.name == end_vertex_name then local path = {} local current = end_vertex_name while current do table.insert(path, 1, current) current = previous[current] end return path, distances[end_vertex_name] end -- 更新邻居的距离 for _, neighbor_info in ipairs(min_vertex.neighbors) do local neighbor = neighbor_info.vertex local alt = distances[min_vertex.name] + neighbor_info.weight if alt &lt; distances[neighbor.name] then distances[neighbor.name] = alt previous[neighbor.name] = min_vertex.name end end end return nil -- 没有路径 end
end print("\n最短路径查找（从A到E）:")
for path, distance in shortest_path_iterator(graph, "A", "E") do print(" 路径: " .. table.concat(path, " -&gt; ")) print(" 总距离: " .. distance)
end
--[[ 输出
创建图：
A -- B (1)
| |
C D (3) \ / D (1) | E (2) 图的深度优先遍历（从A开始）:
A B D C E 图的广度优先遍历（从A开始）:
A B C D E 最短路径查找（从A到E）: 路径: A -&gt; C -&gt; D -&gt; E 总距离: 5
--]]
惰性求值：需要时才计算值-- 1. 无限序列迭代器
local function infinite_sequence(start, step) local current = start - (step or 1) return function() current = current + (step or 1) return current end
end print("自然数序列（惰性）:")
local natural_numbers = infinite_sequence(1)
for i = 1, 10 do io.write(natural_numbers() .. " ")
end
print()
-- 输出 1 2 3 4 5 6 7 8 9 10 -- 2. 斐波那契数列（惰性无限）
local function fibonacci_generator() local a, b = 0, 1 return function() local result = a a, b = b, a + b return result end
end print("\n斐波那契数列（惰性无限，前15项）:")
local fib = fibonacci_generator()
for i = 1, 15 do io.write(fib() .. " ")
end
print()
-- 输出 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 -- 3. 网络数据流迭代器（模拟）
local function network_stream_iterator(url, buffer_size) buffer_size = buffer_size or 4096 local bytes_sent = 0 local total_bytes = 10240 -- 模拟10KB数据 return function() if bytes_sent &gt;= total_bytes then return nil end local chunk_size = math.min(buffer_size, total_bytes - bytes_sent) bytes_sent = bytes_sent + chunk_size -- 模拟数据块 return string.rep("X", chunk_size) end
end print("网络数据流迭代器（模拟）:")
local network_stream = network_stream_iterator("http://example.com/data")
local chunk_count = 0
local total_size = 0 for chunk in network_stream do chunk_count = chunk_count + 1 total_size = total_size + #chunk print(string.format(" 收到块%d: %d字节", chunk_count, #chunk))
end print(string.format(" 总共收到%d块，总大小%d字节", chunk_count, total_size))
--[[ 输出
收到块1: 4096字节
收到块2: 4096字节
收到块3: 2048字节
总共收到3块，总大小10240字节
--]] -- 4. 数据库查询流迭代器（惰性获取）
local function database_stream_iterator(query, page_size) page_size = page_size or 100 local current_page = 0 local current_index = 0 local current_data = nil return function() -- 如果需要新的一页数据 if current_data == nil or current_index &gt;= #current_data then current_page = current_page + 1 current_index = 0 print(string.format(" 查询第%d页数据...", current_page)) -- 模拟数据库查询（实际中这里会有真正的查询） current_data = {} for i = 1, page_size do local item_id = (current_page - 1) * page_size + i if item_id &gt; 250 then -- 模拟总共250条数据 current_data = nil break end table.insert(current_data, { id = item_id, name = "项目" .. item_id, value = math.random(100, 1000) }) end if current_data == nil then return nil -- 没有更多数据 end end -- 返回当前数据项 current_index = current_index + 1 local item = current_data[current_index] return item.id, item.name, item.value end
end print("\n数据库查询流迭代器:")
local item_count = 0
for id, name, value in database_stream_iterator("SELECT * FROM items", 50) do item_count = item_count + 1 if item_count &lt;= 3 or item_count &gt;= 248 then -- 只显示头尾几个 print(string.format(" ID: %d, 名称: %s, 值: %d", id, name, value)) elseif item_count == 4 then print(" ...") end
end
print(" 总共查询到 " .. item_count .. " 条记录")
--[[ 输出
查询第1页数据...
ID: 1, 名称: 项目1, 值: 101
ID: 2, 名称: 项目2, 值: 607
ID: 3, 名称: 项目3, 值: 274
...
查询第2页数据...
查询第3页数据...
查询第4页数据...
查询第5页数据...
ID: 248, 名称: 项目248, 值: 729
ID: 249, 名称: 项目249, 值: 626
ID: 250, 名称: 项目250, 值: 416
查询第6页数据...
总共查询到 250 条记录
--]]
<br>（答案见<a data-href="第 1 节 - 语法/参考答案#练习 11 1：实现一个数据管道系统" href="第-1-节-语法/参考答案.html#练习 11 1：实现一个数据管道系统" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 11 1：实现一个数据管道系统</a>）-- 实现一个数据管道系统，组合多个迭代器处理数据（先收集操作，最后迭代时统一处理数据）
-- 使用示例：
-- 构建管道
local pipeline = pipeline_sys.new(number_source(1, 20))
pipeline:filter(function(x) return x % 2 == 0 end) -- 只保留偶数
pipeline:map(function(x) return x * 2 end) -- 乘以2
pipeline:skip(3) -- 跳过前3个
pipeline:take(5) -- 取5个 print("管道处理结果:")
for value in pipeline:iterator() do io.write(value .. " ")
end
print()
--[[ 输出
管道处理结果:
8 12 16 20 24 --]] 迭代器基础： 迭代器是生成序列值的函数
迭代器三要素：迭代器函数：每次调用返回下一个值，不可变状态：遍历过程中不变的数据，控制变量：当前遍历位置
泛型 for 循环：for var1, var2, ... in iter, state, init do ... end
Lua 内置迭代器：ipairs, pairs, string.gmatch 无状态迭代器： 所有状态通过参数传递
更高效，不创建闭包
示例：ipairs 的实现原理 有状态迭代器： 使用闭包保存状态
更灵活，可以实现复杂逻辑
示例：计数器、斐波那契数列 高级迭代器模式： 树和图遍历迭代器
惰性求值迭代器
数据管道和查询构建器 -- 1. 简单迭代器模式
local function simple_iterator(data) local index = 0 return function() index = index + 1 return data[index] end
end -- 2. 无状态迭代器模式
local function stateless_iter(state, index) -- 计算下一个值 local next_index, next_value = ... return next_index, next_value
end local function iter_factory(data) return stateless_iter, data, initial_index
end -- 3. 生成器模式
local function generator(pattern) return function() -- 每次生成下一个值 return next_value end
end -- 4. 转换器模式
local function transformer(iterator, transform_func) return function() local values = {iterator()} if values[1] then return transform_func(unpack(values)) end end
end
-- 迭代器的性能特点 -- 1. 无状态 vs 有状态
-- 无状态迭代器通常更高效，但不适合复杂状态 -- 2. 惰性求值的优势
-- 只计算需要的值，节省内存和计算资源 -- 3. 避免在迭代器中做耗时操作
-- 迭代器应该快速返回下一个值 -- 4. 大数据集的处理
-- 考虑使用流式迭代器，避免一次性加载所有数据 -- 性能测试示例
local function array_iterator(t, index) index = index + 1 local value = t[index] if value then return index, value end
end local function iter_array(t) return array_iterator, t, 0
end local function stateful_array_iterator(t) local i = 0 return function() i = i + 1 local value = t[i] if value then return i, value end end
end local data = {}
for i = 1, 1000000 do data[i] = i
end -- 测试ipairs
local start = os.clock()
for i, v in ipairs(data) do -- 空循环
end
print("ipairs: " .. (os.clock() - start) .. "秒") -- 测试自定义无状态迭代器
start = os.clock()
for i, v in iter_array(data) do -- 空循环
end
print("无状态迭代器: " .. (os.clock() - start) .. "秒") -- 测试有状态迭代器
start = os.clock()
for v in stateful_array_iterator(data) do -- 空循环
end
print("有状态迭代器: " .. (os.clock() - start) .. "秒")
--[[ 输出
ipairs: 0.051秒
无状态迭代器: 0.073秒
有状态迭代器: 0.087秒
--]]
-- 1. 修改迭代中的表
local t = {1, 2, 3, 4, 5}
for i, v in ipairs(t) do if v == 3 then table.remove(t, i) -- 这会改变表，可能导致意外行为 end
end -- 正确做法：收集要删除的项，然后批量删除
local to_remove = {}
for i, v in ipairs(t) do if v == 3 then table.insert(to_remove, i) end
end
for i = #to_remove, 1, -1 do table.remove(t, to_remove[i])
end -- 2. 迭代器函数调用错误
local function bad_iterator() return 1, 2, 3 -- 应该返回函数，而不是值
end -- 错误：for v in bad_iterator() do ... end -- 3. 忘记处理nil值
local function iterator_with_nil() local data = {1, nil, 3, nil, 5} local i = 0 return function() i = i + 1 return data[i] -- 可能返回nil，但迭代应该继续 end
end -- 4. 无限迭代器缺少终止条件
local function infinite_iterator() local i = 0 return function() i = i + 1 return i -- 永远不返回nil！ end
end -- 使用时要小心
for i in infinite_iterator() do if i &gt; 100 then break	-- 必须手动break end print(i)
end
-- 1. 保持迭代器简单
-- 迭代器应该只负责生成下一个值，不处理复杂业务逻辑 -- 2. 提供清晰的接口
local function create_user_iterator(condition) -- 返回迭代器和其他信息 return iterator, total_count, other_info
end -- 3. 处理边界情况
local function robust_iterator(data) if not data or #data == 0 then -- 返回一个立即结束的迭代器 return function() return nil end end -- 正常迭代器 local index = 0 return function() index = index + 1 return data[index] end
end -- 4. 文档化迭代器行为
--- 遍历表的键值对
-- @param t 要遍历的表
-- @return 迭代器函数
-- @return 表t（不可变状态）
-- @return nil（初始控制变量）
local function my_pairs(t) -- 实现...
end
（点击勾选框勾选）
完成本章后，你应该能够：
理解迭代器的基本概念和工作原理
使用 Lua 内置迭代器（ipairs, pairs, string.gmatch）
创建无状态迭代器和有状态迭代器
实现复杂的遍历模式（树、图等）
使用惰性求值提高性能
构建数据管道
选择适合场景的迭代器类型
避免常见的迭代器错误 无状态迭代器和有状态迭代器各有什么优缺点？如何选择？
如何实现一个迭代器来遍历嵌套的复杂数据结构？
惰性求值迭代器在什么场景下特别有用？
迭代器模式如何提高代码的可复用性和可维护性？
如何处理迭代过程中的错误和异常？
下一章预告：在第 12 章中，我们将学习协程，让我们能够协作式进行多任务处理。学习建议：
多实践创建各种类型的迭代器
理解无状态和有状态迭代器的区别
尝试用迭代器解决实际问题
注意迭代器的性能特点
学习现有的迭代器模式，理解其设计思想
]]></description><link>第-1-节-语法/11.-迭代器与泛型for.html</link><guid isPermaLink="false">第 1 节 - 语法/11. 迭代器与泛型for.md</guid><pubDate>Wed, 17 Dec 2025 01:48:26 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[7. 表]]></title><description><![CDATA[表是 Lua 中唯一的数据结构，但它极其强大和灵活。通过表，Lua 可以实现数组、字典、对象、模块等几乎所有复杂数据结构。-- 比喻：表就像一个"万能容器"
-- 想象一下，有一个魔法背包：
-- 1. 可以按顺序放东西（数组）
-- 2. 可以给东西贴标签，按名字找（字典）
-- 3. 可以放其他背包（嵌套）
-- 4. 甚至可以放"使用说明"（函数） -- 实际示例：一个表可以表示一个游戏角色
local player = { name = "小明", -- 字符串键 level = 10, -- 字符串键 health = 100, -- 字符串键 ["武器类型"] = "剑",	-- 包含特殊字符的键 [123] = "编号", -- 数字键 is_online = true	-- 布尔值键
} print("玩家姓名: " .. player.name) -- 小明
print("玩家等级: " .. player.level) -- 10
print("特殊键: " .. player["武器类型"])	-- 剑
print("数字键: " .. player[123]) -- 编号
-- 创建空表
local empty_table = {} -- 最简单的空表 -- 检查表是否为空
print("空表大小: " .. #empty_table) -- 输出: 0
print("空表类型: " .. type(empty_table)) -- 输出: table
-- 注意：Lua的数组索引从1开始！
local monsters = {"僵尸", "骷髅", "蜘蛛", "土匪"}
print("第一个怪物: " .. monsters[1])	-- 僵尸
print("怪物数量: " .. #monsters) -- 4
local player = { name = "李雷", age = 18, class = "战士", level = 5
}
print("玩家: " .. player.name) -- 李雷
print("职业: " .. player["class"])	-- 战士 -- 使用方括号的复杂键
local complex_keys = { ["full name"] = "张三", -- 包含空格的键 ["score-100"] = 95, -- 包含连字符的键 [true] = "布尔键", -- 布尔值作为键 [function() end] = "函数键" -- 函数作为键（不常见但可能）
} print(complex_keys["full name"]) -- 张三
print(complex_keys[true]) -- 布尔键
local mixed = { "第一个元素", -- 数组部分，索引1 "第二个元素", -- 数组部分，索引2 author = "小明",	-- 字典部分，键"author" version = 1.0	-- 字典部分，键"version"
}
print(mixed[1]) -- 第一个元素
print(mixed.author) -- 小明
local game_world = { name = "魔法世界", players = { {name = "战士", level = 10}, {name = "法师", level = 8} }, settings = { difficulty = "normal", sound = true, graphics = "high" }
} print("游戏世界: " .. game_world.name)	-- 魔法世界
print("第一个玩家: " .. game_world.players[1].name) -- 战士
print("难度设置: " .. game_world.settings.difficulty) -- normal
表传递引用是因为它可能很大且需要共享修改（多个变量操作一个表），传递指针更高效。-- 重要概念：表是引用类型
local original = {x = 10, y = 20}
local reference = original -- 不是复制，是引用同一个表 reference.x = 100 -- 修改引用也会影响原始表
print("original.x = " .. original.x) -- 100 -- 如果需要复制表，需要手动操作（后面会讲） -- 表的相等比较是比较引用，不是内容
local a = {1, 2, 3}
local b = {1, 2, 3}
local c = a print("a == b ? " .. tostring(a == b)) -- false（不同对象）
print("a == c ? " .. tostring(a == c)) -- true（同一对象）
我们可以直接通过等于号来增加与修改元素，缺点是数组必须要知道增加位置。-- 列表
local monsters = {"僵尸", "骷髅", "蜘蛛", "土匪"}
monsters[1] = "恶魔"
print("第一个怪物: " .. monsters[1])	-- 恶魔 -- 字典
-- 创建空表
local inventory = {} -- 添加元素到字典部分
inventory["gold"] = 100
-- inventory.gold = 100 -- 等价写法
inventory.silver = 50
inventory.copper = 200 for k, v in pairs(inventory) do print(k .. ": " .. v)
end
--[[ 输出
copper: 200
silver: 50
gold: 100
--]]
table.insert 会在数组的指定位置插入一个新元素，并将该位置及之后的元素依次后移。-- 不指定增加位置
table.insert(表: table, 元素: any)
-- 指定增加位置
table.insert(表: table, 增加位置: any, 元素: any) 增加位置默认为数组末尾
local inventory = {} -- 添加元素到数组末尾
print("添加元素到数组末尾")
table.insert(inventory, "药水")
table.insert(inventory, "钥匙")
inventory[#inventory + 1] = "地图" -- 等价写法 -- 修改元素
inventory.gold = 150 -- 修改现有元素
inventory[2] = "万能钥匙" -- 修改数组部分 print("库存:")
for k, v in pairs(inventory) do print(k .. ": " .. v)
end print("\n插入元素 “剑” 到数组第二个索引，将元素 2 后移。")
table.insert(inventory, 2, "剑") print("库存:")
for k, v in pairs(inventory) do print(k .. ": " .. v)
end
--[[ 输出
插入元素到数组末尾
库存:
1: 药水
2: 万能钥匙
3: 地图
gold: 150 添加元素 “剑” 到数组第二个索引，将元素 2 后移
库存:
1: 药水
2: 剑
3: 万能钥匙
4: 地图
gold: 150
--]] -- 示例：模拟queue（队列）操作
local queue = {} local function enqueue(item) table.insert(queue, item)
end local function dequeue() if #queue &gt; 0 then return table.remove(queue, 1) end return nil
end -- 测试队列
enqueue("任务1")
enqueue("任务2")
enqueue("任务3") print("\n队列操作:")
print("出队: " .. dequeue()) -- 任务1
print("出队: " .. dequeue()) -- 任务2
print("当前队列长度: " .. #queue) -- 1
--[[ 输出
出队: 任务1
出队: 任务2
当前队列长度: 1
--]]
table.remove 用于移除数组中指定位置的元素，并将后续元素前移以填补空缺，保持数组的连续性。table.remove(表: table, 删除位置?: int) -&gt; 删除的元素: any 移除位置默认为数组末尾
-- 1. 直接删除，缺点：删除数组元素后数组有 “洞”
local items = { "剑", "盾", "药水", "钥匙", "地图", gold = 100, weight = 50
} print("原始物品:")
for k, v in pairs(items) do print(k .. ": " .. v)
end -- 删除数组元素
items[2] = nil -- 删除第二个元素（盾）
print("\n删除盾牌后:")
for k, v in pairs(items) do print(k .. ": " .. v)
end -- 注意：设置nil不会自动调整数组
-- 数组部分可能会有"洞"
print("\n有洞的数组遍历（ipairs会在第一个nil停止）:")
for i, v in ipairs(items) do print(i .. ": " .. v)
end -- 删除字典元素
items.gold = nil
print("\n删除金币后:")
for k, v in pairs(items) do print(k .. ": " .. v)
end
--[[ 删除
原始物品:
1: 剑
2: 盾
3: 药水
4: 钥匙
5: 地图
weight: 50
gold: 100 删除盾牌后:
1: 剑
3: 药水
4: 钥匙
5: 地图
weight: 50
gold: 100 有洞的数组遍历（ipairs会在第一个nil停止）:
1: 剑 删除金币后:
1: 剑
3: 药水
4: 钥匙
5: 地图
weight: 50
--]] -- 2. 使用 table.remove 移除后自动调整数组
local items = { "剑", "盾", "药水", "钥匙", "地图", gold = 100, weight = 50
} local removed = table.remove(items, 2)	-- 移除第二个索引的元素（盾） print("移除了" .. removed .. "，现在第二个索引的元素:" .. items[2]) print("ipairs 遍历（table.remove 自动补洞）:")
for i, v in ipairs(items) do print(i .. ": " .. v)
end
--[[ 输出
移除了盾，现在第二个索引的元素: 药水 ipairs 遍历（table.remove 自动补洞）:
1: 剑
2: 药水
3: 钥匙
4: 地图
--]] -- 实际游戏中删除物品的例子
local backpack = { "红药水", "蓝药水", "传送卷轴", "回城卷轴", "解毒剂"
} function remove_item(container, item_name) for i = #container, 1, -1 do -- 从后往前遍历，避免索引变化问题 if container[i] == item_name then table.remove(container, i) print("已移除: " .. item_name) return true end end print("未找到物品: " .. item_name) return false
end print("\n背包内容:")
for i, v in ipairs(backpack) do print(" " .. i .. ": " .. v)
end remove_item(backpack, "传送卷轴")
remove_item(backpack, "不存在的物品") print("\n移除后的背包:")
for i, v in ipairs(backpack) do print(" " .. i .. ": " .. v)
end
--[[ 输出
背包内容: 1: 红药水 2: 蓝药水 3: 传送卷轴 4: 回城卷轴 5: 解毒剂
已移除: 传送卷轴
未找到物品: 不存在的物品 移除后的背包: 1: 红药水 2: 蓝药水 3: 回城卷轴 4: 解毒剂
--]]
local game_data = { players = { {name = "小明", score = 1000}, {name = "小红", score = 850}, {name = "小刚", score = 920} }, settings = { sound = {volume = 70, enabled = true}, graphics = {quality = "high", resolution = "1920x1080"} }
} -- 检查键是否存在
print("检查键是否存在:")
print("有players键吗? " .. tostring(game_data.players ~= nil)) -- true
print("有monsters键吗? " .. tostring(game_data.monsters ~= nil)) -- false
-- 注意：表中不存在的键值对都是 nil
-- 使用 game_data.players[1] 如果没有 game_data.players 将会报错，因为 game_data.players 是 nil，nil 无法索引 -- 安全的访问方式：使用逻辑运算符短路求值，如果判断到不存在的键直接停止后续逻辑运算
local player_name = game_data.players and game_data.players[1] and game_data.players[1].name
print("第一个玩家: " .. (player_name or "未知"))
-- #操作符用于获取表的数组部分的长度
-- 注意：它只在数组部分是连续的且从1开始时才准确 -- 连续数组
local arr1 = {1, 2, 3, 4, 5}
print("arr1长度: " .. #arr1) -- 5 -- 有"洞"的数组
local arr2 = {1, nil, 3, 4, 5}
print("arr2长度（有洞）: " .. #arr2) -- 1（遇到第一个nil就停止） local arr3 = {1, 2, 3}
arr3[5] = 5
print("arr3长度（不连续）: " .. #arr3) -- 3（只计算连续部分） -- 字典部分不影响长度
local mixed = { "a", "b", "c", name = "测试", value = 100
}
print("mixed长度: " .. #mixed) -- 3（只计算数组部分） -- 安全获取表长度的方法
function table_length(t) local count = 0 for _ in pairs(t) do count = count + 1 end return count
end local test_table = {a = 1, b = 2, c = 3, d = 4}
print("表总元素数: " .. table_length(test_table)) -- 4
print("数组长度操作符: " .. #test_table) -- 0（没有数组部分）
-- 实际应用：统计玩家数量
local players = { {name = "玩家1", ready = true}, {name = "玩家2", ready = false}, {name = "玩家3", ready = true}, {name = "玩家4", ready = true}
} print("玩家总数: " .. #players)
print("就绪玩家数: " .. (function() local count = 0 for _, player in ipairs(players) do if player.ready then count = count + 1 end end return count
end)())
-- ipairs用于遍历数组部分（索引从1开始，连续）
local colors = {"红色", "绿色", "蓝色", "黄色", "紫色"} print("使用ipairs遍历:")
for index, color in ipairs(colors) do print(" 颜色" .. index .. ": " .. color)
end -- ipairs在遇到nil时会停止
local with_holes = {"第一", nil, "第三", "第四"}
print("\n有洞的数组，ipairs遍历:")
for i, v in ipairs(with_holes) do print(" " .. i .. ": " .. v)
end
-- 只会输出: 1: 第一
-- 实际游戏示例：遍历技能列表
local skills = { {name = "火球术", damage = 30, mana_cost = 10}, {name = "治疗术", heal = 50, mana_cost = 15}, {name = "冰箭术", damage = 25, mana_cost = 8, slow = true}
} print("\n技能列表:") for i, skill in ipairs(skills) do print(" 技能" .. i .. ": " .. skill.name) if skill.damage then print(" 伤害: " .. skill.damage) end if skill.heal then print(" 治疗: " .. skill.heal) end print(" 消耗法力: " .. skill.mana_cost)
end
-- pairs遍历表的所有键值对（包括数组和字典部分）
local student = { "小明", -- 数组部分，索引1 age = 18, -- 字典部分 grade = "高三", -- 字典部分 "男", -- 数组部分，索引2 ["出生日期"] = "2005-03-15" -- 字典部分
} print("使用pairs遍历:")
for key, value in pairs(student) do print(" " .. tostring(key) .. ": " .. tostring(value))
end
-- 注意：pairs的遍历顺序是无序的！
local data = { "第一个", "第二个", key1 = "值1", "第三个", key2 = "值2"
} print("\n使用ipairs遍历:")
for i, v in ipairs(data) do print(" " .. i .. ": " .. v) -- 只输出数组部分：1,2,3
end print("\n使用pairs遍历:")
for k, v in pairs(data) do print(" " .. tostring(k) .. ": " .. tostring(v)) -- 输出所有键值对
end
-- 实际应用：遍历物品栏
local inventory = { gold = 150, silver = 300, ["生命药水"] = 5, ["魔法药水"] = 3, weapons = {"木剑", "铁盾"}
} print("\n物品栏内容:") for item, amount in pairs(inventory) do if type(amount) == "number" then print(" " .. item .. ": " .. amount) elseif type(amount) == "table" then print(" " .. item .. ":") for i, weapon in ipairs(amount) do print(" " .. i .. ". " .. weapon) end end
end
-- 由于 pairs 遍历顺序不确定，有时我们需要特定顺序
local scores = { ["小明"] = 85, ["小红"] = 92, ["小刚"] = 78, ["李雷"] = 88, ["韩梅梅"] = 95
} -- 方法1：先收集键，然后排序
print("按名字排序输出:") local keys = {} for name in pairs(scores) do table.insert(keys, name)
end table.sort(keys) -- 按字母顺序排序 for _, name in ipairs(keys) do print(" " .. name .. ": " .. scores[name])
end -- 方法2：按分数排序
print("\n按分数从高到低排序:")
local entries = {}
for name, score in pairs(scores) do table.insert(entries, {name = name, score = score})
end -- 自定义排序函数
table.sort(entries, function(a, b) return a.score &gt; b.score -- 降序排列
end) for i, entry in ipairs(entries) do print(" " .. i .. ". " .. entry.name .. ": " .. entry.score)
end
-- 实际应用：游戏排行榜
local leaderboard = { {name = "Player1", score = 15000, time = 360}, {name = "Player2", score = 12000, time = 420}, {name = "Player3", score = 18000, time = 300}, {name = "Player4", score = 9000, time = 500}
} -- 按分数降序，分数相同时按时间升序
table.sort(leaderboard, function(a, b) if a.score == b.score then return a.time &lt; b.time -- 时间少的排在前面 end return a.score &gt; b.score -- 分数高的排在前面
end) print("\n游戏排行榜:")
for rank, player in ipairs(leaderboard) do print(string.format(" 第%d名: %s (分数: %d, 时间: %d秒)", rank, player.name, player.score, player.time))
end
Lua 提供了几个内置函数来操作表。table.concat(列表: list, 分隔符?: str, 起始位置?: int, 结束位置?: int) 不指定分隔符则直接进行连接
不指定起始位置与结束位置默认连接所有元素
-- table.concat用于连接数组部分的元素
local words = {"Hello", "Lua", "World", "!"} -- 简单连接
local sentence = table.concat(words)
print("简单连接: " .. sentence) -- HelloLuaWorld! -- 用分隔符连接
sentence = table.concat(words, " ")
print("空格分隔: " .. sentence) -- Hello Lua World ! -- 指定起始和结束位置
sentence = table.concat(words, ", ", 2, 3)
print("部分连接: " .. sentence) -- Lua, World -- 实际应用：构建路径
local path_parts = {"home", "user", "projects", "lua", "main.lua"}
local path = table.concat(path_parts, "/")
print("文件路径: " .. path) -- home/user/projects/lua/main.lua -- 构建SQL查询条件
local conditions = {"age &gt; 18", "status = 'active'", "score &gt;= 60"}
local where_clause = table.concat(conditions, " AND ")
print("SQL条件: WHERE " .. where_clause) -- 构建HTML列表
local items = {"苹果", "香蕉", "橙子"}
local html_list = "&lt;ul&gt;\n"
for i, item in ipairs(items) do html_list = html_list .. " &lt;li&gt;" .. item .. "&lt;/li&gt;\n"
end
html_list = html_list .. "&lt;/ul&gt;"
print("\nHTML列表:\n" .. html_list)
table.sort(单结构表: list|dict, 匿名函数?: func) 不指定匿名函数则对于字符串将会以字母升序排序，数字以大小升序排序
为匿名函数传递比较的两个值，匿名函数必须返回布尔值，为真排序在前，为假排序在后
-- table.sort用于对数组部分进行排序
local numbers = {5, 2, 8, 1, 9, 3} print("原始数组: " .. table.concat(numbers, ", ")) -- 默认排序（升序）
table.sort(numbers)
print("升序排序: " .. table.concat(numbers, ", ")) -- 降序排序
table.sort(numbers, function(a, b) return a &gt; b
end)
print("降序排序: " .. table.concat(numbers, ", "))
--[[ 输出
原始数组: 5, 2, 8, 1, 9, 3
升序排序: 1, 2, 3, 5, 8, 9
降序排序: 9, 8, 5, 3, 2, 1
--]] -- 字符串排序
local letter = { "b", "a", "c", "y", "z", "x" }
table.sort(letter)
print("\n字母排序: " .. table.concat(letter, ", "))
--[[ 输出
字母排序: a, b, c, x, y, z
--]] -- 复杂数据排序
local students = { {name = "小明", score = 85, age = 18}, {name = "小红", score = 92, age = 17}, {name = "小刚", score = 78, age = 19}, {name = "李雷", score = 85, age = 18}
} -- 按分数降序，分数相同时按名字升序
table.sort(students, function(a, b) if a.score == b.score then return a.name &lt; b.name end return a.score &gt; b.score
end) print("\n学生排名:")
for i, student in ipairs(students) do print(string.format(" 第%d名: %s (分数: %d, 年龄: %d)", i, student.name, student.score, student.age))
end -- 自定义排序：按字符串长度
local words = {"apple", "banana", "cat", "elephant", "dog"} table.sort(words, function(a, b) return #a &lt; #b -- 按长度升序
end) print("\n按长度排序: " .. table.concat(words, ", "))
-- 浅拷贝（只复制一层）
local function shallow_copy(original) local copy = {} for k, v in pairs(original) do copy[k] = v end return copy
end -- 测试复制
local original = { name = "原始表", data = {1, 2, 3}, nested = { a = "A", b = {x = 10, y = 20} }
} local shallow = shallow_copy(original) -- 修改原表
original.name = "修改后的原表"
original.data[1] = 100
original.nested.b.x = 999 print("浅复制测试:")
print(" 原表.name: " .. original.name) -- 修改后的原表
print(" 浅复制.name: " .. shallow.name) -- 原始表（字符串被复制）
print(" 原表.data[1]: " .. original.data[1]) -- 100
print(" 浅复制.data[1]: " .. shallow.data[1]) -- 100（表是引用！）
-- 深复制（复制所有嵌套结构）
local function deep_copy(original, seen) seen = seen or {} if type(original) ~= "table" then return original end if seen[original] then return seen[original] end local copy = {} seen[original] = copy for k, v in pairs(original) do copy[deep_copy(k, seen)] = deep_copy(v, seen) end return copy
end -- 测试复制
local original = { name = "原始表", data = {1, 2, 3}, nested = { a = "A", b = {x = 10, y = 20} }
} local deep = deep_copy(original) -- 修改原表
original.name = "修改后的原表"
original.data[1] = 100
original.nested.b.x = 999 print("\n深复制测试:")
print(" 深复制.name: " .. deep.name) -- 原始表
print(" 深复制.data[1]: " .. deep.data[1]) -- 1（独立副本）
print(" 深复制.nested.b.x: " .. deep.nested.b.x) -- 10（独立副本）
-- 合并两个表（浅合并）
local function shallow_merge(t1, t2) local result = {} for k, v in pairs(t1) do result[k] = v end for k, v in pairs(t2) do result[k] = v end return result
end -- 测试合并
local defaults = { sound = true, volume = 70, graphics = { quality = "medium", resolution = "1280x720" }
} local user_settings = { volume = 80, language = "中文", graphics = { resolution = "1920x1080", shadows = true }
} local merged = shallow_merge(defaults, user_settings) print("合并后的设置:")
for k, v in pairs(merged) do if type(v) == "table" then print(" " .. k .. ":") for k2, v2 in pairs(v) do print(" " .. k2 .. ": " .. tostring(v2)) end else print(" " .. k .. ": " .. tostring(v)) end
end
--[[ 输出
合并后的设置: language: 中文 volume: 80 sound: true graphics: shadows: true resolution: 1920x1080
--]]
-- 深度合并
local function deep_merge(t1, t2) local result = {} for k, v in pairs(t1) do result[k] = v end for k, v in pairs(t2) do if type(result[k]) == "table" and type(v) == "table" then result[k] = deep_merge(result[k], v) else result[k] = v end end return result
end -- 测试合并
local defaults = { sound = true, volume = 70, graphics = { quality = "medium", resolution = "1280x720" }
} local user_settings = { volume = 80, language = "中文", graphics = { resolution = "1920x1080", shadows = true }
} local merged = deep_merge(defaults, user_settings) print("合并后的设置:")
for k, v in pairs(merged) do if type(v) == "table" then print(" " .. k .. ":") for k2, v2 in pairs(v) do print(" " .. k2 .. ": " .. tostring(v2)) end else print(" " .. k .. ": " .. tostring(v)) end
end
--[[ 输出
合并后的设置: language: 中文 volume: 80 sound: true graphics: shadows: true quality: medium resolution: 1920x1080
--]]
-- 表可以存储函数，模拟对象
local player = { name = "英雄", health = 100, level = 1
} -- 添加方法，注意：这里使用冒号定义
function player:take_damage(amount) self.health = self.health - amount if self.health &lt; 0 then self.health = 0 print(self.name .. " 倒下了！") else print(self.name .. " 受到 " .. amount .. " 点伤害，剩余生命: " .. self.health) end
end
-- 以上代码等价于，由于这里是定义到表内的，所以不分局部与全局函数
function player.take_damage(self, amount) self.health = self.health - amount if self.health &lt; 0 then self.health = 0 print(self.name .. " 倒下了！") else print(self.name .. " 受到 " .. amount .. " 点伤害，剩余生命: " .. self.health) end
end function player:heal(amount) self.health = self.health + amount print(self.name .. " 恢复了 " .. amount .. " 点生命，当前生命: " .. self.health)
end function player:level_up() self.level = self.level + 1 self.health = self.health + 20 print(self.name .. " 升级到 " .. self.level .. " 级！")
end -- 使用冒号调用方法
player:take_damage(30) -- 英雄 受到 30 点伤害，剩余生命: 70
player:heal(10) -- 英雄 恢复了 10 点生命，当前生命: 80
player:level_up() -- 英雄 升级到 2 级！
-- 以上代码等价于（需要显式传递self）
player.take_damage(player, 30)
player.heal(player, 10)
player.level_up(player) -- 创建多个"实例"
local function create_player(name) local new_player = { name = name, health = 100, level = 1 } -- 使用方法共享（避免每个对象都复制方法） new_player.take_damage = player.take_damage new_player.heal = player.heal new_player.level_up = player.level_up return new_player
end local player1 = create_player("战士")
local player2 = create_player("法师") player1:take_damage(40) -- 战士 受到 40 点伤害，剩余生命: 60
player2:level_up() -- 法师 升级到 2 级！
可以使用语法糖 : 冒号来隐式传递 self 参数。-- 定义函数
function player:take_damage(amount) ... end
-- 这等价于
function player.take_damage(self, amount) ... end -- 调用函数
player:take_damage(40)
-- 这等价于
player.take_damage(player, 40)
-- 元表可以改变表的默认行为
-- 这是Lua最强大的特性之一，我们这里先简单介绍 -- 实现向量加法
-- 创建两个表
local v1 = {x = 10, y = 20}
local v2 = {x = 5, y = 15} -- 默认情况下，表不能直接相加
-- print(v1 + v2) -- 错误：尝试对表进行算术运算 -- 创建元表
local mt = {} -- 定义元表的__add方法（用于加法）
mt.__add = function(a, b) return { x = a.x + b.x, y = a.y + b.y }
end -- 设置元表
setmetatable(v1, mt)
setmetatable(v2, mt) -- 现在表可以相加了！
local v3 = v1 + v2
print("v1 + v2 = {x=" .. v3.x .. ", y=" .. v3.y .. "}") -- {x = 15, y = 35}
（答案见 <a data-href="第 1 节 - 语法/参考答案#练习 7 1：简单的联系人管理系统" href="第-1-节-语法/参考答案.html#练习 7 1：简单的联系人管理系统" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 7 1：简单的联系人管理系统</a>）-- 实现一个简单的联系人管理系统，要求：可增加联系人到通讯录，可读取联系人，可以打印通讯录所有联系人
-- 使用示例：
-- 测试联系人管理系统
add_contact("张三", "13800138000", "zhangsan@email.com")
add_contact("李四", "13900139000")
add_contact("王五", "13700137000", "wangwu@company.com") list_contacts() find_contact("张三")
find_contact("赵六") remove_contact("李四")
list_contacts() --[[ 输出
=== 联系人管理系统 ===
已添加联系人: 张三
已添加联系人: 李四
已添加联系人: 王五
通讯录为空
找到联系人 张三: 电话: 17300138000 邮箱: zhangsan@email.com
未找到联系人: 赵六
已删除联系人: 李四
通讯录为空
--]]
<br>（答案见 <a data-href="第 1 节 - 语法/参考答案#练习 7 2：购物车系统" href="第-1-节-语法/参考答案.html#练习 7 2：购物车系统" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 7 2：购物车系统</a>）-- 实现一个购物车系统，可以向购物车增加与移除商品，然后通过购物车购买，买完清空购物车，要求：自行查资料使用 string.format 格式化价格，让价格仅保留两位小数与对齐（%宽度.小数位数f）
-- 使用示例：
-- 测试购物车系统
print("=== 购物车系统 ===")
shopping_cart:add_item("苹果", 5.5, 2)
shopping_cart:add_item("香蕉", 3.2, 3)
shopping_cart:add_item("苹果", 5.5, 1) -- 增加苹果数量 shopping_cart:show_cart() shopping_cart:remove_item("香蕉", 1) -- 减少香蕉数量 shopping_cart:show_cart() shopping_cart:clear()
shopping_cart:show_cart() --[[ 输出
== 购物车系统 ===
已添加商品: 苹果 x2
已添加商品: 香蕉 x3
已更新商品: 苹果 x1
=== 购物车 ===
1. 苹果 单价: 5.50 数量: 3 小计: 16.50
2. 香蕉 单价: 3.20 数量: 3 小计: 9.60 总计: 38.90 元
已减少商品: 香蕉 x1，剩余: x2
=== 购物车 ===
1. 苹果 单价: 5.50 数量: 3 小计: 16.50
2. 香蕉 单价: 3.20 数量: 2 小计: 6.40 总计: 35.70 元
已清空购物车
购物车为空
--]] 表的创建和初始化： 使用 {} 创建空表
构造器语法可以初始化数组和字典部分
表是引用类型，赋值传递的是引用 表的操作： 增：有洞直接赋值，无洞使用 table.insert
删：有洞设为 nil ，无洞使用 table.remove
查：通过键访问，注意处理 nil 值
长度：# 操作符只计算数组部分 表遍历： ipairs：遍历连续数组部分（索引从 1 开始）
pairs：遍历所有键值对（顺序不确定）
自定义排序遍历 相关函数 table.concat 将表连接为字符串
table.sort 表排序，匿名函数传递两个参数 高级用法： 表的复制（浅复制和深复制）
表的合并
表作为对象使用（存储函数）
使用语法糖 : 冒号来隐式传递 self 参数
元表基础（改变表的默认行为） -- 模式 1：配置对象
local config = { window = { width = 800, height = 600, title = "我的游戏" }, player = { speed = 5, health = 100 }
} -- 模式 2：数据记录
local student = { id = 1001, name = "小明", scores = {85, 92, 78}, average = function(self) local sum = 0 for _, score in ipairs(self.scores) do sum = sum + score end return sum / #self .scores end
} -- 模式 3：命名空间（模块模式）
local math_utils = {} function math_utils.clamp(value, min, max) if value &lt; min then return min end if value &gt; max then return max end return value
end function math_utils.lerp(a, b, t) return a + (b - a) * t
end -- 使用
local value = math_utils.clamp(150, 0, 100) -- 100
-- 错误 1：误用 #操作符
local t = {}
t[100] = "值"
print( #t ) -- 0，不是 100！ -- 错误 2：在循环中修改表
local items = {1, 2, 3, 4, 5}
for i, v in ipairs(items) do if v == 2 then table.remove(items, i) -- 这会导致跳过下一个元素 end
end -- 正确做法：从后往前遍历
for i = #items , 1, -1 do if items[i] == 2 then table.remove(items, i) end
end -- 错误 3：忘记表的引用特性
local original = {data = {1, 2, 3}}
local copy = original -- 这只是引用，不是复制！
copy.data[1] = 100 -- 也会修改 original -- 错误 4：混合数组和字典时的不当操作
local mixed = {1, 2, 3, a = "A"}
table.sort(mixed) -- 错误：不能对混合表排序！ local dict = {a = 1, b = 2}
local l = #dict -- 错误：长度运算符仅适用于字符串与列表，这里 l = 0
-- 1. 预分配大数组（如果知道大小）
local big_array = {}
for i = 1, 10000 do big_array[i] = 0 -- 避免多次重新分配
end -- 2. 避免在循环中多次计算表长度
local items = {1, 2, 3, 4, 5}
local length = #items -- 先计算一次
for i = 1, length do -- 使用缓存的值
end -- 3. 使用局部引用访问嵌套表的深层元素
local config = { game = { settings = { graphics = { quality = "high" } } }
} -- 不好：多次查找
print(config.game.settings.graphics.quality)
print(config.game.settings.graphics.resolution) -- 好：使用局部引用
local graphics = config.game.settings.graphics
print(graphics.quality)
print(graphics.resolution) -- 4. 选择合适的遍历方式
-- ipairs 比 pairs 快（只遍历数组部分）
-- 如果需要遍历所有元素，但表主要是数组，先用 ipairs
（点击勾选框勾选）
完成本章后，你应该能够：
创建和初始化各种类型的表
对表进行增删改查操作
正确遍历表的数组部分和所有元素
使用表相关内置函数
实现表的浅复制和深复制
使用表模拟对象和命名空间
理解元表的基本概念
设计和使用复杂的数据结构 Lua 为什么选择表作为唯一的数据结构？这种设计有什么优缺点？
什么情况下应该使用数组形式的表，什么情况下应该使用字典形式的表？
表的引用特性在什么情况下是有用的，什么情况下会带来问题？
如何设计一个高效的表来存储大量数据？
元表能实现哪些强大的功能？你能想到什么实际应用场景？ 实现一个简单的数据库系统，支持增删改查操作
创建一个图数据结构，支持添加节点、边和路径查找
创建一个事件系统，支持事件的注册、触发和取消
下一章预告：在第 8 章中，我们将学习字符串处理。字符串是编程中无处不在的数据类型，Lua 提供了强大的字符串操作功能，包括基础操作和强大的模式匹配（类似正则表达式但更简洁）。我们将学习如何创建、操作、搜索和格式化字符串。学习建议：
多练习表的创建和操作，这是 Lua 的核心
尝试用表解决各种实际问题
理解表的引用特性，避免常见错误
学习表的性能特点，编写高效的代码
探索表的高级用法，特别是作为对象和模块的使用
]]></description><link>第-1-节-语法/7.-表.html</link><guid isPermaLink="false">第 1 节 - 语法/7. 表.md</guid><pubDate>Wed, 17 Dec 2025 01:47:56 GMT</pubDate></item><item><title><![CDATA[6. 函数]]></title><description><![CDATA[函数是组织和重用代码的基本单元。它让我们可以将一段具有特定功能的代码封装起来，通过名称调用执行。在开始学习函数语法之前，先看看不使用函数时的问题：-- 不使用函数的重复代码
print("=== 玩家1 ===")
local player1_name = "小明"
local player1_level = 10
local player1_health = 100
print("姓名：" .. player1_name)
print("等级：" .. player1_level)
print("生命值：" .. player1_health) print("=== 玩家2 ===")
local player2_name = "小红"
local player2_level = 8
local player2_health = 80
print("姓名：" .. player2_name)
print("等级：" .. player2_level)
print("生命值：" .. player2_health) print("=== 玩家3 ===")
local player3_name = "小刚"
local player3_level = 12
local player3_health = 120
print("姓名：" .. player3_name)
print("等级：" .. player3_level)
print("生命值：" .. player3_health)
上面的代码有很多重复模式。函数可以解决这个问题！-- 使用function关键字定义的全局
local function 函数名(参数: any...) -- 函数体 -- 可以包含多条语句 return 返回值 -- 可选
end -- 以上语法等价于此
local 函数名 = function(参数: any...) -- 函数体 return 返回值
end
-- 示例1：简单的问候函数
local function greet() print("你好！欢迎来到Lua世界！")
end -- 调用函数
greet() -- 输出：你好！欢迎来到Lua世界！
greet() -- 可以多次调用
greet() -- 示例2：带参数的函数
local function greet_person(name) print("你好，" .. name .. "！")
end -- 调用带参数的函数
greet_person("小明") -- 输出：你好，小明！
greet_person("小红") -- 输出：你好，小红！
greet_person("老师") -- 输出：你好，老师！ -- 示例3：使用函数表达式
local calculate_area = function(width, height) local area = width * height return area
end -- 调用函数表达式
local result = calculate_area(5, 3)
print("面积为：" .. result) -- 输出：面积为：15
现在用函数重构之前的重复代码：-- 定义显示玩家信息的函数
local function show_player_info(name, level, health) print("=== " .. name .. " ===") print("姓名：" .. name) print("等级：" .. level) print("生命值：" .. health)
end -- 使用函数，使代码变得更简洁
show_player_info("小明", 10, 100)
show_player_info("小红", 8, 80)
show_player_info("小刚", 12, 120)
local function double_number(x) return x * 2
end print("5的两倍是：" .. double_number(5)) -- 输出：10
local function calculate_rectangle(width, height) local area = width * height local perimeter = 2 * (width + height) return area, perimeter
end -- 接收多个返回值
local area, perimeter = calculate_rectangle(4, 3)
print("长方形：面积=" .. area .. ", 周长=" .. perimeter) -- 面积=12, 周长=14
-- 实际游戏示例：计算伤害
local function calculate_damage(attack, defense, multiplier) local damage = attack - defense if damage &lt; 0 then damage = 0 end damage = damage * (multiplier or 1) -- multiplier可选，默认为1 return damage
end -- 测试伤害计算
local damage1 = calculate_damage(50, 30, 1.5) -- 攻击50，防御30，倍率1.5
local damage2 = calculate_damage(40, 45, 1.0) -- 攻击40，防御45
local damage3 = calculate_damage(100, 20) -- multiplier未提供，使用默认值1 print("伤害1：" .. damage1) -- 输出：30 ((50-30)*1.5)
print("伤害2：" .. damage2) -- 输出：0 ((40-45)为负，设为0)
print("伤害3：" .. damage3) -- 输出：80
-- 对于表类型，参数传递的是引用（表的内容可以被修改）
local function modify_table(t) t.x = t.x * 2 -- 修改表的内容 print("函数内 t.x = " .. t.x)
end local my_table = {x = 10, y = 20}
print("调用前 my_table.x = " .. my_table.x)	-- 10 modify_table(my_table) -- 函数内 t.x = 20
print("调用后 my_table.x = " .. my_table.x)	-- 20（改变了！） -- 注意：表本身不会被替换
local function replace_table(t) t = {x = 100, y = 200} -- 这不会影响原始表，只是让 t 指向了 {x = 100, y = 200} 这个表 print("函数内 t.x = " .. t.x)
end local original_table = {x = 10, y = 20}
print("调用前 original_table.x = " .. original_table.x)	-- 10 replace_table(original_table) -- 函数内 t.x = 100
print("调用后 original_table.x = " .. original_table.x)	-- 10（没有改变！）
这个 t 变量可以理解为箭头（指针）指向表这个“盒子”，给指针 t 赋值，只是让指针指向了另一个表，通过 t.x 访问则是先通过指针找到指向的表然后修改里面的 x 键。示意图：
<img alt="Pasted image 20251208134125.png" src="site-lib/media/pasted-image-20251208134125.png" target="_self" style="width: 600px; max-width: 100%;">-- 数字等值，传递的是 "值"
local function modify_value(x) x = x * 2 -- 修改的是副本，不影响原始值 print("函数内 x = " .. x)
end local num = 10
print("调用前 num = " .. num)	-- 10 modify_value(num) -- 函数内 x = 20
print("调用后 num = " .. num)	-- 10（没有改变！） --[[ 这些类型（值类型）都是直接传递值的副本： local a = 10 -- 数字 local b = true -- 布尔 local c = nil -- nil
--]] -- 使用 ... 接收可变数量的参数
local function sum(...) local numbers = {...} -- 将参数收集到表中 local total = 0 for i, num in ipairs(numbers) do total = total + num end return total
end -- 测试变长参数函数
print("1+2 = " .. sum(1, 2)) -- 3
print("1+2+3 = " .. sum(1, 2, 3)) -- 6
print("1+2+3+4+5 = " .. sum(1, 2, 3, 4, 5)) -- 15
print("空参数 = " .. sum()) -- 0 -- 混合固定参数和可变参数
local function format_string(separator, ...) local parts = {...} local result = "" for i, part in ipairs(parts) do if i &gt; 1 then result = result .. separator end result = result .. tostring(part) end return result
end -- 测试格式化函数
print(format_string(", ", "苹果", "香蕉", "橙子")) -- 苹果, 香蕉, 橙子
print(format_string(" - ", "A", "B", "C", "D")) -- A - B - C - D
print(format_string(" and ", "猫", "狗")) -- 猫 and 狗 -- 实际应用：计算平均值
local function average(...) local numbers = {...} local count = #numbers if count == 0 then return 0 end local total = sum(...) -- 重用之前的sum函数 return total / count
end print("平均值1：" .. average(10, 20, 30)) -- 20
print("平均值2：" .. average(1, 2, 3, 4, 5)) -- 3
print("平均值3：" .. average(100)) -- 100
-- 返回单个值
local function is_even(number) if number % 2 == 0 then return true else return false end
end -- 调用单返回值函数
local result = is_even(10)
print("10是偶数吗？" .. tostring(result)) -- true -- 更简洁的写法
local function is_odd(number) return number % 2 == 1
end print("7是奇数吗？" .. tostring(is_odd(7))) -- true -- 注意：返回值后面的代码不会被执行
local function is_odd(number) return number % 2 == 1 print("这里不会被执行")
end
-- 实际游戏示例：计算等级所需经验
function get_exp_for_level(level) -- 假设每级所需经验是 level * 100 return level * 100
end print("升到10级需要经验：" .. get_exp_for_level(10)) -- 1000
-- 返回多个值
function min_max(numbers) if #numbers == 0 then return nil, nil -- 返回两个nil end local min_val = numbers[1] local max_val = numbers[1] for i = 2, #numbers do if numbers[i] &lt; min_val then min_val = numbers[i] end if numbers[i] &gt; max_val then max_val = numbers[i] end end return min_val, max_val
end -- 接收多个返回值
local scores = {85, 92, 78, 90, 88}
local min_score, max_score = min_max(scores)
print("最低分：" .. min_score) -- 78
print("最高分：" .. max_score) -- 92 -- 如果只需要部分返回值，可以用下划线忽略
local _, highest = min_max(scores) -- 只关心最高分
print("只关心最高分：" .. highest) -- 返回值和接收值的数量可以不匹配（多余的会被视为 nil）
local a, b, c = min_max(scores)
print("a = " .. tostring(a)) -- 78
print("b = " .. tostring(b)) -- 92
print("c = " .. tostring(c)) -- nil（只有两个返回值）
-- 游戏示例：获取玩家位置
function get_player_position(player_id) -- 模拟从游戏引擎获取位置 local x = 100 + player_id * 10 local y = 50 + player_id * 5 local z = 0 -- 2D游戏中的高度 return x, y, z
end -- 获取玩家1的位置
local x1, y1, z1 = get_player_position(1)
print("玩家1位置：(" .. x1 .. ", " .. y1 .. ", " .. z1 .. ")") -- 获取玩家2的位置（只关心x和y坐标）
local x2, y2 = get_player_position(2)
print("玩家2位置：(" .. x2 .. ", " .. y2 .. ")")
-- 有时返回表比返回多个值更方便
function get_player_stats(player_id) -- 模拟获取玩家状态 return { health = 100 - player_id * 10, mana = 50 + player_id * 5, level = player_id, experience = player_id * 100 }
end -- 使用返回的表
local stats = get_player_stats(3)
print("玩家3状态：")
print("生命值：" .. stats.health)
print("魔法值：" .. stats.mana)
print("等级：" .. stats.level)
print("经验：" .. stats.experience) -- 可以直接在表达式中使用
print("生命值/魔法值比例：" .. get_player_stats(4).health / get_player_stats(4).mana)
-- 函数可以返回另一个函数
function create_multiplier(factor) -- 返回一个新的函数 return function(x) return x * factor end
end -- 创建特定的乘法器
local double = create_multiplier(2)
local triple = create_multiplier(3)
local times_ten = create_multiplier(10) -- 使用返回的函数
print("2的两倍：" .. double(2)) -- 4
print("2的三倍：" .. triple(2)) -- 6
print("2的十倍：" .. times_ten(2)) -- 20 -- 实际应用：创建不同难度的游戏关卡
function create_enemy_generator(difficulty) local health_multiplier = 1 + (difficulty - 1) * 0.5 -- 难度越高，生命值越高 return function(base_health) return base_health * health_multiplier end
end -- 创建不同难度的敌人生成器
local easy_enemy = create_enemy_generator(1) -- 简单
local normal_enemy = create_enemy_generator(2) -- 普通
local hard_enemy = create_enemy_generator(3) -- 困难 print("简单敌人生命值：" .. easy_enemy(100)) -- 100
print("普通敌人生命值：" .. normal_enemy(100)) -- 150
print("困难敌人生命值：" .. hard_enemy(100)) -- 200
有些函数内的判断可以使用卫语句来提前返回，降低镶套与缩进层数，同时也可以提高性能-- 解锁关卡检查
local player_level = 10 local info_level = "森林"	-- 模拟玩家点击关卡
local level_mode = "夜晚模式"
local unlocked_level = {forest = true} local function check_level_unlock() if info_level == "森林" then if player_level &gt;= 1 then	-- 玩家等级大于等于 1 if level_mode == "夜晚模式" then	-- 判断关卡模式 if unlocked_level.forest then print("玩家进入夜晚的森林") else return "错误，玩家未解锁森林" end elseif level_mode == "白天模式" then if unlocked_level.forest then print("玩家进入白天的森林") else return "错误，玩家未解锁森林" end else return "错误，未知模式" end else return "错误，玩家等级不足，不能进入森林" end end
end -- 改进版本
local function check_level_unlock() if info_level == "森林" then if player_level &lt; 1 then	-- 提前判断等级是否足够，不足直接返回 return "玩家等级不足，不能进入森林" end if not unlocked_level.forest then	-- 提前判断是否解锁关卡，没有解锁直接返回 return "错误，玩家未解锁森林" end if level_mode == "夜晚模式" then	-- 判断关卡模式 print("玩家进入夜晚的森林") elseif level_mode == "白天模式" then print("玩家进入白天的森林") else return "错误，未知模式" end end
end local err = check_level_unlock()
if err then print(err)
end
匿名函数（也叫 lambda 函数）是没有名字的函数，通常作为值使用。-- 基本匿名函数
local add = function(a, b) return a + b
end print("5 + 3 = " .. add(5, 3)) -- 8 -- 立即调用的匿名函数（IIFE）
local result = (function(x) return x * x
end)(5) print("5 的平方：" .. result) -- 25 -- 作为参数传递给其他函数
local numbers = {1, 2, 3, 4, 5} -- 使用匿名函数作为回调
function process_numbers(numbers, processor) for i, num in ipairs(numbers) do numbers[i] = processor(num) end return numbers
end -- 传入匿名函数处理数组
local doubled = process_numbers({1, 2, 3}, function(x) return x * 2 end)
print("加倍后的数组：")
for i, v in ipairs(doubled) do print(" " .. v) -- 2, 4, 6
end
local function outer() print("进入 outer 函数的局部作用域") local outer_var = "局部变量" function inner()	-- 全局函数 print("inner 函数访问: " .. outer_var) end -- 调用全局函数 inner() print("退出 outer 函数的局部作用域")
end outer() -- 注意：inner 函数如果在外部调用，需要先调用 outer 函数定义 inner
闭包是 Lua 中一个强大而有趣的概念。简单说，闭包就是一个能记住并访问其创建时环境的函数。-- 基本闭包示例
-- 计数器函数
local function make_counter() local count = 0 -- 局部变量，外部无法直接访问 -- 返回一个函数，这个函数能访问 count return function() count = count + 1 return count end
end -- 创建两个独立的计数器
local counter1 = make_counter() -- 存储了一个独立的 count，每次调用 counter1 将存储的 count + 1
local counter2 = make_counter() -- 这里创建了一个新的 count print("计数器 1:")
print(counter1()) -- 1
print(counter1()) -- 2
print(counter1()) -- 3 print("计数器 2:")
print(counter2()) -- 1（独立计数）
print(counter2()) -- 2
print(counter2()) -- 3 print(counter1()) -- 4
print(counter2()) -- 4
-- 闭包的实际应用：创建配置器
local function create_configurator(default_config) local config = default_config return { get = function(key) return config[key] end, set = function(key, value) config[key] = value return true end, show = function() print("当前配置:") for k, v in pairs(config) do print(" " .. k .. ": " .. tostring(v)) end end }
end -- 使用配置器
local game_config = create_configurator({ sound = true, music = true, difficulty = "normal", volume = 70
}) game_config.show()
game_config.set("difficulty", "hard")
game_config.set("volume", 80)
print("新的难度：" .. game_config.get("difficulty"))
--[[ 输出
当前配置: difficulty: normal music: true sound: true volume: 70
新的难度：hard
--]]
递归是函数调用自身的技术，常用于解决分治问题。-- 经典的阶乘函数
local function factorial(n) if n &lt;= 1 then return 1 end return n * factorial(n - 1)
end print("5 的阶乘: " .. factorial(5)) -- 120
print("10 的阶乘: " .. factorial(10)) -- 3628800 -- 斐波那契数列
local function fibonacci(n) if n &lt;= 0 then return 0 elseif n == 1 then return 1 end return fibonacci(n - 1) + fibonacci(n - 2)
end print("斐波那契数列前 10 项:")
for i = 0, 9 do print(fibonacci(i) .. " ") -- 0 1 1 2 3 5 8 13 21 34
end -- 注意：递归要有终止条件，否则会导致栈溢出
local function infinite_recursion() infinite_recursion() -- 无限递归，会导致错误
end -- infinite_recursion() -- 不要真的调用！
文档注释类似于类型注解，标注函数作用、每个参数的作用、返回值，同时集成在 vscode 中，鼠标悬浮在函数上即可直接显示参数作用。推荐给你的所有函数增加文档注释，便于阅读代码。---函数作用
---@param 参数 参数类型 参数作用
---@return 返回类型 返回描述
-- 注意：只能写到定义函数的上面 ---对某人说 hello
---@param name string 名称
---@return string 完整文本
local function say_hello(name) local text = "hello " .. name print(text) return text
end say_hello("bob")
-- 输出 hello bob
鼠标悬浮到 say_hello 函数上面显示：<br>
<img alt="Pasted image 20251211205307.png" src="site-lib/media/pasted-image-20251211205307.png" target="_self" style="width: 345px; max-width: 100%;"><br>（答案见 <a data-href="第 1 节 - 语法/参考答案#练习 6 1：简单的计算器函数库" href="第-1-节-语法/参考答案.html#练习 6 1：简单的计算器函数库" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 6 1：简单的计算器函数库</a>）-- 写几个计算器用的函数，需要有基础四则运算，平均值计算
-- 使用示例：
-- 使用函数库
print("5 + 3 = " .. add(5, 3))
print("10 - 4 = " .. subtract(10, 4))
print("6 * 7 = " .. multiply(6, 7)) local result, error_msg = divide(10, 0)
if error_msg then print("错误: " .. error_msg)
else print("10 / 2 = " .. result)
end print("平均值(1,2,3,4,5) = " .. average(1, 2, 3, 4, 5))
--[[ 输出
5 + 3 = 8
10 - 4 = 6
6 * 7 = 42
错误: 除数不能为 0
平均值(1,2,3,4,5) = 3
--]]
<br>（答案见 <a data-href="第 1 节 - 语法/参考答案#练习 6 2：提取函数，优化代码" href="第-1-节-语法/参考答案.html#练习 6 2：提取函数，优化代码" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 6 2：提取函数，优化代码</a>）-- 将以下所有代码提取为函数，再改进代码，要求：使用卫语句 -- 购物车商品处理程序 -- 模拟购买的物品
local cart = { { name = "苹果", price = 5, quantity = 3 }, { name = "香蕉", price = 3, quantity = 2 }, { name = "橙子", price = 6, quantity = 4 }, { name = "葡萄", price = 8, quantity = 1 }
} -- 打印商品详细信息
print("=== 商品详情 ===") for _, item in ipairs(cart) do local item_total = item.price * item.quantity print("商品: " .. item.name) print("单价: " .. item.price .. "元") print("数量: " .. item.quantity) print("小计: " .. item_total .. "元") print("------------")
end -- 计算购物车信息
local total_price = 0
local total_quantity = 0 for _, item in ipairs(cart) do total_price = total_price + (item.price * item.quantity) total_quantity = total_quantity + item.quantity
end print("购物车总价: " .. total_price .. "元") -- 判断是否有优惠（满50减10，满100减25，买10个赠1个）
if total_price &gt;= 50 and total_price &lt; 100 then if total_quantity &gt;= 10 then print("购物车物品总数：" .. total_quantity .. "个，赠品1个") local discount_price = total_price - 10 print("符合优惠条件，满50减10") print("优惠后价格: " .. discount_price .. "元") else local discount_price = total_price - 10 print("符合优惠条件，满50减10") print("优惠后价格: " .. discount_price .. "元") end
elseif total_price &gt;= 100 then if total_quantity &gt;= 10 then print("购物车物品总数：" .. total_quantity .. "个，赠品1个") local discount_price = total_price - 25 print("符合优惠条件，满100减25") print("优惠后价格: " .. discount_price .. "元") else local discount_price = total_price - 25 print("符合优惠条件，满100减25") print("优惠后价格: " .. discount_price .. "元") end
else print("未满50元，无优惠")
end print("\n=== 推荐商品 ===")
-- 根据购物车推荐相关商品
local recommendations = { { name = "梨子", price = 6 }, { name = "芒果", price = 10 }
} for _, cart_item in ipairs(cart) do if cart_item.name == "苹果" then print("您购买了苹果，可能也喜欢:") for _, rec in ipairs(recommendations) do local rec_total = rec.price * 1 -- 假设推荐买1个 print(" " .. rec.name .. ": " .. rec.price .. "元/个") end end if cart_item.name == "香蕉" then print("您购买了香蕉，可能也喜欢:") for _, rec in ipairs(recommendations) do local rec_total = rec.price * 1 print(" " .. rec.name .. ": " .. rec.price .. "元/个") end end if cart_item.name == "橙子" then print("您购买了橙子，可能也喜欢:") for _, rec in ipairs(recommendations) do local rec_total = rec.price * 1 print(" " .. rec.name .. ": " .. rec.price .. "元/个") end end
end 函数定义： function name(params) ... end 语法
函数表达式：local name = function(params) ... end
匿名函数：直接作为值使用 参数传递： 值类型是值传递，表是引用传递
变长参数：使用 ...
参数可以有默认值（通过 or 实现） 返回值： 可以返回单个值或多个值
可以返回函数（高阶函数）
可以返回表来组织复杂数据 高级概念： 闭包：能记住创建环境的函数
递归：函数调用自身 文档注释： 使用 --- 进行文档注释
使用 @param 和 @return 描述参数与返回值作用 -- 1. 函数应该只做一件事（单一职责）
local function calculate_area(width, height) -- 好：只计算面积 return width * height
end local function calculate_area_and_perimeter(width, height) -- 不太好：做两件事 return width * height, 2 * (width + height)
end -- 2. 使用有意义的函数名
local function get_player_health(player_id) -- 好：名字说明功能 -- ...
end local function f1(x) -- 不好：名字没有意义 -- ...
end -- 3. 参数数量适中（不超过 3-4 个）
local function create_player(name, class, level) -- 好：参数明确 -- ...
end local function setup_game(player1_name, player1_class, player1_level, player2_name, player2_class, player2_level, map_name, difficulty) -- 不好：参数太多 -- ...
end -- 4. 使用返回值表示成功/失败
local function load_file(file) if not file then return nil, "错误，无法加载文件" -- 失败时返回 nil 和错误信息 end return file
end -- 5. 局部函数应该声明为 local
local function helper_function() -- 好：不会污染全局命名空间 -- ...
end -- 6. 使用卫语句提前返回
local function get_player_info(player)	-- 不好：镶套过多 if not player.dead then if player.level_up then print("玩家升级了") end if player.walk then print("玩家移动中...") end else print("玩家已死亡") return "玩家已死亡" end
end local function get_player_info(player)	-- 好：较少镶套 if player.dead then print("玩家已死亡") return "玩家已死亡" end if player.level_up then print("玩家升级了") end if player.walk then print("玩家移动中...") end
end
-- 错误 1：忘记写 return 语句
function add(a, b) local sum = a + b -- 忘记写 return sum
end local result = add(2, 3)
print(result) -- 输出：nil -- 错误 2：递归没有终止条件
local function infinite_recursion(n) print(n) infinite_recursion(n + 1) -- 无限递归！
end
-- infinite_recursion(1) -- 会导致栈溢出 -- 错误 3：修改不应该修改的参数
local function process_user_data(user) user = {} -- 错误：这不会影响原始参数 -- 应该修改 user 的字段，而不是替换整个表
end -- 错误 4：全局变量污染
local function calculate() result = 10 -- 错误：创建了全局变量 local local_result = 10 -- 正确：使用局部变量
end
（点击勾选框勾选）
完成本章后，你应该能够：
定义和调用函数
理解参数传递的机制
使用变长参数处理不定数量的参数
从函数返回单个或多个值
创建和使用匿名函数
理解闭包的概念和用途
编写递归函数
设计模块化的函数库 什么时候应该使用多个返回值，什么时候应该返回表？
闭包和普通函数有什么区别？什么时候应该使用闭包？
递归有什么优缺点？如何避免递归导致的栈溢出？
为什么应该优先使用局部函数而不是全局函数？
如何设计一个良好的函数 API（参数、返回值、错误处理）？ 创建一个简单的银行账户系统，包含存款、取款、查询功能
实现一个简单的缓存系统，使用闭包来保存缓存数据
编写一个函数，可以生成不同难度的数学题目
创建一个事件系统，允许注册回调函数并在特定事件发生时调用
实现一个简单的状态机，使用函数表示不同状态的行为
下一章预告：在第 7 章中，我们将深入学习 Lua 的核心数据结构——表（Table）。表是 Lua 中最重要、最灵活的数据结构，它可以用来实现数组、字典、对象、模块等几乎所有复杂数据结构。我们将学习表的创建、操作、遍历以及各种高级用法。学习建议：
多练习函数的设计和实现
尝试用函数重构重复的代码
理解闭包的概念，这是 Lua 的精华之一
注意函数的命名和参数设计，写出易读易用的代码
尝试编写一些实用的小工具函数库
常见问题解答：
Q: 为什么值类型，参数传递时传递的是副本？
A: 值类型传递副本是因为它们简单且不可变，复制开销小且语义安全。表传递引用是因为它可能很大且需要共享修改（多个变量操作一个表），传递指针更高效。]]></description><link>第-1-节-语法/6.-函数.html</link><guid isPermaLink="false">第 1 节 - 语法/6. 函数.md</guid><pubDate>Wed, 17 Dec 2025 01:47:50 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. 变量与数据类型]]></title><description><![CDATA[-- 使用local关键字声明局部变量
local level = 1
local health = 100
local damage = 12 -- 局部变量只在声明它的代码块内有效
do local x = 10 print("内部 x = " .. x) -- 可以访问x
end print(x) -- 输出 nil，Lua 中不存在的值都是 nil
局部变量的特点：
只在声明它的代码块内可见
使用 local 关键字声明
推荐优先使用局部变量
性能比全局变量好
-- 不使用local关键字，直接赋值创建全局变量
global_counter = 0 -- 全局变量 do global_counter = global_counter + 1
end print(global_counter) -- 输出：1 -- 也可直接在代码块内定义
do x = 1
end print(x) -- 输出：1
全局变量的特点：
在整个程序中都可以访问
不需要关键字，直接赋值即创建
不要过度使用（容易造成命名冲突）
代码块是一组语句的集合：local z = 100 do -- do-end创建普通代码块 local x = 10 local y = 20 print(x + y)	-- 30 print(z) -- 100
end if 条件 then -- 创建条件代码块 local x = 10 a = 1000	-- 全局变量 print(x)	-- 10
end print(x)	-- nil
代码块可以理解为一个 “盒子”盒子内部可以访问外面，以及内部之间的访问，盒子外部无法访问内部。
全局变量其实是定义到一个全局作用域（_G）访问变量时优先从当前作用域查找变量，最后从 _G 查找全局变量。示意图：
<img alt="Pasted image 20251209094358.png" src="site-lib/media/pasted-image-20251209094358.png" target="_self" style="width: 900px; max-width: 100%;">
do-end 代码块
判断条件内的条件代码块
循环内的循环体
函数内的函数体
一个代码块的内部称为一个作用域local x = 5 -- 这里文件顶层代码其实也是个作用域 do local x = 10 -- 局部作用域，只在do...end块内有效 print("内部 x = " .. x) -- 输出：内部 x = 10
end print("外部 x = " .. x) -- 输出：外部 x = 5
-- 1. 一次声明多个局部变量
local x, y, z = 10, 20, 30 -- 2. 先声明，后赋值
local player_name
local player_score player_name = "李雷"
player_score = 1000 -- 3. 交换变量值（无需临时变量）
local a, b = 10, 20
a, b = b, a -- 交换后：a=20, b=10 -- 4. 声明但不初始化（值为nil）
local uninitialized
print(type(uninitialized)) -- 输出：nil
作用域示例：-- 作用域示例：理解变量可见性
local global_x = 100 do -- 内层作用域可以访问外部的局部变量 print("在内部访问外部变量: " .. global_x) -- 输出：100 -- 这个x只在当前作用域内有效 local x = 50 print("局部作用域内的x: " .. x) -- 输出：50 -- 如果没有提前在外部，将会创建全局变量 global_z = 300 -- 创建全局变量
end print("外部的global_z: " .. (global_z)) -- 输出：300
print("外部的x: " .. (x)) -- 输出：nil（局部作用域内的x不可见）
Lua 是动态类型语言，变量类型由值决定。使用 type() 函数可以查看数据类型。-- nil表示"无"或"不存在"
local empty = nil
local undefined -- 未赋值的变量自动为nil print("empty的类型: " .. type(empty)) -- 输出：nil
print("undefined的类型: " .. type(undefined)) -- 输出：nil
local config = { sound = true, music = true }
config.music = nil -- 删除music设置
print("music 值：" .. config.music) -- 输出：nil
-- 只有两个值：true和false
local is_game_over = false
local is_player_alive = true
local has_key = false -- 在条件判断中使用
if is_player_alive then print("玩家还活着")
else print("游戏结束")
end -- Lua中只有false和nil被视为"假"，其他都是"真"
local truth_test = 0 -- 数字0在Lua中是真值
if truth_test then print("数字0是真值") -- 这行会执行
end if nil then print("nil是真值？") -- 这行不会执行
else print("nil是假值") -- 这行会执行
end
-- Lua 5.1中所有数字都是双精度浮点数
local integer = 42 -- 整数
local float = 3.14 -- 浮点数
local negative = -10 -- 负数
local scientific = 2e3 -- 科学计数法：2×10³=2000
local hex = 0xFF -- 十六进制：255
local oct = 0755 -- 八进制：493（0开头） print("整数: " .. integer)
print("浮点数: " .. float)
print("科学计数法: " .. scientific)
print("十六进制: " .. hex)
-- 字符串创建
local str1 = "双引号字符串"	-- 注：不能在其中使用双引号
local str2 = '单引号字符串'	-- 注：不能在其中使用单引号
local str3 = [[多行字符串
可以包含换行
和各种引号]]
local empty_table = {}
local towers = {"箭塔", "兵营", "法师塔", "炮塔"}
print("第一个防御塔: " .. towers[1]) -- 输出：箭塔
local tower = { name = "炮塔", level = 10, damage = 100, ["class"] = "防御塔" -- 如果键包含特殊字符或关键字，需要方括号
} -- 索引字典
print("防御塔: " .. tower.name)
print("等级: " .. tower.level)
print("防御塔类型: " .. tower.class) -- 第二个索引方法
print("防御塔: " .. tower["name"])
print("等级: " .. tower["level"])
print("防御塔类型: " .. tower["class"])
local config = { "设置1", -- 索引1（数组部分） "设置2", -- 索引2 version = "1.0",	-- 键值对（字典部分） author = "开发者"
} print(config[1]) -- 输出：设置1
print(config.version) -- 输出：1.0
-- 函数也是一种数据类型，可以赋值给变量
local say_hello = function(name) return "你好, " .. name
end -- 等价于
local function say_hello(name) return "你好, " .. name
end -- 与变量相同也有全局函数
say_hello = function(name) return "你好, " .. name
end -- 等价于
function say_hello(name) return "你好, " .. name
end -- 函数作为值传递
local greeting_func = say_hello	-- 此时 greeting_func 就是 say_hello
print(greeting_func("世界")) -- 输出：你好, 世界 -- 函数存储在表中
local math_operations = { add = function(a, b) return a + b end, subtract = function(a, b) return a - b end
} print("5 + 3 = " .. math_operations.add(5, 3)) -- 输出 8
print("5 - 3 = " .. math_operations.subtract(5, 3))	-- 输出 2
-- thread：协程，用于实现协作式多任务
local co = coroutine.create(function() print("协程执行中") coroutine.yield() print("协程恢复")
end) coroutine.resume(co) -- 输出：协程执行中
coroutine.resume(co) -- 输出：协程恢复
userdata 用于存储C语言数据，主要用于与C交互
通常由C库创建，Lua代码只能使用，不能创建type(值: any) -&gt; 数据类型: "nil"|"number"|"string"|"boolean"|"table"|"function"|"thread"|"userdata"
print(type("字符串"))	-- 输出 "string"
print(type(123))	-- 输出 "number"
print(type({1, 2, 3}))	-- 输出 "table"
<br>（答案见 <a data-href="第 1 节 - 语法/参考答案#练习 3 1：数据类型识别" href="第-1-节-语法/参考答案.html#练习 3 1：数据类型识别" class="internal-link" target="_self" rel="noopener nofollow">第 1 节 - 语法/参考答案 &gt; 练习 3 1：数据类型识别</a>）-- 创建一个函数，可以识别并输出传入的值的数据类型 变量声明： 使用 local 声明局部变量
直接赋值创建全局变量（不推荐滥用）
代码块的作用域的 “盒子模型” 8 种数据类型： nil：空值
boolean：布尔值（true/false）
number：数字（所有数字都是双精度浮点）
string：字符串
table：表（Lua 的核心数据结构）
function：函数（一等公民）
userdata：C 数据（与 C 交互）
thread：协程（协作式多任务） type()函数： 返回数据类型的字符串表示
用于类型检查和调试 （点击勾选框勾选）
完成本章后，你应该能够：
正确声明局部变量和全局变量
理解代码块的作用域
识别和使用 8 种基本数据类型
使用 type() 函数检查变量类型
理解 Lua 中"真值"的概念（只有 false 和 nil 是假） 为什么 Lua 中 0 是真值而 false 是假值？这样设计有什么好处？
表（table）为什么是 Lua 的核心数据结构？它能替代哪些其他数据结构？
在什么情况下应该使用全局变量？什么情况下应该避免？
下一章预告：在第 4 章中，我们将学习运算符，这是进行基础运算的关键！拓展练习：
创建一个变量交换函数，不使用临时变量
写一个函数判断一个数字是奇数还是偶数
]]></description><link>第-1-节-语法/3.-变量与数据类型.html</link><guid isPermaLink="false">第 1 节 - 语法/3. 变量与数据类型.md</guid><pubDate>Wed, 17 Dec 2025 01:47:09 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1. Lua 介绍]]></title><description><![CDATA[游戏引擎版本：Lua_v5.1 + Love2d_v10.2 + LuaJIT_v2.0.4Lua是一种轻量级、高效、可嵌入的脚本语言。它诞生于 1993 年，由巴西里约热内卢天主教大学（PUC-Rio）的 TeCGraf 实验室开发。简单、小巧、高效、可嵌入、可扩展如果说 C/C++、Java 这样的语言是"工业级重型机械"，那么 Lua 就像是"瑞士军刀"——小巧灵活，适合嵌入到其他系统中，为大型程序添加脚本能力。
体积小巧：Lua 5.1 解释器仅约 200KB（编译后）
资源占用少：内存占用小，启动速度快
代码简洁：整个 Lua 语言规范用几页纸就能描述清楚
这是 Lua 最重要的特性之一。你可以将 Lua 嵌入到 C/C++、Java、C#、Python 等程序中，让这些程序获得脚本扩展能力。示例场景：游戏引擎（主程序，C++编写） ↓
嵌入Lua解释器 ↓
用Lua编写游戏逻辑、AI行为、任务系统 ↓
无需重新编译主程序即可修改游戏内容 Lua 的解释器非常高效
执行速度通常比其他脚本语言快
具有自动内存管理（垃圾回收）
Lua 语法简单，但功能强大。它使用表（table）作为唯一的数据结构机制，通过这一种结构实现了数组、字典、对象、模块等多种功能。Lua 5.1 发布于 2006 年，虽然现在已有更新的版本（5.2、5.3、5.4），但 5.1 版本仍然是：
最广泛使用的版本：大量现有项目基于 5.1
最稳定的版本：经过多年实践检验
兼容性最好：与各种中间件、引擎兼容性最佳
Python：def greet(name): print(f"Hello, {name}!") greet("World")
JavaScript：function greet(name) { console.log(`Hello, ${name}!`);
} greet("World");
Lua 5.1：function greet(name) print("Hello, " .. name .. "!")
end greet("World")
Lua 的语法更加简洁，没有花括号，使用 function 和 end 来界定函数体，使用 .. 来连接字符串。在学习 Lua 之前，理解它的几个核心理念很重要：在 Lua 中，所有值都是"一等公民"——函数可以存储在变量中，作为参数传递，作为返回值。表（table）是 Lua 中唯一的数据结构，但通过它你可以实现：
数组（列表）
字典（映射）
对象（通过表+函数）
模块
包
Lua 语言本身只有很少的关键字（约 20 个），标准库也很精简，但通过这种简洁性获得了极大的灵活性和可扩展性。 游戏领域： 《魔兽世界》：用户界面和插件系统
《愤怒的小鸟》：游戏逻辑
《文明》系列：AI 和游戏规则 软件领域： Redis：支持 Lua 脚本执行
Nginx：通过 OpenResty 支持 Lua
Wireshark：协议分析脚本 工业领域： 思科路由器：配置和自动化
医疗设备：控制逻辑 作为零基础学习者，你的学习路径将是：在开始学习前，让我们澄清一些常见误解： "Lua 只是玩具语言" ❌
事实：Lua 被用于许多关键系统，性能优异，功能完整。 "Lua 功能太弱" ❌
事实：Lua 通过 C API 可以轻松扩展，理论上可以实现任何功能。 "Lua 只适合游戏" ❌
事实：Lua 在嵌入式、网络、工具等领域都有广泛应用。 "学习 Lua 没什么用" ❌
事实：Lua 让你理解"简洁设计"的价值，这种思想适用于所有编程领域。 Lua 是轻量级、可嵌入的脚本语言
Lua 5.1 是最稳定、应用最广泛的版本
Lua 的核心特点是简洁、高效、灵活
表（table）是 Lua 中最重要的数据结构
Lua 在游戏、嵌入式、网络等领域有广泛应用 根据你的了解，Lua 最适合解决什么类型的问题？
为什么许多游戏选择 Lua 作为脚本语言，而不是直接使用 C++？
你觉得 Lua 的"简洁设计"理念有什么优点和缺点？
下一章预告：在第 2 章中，我们将学习基础语法规则，这是写出高质量代码的关键！]]></description><link>第-1-节-语法/1.-lua-介绍.html</link><guid isPermaLink="false">第 1 节 - 语法/1. Lua 介绍.md</guid><pubDate>Wed, 17 Dec 2025 01:46:50 GMT</pubDate></item><item><title><![CDATA[11. 其他函数]]></title><description><![CDATA[storage:load_slot(存档索引?: int, 是否强制重新加载文件?: bool)
storage:save_slot(保存的表: table, 存档索引?: int)
保存前必须要先读取存档
因为这个函数会将存档直接完全替换为保存的表，所以刚开始必须先读取存档，否则存档会丢失此前保存的内容，仅有保存的内容示例：slot = storage:load_slot()	-- slot 接收存档的表，如果你要修改存档必须首先加载存档 slot.heroes.status.hero_gerald.xp = 2333	-- 将爵士的经验设置为 2333 点 storage:save_slot(slot) -- 保存到存档里
]]></description><link>总结/11.-其他函数.html</link><guid isPermaLink="false">总结/11. 其他函数.md</guid><pubDate>Tue, 16 Dec 2025 03:30:35 GMT</pubDate></item><item><title><![CDATA[10. 脚本函数]]></title><description><![CDATA[SU.can_range_soldier(store, 当前实体: table, 被攻击士兵: table) -&gt; 是否可以攻击: bool 作用：判断是否可以远程攻击士兵
判断条件： 是否站桩远程攻击或远程攻击冷却完毕
当前实体没有死亡
当前实体没有被眩晕
被攻击士兵没有死亡
标签没有被禁止
在最小攻击范围外
在最大攻击范围内
]]></description><link>总结/10.-脚本函数.html</link><guid isPermaLink="false">总结/10. 脚本函数.md</guid><pubDate>Tue, 16 Dec 2025 03:26:38 GMT</pubDate></item><item><title><![CDATA[1. 更新逻辑]]></title><description><![CDATA[处理实体移除更新逻辑时间 store.tick_ts + 1调用
game:update调用 director:update调用所有系统更新函数处理实体插入调用 simulation:update simulation:do_tick调用所有系统移除函数调用所有系统插入函数每帧调用的游戏引擎回调函数
love.update]]></description><link>总结/逻辑/1.-更新逻辑.html</link><guid isPermaLink="false">总结/逻辑/1. 更新逻辑.canvas</guid><pubDate>Mon, 15 Dec 2025 10:55:38 GMT</pubDate></item><item><title><![CDATA[8. 表]]></title><description><![CDATA[table.keys(表: table) -&gt; 包含表中所有键的列表: list
table.keyforobject(表: table, 键值: any) -&gt; 键: any
table.contains(表: table, 键值: any) -&gt; 是否包含键值: bool
table.clone(表: table) -&gt; 浅拷贝的表: table
table.deepclone(表: table) -&gt; 深拷贝的表: table
table.merge(表1: table, 表2: table, 是否创建新表合并: bool) -&gt; 浅合并后的表: table 如果不创建新表合并将会修改表 1
table.deepmerge(表1: table, 表2: table, 是否合并到新表?: bool) -&gt; 深合并后的表: table 如果不创建新表合并将会修改表 1
table.append(表1: table, 表2: table, 是否合并到新表?: bool) -&gt; 合并后的列表: list
table.reverse(表: table, 是否深度反转?: bool) -&gt; 反转后的列表: list
table.count(表: table, 过滤函数?: func) -&gt; 统计到的数量: int 为过滤函数传递迭代到的：键: any, 键值: any
table.find(表: table, 元素键值: any|过滤函数: func) -&gt; 键: any 为过滤函数传递迭代到的：键: any, 键值: any
table.filter(表: table, 过滤函数: func) -&gt; 过滤后的列表: list 为过滤函数传递迭代到的：键: any, 键值: any
table.map(表: table, 映射函数: func) -&gt; 转换后表: table 为映射函数传递迭代到的：键: any, 键值: any
映射函数返回值：键: any, 键值: any
映射函数返回单个值将会被序列化
映射函数返回两个值将会保留键值映射
table.reduce(表: table, 归约函数: func) -&gt; 结果: any 为归约函数传递迭代到的：键值: any
示例：
-- 求和
local numbers = { 10, 20, 30, 40 } local sum = table.reduce(numbers, function(element, accumulator) return element + accumulator
end) print("求和结果:", sum) -- 100
table.maxv(表: table) -&gt; 键: any, 键值: any
table.minv(表: table) -&gt; 键: any, 键值: any
table.slice(表: table, 起始索引: int, 结束索引: int) -&gt; 结果: list
table.removeobject(表: table, 键值: any)
table.random(表: table) -&gt; 元素的值: any, 元素索引: int
table.random_order(表: table) -&gt; 获取到的元素列表: list
]]></description><link>总结/8.-表.html</link><guid isPermaLink="false">总结/8. 表.md</guid><pubDate>Mon, 15 Dec 2025 01:57:29 GMT</pubDate></item><item><title><![CDATA[2. 模板函数]]></title><description><![CDATA[E:register_t(模板名: str, 续承模板名?: str) -&gt; 模板的引用: table 示例：
a = E:register_t("a")	-- 创建一个名为 “a” 的模板
a.has_a = true
a.num = 1 template = E:register_t("template", "a")	-- 创建一个名为 “template” 的模板，同时续承 “a” 模板
template.n = 123
-- “template” 模板具有 “a” 模板所有键，修改对应键不影响模板 “a”
-- 也就是 template = { n = 123, has_a = true, num = 1 }
E:get_template(模板名: str) -&gt; 模板的引用: table 作用：返回给定的模板，该函数等价于 E.entities[模板名]
示例：
template = E:register_t("template")
template.num = 1 t = E:get_template("template")	-- 索引模板，等价于 `E.entities.template`
t.num = 123 -- 等价于 `E.entities.template.num = 123`
-- 此时模板 “template” 的 num 键等于 123
E:set_template(模板名: str, 新模板: table) 作用：将对应模板赋值为新模板，该函数等价于 self.entities[模板名] = 新模板
示例：
template = E:register_t("template")
template.num = 1 new_template = { n = 123 } E:set_template("template", new_template)	-- 将 “template” 模板设为 “new_template” 表
-- 此时 template = { n = 123 }
E:register_c(组件: str) -&gt; 组件的引用: table 作用：创建新组件
示例：
a = E:register_c("a")	-- 创建一个名为 “a” 的组件
E:add_comps(模板: table, 组件名: str...) 作用：向模板增加 components 中的组件
示例：
component = E:register_c("component")	-- 创建组件 “component”
component.num = 123
component.is_component = true template = E:register_t("template")
E:add_comps(template, "component") -- 增加组件 “component”
template.n = 1
-- 此时 template = { component = { num = 123, is_component = true }, n = 1}
E:clone_c(组件名: str) -&gt; 表: table 作用：返回深拷贝的组件
示例：
component = E:register_c("component")	-- 创建组件 “component”
component.num = 123
component.is_component = true template = E:register_t("template")
template.cc = E:clone_c("component")	-- 拷贝组件，此时 cc 就是组件 component
template.num = 1
-- 此时 template = { cc = { num = 123, is_component = true }, num = 1 }
E:get_component(组件名: str) -&gt; 组件的引用: table 作用：返回给定的组件，该函数等价于 E.components[组件名]
示例：
component = E:register_c("component")	-- 创建组件 “component”
component.num = 123 c = E:get_component("component")	-- 索引组件，等价于 `E.components.component`
c.num = 1 -- 等价于 `E.components.component.num = 1`
-- 此时 component = { num = 1 }
E:filter(表: table, 键: str...) -&gt; 筛选出的表: table 作用：返回一个表，表内包含在给定表内具有指定键的表
示例：
t = { a = { k = true }, b = { k = true }, c = { n = 2 }
} ft = E:filter(t, "k")	-- 得到 t 里面的所有具有 k 键的表
-- 此时 ft = { a = { k = true }, b = { k = true } }，不包含 c 子表
E:filter_templates(键: str...) -&gt; 筛选出的模板: table 作用：返回一个表，表内包含具有给定键的模板，该函数等价于 E:filter(E.entities, 键: str...)
示例：
enemy_templates = E:filter_templates("enemy")	-- 得到所有敌人模板 for _, e in pairs(enemy_templates) do e.enemy.gold = e.enemy.gold + 100	-- 所有敌人赏金加 100
end
]]></description><link>总结/2.-模板函数.html</link><guid isPermaLink="false">总结/2. 模板函数.md</guid><pubDate>Sun, 14 Dec 2025 09:01:22 GMT</pubDate></item><item><title><![CDATA[6. 造成效果逻辑]]></title><description><![CDATA[效果实体插入时调用 systems.mod_lifecycle:on_insert 函数遍历所有具有相同目标的其他效果实体若被其中任意一个效果禁止返回真replaces_lower 为真则移除其中与当前效果名称相同的效果allows_duplicates 为真，则移除并替换其中与当前效果模板名相同的低级效果返回真resets_same 为真则更新其中效果的时间戳，返回假若当前效果 remove_banned 为真，则移除被当前效果禁止的所有效果]]></description><link>总结/逻辑/6.-造成效果逻辑.html</link><guid isPermaLink="false">总结/逻辑/6. 造成效果逻辑.canvas</guid><pubDate>Sat, 13 Dec 2025 03:28:56 GMT</pubDate></item><item><title><![CDATA[4. 移植]]></title><description><![CDATA[已前三代移植五代为例在五代目录搜索要移植的实体的模板将所有与此实体相关的模板从五代复制到前三代 game_templates 内注：这些模板可能在不同位置，务必将这些都复制过去，而不是搜索后仅复制一部分通常敌人与单位的锚点位于脚下
<img alt="Pasted image 20251120103043.png" src="site-lib/media/pasted-image-20251120103043.png" target="_self" style="width: 475px; max-width: 100%;">
如图锚点（红点）位置 [160, 183]
图像大小 320x211
X 轴相对位置：160 / 320 = 0.5
Y 轴相对位置：1 - 183 / 211 ≈ 0.133
综上 anchor = v(0.5, 0.133) Q：为什么 Y 轴相对位置是 1 与原 Y 轴相对位置之差
A：这是因为 love2d 坐标系原点在左上角，而图像坐标系原点在左下角，所以需要反转
]]></description><link>第-3-节-进阶/4.-移植.html</link><guid isPermaLink="false">第 3 节 - 进阶/4. 移植.md</guid><pubDate>Fri, 12 Dec 2025 08:36:27 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[6. 字符串]]></title><link>总结/6.-字符串.html</link><guid isPermaLink="false">总结/6. 字符串.md</guid><pubDate>Tue, 09 Dec 2025 13:01:53 GMT</pubDate></item><item><title><![CDATA[3. 生成怪物逻辑]]></title><description><![CDATA[调用 simulation:init 函数初始化 simulation调用 system.wave_spawn:init 函数创建波次线协程若下一波没有到来，挂起协程等待释放第一波若玩家主动释放下一波，给予玩家奖励创建新协程根据延迟等数据生成怪物]]></description><link>总结/5-关卡/逻辑/3.-生成怪物逻辑.html</link><guid isPermaLink="false">总结/5 - 关卡/逻辑/3. 生成怪物逻辑.canvas</guid><pubDate>Wed, 26 Nov 2025 08:07:23 GMT</pubDate></item><item><title><![CDATA[3. 精灵更新逻辑]]></title><description><![CDATA[若该精灵是动画，则跳过 animation_db:fn 通过搜索动画调用 animation_db:fni 函数得到图像名称通过时间戳与精灵的 fps 得到图像名称、计算播放次数、将要播放的帧若该精灵启用动画，则调用 animation_db:fn 通过前缀与精灵名称搜索动画默认情况，则图像名称为精灵指定的名称遍历所有具有精灵组件的实体的所有精灵，得到图像名称根据实体血量更新血条缩放、使血条帧同步血条等根据图层升序排序 store.render_frames更新并使精灵帧同步精灵调用 image_db:s 函数根据名称加载对应图像，并存入精灵帧的 ss在 game.draw_game 函数调用 render_utils.draw_frames_range 函数绘制图像]]></description><link>总结/6-动画/逻辑/3.-精灵更新逻辑.html</link><guid isPermaLink="false">总结/6 - 动画/逻辑/3. 精灵更新逻辑.canvas</guid><pubDate>Wed, 26 Nov 2025 06:41:09 GMT</pubDate></item><item><title><![CDATA[2. 精灵移除逻辑]]></title><description><![CDATA[将精灵帧从 store.render_frames 移除]]></description><link>总结/6-动画/逻辑/2.-精灵移除逻辑.html</link><guid isPermaLink="false">总结/6 - 动画/逻辑/2. 精灵移除逻辑.canvas</guid><pubDate>Wed, 26 Nov 2025 06:34:36 GMT</pubDate></item><item><title><![CDATA[4. 补间动画更新逻辑]]></title><description><![CDATA[调用 system.tween:on_update 函数根据关键帧进行插值计算遍历所有实体补间组件的 props获取目标精灵根据补间的 keys 对指定的精灵的键进行插值计算]]></description><link>总结/6-动画/逻辑/4.-补间动画更新逻辑.html</link><guid isPermaLink="false">总结/6 - 动画/逻辑/4. 补间动画更新逻辑.canvas</guid><pubDate>Wed, 26 Nov 2025 06:27:13 GMT</pubDate></item><item><title><![CDATA[特殊出怪逻辑]]></title><description><![CDATA[falsetrue在关卡实体表增加 mega_spawner 实体，并指定加载的特殊出怪文件调用 scripts.mega_spawner.insert 函数加载特殊出怪文件调用 scripts.mega_spawner.update 函数将当前波次的怪物增加到生成队列取出队列根据数据实时生成敌人判断是否到达指定波次，并且没有被中断正常出怪模式遍历所有组，得到其中指定的生成器实体判断通过，加载当前波次出怪数据判断未通过重新判断解包得到数据出怪包模式生成器出怪模式筛选出具有 spawner 组件的实体根据不同模式插入队列根据延迟升序排序队列计算时间，生成敌人]]></description><link>总结/5-关卡/逻辑/特殊出怪逻辑.html</link><guid isPermaLink="false">总结/5 - 关卡/逻辑/特殊出怪逻辑.canvas</guid><pubDate>Wed, 26 Nov 2025 03:41:05 GMT</pubDate></item><item><title><![CDATA[1. 精灵插入逻辑]]></title><description><![CDATA[插入具有精灵组件的实体时调用 system.render:on_insert 函数初始化精灵帧遍历实体的所有精灵初始化相应精灵的帧，增加各种参数，位置、透明度、旋转等增加到 store.render_frames同上初始化血条帧 health_bar.frames]]></description><link>总结/6-动画/逻辑/1.-精灵插入逻辑.html</link><guid isPermaLink="false">总结/6 - 动画/逻辑/1. 精灵插入逻辑.canvas</guid><pubDate>Wed, 26 Nov 2025 03:26:37 GMT</pubDate></item><item><title><![CDATA[4. 创建新关卡]]></title><description><![CDATA[ 绘图
可以使用 AI 进行绘图 <a data-tooltip-position="top" aria-label="https://tieba.baidu.com/p/9780582087?" rel="noopener nofollow" class="external-link is-unresolved" href="https://tieba.baidu.com/p/9780582087?" target="_self">AI 链接</a> 将背景图像放入 _assets/kr-desktop/images/fullhd 内，并改名为 go_stagex_bg-1，x 为关卡编号，在保证不会与已有关卡冲突的条件下可以随便填一个
图像分辨率推荐 1920x1080<br>
<img alt="Pasted image 20250809164512.png" src="site-lib/media/pasted-image-20250809164512.png" target="_self" style="width: 425px; max-width: 100%;"> 然后创建对应的数据文件 go_stagex_bg.lua，x 同上，并复制以下模板 return { stagex = {	-- x 同上 a_name = "go_stagex_bg-1.png",-- x 同上 size = { 1920, 1080 }, trim = { 0, 0, 0, 0 }, a_size = { 1920, 1080 }, f_quad = { 0, 0, 1920, 1080 }, alias = {} }
}
在 _assets/kr1-desktop/images/fullhd/screen_map 最后面增加一个表即可：stage_thumbs_000x = {	-- x 同上，若 x 为 1 则是 0001，大于等于 10 则需要在前面加 “00” 如：0010 a_name = "go_stagex_bg-1.png", size = { 1920, 1080 }, trim = { 0, 0, 0, 0 }, a_size = { 342, 246 }, f_quad = { 0, 0, 342, 246 }, alias = {}
}
<br><img alt="Pasted image 20250809094636.png" src="site-lib/media/pasted-image-20250809094636.png" target="_self" style="width: 425px; max-width: 100%;">level_select_thumbs_thumb_stage_427_0001 = { a_name = "room_levelselect_level_select_thumbs-427.dds", defer = true, size = { 2016, 1064 }, trim = { 0, 0, 0, 0 }, a_size = { 2016, 1064 }, f_quad = { 0, 0, 2016, 1064 }, alias = {}
},
在 kr\data\levels 创建 levelx_data.lua 文件，x 同上，并复制以下模板，参数可以按照自己的想法填return { entities_list = { { template = "decal_background",	-- 背景贴图，背景本质也是实体 pos = { x = 512, y = 384 }, ["render.sprites[1].name"] = "stage27", ["render.sprites[1].z"] = 1000 }, { template = "decal_background",	-- 防守点旗帜，可选 pos = { x = -43.46875, y = 326.34375 }, ["render.sprites[1].name"] = "blue_flag", ["render.sprites[1].z"] = 1400 }, { template = "decal_background", pos = { x = -43.46875, y = 526.03125 }, ["render.sprites[1].name"] = "blue_flag", ["render.sprites[1].z"] = 1400 }, { template = "decal_defend_point",	-- 防守点，必加，否则进入将会报错 ["editor.exit_id"] = 1, pos = { x = -44.875, y = 402.28125 } }, { template = "editor_wave_flag",	-- 释放波次贴图，必加，否则无法释放波次 ["editor.len"] = 240, ["editor.path_id"] = 1, ["editor.r"] = 0, pos = { x = 1156.0625, y = 399.46875 } }, }, invalid_path_ranges = {}, level_mode_overrides = { { locked_towers = {}, max_upgrade_level = 5 }, { locked_towers = {}, max_upgrade_level = 5 }, { locked_towers = {}, max_upgrade_level = 5 } }, level_terrain_type = 1, locked_hero = false, max_upgrade_level = 5, nav_mesh = {}, required_sounds = {},	-- 音效资源 required_textures = { "go_enemies_grass",	-- 一些敌人资源 "go_stagex_bg",	-- 加载对应关卡背景资源，x 同上 "go_stages_blackburn"	-- 借用里面的防守点旗帜资源 }
} 将 game_settings.last_level 数字加 1 在 game_settings.level_ranges 最后面增加一个关卡序号表，表内填增加的关卡序号 {x}，可以增加 list 键改为无序解锁
game_settings.level_ranges 表决定关卡解锁顺序，注：所有支线第一关在主线通关后会全部解锁 示例：game_settings.level_ranges = { { 1, 12	-- 1-12 关为主线 }, -- 主线通关后解锁第 13、14、17 关支线 { 13 }, { 14, 16	-- 第 14 关通关后解锁第 15 关，第 15 关通关后解锁第 16 关，以此类推 }, { 17, 22,	-- 第 16 关通关后仅解锁第 22 关 list = true }, ...
} 在 kr-desktop\data\map_data.level_data 最后面增加一个表：
{ upgrades = { heroe = true,	-- 规则：有英雄 level = 5	-- 规则：防御塔等级 }, iron = {	-- 钢铁规则：禁用的塔 "archers",	-- 箭塔 "barracks"	-- 兵营 "mages",	-- 法师 "artillery",	-- 炮塔 }
}
map_data.level_data 表的键的下标索引决定对应的关卡的模式选择界面显示的规则<br>
<img alt="Pasted image 20250809094524.png" src="site-lib/media/pasted-image-20250809094524.png" target="_self" style="width: 190px; max-width: 100%;">
在 kr-desktop/data/map_points.flags 最后面增加一个入口位置表
{ number = "x",	-- 关卡编号 pos = { x = 1173,	-- 位置 y = 102 }
}
map_points.flags 表的键的下标索引决定对应关卡的入口的坐标位置将 args 启动参数的关卡编辑器取消注释，将 custom 键修改为刚刚创建的关卡编号
运行游戏即可进入关卡编辑器点击小加号选中，拖动即可移动位置，注：需要点击 entities 选项<br>
<img alt="Pasted image 20250807181638.png" src="site-lib/media/pasted-image-20250807181638.png" target="_self" style="width: 900px; max-width: 100%;">
防守点规定了英雄出生位置搜索并选择样式，然后插入塔位即可
修改位置的方法还是拖动，注：会同时插入名为 editor_rally_point 的默认集结点<br>
<img alt="Pasted image 20250807183501.png" src="site-lib/media/pasted-image-20250807183501.png" target="_self">
注：若进入关卡发现塔位贴图消失就是忘记选择样式了点击 paths 选项然后创建路径，自行设定路径即可<br>
<img alt="Pasted image 20250807182230.png" src="site-lib/media/pasted-image-20250807182230.png" target="_self">
注：较大的节点为起点，推荐将起点与终点设在关卡背景外
最下面 subdivide 可以增加额外节点点击 grid 选项，选择网格类型然后画满背景即可<br>
<img alt="Pasted image 20250807183059.png" src="site-lib/media/pasted-image-20250807183059.png" target="_self" style="width: 725px; max-width: 100%;">
网格规定了可更改集结点单位的可移动区域路径上直接画 land，非路径一般都有 no walk 标签
brush size 为刷子大小点击 nav 选项然后点击塔位调整 top / left / right / bottom 即可<br>
<img alt="Pasted image 20250808185126.png" src="site-lib/media/pasted-image-20250808185126.png" target="_self" style="width: 500px; max-width: 100%;">
nav 规定了键盘方向键切换塔位的顺序一切完毕后点击 save 保存即可
此时会自动创建对应关卡的路径与格子数据文件使用波次编辑器在 kr\data\waves 创建 levelx_waves_campaign 波次数据文件
注：不同后缀表示对应模式的波次数据，英雄为 _heroic，钢铁为 _iron，请自行创建，若没有则全部使用战役的波次数据再次打开关卡编辑器插入 editor_wave_flag 的实体，修改位置即可<br>
<img alt="Pasted image 20250808090849.png" src="site-lib/media/pasted-image-20250808090849.png" target="_self">
注：默认按钮是没有贴图的，需要找加号修改位置（加号默认在中心点偏下）
如果有多条路径则需要增加多个波次释放按钮可以通过插入实体来创建一些动态贴图或可交互彩蛋<br>
<img alt="Pasted image 20250811184142.png" src="site-lib/media/pasted-image-20250811184142.png" target="_self" style="width: 349px; max-width: 100%;">
注：其他场景装饰实体自行在关卡编辑器查看，并且需要加载相应贴图与动画资源]]></description><link>第-3-节-进阶/4.-创建新关卡.html</link><guid isPermaLink="false">第 3 节 - 进阶/4. 创建新关卡.md</guid><pubDate>Wed, 26 Nov 2025 03:15:53 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[README]]></title><description><![CDATA[文档地址：
mc123acd.github.io/KR_modCourseHTML文件在另一个分支，主分支用来放 Markdown 源文件第三个分支为整合包 使用 Git 克隆本仓库的 MD 源文件的分支 使用 Obsidian 打开克隆的仓库 <a data-tooltip-position="top" aria-label="https://thoughts.teambition.com/share/62a131711a6baa00416a79d3#title=Obsidian_%E5%AE%89%E8%A3%85%E5%8C%85" rel="noopener nofollow" class="external-link is-unresolved" href="https://thoughts.teambition.com/share/62a131711a6baa00416a79d3#title=Obsidian_%E5%AE%89%E8%A3%85%E5%8C%85" target="_self">下载链接</a> 虽然仓库自带 MD 转化 HTML 插件，但是还是推荐编辑完毕后仅提交 MD 源文件
<br>
图像必须为 png，并且需要压缩，请将图像放到 site-lib/media 内 <a data-tooltip-position="top" aria-label="https://www.iloveimg.com/zh-cn/compress-image" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.iloveimg.com/zh-cn/compress-image" target="_self">在线压缩图像</a> 格式统一 ]]></description><link>readme.html</link><guid isPermaLink="false">README.md</guid><pubDate>Wed, 26 Nov 2025 03:15:53 GMT</pubDate></item><item><title><![CDATA[2. 实体创建逻辑]]></title><description><![CDATA[调用 entity_db:create_entity 函数创建实体表返回该实体表深拷贝模板，生成独立实体表实体表具有只增不减的 ID取出队列的实体表调用插入系统传递参数：this 当前实体表、store若其中任意一个返回假则调用出列系统传递参数：this、store、true调用 simulation:insert_entity&nbsp;函数插入实体以键值对&nbsp;[ID] = 实体表&nbsp;形式插入&nbsp;store.entities 正式创建实体调用 simulation.queue_insert_entity 函数将实体表增加到待插入队列增加到 store.pending_inserts]]></description><link>总结/逻辑/2.-实体创建逻辑.html</link><guid isPermaLink="false">总结/逻辑/2. 实体创建逻辑.canvas</guid><pubDate>Tue, 25 Nov 2025 07:45:00 GMT</pubDate></item><item><title><![CDATA[8. 远程攻击逻辑]]></title><description><![CDATA[在实体插入函数调用 U.attack_order 函数排序攻击见近战攻击逻辑，不进行赘叙在实体更新函数调用 SU.y_soldier_ranged_attacks 远程攻击函数调用 SU.soldier_pick_ranged_target_and_attack 函数寻找攻击范围内目标与得到可用攻击按顺序遍历攻击的 order 表寻找攻击范围内的目标根据攻击类型：单体攻击、多次攻击，调用对应攻击类型的函数创建子弹计算子弹飞行轨迹，抛物线（箭矢），直线追踪（魔法弹）等造成伤害与造成效果]]></description><link>总结/逻辑/8.-远程攻击逻辑.html</link><guid isPermaLink="false">总结/逻辑/8. 远程攻击逻辑.canvas</guid><pubDate>Tue, 25 Nov 2025 07:17:37 GMT</pubDate></item><item><title><![CDATA[5. 造成伤害逻辑]]></title><description><![CDATA[调用 entity_db:create_entity 创建伤害实体表调用 table.insert 函数将伤害增加到伤害队列遍历伤害队列通过 target_id 在 store.entities 得到目标实体调用 U.predict_damage 函数计算伤害大小降低实体血量，造成伤害将造成过伤害的伤害移出队列计算护甲与伤害类型的影响，不进行赘叙处理血量小于 0 死亡的敌人将此敌人标记为已死亡通过赏金给予玩家金币health.dead = true]]></description><link>总结/逻辑/5.-造成伤害逻辑.html</link><guid isPermaLink="false">总结/逻辑/5. 造成伤害逻辑.canvas</guid><pubDate>Tue, 25 Nov 2025 07:07:25 GMT</pubDate></item><item><title><![CDATA[4. 实体更新逻辑]]></title><description><![CDATA[调用 systems.main_script:on_update 函数调度协程遍历所有具有 main_script.update 更新函数的实体若实体更新函数没有协程且没有运行过，则创建更新函数的协程重启协程传递参数：当前实体、store、实体函数表的引用]]></description><link>总结/逻辑/4.-实体更新逻辑.html</link><guid isPermaLink="false">总结/逻辑/4. 实体更新逻辑.canvas</guid><pubDate>Tue, 25 Nov 2025 00:30:22 GMT</pubDate></item><item><title><![CDATA[3. 实体移除逻辑]]></title><description><![CDATA[取出队列的实体调用&nbsp;simulation:remove_entity&nbsp;函数移除实体调用移除系统传递参数：this、store调用 simulation.queue_remove_entity 函数将实体增加到待移除队列增加到 store.pending_removals将 store.entities 对应 ID 实体表赋值为 nil 移除实体若其中任意一个移除函数返回假则调用出列系统传递参数：this、store、false]]></description><link>总结/逻辑/3.-实体移除逻辑.html</link><guid isPermaLink="false">总结/逻辑/3. 实体移除逻辑.canvas</guid><pubDate>Tue, 25 Nov 2025 00:15:54 GMT</pubDate></item><item><title><![CDATA[12. 关卡逻辑]]></title><description><![CDATA[ 调用 screen_map:start_level 函数 回调 director:item_done_callback 函数指定即将进入的界面：
1. 将 director.next_item_name 键赋值为 "game" 调用 director:update 函数更新界面： 调用 director:queue_load_item_named 函数进入加载界面中转： 根据 next_item_name 键在 kr-desktop/data/director_data.item_props 的 src 决定进入的界面 进入 game 关卡界面
加载模块 game 并存入 director.queued_item 队列内 调用 director.queued_item.init 函数（game:init）初始化关卡 调用 grid_db:load 函数加载网格数据 调用 path_db:load 函数加载路径数据 调用 wave_db:load 函数加载波次数据 若有 level:init 关卡初始化函数则调用其 若有关卡数据则调用 LU.insert_entities 创建关卡数据内的实体 若有 level.load 关卡加载函数则调用其 根据波次数据设定初始金币 根据模式设定初始生命 战役设定为 20
英雄、钢铁设定为 1 若有 store.level.update 关卡更新函数则调用其 调用 LU.insert_hero 函数插入英雄 若当前生命小于 1 （失败）则： 将结果、关卡索引、模式、难度存入 store.game_outcome 游戏结果 将存档 last_victory 键赋值为 nil，表示未胜利 调用 store_hero_xp 函数保存英雄经验 无尽模式则将最高分数写入存档 若关卡完成、所有波次已释放、敌人全部死亡（胜利）则： 根据血量计算星星 将结果、模式、关卡索引、星星数量等存入游戏结果以及存档的 last_victory 最近胜利中 保存英雄经验 调用 game_gui:go_to_map 函数前往地图： 保存英雄经验到存档 调用 sound_db:stop_all 停止所有音效 回调 director:item_done_callback 函数指定即将进入的界面： 将 director.next_item_name 键赋值为 "map" 调用 director:update 函数更新界面： 调用 director:queue_load_item_named 函数进入加载界面中转： 根据 next_item_name 键在 kr-desktop/data/director_data.item_props 的 src 决定进入的界面 进入 screen_map 地图界面
加载模块 screen_map 并存入 director.queued_item 队列内 调用 director.queued_item.init 函数（screen_map:init）重新初始化 若存档中有 last_victory 键且存档没有对应关卡模式的通关数据（存档的 levels 键），则根据关卡模式进行： 战役模式：调用 U.find_next_level_in_ranges 函数在 game_settings.level_ranges 寻找下一关 将 screen.unlock_data 解锁数据表的 show_stars_level 赋值为通关的关卡索引，表示通关的关卡旗帜上播放星星增加动画 将解锁数据表的 new_level 赋值为下一个关卡的索引： 遍历 game_settings.level_ranges 关卡范围
若一个范围内的 list 键为 true （表示这个范围为列表）且通关的关卡索引包含在内，则： 返回范围中的下一个关卡的索引 ↑ 若通关的关卡索引等于最大范围，则： 返回下一个范围的第一个键 ↑ 若通关的关卡索引在一个范围区间内，则： 返回范围中的下一个关卡的索引 ↑ 将下一个关卡的索引存入解锁数据表的 new_level 与 unlocked_levels 中 若通关获得的星星大于此前获得的星星，则： 将解锁数据表的 star_count_before 此前星星总数赋值为通关获得的星星
将通关获得的星星重新赋值给存档的对应关卡数据 英雄模式：将解锁数据表的 heroic_level 赋值为通关的关卡的索引 钢铁模式：将解锁数据表的 iron_level 赋值为通关的关卡的索引 调用 U.unlock_next_levels_in_ranges 函数将将要解锁的关卡存起： 若存档有主线最后一关的关卡数据则： 将所有存档内没有的支线关卡第一关存入将要解锁的关卡表 将所有存档内没有的关卡，根据关卡范围将下一关索引存入将要解锁的关卡表 同时将下一关索引存入 screen.unlock_data.new_level 加载 kr-desktop/data/map_points 模块并将对应表分别存入 screen_map.map_points.points / flags / endless_flags 调用 self:show_flags 函数（续承自父类 MapView）显示关卡旗帜： 调用 self:load_level_decos 函数加载并创建地图装饰 kr-desktop/data.map_data.map_decos 将有 trigger_level 键的装饰返回到 self.level_decos 中 根据 game_settings.last_level 设定最大关卡数 遍历存档中通关的关卡 根据 screen_map.map_points.points 表创建旗帜之间的连接点（续承自 KImageView） 创建已通关的关卡的旗帜（续承自 LevelFlagView） 根据存档内战役、英雄、钢铁通关状态为旗帜设定不同样式 创建无尽模式旗帜（续承自 EndlessLevelFlagView） 若是首次创建的旗帜则根据不同情况播放动画： 若关卡索引等于 screen.unlock_data.show_stars_level 则播放显示星星动画
若通过钢铁模式 screen.unlock_data.iron_level 则播放通过钢铁模式的动画
若通过英雄模式 screen.unlock_data.heroic_level 则播放通过英雄模式的动画
显示对应关卡的地图装饰（trigger_level）
播放连接新解锁（screen.unlock_data.new_level）的关卡的连接动画（旗帜之间的连接点）
播放所有将要解锁的关卡表的关卡（screen.unlock_data.unlocked_levels）的插入旗帜动画 根据不同数据格式调用： tsv 则调用 wave_db:load_tsv
lua 则调用 wave_db:load_lua 将波次数据存入 wave_db.db 调用 system.wave_spawn:init 函数： 根据模式设定关卡最大波次 无尽最大波次 store.wave_group_total 设定为 0
非无尽根据波次数据的波次数量决定 创建波次线协程 store.wave_spawn_thread 调用 W:get_group 获得对应波次的数据 第一波则调用 game_gui.wave_notification_handler 函数显示消息 若没有主动释放第一波则循环挂起协程 若下一波没有到来（interval），没有跳过这一波则循环挂起协程 若主动释放下一波则调用 game_gui.early_wave_called_handler 函数处理释放非第一波波次 无尽模式额外增加分数
调用对应能力的 early_wave_bonus 函数给予玩家奖励（减冷却） 调用 game_gui.next_wave_sent_handler 函数处理释放波次 隐藏释放波次按钮
调用 game_gui.unlock_user_power_handler 函数解锁对应技能 显示消息 创建协程，延迟 delay 一定时间，返回并 spawner 调用生成敌人 协程返回到 store.waves_active 这一波敌人生成完毕后 i += 1 标志进入下一波 加载关卡路径数据并存入 path_db:paths 调用 path_db:set_start_node 与 path_db:set_end_node 函数设定起点与终点节点并存入 path_db:path_start_node 与 path_db:path_end_node 内 在驱动函数调用 system.goal_line:on_update 函数 若具有 nav_path 键的敌人到达终点（nav_path.ni &gt;= P:path_end_node）则： 将生命减去敌人的 enemy.lives_cost，并移除这个敌人 加载关卡网格数据，并存入 grid_db.grid grid_db.ox 网格中心点 x 轴
grid_db.oy 网格中心点 y 轴
grid_db.grid_w 所有网格总长度
grid_db.grid_h 所有网格总宽度 ]]></description><link>总结/5-关卡/逻辑/12.-关卡逻辑.html</link><guid isPermaLink="false">总结/5 - 关卡/逻辑/12. 关卡逻辑.md</guid><pubDate>Tue, 14 Oct 2025 06:07:43 GMT</pubDate></item><item><title><![CDATA[8. 存档]]></title><description><![CDATA[存档用于存储各种英雄等级，加点，完成的成就、星星以及升级、关卡完成情况等
原版 C:\Users\用户\AppData\Roaming\kingdom_rush_xxx 调试 C:\Users\用户\AppData\Roaming\LOVE\kingdom_rush_xxx 里面 也可以点击工作区文件夹内的存档位置快捷方式进行跳转
]]></description><link>第-2-节-修改基础/8.-存档.html</link><guid isPermaLink="false">第 2 节 - 修改基础/8. 存档.md</guid><pubDate>Tue, 14 Oct 2025 05:04:52 GMT</pubDate></item></channel></rss>