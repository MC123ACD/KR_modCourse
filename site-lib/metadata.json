{"createdTime":1766752091556,"shownInTree":["第-1-节-语法/0.-配置环境.html","第-1-节-语法/1.-lua-介绍.html","第-1-节-语法/2.-基础语法规则.html","第-1-节-语法/3.-变量与数据类型.html","第-1-节-语法/4.-运算符.html","第-1-节-语法/5.-控制结构.html","第-1-节-语法/6.-函数.html","第-1-节-语法/7.-表.html","第-1-节-语法/8.-字符串.html","第-1-节-语法/9.-模块.html","第-1-节-语法/10.-调试与错误处理.html","第-1-节-语法/11.-迭代器与泛型for.html","第-1-节-语法/12.-协程.html","第-1-节-语法/13.-元表.html","第-1-节-语法/14.-luajit.html","第-1-节-语法/15.-love-2d.html","第-1-节-语法/参考答案.html","第-2-节-修改基础/1.-介绍.html","第-2-节-修改基础/2.-实体与模板.html","第-2-节-修改基础/3.-实体函数.html","第-2-节-修改基础/4.-关卡.html","第-2-节-修改基础/5.-科技树与难度设定.html","第-2-节-修改基础/6.-精灵与声音.html","第-2-节-修改基础/7.-界面.html","第-2-节-修改基础/8.-存档.html","第-2-节-修改基础/9.-系统.html","第-2-节-修改基础/11.-工具使用方法.html","第-2-节-修改基础/参考答案.html","第-3-节-进阶/4.-创建新关卡.html","第-3-节-进阶/4.-移植.html","其他/local-lua-debugger-说明翻译.html","总结/5-关卡/逻辑/3.-生成怪物逻辑.html","总结/5-关卡/逻辑/12.-关卡逻辑.html","总结/5-关卡/逻辑/特殊出怪逻辑.html","总结/6-动画/逻辑/1.-精灵插入逻辑.html","总结/6-动画/逻辑/2.-精灵移除逻辑.html","总结/6-动画/逻辑/3.-精灵更新逻辑.html","总结/6-动画/逻辑/4.-补间动画更新逻辑.html","总结/逻辑/1.-更新逻辑.html","总结/逻辑/2.-实体创建逻辑.html","总结/逻辑/3.-实体移除逻辑.html","总结/逻辑/4.-实体更新逻辑.html","总结/逻辑/5.-造成伤害逻辑.html","总结/逻辑/6.-造成效果逻辑.html","总结/逻辑/7.-近战攻击逻辑.html","总结/逻辑/8.-远程攻击逻辑.html","总结/逻辑/9.-闪避逻辑.html","总结/1.-模板名.html","总结/2.-模板函数.html","总结/3.-常量.html","总结/4.-关卡.html","总结/5.-路径.html","总结/6.-网格.html","总结/6.-字符串.html","总结/7.-键.html","总结/8.-表.html","总结/9.-工具函数.html","总结/10.-脚本函数.html","总结/11.-其他函数.html","总结/12.-库.html","总结/13.-类.html","index.html","readme.html"],"attachments":["site-lib/html/custom-head-content-content.html","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/293fd13dbca5a3e450ef.woff2","site-lib/fonts/085cb93e613ba3d40d2b.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/other-plugins.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css","site-lib/media/pasted-image-20250803100142.png","site-lib/media/pasted-image-20250803100333.png","site-lib/media/pasted-image-20251225185539.png","site-lib/media/pasted-image-20251225185723.png","site-lib/media/pasted-image-20251225185853.png","site-lib/media/pasted-image-20251225190026.png","site-lib/media/pasted-image-20251225190451.png","site-lib/media/pasted-image-20251225191640.png","site-lib/media/pasted-image-20251225195034.png","site-lib/media/pasted-image-20251225203906.png","site-lib/media/pasted-image-20251225201739.png","site-lib/media/pasted-image-20251225202221.png","site-lib/media/pasted-image-20250621105918.png","site-lib/media/pasted-image-20250620190901.png","site-lib/media/pasted-image-20251213194044.png","site-lib/media/pasted-image-20251213173619.png","site-lib/media/pasted-image-20250712192159.png","site-lib/media/pasted-image-20250624161626.png","site-lib/media/pasted-image-20250803203730.png","site-lib/media/pasted-image-20250717091020.png","site-lib/media/pasted-image-20251206205112.png","site-lib/media/pasted-image-20251206205740.png","site-lib/media/pasted-image-20251225155912.png","site-lib/media/pasted-image-20251225194347.png","site-lib/media/pasted-image-20251225194118.png","site-lib/media/pasted-image-20251226133851.png","site-lib/media/pasted-image-20251225194600.png","site-lib/media/pasted-image-20251210202636.png","site-lib/media/pasted-image-20250706200745.png","site-lib/media/pasted-image-20250710092722.png","site-lib/media/pasted-image-20251206202705.png","site-lib/media/pasted-image-20250618131806.png","site-lib/media/pasted-image-20250716183243.png","site-lib/media/pasted-image-20250707085646.png","site-lib/media/pasted-image-20250707085857.png","site-lib/media/pasted-image-20250716131909.png","site-lib/media/pasted-image-20251115141653.png","site-lib/media/pasted-image-20251215185551.png","site-lib/media/pasted-image-20251109133154.png","site-lib/media/pasted-image-20251215100819.png","site-lib/media/pasted-image-20250812125430.png","site-lib/media/pasted-image-20250828164236.png","site-lib/media/pasted-image-20250828164839.png","site-lib/media/pasted-image-20251223100412.png","site-lib/media/pasted-image-20251212181056.png","site-lib/media/pasted-image-20250626192149.png","site-lib/media/pasted-image-20250626191819.png","site-lib/media/pasted-image-20251211142754.png","site-lib/media/pasted-image-20251208134125.png","site-lib/media/pasted-image-20251211205307.png","site-lib/media/pasted-image-20251209094358.png","site-lib/media/pasted-image-20251120103043.png","site-lib/media/pasted-image-20250809164512.png","site-lib/media/pasted-image-20250809094636.png","site-lib/media/pasted-image-20250809094524.png","site-lib/media/pasted-image-20250807181638.png","site-lib/media/pasted-image-20250807183501.png","site-lib/media/pasted-image-20250807182230.png","site-lib/media/pasted-image-20250807183059.png","site-lib/media/pasted-image-20250808185126.png","site-lib/media/pasted-image-20250808090849.png","site-lib/media/pasted-image-20250811184142.png","site-lib/rss.xml"],"allFiles":["index.html","第-1-节-语法/14.-luajit.html","第-1-节-语法/10.-调试与错误处理.html","site-lib/media/pasted-image-20251225185539.png","site-lib/media/pasted-image-20251225155912.png","site-lib/media/pasted-image-20251223100412.png","site-lib/media/pasted-image-20251225195034.png","site-lib/media/pasted-image-20251225203906.png","site-lib/media/pasted-image-20251225201739.png","site-lib/media/pasted-image-20251225202221.png","site-lib/media/pasted-image-20251226133851.png","site-lib/media/pasted-image-20251215185551.png","site-lib/media/pasted-image-20251225185853.png","site-lib/media/pasted-image-20251225190026.png","site-lib/media/pasted-image-20251225190451.png","site-lib/media/pasted-image-20251225191640.png","site-lib/media/pasted-image-20251225194347.png","site-lib/media/pasted-image-20251225194118.png","site-lib/media/pasted-image-20251225194600.png","site-lib/media/pasted-image-20251225185723.png","第-2-节-修改基础/5.-科技树与难度设定.html","第-2-节-修改基础/1.-介绍.html","第-1-节-语法/2.-基础语法规则.html","第-1-节-语法/参考答案.html","其他/local-lua-debugger-说明翻译.html","第-1-节-语法/5.-控制结构.html","第-1-节-语法/4.-运算符.html","第-1-节-语法/8.-字符串.html","第-1-节-语法/9.-模块.html","第-2-节-修改基础/11.-工具使用方法.html","第-1-节-语法/0.-配置环境.html","第-2-节-修改基础/3.-实体函数.html","第-1-节-语法/13.-元表.html","第-2-节-修改基础/9.-系统.html","第-2-节-修改基础/7.-界面.html","第-2-节-修改基础/6.-精灵与声音.html","第-1-节-语法/12.-协程.html","第-1-节-语法/15.-love-2d.html","总结/5.-路径.html","总结/9.-工具函数.html","总结/6.-网格.html","第-2-节-修改基础/4.-关卡.html","总结/3.-常量.html","总结/4.-关卡.html","第-2-节-修改基础/参考答案.html","总结/逻辑/9.-闪避逻辑.html","总结/逻辑/7.-近战攻击逻辑.html","总结/12.-库.html","第-2-节-修改基础/2.-实体与模板.html","总结/13.-类.html","总结/1.-模板名.html","总结/7.-键.html","第-1-节-语法/11.-迭代器与泛型for.html","第-1-节-语法/7.-表.html","第-1-节-语法/6.-函数.html","第-1-节-语法/3.-变量与数据类型.html","第-1-节-语法/1.-lua-介绍.html","总结/11.-其他函数.html","总结/10.-脚本函数.html","总结/逻辑/1.-更新逻辑.html","site-lib/media/pasted-image-20251213194044.png","site-lib/media/pasted-image-20251213173619.png","site-lib/media/pasted-image-20251215100819.png","site-lib/media/pasted-image-20251212181056.png","总结/8.-表.html","总结/2.-模板函数.html","总结/逻辑/6.-造成效果逻辑.html","第-3-节-进阶/4.-移植.html","site-lib/media/pasted-image-20251211142754.png","site-lib/media/pasted-image-20251211205307.png","site-lib/media/pasted-image-20251209094358.png","site-lib/media/pasted-image-20251210202636.png","总结/6.-字符串.html","site-lib/media/pasted-image-20251206205112.png","site-lib/media/pasted-image-20251206205740.png","site-lib/media/pasted-image-20251206202705.png","site-lib/media/pasted-image-20251208134125.png","总结/5-关卡/逻辑/3.-生成怪物逻辑.html","总结/6-动画/逻辑/3.-精灵更新逻辑.html","总结/6-动画/逻辑/2.-精灵移除逻辑.html","总结/6-动画/逻辑/4.-补间动画更新逻辑.html","总结/5-关卡/逻辑/特殊出怪逻辑.html","总结/6-动画/逻辑/1.-精灵插入逻辑.html","第-3-节-进阶/4.-创建新关卡.html","readme.html","总结/逻辑/2.-实体创建逻辑.html","总结/逻辑/8.-远程攻击逻辑.html","总结/逻辑/5.-造成伤害逻辑.html","site-lib/media/pasted-image-20251115141653.png","site-lib/media/pasted-image-20251120103043.png","总结/逻辑/4.-实体更新逻辑.html","总结/逻辑/3.-实体移除逻辑.html","site-lib/media/pasted-image-20251109133154.png","总结/5-关卡/逻辑/12.-关卡逻辑.html","第-2-节-修改基础/8.-存档.html","site-lib/media/pasted-image-20250812125430.png","site-lib/media/pasted-image-20250828164236.png","site-lib/media/pasted-image-20250828164839.png","site-lib/media/pasted-image-20250809164512.png","site-lib/media/pasted-image-20250811184142.png","site-lib/media/pasted-image-20250803100142.png","site-lib/media/pasted-image-20250803100333.png","site-lib/media/pasted-image-20250620190901.png","site-lib/media/pasted-image-20250717091020.png","site-lib/media/pasted-image-20250618131806.png","site-lib/media/pasted-image-20250807183501.png","site-lib/media/pasted-image-20250807182230.png","site-lib/media/pasted-image-20250807183059.png","site-lib/media/pasted-image-20250808090849.png","site-lib/media/pasted-image-20250803203730.png","site-lib/media/pasted-image-20250807181638.png","site-lib/media/pasted-image-20250809094636.png","site-lib/media/pasted-image-20250809094524.png","site-lib/media/pasted-image-20250808185126.png","site-lib/html/custom-head-content-content.html","site-lib/media/pasted-image-20250712192159.png","site-lib/media/pasted-image-20250716183243.png","site-lib/media/pasted-image-20250716131909.png","site-lib/media/pasted-image-20250710092722.png","site-lib/media/pasted-image-20250706200745.png","site-lib/media/pasted-image-20250707085646.png","site-lib/media/pasted-image-20250707085857.png","site-lib/media/favicon.png","site-lib/media/pasted-image-20250624161626.png","site-lib/media/pasted-image-20250626192149.png","site-lib/media/pasted-image-20250626191819.png","site-lib/media/pasted-image-20250621105918.png","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/293fd13dbca5a3e450ef.woff2","site-lib/fonts/085cb93e613ba3d40d2b.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/other-plugins.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css"],"webpages":{"第-1-节-语法/0.-配置环境.html":{"title":"0. 配置环境","icon":"","description":"\n<a data-tooltip-position=\"top\" aria-label=\"https://code.visualstudio.com/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://code.visualstudio.com/\" target=\"_self\">下载链接</a>\n<br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://wwuk.lanzouo.com/b007u3i2jg\" target=\"_self\">https://wwuk.lanzouo.com/b007u3i2jg</a>\n密码:fv51\n可以放到其他地方，但要保证没有中文路径，也可以重命名，请改一个便于找到的位置与名字<br>\n<img alt=\"Pasted image 20250706200745.png\" src=\"site-lib/media/pasted-image-20250706200745.png\" target=\"_self\" style=\"width: 395px; max-width: 100%;\">\n此文件夹包含配置文件、Love 2d 引擎，以及用于推荐插件与使用预先修改的设置<br><img alt=\"Pasted image 20250710092722.png\" src=\"site-lib/media/pasted-image-20250710092722.png\" target=\"_self\" style=\"width: 525px; max-width: 100%;\">\n包含 Lua 代码补全、诊断、格式化、用于调试的扩展\n所有插件均配置完毕，无需自行配置\n<br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://wwuk.lanzouo.com/b007u3i2jg\" target=\"_self\">https://wwuk.lanzouo.com/b007u3i2jg</a>\n密码:fv51\n<br><img alt=\"Pasted image 20251206202705.png\" src=\"site-lib/media/pasted-image-20251206202705.png\" target=\"_self\" style=\"width: 425px; max-width: 100%;\">注：不是直接解压，而是解压到当前位置后续 exe 本体可自行删除\n使用 VSCode 打开文件夹\n双击工作区文件夹的 VScode_KR_workspace 文件即可<br>\n<img alt=\"Pasted image 20250716131909.png\" src=\"site-lib/media/pasted-image-20250716131909.png\" target=\"_self\" style=\"width: 325px; max-width: 100%;\"> 设置与配置均已在 .vscode 内设置完毕，为了性能部分游戏资源文件已被排除（图像等）\n<br><img alt=\"Pasted image 20251115141653.png\" src=\"site-lib/media/pasted-image-20251115141653.png\" target=\"_self\" style=\"width: 425px; max-width: 100%;\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"0.1 安装 VS Code：","level":2,"id":"0.1_安装_VS_Code：_0"},{"heading":"0.2 创建工作区文件夹","level":2,"id":"0.2_创建工作区文件夹_0"},{"heading":"1. 将网盘的整合包 Modpack 下载并解压","level":3,"id":"1._将网盘的整合包_Modpack_下载并解压_0"},{"heading":"2. 将 VScode_KR_workspace 文件夹放到 D 盘","level":3,"id":"2._将_VScode_KR_workspace_文件夹放到_D_盘_0"},{"heading":"0.3 安装 Lua 扩展","level":2,"id":"0.3_安装_Lua_扩展_0"},{"heading":"1. 打开 VSCode 安装所有建议的扩展","level":3,"id":"1._打开_VSCode_安装所有建议的扩展_0"},{"heading":"0.4 安装 Lua","level":2,"id":"0.4_安装_Lua_0"},{"heading":"1. 下载调试整合包内的&nbsp;LuaForWindows 安装程序","level":3,"id":"1._下载调试整合包内的 LuaForWindows_安装程序_0"},{"heading":"2. 运行，同意条款，一直点击下一步即可","level":3,"id":"2._运行，同意条款，一直点击下一步即可_0"},{"heading":"3. 重启电脑","level":3,"id":"3._**重启电脑**_0"},{"heading":"0.5 将游戏复制到工作区文件夹","level":2,"id":"0.5_将游戏复制到工作区文件夹_0"},{"heading":"1. 游戏本体 exe 复制到工作区文件夹内的 src 文件夹内","level":3,"id":"1._游戏本体_exe_复制到工作区文件夹内的_src_文件夹内_0"},{"heading":"2. 将游戏本体解压到当前位置","level":3,"id":"2._将游戏本体解压到当前位置_0"},{"heading":"0.6 运行工作区文件夹内的脚本快速配置环境","level":2,"id":"0.6_运行工作区文件夹内的脚本快速配置环境_0"},{"heading":"0.7 完成","level":2,"id":"0.7_完成_0"}],"links":[],"author":"","coverImageURL":".","fullURL":"第-1-节-语法/0.-配置环境.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20250706200745.png","site-lib/media/pasted-image-20250710092722.png","site-lib/media/pasted-image-20251206202705.png","site-lib/media/pasted-image-20250618131806.png","site-lib/media/pasted-image-20250716183243.png","site-lib/media/pasted-image-20250707085646.png","site-lib/media/pasted-image-20250707085857.png","site-lib/media/pasted-image-20250716131909.png","site-lib/media/pasted-image-20251115141653.png"],"createdTime":1765023457061,"modifiedTime":1766647323566,"sourceSize":2038,"sourcePath":"第 1 节 - 语法/0. 配置环境.md","exportPath":"第-1-节-语法/0.-配置环境.html","showInTree":true,"treeOrder":1,"backlinks":[],"type":"markdown"},"第-1-节-语法/1.-lua-介绍.html":{"title":"1. Lua 介绍","icon":"","description":"游戏引擎版本：Lua_v5.1 + Love2d_v10.2 + LuaJIT_v2.0.4Lua是一种轻量级、高效、可嵌入的脚本语言。它诞生于 1993 年，由巴西里约热内卢天主教大学（PUC-Rio）的 TeCGraf 实验室开发。简单、小巧、高效、可嵌入、可扩展如果说 C/C++、Java 这样的语言是\"工业级重型机械\"，那么 Lua 就像是\"瑞士军刀\"——小巧灵活，适合嵌入到其他系统中，为大型程序添加脚本能力。\n体积小巧：Lua 5.1 解释器仅约 200KB（编译后）\n资源占用少：内存占用小，启动速度快\n代码简洁：整个 Lua 语言规范用几页纸就能描述清楚\n这是 Lua 最重要的特性之一。你可以将 Lua 嵌入到 C/C++、Java、C#、Python 等程序中，让这些程序获得脚本扩展能力。示例场景：游戏引擎（主程序，C++编写） ↓\n嵌入Lua解释器 ↓\n用Lua编写游戏逻辑、AI行为、任务系统 ↓\n无需重新编译主程序即可修改游戏内容 Lua 的解释器非常高效\n执行速度通常比其他脚本语言快\n具有自动内存管理（垃圾回收）\nLua 语法简单，但功能强大。它使用表（table）作为唯一的数据结构机制，通过这一种结构实现了数组、字典、对象、模块等多种功能。Lua 5.1 发布于 2006 年，虽然现在已有更新的版本（5.2、5.3、5.4），但 5.1 版本仍然是：\n最广泛使用的版本：大量现有项目基于 5.1\n最稳定的版本：经过多年实践检验\n兼容性最好：与各种中间件、引擎兼容性最佳\nPython：def greet(name): print(f\"Hello, {name}!\") greet(\"World\")\nJavaScript：function greet(name) { console.log(`Hello, ${name}!`);\n} greet(\"World\");\nLua 5.1：function greet(name) print(\"Hello, \" .. name .. \"!\")\nend greet(\"World\")\nLua 的语法更加简洁，没有花括号，使用 function 和 end 来界定函数体，使用 .. 来连接字符串。在学习 Lua 之前，理解它的几个核心理念很重要：在 Lua 中，所有值都是\"一等公民\"——函数可以存储在变量中，作为参数传递，作为返回值。表（table）是 Lua 中唯一的数据结构，但通过它你可以实现：\n数组（列表）\n字典（映射）\n对象（通过表+函数）\n模块\n包\nLua 语言本身只有很少的关键字（约 20 个），标准库也很精简，但通过这种简洁性获得了极大的灵活性和可扩展性。 游戏领域： 《魔兽世界》：用户界面和插件系统\n《愤怒的小鸟》：游戏逻辑\n《文明》系列：AI 和游戏规则 软件领域： Redis：支持 Lua 脚本执行\nNginx：通过 OpenResty 支持 Lua\nWireshark：协议分析脚本 工业领域： 思科路由器：配置和自动化\n医疗设备：控制逻辑 作为零基础学习者，你的学习路径将是：在开始学习前，让我们澄清一些常见误解： \"Lua 只是玩具语言\" ❌\n事实：Lua 被用于许多关键系统，性能优异，功能完整。 \"Lua 功能太弱\" ❌\n事实：Lua 通过 C API 可以轻松扩展，理论上可以实现任何功能。 \"Lua 只适合游戏\" ❌\n事实：Lua 在嵌入式、网络、工具等领域都有广泛应用。 \"学习 Lua 没什么用\" ❌\n事实：Lua 让你理解\"简洁设计\"的价值，这种思想适用于所有编程领域。 Lua 是轻量级、可嵌入的脚本语言\nLua 5.1 是最稳定、应用最广泛的版本\nLua 的核心特点是简洁、高效、灵活\n表（table）是 Lua 中最重要的数据结构\nLua 在游戏、嵌入式、网络等领域有广泛应用 根据你的了解，Lua 最适合解决什么类型的问题？\n为什么许多游戏选择 Lua 作为脚本语言，而不是直接使用 C++？\n你觉得 Lua 的\"简洁设计\"理念有什么优点和缺点？\n下一章预告：在第 2 章中，我们将学习基础语法规则，这是写出高质量代码的关键！","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1.1 什么是 Lua？","level":3,"id":"1.1_什么是_Lua？_0"},{"heading":"Lua 的设计哲学","level":4,"id":"Lua_的设计哲学_0"},{"heading":"1.2 Lua 的核心特点","level":3,"id":"1.2_Lua_的核心特点_0"},{"heading":"1. 轻量级","level":4,"id":"1._**轻量级**_0"},{"heading":"2. 可嵌入性","level":4,"id":"2._**可嵌入性**_0"},{"heading":"3. 高效","level":4,"id":"3._**高效**_0"},{"heading":"4. 简单而强大","level":4,"id":"4._**简单而强大**_0"},{"heading":"1.3 Lua 5.1 的特殊地位","level":3,"id":"1.3_Lua_5.1_的特殊地位_0"},{"heading":"为什么选择 Lua 5.1？","level":4,"id":"为什么选择_Lua_5.1？_0"},{"heading":"主要应用领域","level":4,"id":"主要应用领域_0"},{"heading":"1.4 Lua 与其他语言的对比","level":3,"id":"1.4_Lua_与其他语言的对比_0"},{"heading":"1.5 Lua 语言的\"世界观\"","level":3,"id":"1.5_Lua_语言的\"世界观\"_0"},{"heading":"1. 一切皆值","level":4,"id":"1._**一切皆值**_0"},{"heading":"2. 表的万能性","level":4,"id":"2._**表的万能性**_0"},{"heading":"3. 少即是多","level":4,"id":"3._**少即是多**_0"},{"heading":"1.6 谁在使用 Lua？","level":3,"id":"1.6_谁在使用_Lua？_0"},{"heading":"1.7 学习路线图","level":3,"id":"1.7_学习路线图_0"},{"heading":"1.8 常见误解澄清","level":3,"id":"1.8_常见误解澄清_0"},{"heading":"1.9 本章总结","level":2,"id":"1.9_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"思考题","level":3,"id":"思考题_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"第-1-节-语法/1.-lua-介绍.html","pathToRoot":"..","attachments":[],"createdTime":1765019901432,"modifiedTime":1765936010616,"sourceSize":5265,"sourcePath":"第 1 节 - 语法/1. Lua 介绍.md","exportPath":"第-1-节-语法/1.-lua-介绍.html","showInTree":true,"treeOrder":2,"backlinks":[],"type":"markdown"},"第-1-节-语法/2.-基础语法规则.html":{"title":"2. 基础语法规则","icon":"","description":"首先从最简单的程序开始，理解 Lua 的基本结构。1. 打开工作区文件夹\n<img alt=\"Pasted image 20251206205112.png\" src=\"site-lib/media/pasted-image-20251206205112.png\" target=\"_self\" style=\"width: 425px; max-width: 100%;\">\n2. 创建 Lua 文件 test.lua<br>\n<img alt=\"Pasted image 20251206205740.png\" src=\"site-lib/media/pasted-image-20251206205740.png\" target=\"_self\" style=\"width: 372px; max-width: 100%;\">3. 输入代码print(\"Hello, Lua World!\")\n4. 运行<br>\n<img alt=\"Pasted image 20251225155912.png\" src=\"site-lib/media/pasted-image-20251225155912.png\" target=\"_self\" style=\"width: 650px; max-width: 100%;\">可以看到成功输出 Hello, Lua World!\n语句：print(\"Hello, Lua World!\") 是一条语句\n函数调用：print() 是调用一个函数\n字符串：\"Hello, Lua World!\" 是一个字符串值\nprint(\"你好，世界！\")\n-- 输出 浣犲ソ锛屼笘鐣岋紒\n由于终端编码限制所以需要让文本输出到调试控制台上。<br>\n<img alt=\"Pasted image 20251225194347.png\" src=\"site-lib/media/pasted-image-20251225194347.png\" target=\"_self\" style=\"width: 775px; max-width: 100%;\">将 integratedTerminal 修改为 internalConsole<br>\n<img alt=\"Pasted image 20251225194118.png\" src=\"site-lib/media/pasted-image-20251225194118.png\" target=\"_self\" style=\"width: 407px; max-width: 100%;\">\nLua 版本修改为 5.1 即可<br>\n<img alt=\"Pasted image 20251226133851.png\" src=\"site-lib/media/pasted-image-20251226133851.png\" target=\"_self\"><br>\n<img alt=\"Pasted image 20251225194600.png\" src=\"site-lib/media/pasted-image-20251225194600.png\" target=\"_self\">注释用于解释代码，不会被 Lua 执行。Lua 有两种注释方式：-- 这是单行注释，直到行尾结束\nlocal x = 10 -- 行尾注释，解释这行代码\n--[[ 这是多行注释 可以跨越多行 常用于文档说明或临时禁用代码块\n]]\nprint(\"这段代码会执行\") --[[ 临时禁用一段代码： print(\"这行不会执行\") local y = 20\n]]\n使用快捷键 ctrl + / 即可快速注释以及取消注释-- print(\"被注释的代码\")\t-- ctrl + / 快速注释\n标识符是变量、函数、表等的名称。Lua 的命名规则很简单：player_name -- 蛇形命名法（使用下划线替代空格，全小写） PlayerName -- 帕斯卡命名法（使用大写替代空格，首字母大写） playerName -- 驼峰命名法（使用大写替代空格，首字母小写） _player -- 下划线开头\nplayer1 -- 包含数字（但不能以数字开头）\n-- 这些会导致错误：\n变量名 -- 不能使用中文\n1player -- 不能以数字开头\nplayer-name -- 不能包含连字符\nplayer name -- 不能包含空格\nlocal -- 不能使用关键字\nend\n以下是 Lua 的保留字，不能用作标识符：-- 1. 变量使用蛇形命名法\nlocal player_health = 100\nlocal game_score = 0 -- 2. 常量使用全大写（虽然没有真正的常量，但约定俗成）\nlocal MAX_PLAYERS = 4\nlocal PI = 3.14159 -- 3. 函数名使用蛇形命名法\nfunction calculate_damage() -- 函数体\nend -- 4. 避免使用单个字母的变量名（除非是循环计数器）\nfor i = 1, 10 do -- i是习惯用法，可以接受 print(i)\nend -- 5. 类名使用帕斯卡命名法\nTowerMenu = class(\"TowerMenu\")\nLua 中，语句可以用分号或换行分隔：-- 使用分号分隔（不常用）\nlocal a = 1; local b = 2; print(a + b) -- 使用换行分隔（推荐）\nlocal a = 1\nlocal b = 2\nprint(a + b) -- 混合使用\nlocal a = 1; local b = 2 -- 同一行用分号\nprint(a + b) -- 新一行不需要分号\n良好的代码风格让程序更易读：-- 使用Tab缩进（不要用空格）\nif condition then print(\"缩进的代码\")\nend -- 不好的缩进\nif condition then\nprint(\"这样很难读\") -- 没有缩进 print(\"缩进不一致\") -- 突然缩进\nend\n-- 建议每行不超过80个字符\n-- 太长的行可以这样拆分： -- 拆分字符串\nlocal message = \"这是一段非常非常非常非常非常\" .. \"非常非常非常非常长的字符串\" -- 拆分函数传递\nlocal result = calculate_total_score( player1_score, player2_score, bonus_points, difficulty_multiplier\n)\n-- 用空白行分隔逻辑块\nlocal player_name = \"小明\"\nlocal player_level = 1 -- 角色状态初始化\nlocal health = 100\nlocal mana = 50 -- 装备初始化\nlocal weapon = \"木剑\"\nlocal armor = \"布衣\" print(\"角色创建完成\")\nlocal t = { \"箭塔\", \"兵营\", \"法师塔\", \"炮塔\"\n}\n-- 运算符空格\nlocal n = 100 + 50\n-- local n=100+50 过于紧凑不好 if n == 150 then\n...\nend\n-- if n==150 then 过于紧凑不好 -- 逗号空格\nlocal function test(test1, test2, test3) ...\nend test(1, 2, 3)\n-- test(1,2,3) 过于紧凑不好\n可以使用 vscode 的自动格式化功能来优化代码格式。使用快捷键：shift + alt + f-- 不好的格式\nprint(1,2,3,4,5) do\nlocal a = 10 local b = 20\nprint(a+b)\nend -- 按 shift + alt + f 格式化后\nprint(1, 2, 3, 4, 5)\ndo local a = 10 local b = 20 print(a + b)\nend\n-- 错误1：缺少引号\nprint(\"Hello World) -- 编译错误：未结束的字符串 -- 错误2：拼写错误\nprin(\"Hello\") -- 运行时错误：尝试调用nil值 -- 错误3：缺少end\nif true then print(\"This is true\")\n-- 忘记写end -- 编译错误：'&lt;eof&gt;' expected near '&lt;eof&gt;' -- 错误4：中文标点（初学者常见）\nprint（\"Hello\"） -- 编译错误：使用中文括号\n-- 1. 使用print调试\nprint(\"=== 程序开始 ===\")\nlocal x = 10\nprint(\"x的值为: \" .. x) -- 2. 检查变量类型\nlocal value = \"100\"\nprint(type(value)) -- 输出：string -- 3. 临时禁用代码块\n-- print(\"这段代码暂时不需要\")\n-- 可以按快捷键 ctrl + / 快速注释掉\n<br>（答案见 <a data-href=\"第 1 节 - 语法/参考答案#练习 2 2 ：判断以下哪些是合法的标识符：\" href=\"第-1-节-语法/参考答案.html#练习 2 2 ：判断以下哪些是合法的标识符：\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 2 2 ：判断以下哪些是合法的标识符：</a>）\nplayerName\n2ndPlayer\nplayer_score\nlocal\n_internal\nmy-var\n玩家1\n<br>（答案见 <a data-href=\"第 1 节 - 语法/参考答案#练习 2 3：创建一个自我介绍程序\" href=\"第-1-节-语法/参考答案.html#练习 2 3：创建一个自我介绍程序\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 2 3：创建一个自我介绍程序</a>）--[[\n任务：创建一个程序，输出以下信息：\n1. 你的名字\n2. 年龄\n3. 兴趣爱好\n4. 学习Lua的目标\n]] 注释：-- 单行注释，--[[ ... ]] 多行注释\n标识符：字母、数字、下划线组成，不能以数字开头，区分大小写\n关键字：避免使用 and、if、end 等保留字作为标识符\n代码块：do...end 定义局部作用域\n语句分隔：分号可选，通常用换行\n代码风格：一致的缩进、命名、格式、表换行\n自动格式化：使用快捷键 shift + alt + f （点击勾选框勾选）\n完成本章后，你应该能够：\n写出带注释的 Lua 程序\n使用合法的标识符命名变量\n识别常见的语法错误\n遵循基本的代码风格规范 为什么良好的代码风格很重要？\n如果程序中有一段暂时不需要的代码，应该怎么做？\n以下哪个命名最好？为什么？ a\nplayer1Health\nplayer_health\nPlayerHealth 下一章预告：在第 3 章中，我们将学习变量和数据类型，这是编程的基础。你会学到如何存储不同类型的数据。拓展阅读：\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.runoob.com/lua/lua-tutorial.html\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.runoob.com/lua/lua-tutorial.html\" target=\"_self\">Lua 教程 | 菜鸟教程</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"http://www.lua.org/manual/5.1\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://www.lua.org/manual/5.1\" target=\"_self\">Lua 官方手册</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://github.com/luarocks/lua-style-guide\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/luarocks/lua-style-guide\" target=\"_self\">代码风格指南</a>\n常见问题解答：\nQ: Lua 区分大小写吗？\nA: 是的，myVar 和 myvar 是两个不同的变量。Q: 注释会影响程序性能吗？\nA: 不会，注释在程序运行时会被完全忽略。Q: 一行代码可以写多个语句吗？\nA: 可以，用分号分隔，但不推荐这样做。","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"2.1 第一个程序","level":2,"id":"2.1_第一个程序_0"},{"heading":"2.1.1 程序结构解析","level":3,"id":"2.1.1_程序结构解析_0"},{"heading":"2.1.2 修复无法中文乱码","level":3,"id":"2.1.2_修复无法中文乱码_0"},{"heading":"2.2 Lua 中的注释","level":2,"id":"2.2_Lua_中的注释_0"},{"heading":"2.2.1 单行注释","level":3,"id":"2.2.1_单行注释_0"},{"heading":"2.2.2 多行注释","level":3,"id":"2.2.2_多行注释_0"},{"heading":"2.2.3 快速注释/取消注释技巧","level":3,"id":"2.2.3_快速注释/取消注释技巧_0"},{"heading":"2.3 标识符命名规则","level":2,"id":"2.3_标识符命名规则_0"},{"heading":"2.3.1. 合法标识符","level":3,"id":"2.3.1._合法标识符_0"},{"heading":"2.3.2 非法标识符","level":3,"id":"2.3.2_非法标识符_0"},{"heading":"2.3.3 Lua 关键字（保留字）","level":3,"id":"2.3.3_Lua_关键字（保留字）_0"},{"heading":"2.3.4 命名约定：","level":3,"id":"2.3.4_命名约定：_0"},{"heading":"2.4 语句分隔","level":2,"id":"2.4_语句分隔_0"},{"heading":"2.5 代码风格指南","level":2,"id":"2.5_代码风格指南_0"},{"heading":"2.5.1 缩进","level":3,"id":"2.5.1_缩进_0"},{"heading":"2.5.2 行长度","level":3,"id":"2.5.2_行长度_0"},{"heading":"2.5.3 空白行","level":3,"id":"2.5.3_空白行_0"},{"heading":"2.5.4 表内每个元素换行","level":3,"id":"2.5.4_表内每个元素换行_0"},{"heading":"2.5.5 符号后增加空格","level":3,"id":"2.5.5_符号后增加空格_0"},{"heading":"2.5.6 自动格式化","level":3,"id":"2.5.6_自动格式化_0"},{"heading":"2.6 常见错误与调试","level":2,"id":"2.6_常见错误与调试_0"},{"heading":"语法错误示例","level":4,"id":"语法错误示例_0"},{"heading":"简单调试技巧","level":3,"id":"简单调试技巧_0"},{"heading":"2.7 练习","level":2,"id":"2.7_练习_0"},{"heading":"练习 1：创建一个文件，尝试不同类型的注释","level":3,"id":"练习_1：创建一个文件，尝试不同类型的注释_0"},{"heading":"练习 2：判断以下哪些是合法的标识符","level":3,"id":"练习_2：判断以下哪些是合法的标识符_0"},{"heading":"练习 3：创建一个自我介绍程序","level":3,"id":"练习_3：创建一个自我介绍程序_0"},{"heading":"2.8 本章总结","level":2,"id":"2.8_本章总结_0"},{"heading":"关键知识点回顾","level":4,"id":"关键知识点回顾_0"},{"heading":"检查清单","level":4,"id":"检查清单_0"},{"heading":"思考题","level":4,"id":"思考题_0"}],"links":["第-1-节-语法/参考答案.html#练习 2 2 ：判断以下哪些是合法的标识符：","第-1-节-语法/参考答案.html#练习 2 3：创建一个自我介绍程序"],"author":"","coverImageURL":".","fullURL":"第-1-节-语法/2.-基础语法规则.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251206205112.png","site-lib/media/pasted-image-20251206205740.png","site-lib/media/pasted-image-20251225155912.png","site-lib/media/pasted-image-20251225194347.png","site-lib/media/pasted-image-20251225194118.png","site-lib/media/pasted-image-20251226133851.png","site-lib/media/pasted-image-20251225194600.png"],"createdTime":1765021472737,"modifiedTime":1766727564386,"sourceSize":8653,"sourcePath":"第 1 节 - 语法/2. 基础语法规则.md","exportPath":"第-1-节-语法/2.-基础语法规则.html","showInTree":true,"treeOrder":3,"backlinks":["第-1-节-语法/14.-luajit.html","第-1-节-语法/5.-控制结构.html"],"type":"markdown"},"第-1-节-语法/3.-变量与数据类型.html":{"title":"3. 变量与数据类型","icon":"","description":"-- 使用local关键字声明局部变量\nlocal level = 1\nlocal health = 100\nlocal damage = 12 -- 局部变量只在声明它的代码块内有效\ndo local x = 10 print(\"内部 x = \" .. x) -- 可以访问x\nend print(x) -- 输出 nil，Lua 中不存在的值都是 nil\n局部变量的特点：\n只在声明它的代码块内可见\n使用 local 关键字声明\n推荐优先使用局部变量\n性能比全局变量好\n-- 不使用local关键字，直接赋值创建全局变量\nglobal_counter = 0 -- 全局变量 do global_counter = global_counter + 1\nend print(global_counter) -- 输出：1 -- 也可直接在代码块内定义\ndo x = 1\nend print(x) -- 输出：1\n全局变量的特点：\n在整个程序中都可以访问\n不需要关键字，直接赋值即创建\n不要过度使用（容易造成命名冲突）\n代码块是一组语句的集合：local z = 100 do -- do-end创建普通代码块 local x = 10 local y = 20 print(x + y)\t-- 30 print(z) -- 100\nend if 条件 then -- 创建条件代码块 local x = 10 a = 1000\t-- 全局变量 print(x)\t-- 10\nend print(x)\t-- nil\n代码块可以理解为一个 “盒子”盒子内部可以访问外面，以及内部之间的访问，盒子外部无法访问内部。\n全局变量其实是定义到一个全局作用域（_G）访问变量时优先从当前作用域查找变量，最后从 _G 查找全局变量。示意图：\n<img alt=\"Pasted image 20251209094358.png\" src=\"site-lib/media/pasted-image-20251209094358.png\" target=\"_self\" style=\"width: 900px; max-width: 100%;\">\ndo-end 代码块\n判断条件内的条件代码块\n循环内的循环体\n函数内的函数体\n一个代码块的内部称为一个作用域local x = 5 -- 这里文件顶层代码其实也是个作用域 do local x = 10 -- 局部作用域，只在do...end块内有效 print(\"内部 x = \" .. x) -- 输出：内部 x = 10\nend print(\"外部 x = \" .. x) -- 输出：外部 x = 5\n-- 1. 一次声明多个局部变量\nlocal x, y, z = 10, 20, 30 -- 2. 先声明，后赋值\nlocal player_name\nlocal player_score player_name = \"李雷\"\nplayer_score = 1000 -- 3. 交换变量值（无需临时变量）\nlocal a, b = 10, 20\na, b = b, a -- 交换后：a=20, b=10 -- 4. 声明但不初始化（值为nil）\nlocal uninitialized\nprint(type(uninitialized)) -- 输出：nil\n作用域示例：-- 作用域示例：理解变量可见性\nlocal global_x = 100 do -- 内层作用域可以访问外部的局部变量 print(\"在内部访问外部变量: \" .. global_x) -- 输出：100 -- 这个x只在当前作用域内有效 local x = 50 print(\"局部作用域内的x: \" .. x) -- 输出：50 -- 如果没有提前在外部，将会创建全局变量 global_z = 300 -- 创建全局变量\nend print(\"外部的global_z: \" .. (global_z)) -- 输出：300\nprint(\"外部的x: \" .. (x)) -- 输出：nil（局部作用域内的x不可见）\nLua 是动态类型语言，变量类型由值决定。使用 type() 函数可以查看数据类型。-- nil表示\"无\"或\"不存在\"\nlocal empty = nil\nlocal undefined -- 未赋值的变量自动为nil print(\"empty的类型: \" .. type(empty)) -- 输出：nil\nprint(\"undefined的类型: \" .. type(undefined)) -- 输出：nil\nlocal config = { sound = true, music = true }\nconfig.music = nil -- 删除music设置\nprint(\"music 值：\" .. config.music) -- 输出：nil\n-- 只有两个值：true和false\nlocal is_game_over = false\nlocal is_player_alive = true\nlocal has_key = false -- 在条件判断中使用\nif is_player_alive then print(\"玩家还活着\")\nelse print(\"游戏结束\")\nend -- Lua中只有false和nil被视为\"假\"，其他都是\"真\"\nlocal truth_test = 0 -- 数字0在Lua中是真值\nif truth_test then print(\"数字0是真值\") -- 这行会执行\nend if nil then print(\"nil是真值？\") -- 这行不会执行\nelse print(\"nil是假值\") -- 这行会执行\nend\n-- Lua 5.1中所有数字都是双精度浮点数\nlocal integer = 42 -- 整数\nlocal float = 3.14 -- 浮点数\nlocal negative = -10 -- 负数\nlocal scientific = 2e3 -- 科学计数法：2×10³=2000\nlocal hex = 0xFF -- 十六进制：255\nlocal oct = 0755 -- 八进制：493（0开头） print(\"整数: \" .. integer)\nprint(\"浮点数: \" .. float)\nprint(\"科学计数法: \" .. scientific)\nprint(\"十六进制: \" .. hex)\n-- 字符串创建\nlocal str1 = \"双引号字符串\"\t-- 注：不能在其中使用双引号\nlocal str2 = '单引号字符串'\t-- 注：不能在其中使用单引号\nlocal str3 = [[多行字符串\n可以包含换行\n和各种引号]]\nlocal empty_table = {}\nlocal towers = {\"箭塔\", \"兵营\", \"法师塔\", \"炮塔\"}\nprint(\"第一个防御塔: \" .. towers[1]) -- 输出：箭塔\nlocal tower = { name = \"炮塔\", level = 10, damage = 100, [\"class\"] = \"防御塔\" -- 如果键包含特殊字符或关键字，需要方括号\n} -- 索引字典\nprint(\"防御塔: \" .. tower.name)\nprint(\"等级: \" .. tower.level)\nprint(\"防御塔类型: \" .. tower.class) -- 第二个索引方法\nprint(\"防御塔: \" .. tower[\"name\"])\nprint(\"等级: \" .. tower[\"level\"])\nprint(\"防御塔类型: \" .. tower[\"class\"])\nlocal config = { \"设置1\", -- 索引1（数组部分） \"设置2\", -- 索引2 version = \"1.0\",\t-- 键值对（字典部分） author = \"开发者\"\n} print(config[1]) -- 输出：设置1\nprint(config.version) -- 输出：1.0\n-- 函数也是一种数据类型，可以赋值给变量\nlocal say_hello = function(name) return \"你好, \" .. name\nend -- 等价于\nlocal function say_hello(name) return \"你好, \" .. name\nend -- 与变量相同也有全局函数\nsay_hello = function(name) return \"你好, \" .. name\nend -- 等价于\nfunction say_hello(name) return \"你好, \" .. name\nend -- 函数作为值传递\nlocal greeting_func = say_hello\t-- 此时 greeting_func 就是 say_hello\nprint(greeting_func(\"世界\")) -- 输出：你好, 世界 -- 函数存储在表中\nlocal math_operations = { add = function(a, b) return a + b end, subtract = function(a, b) return a - b end\n} print(\"5 + 3 = \" .. math_operations.add(5, 3)) -- 输出 8\nprint(\"5 - 3 = \" .. math_operations.subtract(5, 3))\t-- 输出 2\n-- thread：协程，用于实现协作式多任务\nlocal co = coroutine.create(function() print(\"协程执行中\") coroutine.yield() print(\"协程恢复\")\nend) coroutine.resume(co) -- 输出：协程执行中\ncoroutine.resume(co) -- 输出：协程恢复\nuserdata 用于存储C语言数据，主要用于与C交互\n通常由C库创建，Lua代码只能使用，不能创建type(值: any) -&gt; 数据类型: \"nil\"|\"number\"|\"string\"|\"boolean\"|\"table\"|\"function\"|\"thread\"|\"userdata\"\nprint(type(\"字符串\"))\t-- 输出 \"string\"\nprint(type(123))\t-- 输出 \"number\"\nprint(type({1, 2, 3}))\t-- 输出 \"table\"\n<br>（答案见 <a data-href=\"第 1 节 - 语法/参考答案#练习 3 1：数据类型识别\" href=\"第-1-节-语法/参考答案.html#练习 3 1：数据类型识别\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 3 1：数据类型识别</a>）-- 创建一个函数，可以识别并输出传入的值的数据类型 变量声明： 使用 local 声明局部变量\n直接赋值创建全局变量（不推荐滥用）\n代码块的作用域的 “盒子模型” 8 种数据类型： nil：空值\nboolean：布尔值（true/false）\nnumber：数字（所有数字都是双精度浮点）\nstring：字符串\ntable：表（Lua 的核心数据结构）\nfunction：函数（一等公民）\nuserdata：C 数据（与 C 交互）\nthread：协程（协作式多任务） type()函数： 返回数据类型的字符串表示\n用于类型检查和调试 （点击勾选框勾选）\n完成本章后，你应该能够：\n正确声明局部变量和全局变量\n理解代码块的作用域\n识别和使用 8 种基本数据类型\n使用 type() 函数检查变量类型\n理解 Lua 中\"真值\"的概念（只有 false 和 nil 是假） 为什么 Lua 中 0 是真值而 false 是假值？这样设计有什么好处？\n表（table）为什么是 Lua 的核心数据结构？它能替代哪些其他数据结构？\n在什么情况下应该使用全局变量？什么情况下应该避免？\n下一章预告：在第 4 章中，我们将学习运算符，这是进行基础运算的关键！拓展练习：\n创建一个变量交换函数，不使用临时变量\n写一个函数判断一个数字是奇数还是偶数\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"3.1 变量声明：理解作用域","level":2,"id":"3.1_变量声明：理解作用域_0"},{"heading":"3.1.1 局部变量（Local Variables）","level":3,"id":"3.1.1_局部变量（Local_Variables）_0"},{"heading":"3.1.2 全局变量（Global Variables）","level":3,"id":"3.1.2_全局变量（Global_Variables）_0"},{"heading":"3.1.3 代码块","level":3,"id":"3.1.3_代码块_0"},{"heading":"所有代码块","level":4,"id":"所有代码块_0"},{"heading":"代码块的作用域","level":4,"id":"代码块的作用域_0"},{"heading":"3.1.4 变量声明的最佳实践","level":3,"id":"3.1.4_变量声明的最佳实践_0"},{"heading":"3.2 Lua 的 8 种基本数据类型","level":2,"id":"3.2_Lua_的_8_种基本数据类型_0"},{"heading":"3.2.1 nil - 空值","level":3,"id":"3.2.1_nil_-_空值_0"},{"heading":"nil的特殊用途：删除变量或表元素","level":4,"id":"nil的特殊用途：删除变量或表元素_0"},{"heading":"3.2.2 boolean - 布尔值","level":3,"id":"3.2.2_boolean_-_布尔值_0"},{"heading":"3.2.3 number - 数字","level":3,"id":"3.2.3_number_-_数字_0"},{"heading":"3.2.4. string - 字符串","level":3,"id":"3.2.4._string_-_字符串_0"},{"heading":"3.2.5 table - 表","level":3,"id":"3.2.5_table_-_表_0"},{"heading":"创建空表","level":4,"id":"创建空表_0"},{"heading":"作为数组使用（索引从1开始）","level":4,"id":"作为数组使用（索引从1开始）_0"},{"heading":"作为字典/映射使用","level":4,"id":"作为字典/映射使用_0"},{"heading":"混合使用","level":4,"id":"混合使用_0"},{"heading":"3.2.6 function - 函数","level":3,"id":"3.2.6_function_-_函数_0"},{"heading":"3.2.7 thread - 协程","level":3,"id":"3.2.7_thread_-_协程_0"},{"heading":"3.2.8 userdata - 用户数据","level":3,"id":"3.2.8_userdata_-_用户数据_0"},{"heading":"3.3 获取数据类型","level":2,"id":"3.3_获取数据类型_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"3.4 练习","level":2,"id":"3.4_练习_0"},{"heading":"练习 1：数据类型识别","level":3,"id":"练习_1：数据类型识别_0"},{"heading":"3.5 本章总结","level":2,"id":"3.5_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"}],"links":["第-1-节-语法/参考答案.html#练习 3 1：数据类型识别"],"author":"","coverImageURL":".","fullURL":"第-1-节-语法/3.-变量与数据类型.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251209094358.png"],"createdTime":1765072758647,"modifiedTime":1765936029553,"sourceSize":9526,"sourcePath":"第 1 节 - 语法/3. 变量与数据类型.md","exportPath":"第-1-节-语法/3.-变量与数据类型.html","showInTree":true,"treeOrder":4,"backlinks":[],"type":"markdown"},"第-1-节-语法/4.-运算符.html":{"title":"4. 运算符","icon":"","description":"local a, b = 10, 3 print(a + b)\t-- 加法：13\nprint(a - b)\t-- 减法：7\nprint(a * b)\t-- 乘法：30\nprint(a / b)\t-- 除法：3.3333\nprint(a % b)\t-- 取余：1\nprint(a ^ b)\t-- 指数：1000（10³）\nprint(-a) -- 取负：-10 -- 取余运算的特殊用途\nprint(\"奇数判断: 15 % 2 = \" .. (15 % 2)) -- 1为奇数，0为偶数\nprint(\"范围限制: 25 % 24 = \" .. (25 % 24))\t-- 结果在0-23之间\nlocal x, y = 10, 20 print(x == y) -- 相等：false\nprint(x ~= y) -- 不相等：true（注意：不是!=）\nprint(x &lt; y) -- 小于：true\nprint(x &gt; y) -- 大于：false\nprint(x &lt;= y) -- 小于等于：true\nprint(x &gt;= y) -- 大于等于：false\nprint(\"apple\" &lt; \"banana\") -- true\nprint(\"10\" &lt; \"2\") -- true（字符串比较，不是数值）\nlocal t1 = {1, 2, 3}\nlocal t2 = {1, 2, 3}\nlocal t3 = t1 print(t1 == t2) -- false（不同对象）\n-- 注：比较的是引用，不是内容\nprint(t1 == t3) -- true（同一对象）\nprint(1 == \"1\") -- false（类型不同）\nprint(1 == tonumber(\"1\"))\t-- true\n-- and：如果第一个操作数为真，返回第二个操作数；否则返回第一个操作数\nprint(true and false)\t-- true 为真，输出 false\nprint(false and true)\t-- false 为假，输出 false\nprint(true and \"hello\")\t-- true 为真，输出 \"hello\"\nprint(nil and true) -- nil 为假，输出 nil\n-- or：如果第一个操作数为真，返回第一个操作数；否则返回第二个操作数\nprint(true or false) -- true 为真，输出 true\nprint(false or true) -- false 为假，输出 true\nprint(nil or \"default\") -- nil 为假，输出 \"default\"\n-- not：取反，总是返回布尔值\nprint(not true) -- false\nprint(not false)\t-- true\nprint(not nil) -- true\nprint(not 0) -- false（0是真值）\nlocal config = { volume = nil, -- 未设置 difficulty = \"normal\"\n} -- 使用or提供默认值\nlocal volume = config.volume or 50 -- 如果volume是nil，使用50\nprint(\"音量: \" .. volume) -- 使用and进行条件赋值\nlocal is_admin = true\nlocal message = is_admin and \"欢迎管理员\" or \"欢迎访客\"\nprint(\"消息: \" .. message) -- 如果其中一个判断为假，跳过后续运算\n-- 第一个判断为假，跳过第二个 true 判断\nif false and true then ...\nend -- 示例\nlocal function expensive_calculation() print(\"执行复杂计算...\") return 42\nend local should_calculate = false -- 不想进行计算\nlocal result = should_calculate and expensive_calculation()\n-- should_calculate 为假，expensive_calculation 函数不会被调用\n-- 如果其中一个判断为真，跳过后续运算\n-- 第一个判断为真，跳过第二个 false 判断\nif true or false then ...\nend -- 示例\n-- 示例\nlocal function say(s) if not s then print(\"s = false\") else print(\"s = true\") end -- 如果 s 为假（nil），将 s 赋值为 \"hello world\"，否则不变 s = s or \"hello world\" print(s)\nend say()\nsay(\"hello\")\n--[[ 输出\ns = false\nhello world\ns = true\nhello\n--]]\nlocal name = \"张三\"\n-- 使用 \"#\" 统计字符串长度\nprint(\"\\\"\" .. name .. \"\\\"的长度: \" .. #name) -- 输出：6（中文一个字符等于 3 个字节）\nlocal towers = {\"箭塔\", \"兵营\", \"法师塔\", \"炮塔\"}\nprint(\"防御塔数量: \" .. #towers) -- 输出：4 -- 注意：无法使用 \"#\" 统计字典部分的长度\nlocal tower = { name = \"炮塔\", level = 10, damage = 100\n}\nprint(\"键数量: \" .. #tower) -- 错误！输出：0\n-- 使用 .. 连接字符串\nlocal greeting = \"你好\" .. \", \" .. \"世界!\"\nprint(greeting) -- 输出：你好, 世界! -- 如果操作数不是字符串，会自动转换\nlocal age = 25\nprint(\"年龄: \" .. age) -- 自动将25转换为\"25\"\n算术运算符：print(2 + 3 * 4)\t-- 3*4先计算，然后加2 = 14 -- 可以使用括号来指定优先级\nprint((2 + 3) * 4)\t-- 2+3先计算，然后乘4 = 20\n逻辑运算符：local x, y, z = true, 1, 2 print(x and y or z) -- 如果 x 为真输出 1，为假输出 2 print(x and (y and 3 or z))\t-- 先判断 y 得到值，为真则值为 3，为假则值为 2，如果 x 为真输出 3\n（答案见 <a data-href=\"第 1 节 - 语法/参考答案#练习 4.1：简单计算器\" href=\"第-1-节-语法/参考答案.html#练习 4.1：简单计算器\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 4.1：简单计算器</a>）-- 实现一个简单的四则运算计算器 运算符： 算术：+ - * / % ^ -（负号）\n关系：== ~= &lt; &gt; &lt;= &gt;=\n逻辑：and or not\n字符串：..（连接） 短路求值： and：其中一个为假跳过后续运算\nor：其中一个为真跳过后续运算\n短路求值失效：使用括号分组而不是变量 优先级： 指数 &gt; 负号 &gt; 乘除 &gt; 加减 &gt; 连接 &gt; 比较 &gt; 逻辑 -- 1. 错误：混淆 \"=\"、 \"==\"\nlocal x = 5 -- 错误示例，应该是 ==\nif x = 10 then print(\"x是10\")\nend -- 正确示例\nif x == 10 then print(\"x是10\")\nend -- 2. 技巧：使用 or 提供默认值\nlocal sound_volume = user_setting.volume or 70 -- 3. 技巧：使用 and 简化条件判断\nlocal player = get_player()\nlocal name = player and player.name or \"未知玩家\" -- 注意：Lua 中只有 false 和 nil 是假值，其他任何值都是真\nif 0 then -- 这个条件为真！ print(\"0在Lua中是真值\")\nend -- 4. 错误：将逻辑运算分组为多个变量\nlocal n1, n2, n3 = 1, 2, 3\nlocal s1, s2, s3 = \"a\", \"b\", \"c\" -- 错误示例，应使用括号分组，而不是分组为变量\nlocal check_n = n1 == 1 and n2 == 2 and n3 == 3\nlocal check_s = s1 == \"a\" and s2 == \"b\" and s3 == \"c\"\t-- 即使 n3 判断为假也会继续判断 s123 if check_n and check_s then -- 可读性改善，代价是短路求值失效一半 print(\"检查通过\")\nend -- 正确示例，使用括号分组\n-- n3 判断为假，直接停止判断，虽然可读性较差\nif (n1 == 1 and n2 == 2 and n3 == 3) and (s1 == \"a\" and s2 == \"b\" and s3 == \"c\") then print(\"检查通过\")\nend\n（点击勾选框勾选）\n完成本章后，你应该能够：\n使用各种运算符进行计算和比较\n理解运算符优先级并正确使用括号\n利用逻辑运算符实现条件默认值 为什么字符串连接使用 .. 而不是 +？\n表达式 a and b or c 在什么情况下不能代替 a ? b : c 的三元运算？\n下一章预告：在第 5 章中，我们将学习控制结构，包括条件判断和循环语句。这是让程序\"有逻辑\"的关键一步！拓展练习：\n创建一个简单的配置系统，使用表存储配置，并提供默认值\n实现一个类型安全的加法函数，只对数字进行加法运算\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"4.1 算术运算符","level":2,"id":"4.1_算术运算符_0"},{"heading":"4.2 关系运算符（比较运算符）","level":2,"id":"4.2_关系运算符（比较运算符）_0"},{"heading":"4.2.1 字符串比较","level":3,"id":"4.2.1_字符串比较_0"},{"heading":"4.2.2 表比较","level":3,"id":"4.2.2_表比较_0"},{"heading":"4.2.3 不同类型比较","level":3,"id":"4.2.3_不同类型比较_0"},{"heading":"4.3 逻辑运算符","level":2,"id":"4.3_逻辑运算符_0"},{"heading":"4.3.1 and 与逻辑","level":3,"id":"4.3.1_and_与逻辑_0"},{"heading":"4.3.2 or 或逻辑","level":3,"id":"4.3.2_or_或逻辑_0"},{"heading":"4.3.3 not 取反","level":3,"id":"4.3.3_not_取反_0"},{"heading":"4.3.4 实用技巧","level":3,"id":"4.3.4_实用技巧_0"},{"heading":"4.3.5 短路求值","level":3,"id":"4.3.5_短路求值_0"},{"heading":"and 的短路求值","level":4,"id":"and_的短路求值_0"},{"heading":"or 的短路求值","level":4,"id":"or_的短路求值_0"},{"heading":"4.4 长度运算符","level":2,"id":"4.4_长度运算符_0"},{"heading":"4.4.1 统计字符串长度","level":4,"id":"4.4.1_统计字符串长度_0"},{"heading":"4.4.2 统计表内数组部分长度","level":3,"id":"4.4.2_统计表内数组部分长度_0"},{"heading":"4.5 字符串连接运算符","level":2,"id":"4.5_字符串连接运算符_0"},{"heading":"4.6 运算符优先级","level":2,"id":"4.6_运算符优先级_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"4.7 练习","level":2,"id":"4.7_练习_0"},{"heading":"练习 1：简单计算器","level":3,"id":"练习_1：简单计算器_0"},{"heading":"4.8 本章总结","level":2,"id":"4.8_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"常见错误与技巧","level":3,"id":"常见错误与技巧_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"}],"links":["第-1-节-语法/参考答案.html#练习 4.1：简单计算器"],"author":"","coverImageURL":"","fullURL":"第-1-节-语法/4.-运算符.html","pathToRoot":"..","attachments":[],"createdTime":1765076428774,"modifiedTime":1766712895124,"sourceSize":7917,"sourcePath":"第 1 节 - 语法/4. 运算符.md","exportPath":"第-1-节-语法/4.-运算符.html","showInTree":true,"treeOrder":5,"backlinks":[],"type":"markdown"},"第-1-节-语法/5.-控制结构.html":{"title":"5. 控制结构","icon":"","description":"控制结构是编程中实现逻辑决策和重复执行的关键。在 Lua 中，最基本的控制结构是 if 语句。if 条件 then -- 条件为真时执行的条件代码块\nend\n-- 示例：检查玩家生命值\nlocal health = 75 if health &gt; 0 then print(\"玩家还活着\")\nend\n还记得学过的 <a data-href=\"2. 基础语法规则#1 代码块\" href=\"第-1-节-语法/2.-基础语法规则.html#1 代码块\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">2. 基础语法规则 &gt; 1 代码块</a> 吗？这里条件语句中的条件代码块也是局部作用域错误 1：局部作用域内的局部变量外部不可见if true then local health = 999\nend print(health)\t-- 错误！\n错误 2： 意外定义全局变量if true then health = 999\nend print(health)\t-- 错误！输出 999，虽然成功输出但是意外定义了全局变量，全局变量应避免滥用\n正确方法：local health\t-- 提前定义局部变量 if true then health = 999\t-- 这里程序会优先查找有没有已定义的局部变量，所以是给上面定义的局部变量赋值\nend print(health)\t-- 正确！输出 999\nif 条件 then -- 条件为真时执行的条件代码块\nelse -- 条件为假时执行的条件代码块\nend\n-- 示例：判断玩家是否存活\nlocal health = 0 if health &gt; 0 then print(\"玩家还活着\") print(\"当前生命值：\" .. health)\nelse print(\"玩家已死亡\") print(\"游戏结束\")\nend\nif 条件1 then -- 条件1为真时执行的条件代码块\nelseif 条件2 then -- 条件2为真时执行的条件代码块\nelseif 条件3 then -- 条件3为真时执行的条件代码块\nelse -- 所有条件都为假时执行的条件代码块\nend\n-- 示例：游戏难度选择\nlocal difficulty_level = \"hard\"\nlocal enemy_health, player_health\t-- 注意！：一定要提前定义局部变量，避免意外定义全局变量 if difficulty_level == \"easy\" then enemy_health = 50 player_health = 200\nelseif difficulty_level == \"normal\" then enemy_health = 100 player_health = 150\nelseif difficulty_level == \"hard\" then enemy_health = 150 player_health = 100\nelseif difficulty_level == \"insane\" then enemy_health = 200 player_health = 50\nelse print(\"无效的难度设置，使用默认难度\") enemy_health = 100 player_health = 150\nend print(\"难度：\" .. difficulty_level)\nprint(\"敌人生命值：\" .. enemy_health)\nprint(\"玩家生命值：\" .. player_health)\n-- 示例：等级解锁关卡检查\nlocal player_level = 10 local info_level = \"森林\"\t-- 模拟玩家点击关卡\nlocal level_mode = \"夜晚模式\" -- 外层检查\nif info_level == \"森林\" then -- 内层检查 if player_level &gt;= 1 then\t-- 玩家等级大于等于 1 print(\"玩家等级足够，可以进入森林\") -- 更深层的检查 if level_mode == \"夜晚模式\" then\t-- 判断关卡模式 print(\"玩家进入夜晚的森林\") elseif level_mode == \"白天模式\" then print(\"玩家进入白天的森林\") else print(\"未知模式\") end else print(\"玩家等级不足，不能进入森林\") end\nelseif info_level == \"雪地\" then -- 内层检查 if player_level &gt;= 11 then\t-- 玩家等级大于等于 11 print(\"玩家等级足够，可以进入雪地\") -- 更深层的检查 if level_mode == \"夜晚模式\" then\t-- 判断关卡模式 print(\"玩家进入夜晚的雪地\") elseif level_mode == \"白天模式\" then print(\"玩家进入白天的雪地\") else print(\"未知模式\") end else print(\"玩家等级不足，不能进入雪地\") end\nelse print(\"未知关卡\")\nend\nlocal age = 25\nlocal has_license = true if age &gt;= 18 and has_license then\t-- 如果年龄大于等于 18，并且有驾驶证 print(\"可以驾驶\")\nelse print(\"不能驾驶\")\nend\nlocal is_weekend = false\nlocal is_holiday = true if is_weekend or is_holiday then\t-- 如果是周末，或者是节假日 print(\"今天是休息日\")\nelse print(\"今天是工作日\")\nend\nlocal is_raining = false if not is_raining then -- 如果没有下雨 print(\"天气晴朗，适合外出\")\nelse print(\"下雨了，记得带伞\")\nend\nlocal temperature = 28\nlocal is_sunny = true\nlocal has_umbrella = false -- 如果温度大于 25 度，并且是晴天，或者不是晴天，并且带了伞\nif (temperature &gt; 25 and is_sunny) or (not is_sunny and has_umbrella) then print(\"适合去公园\")\nelse print(\"最好待在家里\")\nend\nlocal player_level = 15\nlocal has_quest_item = true\nlocal completed_prerequisite = false -- 如果玩家等级大于等于 10 并且有任务物品以及完成前置任务\nif player_level &gt;= 10 and has_quest_item and completed_prerequisite then print(\"可以接受新任务\")\nelse print(\"条件不足，无法接受任务\") -- 提供具体反馈 if player_level &lt; 10 then print(\"需要达到10级\") end if not has_quest_item then print(\"需要任务物品\") end if not completed_prerequisite then print(\"需要完成前置任务\") end\nend\n循环允许我们重复执行一段代码，直到满足特定条件为止。while 条件 do -- 循环体（条件为真时重复执行）\nend\n-- 示例：简单的计数器\nlocal count = 1\nwhile count &lt;= 5 do print(\"当前计数：\" .. count) count = count + 1 -- 注意！：不要忘记改变循环条件\nend\n--[[ 输出\n当前计数：1\n当前计数：2\n当前计数：3\n当前计数：4\n当前计数：5\n--]] -- 注意：如果没有正确改变条件，可能导致无限循环！\n-- local count = 1\n-- while count &lt;= 5 do\n-- print(\"无限循环？\") -- count永远不大于5，所以会一直执行\n-- -- 忘记写 count = count + 1\n-- end\n-- 实际应用：等待玩家准备\nlocal is_player_ready = false\nlocal wait_time = 0\nlocal max_wait_time = 30 -- 最大等待30秒 print(\"等待玩家准备...\")\n-- 如果玩家没有准备，并且没有超过最大等待时间\nwhile not is_player_ready and wait_time &lt; max_wait_time do print(\"等待中... 已等待\" .. wait_time .. \"秒\") -- 模拟每秒检查一次 -- 在实际游戏中，这里可能会有网络检查或用户输入检查 wait_time = wait_time + 1 -- 模拟玩家在第5秒时准备好 if wait_time == 5 then is_player_ready = true print(\"玩家已准备好！\") end\nend if not is_player_ready then print(\"等待超时，开始游戏\")\nelse print(\"游戏开始\")\nend\n--[[ 输出\n等待玩家准备...\n等待中... 已等待0秒\n等待中... 已等待1秒\n等待中... 已等待2秒\n等待中... 已等待3秒\n等待中... 已等待4秒\n玩家已准备好！\n游戏开始\n--]]\nrepeat -- 循环体\nuntil 条件 -- 当条件为真时停止循环\n-- 示例：密码验证（至少尝试一次）\nlocal correct_password = \"123456\"\nlocal user_password\nlocal attempts = 0 repeat attempts = attempts + 1 -- 模拟用户输入 if attempts == 1 then user_password = \"111111\" -- 错误密码 elseif attempts == 2 then user_password = \"654321\" -- 错误密码 else user_password = \"123456\" -- 正确密码 end print(\"第\" .. attempts .. \"次尝试输入密码\") if user_password ~= correct_password then print(user_password .. \"密码错误，请重试\") end\nuntil user_password == correct_password print(\"密码正确，登录成功！\")\nprint(\"总共尝试次数：\" .. attempts)\n--[[ 输出\n第1次尝试输入密码\n111111密码错误，请重试\n第2次尝试输入密码\n654321密码错误，请重试\n第3次尝试输入密码\n密码正确，登录成功！\n总共尝试次数：3\n--]] -- 游戏中的实际应用：玩家生命值恢复\nlocal player_health = 30\nlocal max_health = 60 print(\"初始生命值：\" .. player_health) repeat -- 模拟每秒恢复一次 player_health = player_health + 10 if player_health &gt; max_health then player_health = max_health end print(\"血量恢复！当前生命值：\" .. player_health) -- 直到血量回满\nuntil player_health == max_health print(\"生命值已满！\")\n--[[ 输出\n初始生命值：30\n血量恢复！当前生命值：40\n血量恢复！当前生命值：50\n血量恢复！当前生命值：60\n生命值已满！\n--]]\n首先需要明确语义：\nwhile 循环：当条件为真时，继续执行循环体；当条件为假时，退出循环。\nrepeat-until 循环：重复执行循环体，直到条件为真时退出（即条件为真时结束循环）\n即：在 repeat-until 循环中，设置的条件是退出循环的条件，而在 while 循环中，设置的条件是继续循环的条件。\n所以：两个循环设置的条件完全相反-- while\nlocal count = 10 while count &lt; 5 do -- 继续循环的条件：计数小于 5，一开始就不成立 print(\"while循环执行\") -- 循环体不会执行 count = count + 1\nend print(\"while循环结束，count = \" .. count) -- 输出 10 -- repeat-until\nlocal count = 10 repeat print(\"repeat-until循环执行\") -- 循环体至少会执行一次 count = count + 1\nuntil count &gt;= 5 -- 结束循环的条件：计算大于等于 5，检查在循环体之后 print(\"repeat-until循环结束，count = \" .. count)\t-- 输出 11\nfor 变量 = 起始值, 结束值, 步长 do -- 循环体\nend\n-- 步长可以省略，默认为1\nprint(\"=== 从1到5 ===\")\nfor i = 1, 5 do print(\"i = \" .. i)\nend\n--[[ 输出\ni = 1\ni = 2\ni = 3\ni = 4\ni = 5\n--]] print(\"\\n=== 从5到1（递减）===\")\nfor i = 5, 1, -1 do print(\"i = \" .. i)\nend\n--[[ 输出\ni = 5\ni = 4\ni = 3\ni = 2\ni = 1\n--]] print(\"\\n=== 从0到10，步长为2 ===\")\nfor i = 0, 8, 2 do print(\"偶数: \" .. i)\nend\n--[[ 输出\n偶数: 0\n偶数: 2\n偶数: 4\n偶数: 6\n偶数: 8\n--]] -- 注意：for循环变量是局部变量\nfor index = 1, 3 do print(\"循环内 index = \" .. index)\nend print(\"循环外 index = \" .. index) -- 错误！index 在这里不可访问\n-- 计算示例：累加和阶乘\nlocal sum = 0\nlocal factorial = 1 print(\"\\n=== 计算1到10的和与10的阶乘 ===\")\nfor i = 1, 10 do sum = sum + i factorial = factorial * i\nend\nprint(\"1到10的和 = \" .. sum)\nprint(\"10的阶乘 = \" .. factorial)\n--[[ 输出\n1到10的和 = 55\n10的阶乘 = 3628800\n--]] -- 生成乘法表\nprint(\"\\n=== 乘法表 ===\")\nfor i = 1, 9 do for j = 1, i do print(j .. \" × \" .. i .. \" = \" .. i * j) end\nend\n--[[ 输出\n1 × 1 = 1\n1 × 2 = 2\n...\n--]]\nbreak用于立即退出当前循环-- 示例：寻找第一个能被7整除的数\nfor i = 8, 100 do if i % 7 == 0 then print(\"找到第一个能被7整除的数：\" .. i) break -- 找到后立即退出循环 end\nend\n-- 输出 找到第一个能被7整除的数：14 -- 游戏示例：搜索敌人直到找到首领\nlocal enemies = {\"小兵\", \"小兵\", \"小兵\", \"小兵\", \"首领\", \"小兵\"}\nlocal boss_found print(\"=== 搜索敌人 ===\")\nfor index, enemy in ipairs(enemies) do print(\"遭遇：\" .. enemy) if enemy == \"首领\" then print(\"找到首领！开始战斗\") boss_found = true break end print(\"击败\" .. enemy)\nend if not boss_found then print(\"没有找到首领\")\nend\n--[[ 输出\n遭遇：小兵\n击败小兵\n遭遇：小兵\n击败小兵\n遭遇：小兵\n击败小兵\n遭遇：小兵\n击败小兵\n遭遇：首领\n找到首领！开始战斗\n--]] -- 注意：break只能用于循环中，不能用于if语句\n-- if true then\n-- break -- 错误：break不在循环内\n-- end -- 多层循环中的break\nprint(\"\\n=== 多层循环中的break ===\")\nfor i = 1, 3 do print(\"外层循环 i = \" .. i) for j = 1, 3 do print(\" 内层循环 j = \" .. j) if i == 2 and j == 2 then print(\" 触发break，只退出内层循环\") break end end\nend\n--[[ 输出\n外层循环 i = 1 内层循环 j = 1 内层循环 j = 2 内层循环 j = 3\n外层循环 i = 2 内层循环 j = 1 内层循环 j = 2 触发break，只退出内层循环\n外层循环 i = 3 内层循环 j = 1 内层循环 j = 2 内层循环 j = 3\n--]] -- 无限循环中的break\nprint(\"\\n=== 无限循环与break ===\")\nlocal count = 0 while true do -- 故意创建无限循环 count = count + 1 print(\"无限循环计数：\" .. count) if count &gt;= 5 then print(\"达到5次，使用break退出\") break end\nend print(\"成功退出无限循环\")\n--[[ 输出\n无限循环计数：1\n无限循环计数：2\n无限循环计数：3\n无限循环计数：4\n无限循环计数：5\n达到5次，使用break退出\n成功退出无限循环\n--]]\n-- 与其他语言不同，Lua没有continue语句\n-- 但我们可以用其他方法实现类似功能 -- 方法1：使用if语句包装\nprint(\"=== 方法1：使用if跳过单次循环 ===\")\nfor i = 1, 10 do if i % 2 ~= 0 then -- 如果不是偶数 -- 执行代码（相当于跳过偶数） print(\"奇数：\" .. i) end -- 如果是偶数，这里什么都不做，相当于continue\nend\n--[[ 输出\n奇数：1\n奇数：3\n奇数：5\n奇数：7\n奇数：9\n--]] -- 方法2：使用反向逻辑\nprint(\"\\n=== 方法2：反向逻辑 ===\")\nfor i = 1, 10 do if i % 2 == 0 then -- 如果是偶数 -- 直接进入下一次迭代 -- 在Lua中没有continue，所以我们用if的else部分 else print(\"奇数：\" .. i) end\nend\n--[[ 输出\n奇数：1\n奇数：3\n奇数：5\n奇数：7\n奇数：9\n--]] -- 方法3：使用 goto（Lua 5.1不支持，但 LuaJIT 2.0+ 支持）\n-- 注意：Lua 5.1 不支持 goto，这里仅能用于 LuaJIT，这里仅说明，后续 LuaJIT 篇详细说明\n-- for i = 1, 10 do\n-- if i % 2 == 0 then\n-- goto continue -- 跳过后续代码\n-- end -- print(\"处理奇数：\" .. i) -- ::continue::\n-- end -- 方法4：使用嵌套的if-else\nprint(\"\\n=== 方法4：跳过特定条件的处理 ===\")\nfor i = 1, 6 do if i == 5 then print(\"跳过数字5\") -- 什么都不做，相当于continue else -- 正常处理 if i % 2 == 0 then print(i .. \"是偶数\") else print(i .. \"是奇数\") end end\nend\n--[[ 输出\n1是奇数\n2是偶数\n3是奇数\n4是偶数\n跳过数字5\n6是偶数\n--]] -- 实际游戏示例：处理敌人列表，跳过已死亡的敌人\nprint(\"\\n=== 敌人处理示例 ===\")\nlocal enemies = { {name = \"敌人A\", health = 50}, {name = \"敌人B\", health = 0}, -- 已死亡 {name = \"敌人C\", health = 30}, {name = \"敌人D\", health = 0}, -- 已死亡 {name = \"敌人E\", health = 80}\n} for index, enemy in ipairs(enemies) do -- 跳过已死亡的敌人（模拟continue） if enemy.health &lt;= 0 then print(\"跳过已死亡的敌人：\" .. enemy.name) -- 在Lua 5.1中，我们只能这样\"跳过\" -- 实际的代码应该放在else块中 else -- 处理存活的敌人 print(\"攻击敌人：\" .. enemy.name) enemy.health = enemy.health - 20 print(\"敌人\" .. enemy.name .. \"剩余生命值：\" .. enemy.health) end\nend\n--[[ 输出\n攻击敌人：敌人A\n敌人敌人A剩余生命值：30\n跳过已死亡的敌人：敌人B\n攻击敌人：敌人C\n敌人敌人C剩余生命值：10\n跳过已死亡的敌人：敌人D\n攻击敌人：敌人E\n敌人敌人E剩余生命值：60\n--]]\n-- 泛型for循环用于遍历表\n-- 我们会在第7章详细学习表，这里先简单了解 -- 使用ipairs遍历数组部分（索引从1开始）\nprint(\"=== 使用ipairs遍历数组 ===\")\nlocal monsters = {\"哥布林\", \"兽人\", \"骷髅\", \"僵尸\"} for index, m in ipairs(monsters) do print(\"第\" .. index .. \"个怪物: \" .. m)\nend\n--[[ 输出\n第1个怪物: 哥布林\n第2个怪物: 兽人\n第3个怪物: 骷髅\n第4个怪物: 僵尸\n--]] -- 使用pairs遍历所有键值对\nprint(\"\\n=== 使用pairs遍历表 ===\")\nlocal player = { name = \"英雄\", level = 10, health = 100, class = \"hero\"\n} for key, value in pairs(player) do print(key .. \": \" .. value)\nend\n--[[ 输出\nclass: hero\nlevel: 10\nname: 英雄\nhealth: 100\n--]]\n-- 注：pairs的遍历顺序是无序的\n<br>（答案见 <a data-href=\"第 1 节 - 语法/参考答案#练习 5 1：猜数字游戏\" href=\"第-1-节-语法/参考答案.html#练习 5 1：猜数字游戏\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 5 1：猜数字游戏</a>）-- 使用以下代码生成 1 - 100 的随机数，设定一个最大尝试次数，模拟用户多次输入\n-- 如果猜错了给出太小了还是太大了的提示，猜中数字或超过最大尝试次数退出循环\nmath.randomseed(os.time())\nlocal random_number = math.random(1, 100)\n<br>（答案见<a data-href=\"第 1 节 - 语法/参考答案#练习 5.2：打印图形\" href=\"第-1-节-语法/参考答案.html#练习 5.2：打印图形\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 5.2：打印图形</a>）-- 使用 io.write(\"*\") （不换行的 print）打印星号与 print() 换行打印以下图形\n-- 1. 打印直角三角形\n-- 2. 打印倒直角三角形\n-- 3. 打印等腰三角形\n-- 4. 打印空心菱形\n--[[ 输出\n1. 直角三角形:\n* * * * * * * * * * * * * * * 2. 倒直角三角形:\n* * * * * * * * * * * * * * * 3. 等腰三角形: * *** ***** *******\n********* 4. 空心菱形: * * * * * * *\n* * * * * * * * *\n--]] 条件语句： if-then：基本条件判断\nif-then-else：二选一分支\nif-then-elseif-then-else：多分支选择\n嵌套 if 语句：复杂条件逻辑 循环语句： while 循环：先判断条件，条件为真时执行循环体，设置的是继续循环的条件\nrepeat-until 循环：先执行循环体，然后判断条件，条件为真时停止，设置的是结束循环的条件\nfor 循环（数值）：精确控制循环次数，使用计数器\n泛型 for 循环：用于遍历表（初步了解） 循环控制： break 语句：立即退出当前循环\nLua 没有 continue 语句，但可以通过 if 语句模拟 条件逻辑思维：学会将现实问题转化为条件判断\n循环思维：识别需要重复执行的模式\n边界思维：注意循环的起始、结束条件和边界情况\n效率思维：避免无限循环，合理使用 break\n-- 错误1：忘记改变循环条件（无限循环）\nlocal i = 1\nwhile i &lt;= 5 do print(i) -- 忘记写 i = i + 1\nend -- 错误2：错误的条件表达式\nlocal count = 0\nwhile count ~= 10 do -- 如果count跳过10，可能成为无限循环 count = count + 2 print(count)\nend -- 错误3：在for循环中修改循环变量（通常不是好主意）\nfor i = 1, 10 do print(i) i = i + 2 -- 不推荐，可能导致意外行为\nend -- 调试技巧：添加打印语句\nprint(\"=== 开始循环 ===\")\nfor i = 1, 5 do print(\"循环开始，i = \" .. i) -- ... 其他代码 ... print(\"循环结束，i = \" .. i)\nend\nprint(\"=== 循环结束 ===\")\n-- 1. 总是使用局部变量作为循环计数器\nfor i = 1, 10 do -- i自动成为局部变量 print(i)\nend -- 2. 复杂条件使用括号提高可读性\nif (player_level &gt;= 10 and has_key) or is_admin then -- 清晰的逻辑\nend -- 3. 避免过深的嵌套\n-- 不好：嵌套太深\nif condition1 then if condition2 then if condition3 then -- 条件代码块 end end\nend -- 更好：使用逻辑运算符\nif condition1 and condition2 and condition3 then -- 条件代码块\nend -- 4. 避免短路求值失效，尤其是循环内\nlocal n1, n2, n3 = 1, 2, 3\nlocal s1, s2, s3 = \"a\", \"b\", \"c\" -- 计时\nlocal start1 = os.clock()\nfor i = 1, 10000000 do -- 错误示例，循环内使用变量分组 local check_n = n1 == 1 and n2 == 2 and n3 == 3 local check_s = s1 == \"a\" and s2 == \"b\" and s3 == \"c\" -- 即使 n3 判断为假也会继续判断 s123 if check_n and check_s then\t-- 可读性改善，代价是短路求值失效一半 end\nend\nlocal time1 = os.clock() - start1 local start2 = os.clock()\nfor i = 1, 10000000 do -- 正确示例，使用括号分组 -- n3 判断为假，直接停止判断，虽然可读性较差 if (n1 == 1 and n2 == 2 and n3 == 3) and (s1 == \"a\" and s2 == \"b\" and s3 == \"c\") then end\nend\nlocal time2 = os.clock() - start2 -- 或者在循环外部创建变量\nlocal start3 = os.clock()\nlocal check_n = n1 == 1 and n2 == 2 and n3 == 3\nlocal check_s = s1 == \"a\" and s2 == \"b\" and s3 == \"c\"\nfor i = 1, 10000000 do if check_n and check_s then end\nend\nlocal time3 = os.clock() - start3 print(string.format(\"括号分组: %.4f 秒\", time2))\nprint(string.format(\"变量分组: %.4f 秒\", time1))\nprint(string.format(\"静态变量分组: %.4f 秒\", time3))\nprint(string.format(\"动态变量分组开销: %.2f%%\", (time1 - time2) / time2 * 100))\nprint(string.format(\"静态变量分组开销: %.2f%%\", (time1 - time3) / time3 * 100))\n--[[ 输出\n变量分组: 0.1200 秒\n括号分组: 0.1010 秒\n静态变量分组: 0.0290 秒\n动态变量分组开销: 18.81%\n静态变量分组开销: -313.79%\n--]]\n（点击勾选框勾选）\n完成本章后，你应该能够：\n使用 if 语句实现条件分支\n理解并使用各种循环结构\n正确使用 break 退出循环\n识别并避免无限循环\n使用嵌套的控制结构解决复杂问题\n理解 while 和 repeat-until 的区别\n使用 for 循环处理计数任务 什么情况下应该使用 while 循环而不是 for 循环？\n如果需要在循环中跳过某些迭代但不退出循环，有哪些方法？\n如何设计一个程序，让用户可以多次尝试直到成功？\n在什么情况下应该使用嵌套循环？有什么需要注意的？\n如何确保循环能够正常结束，不会成为无限循环？ 编写一个程序，找出 100 以内所有的素数\n创建一个简单的文字冒险游戏，使用条件语句控制游戏流程\n实现一个模拟银行 ATM 机的程序，支持存款、取款、查询等功能\n编写一个程序，打印出斐波那契数列的前 20 项\n创建一个简单的成绩管理系统，可以输入多个学生成绩并统计平均分\n下一章预告：在第 6 章中，我们将深入学习函数。函数是组织和重用代码的重要工具，它能将复杂问题分解为小的、可管理的部分。我们将学习如何定义函数、传递参数、返回值，以及更高级的函数概念。学习建议：\n多做练习，特别是循环和条件组合的题目\n尝试将日常生活中的决策过程用 if 语句描述\n注意观察哪些任务适合用循环自动化\n多调试，理解程序执行的流程\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"5.1 条件判断：if 语句","level":2,"id":"5.1_条件判断：if_语句_0"},{"heading":"5.1.1 基本 if 语句","level":3,"id":"5.1.1_基本_if_语句_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"错误示例","level":4,"id":"错误示例_0"},{"heading":"5.1.2 if-else 语句","level":3,"id":"5.1.2_if-else_语句_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"5.1.3 if-elseif-else 语句","level":3,"id":"5.1.3_if-elseif-else_语句_0"},{"heading":"示例","level":4,"id":"示例_2"},{"heading":"5.1.4 嵌套 if 语句","level":3,"id":"5.1.4_嵌套_if_语句_0"},{"heading":"5.1.5 条件表达式中的逻辑运算符","level":3,"id":"5.1.5_条件表达式中的逻辑运算符_0"},{"heading":"1. 使用 and 连接多个条件","level":4,"id":"1._使用_and_连接多个条件_0"},{"heading":"2. 使用 or 表示多个条件之一成立","level":4,"id":"2._使用_or_表示多个条件之一成立_0"},{"heading":"3. 使用not进行条件取反","level":4,"id":"3._使用not进行条件取反_0"},{"heading":"4. 复杂条件组合","level":4,"id":"4._复杂条件组合_0"},{"heading":"5. 示例","level":4,"id":"5._示例_0"},{"heading":"5.2 循环结构","level":2,"id":"5.2_循环结构_0"},{"heading":"5.2.1 while 循环","level":3,"id":"5.2.1_while_循环_0"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"示例","level":4,"id":"示例_4"},{"heading":"5.2.2 repeat-until 后判断循环","level":3,"id":"5.2.2_repeat-until_后判断循环_0"},{"heading":"示例","level":4,"id":"示例_5"},{"heading":"while 与 repeat-until 对比","level":4,"id":"while_与_repeat-until_对比_0"},{"heading":"5.2.3 for 循环：数值 for","level":3,"id":"5.2.3_for_循环：数值_for_0"},{"heading":"示例","level":4,"id":"示例_6"},{"heading":"实际应用","level":4,"id":"实际应用_0"},{"heading":"5.2.4 循环控制：break 语句","level":3,"id":"5.2.4_循环控制：break_语句_0"},{"heading":"示例","level":4,"id":"示例_7"},{"heading":"5.2.5 进入下一次循环","level":3,"id":"5.2.5_进入下一次循环_0"},{"heading":"5.2.6 泛型 for 循环（初步了解）","level":3,"id":"5.2.6_泛型_for_循环（初步了解）_0"},{"heading":"5.3 练习","level":2,"id":"5.3_练习_0"},{"heading":"练习 1：猜数字游戏","level":3,"id":"练习_1：猜数字游戏_0"},{"heading":"练习2：打印图形","level":3,"id":"练习2：打印图形_0"},{"heading":"5.4 本章总结","level":2,"id":"5.4_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"编程思维培养","level":3,"id":"编程思维培养_0"},{"heading":"常见错误与调试技巧","level":3,"id":"常见错误与调试技巧_0"},{"heading":"最佳实践","level":3,"id":"最佳实践_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"},{"heading":"拓展练习","level":3,"id":"拓展练习_0"}],"links":["第-1-节-语法/2.-基础语法规则.html#1 代码块","第-1-节-语法/参考答案.html#练习 5 1：猜数字游戏","第-1-节-语法/参考答案.html#练习 5.2：打印图形"],"author":"","coverImageURL":"","fullURL":"第-1-节-语法/5.-控制结构.html","pathToRoot":"..","attachments":[],"createdTime":1765088947239,"modifiedTime":1766713040993,"sourceSize":24087,"sourcePath":"第 1 节 - 语法/5. 控制结构.md","exportPath":"第-1-节-语法/5.-控制结构.html","showInTree":true,"treeOrder":6,"backlinks":[],"type":"markdown"},"第-1-节-语法/6.-函数.html":{"title":"6. 函数","icon":"","description":"函数是组织和重用代码的基本单元。它让我们可以将一段具有特定功能的代码封装起来，通过名称调用执行。在开始学习函数语法之前，先看看不使用函数时的问题：-- 不使用函数的重复代码\nprint(\"=== 玩家1 ===\")\nlocal player1_name = \"小明\"\nlocal player1_level = 10\nlocal player1_health = 100\nprint(\"姓名：\" .. player1_name)\nprint(\"等级：\" .. player1_level)\nprint(\"生命值：\" .. player1_health) print(\"=== 玩家2 ===\")\nlocal player2_name = \"小红\"\nlocal player2_level = 8\nlocal player2_health = 80\nprint(\"姓名：\" .. player2_name)\nprint(\"等级：\" .. player2_level)\nprint(\"生命值：\" .. player2_health) print(\"=== 玩家3 ===\")\nlocal player3_name = \"小刚\"\nlocal player3_level = 12\nlocal player3_health = 120\nprint(\"姓名：\" .. player3_name)\nprint(\"等级：\" .. player3_level)\nprint(\"生命值：\" .. player3_health)\n上面的代码有很多重复模式。函数可以解决这个问题！-- 使用function关键字定义的全局\nlocal function 函数名(参数: any...) -- 函数体 -- 可以包含多条语句 return 返回值 -- 可选\nend -- 以上语法等价于此\nlocal 函数名 = function(参数: any...) -- 函数体 return 返回值\nend\n-- 示例1：简单的问候函数\nlocal function greet() print(\"你好！欢迎来到Lua世界！\")\nend -- 调用函数\ngreet() -- 输出：你好！欢迎来到Lua世界！\ngreet() -- 可以多次调用\ngreet() -- 示例2：带参数的函数\nlocal function greet_person(name) print(\"你好，\" .. name .. \"！\")\nend -- 调用带参数的函数\ngreet_person(\"小明\") -- 输出：你好，小明！\ngreet_person(\"小红\") -- 输出：你好，小红！\ngreet_person(\"老师\") -- 输出：你好，老师！ -- 示例3：使用函数表达式\nlocal calculate_area = function(width, height) local area = width * height return area\nend -- 调用函数表达式\nlocal result = calculate_area(5, 3)\nprint(\"面积为：\" .. result) -- 输出：面积为：15\n现在用函数重构之前的重复代码：-- 定义显示玩家信息的函数\nlocal function show_player_info(name, level, health) print(\"=== \" .. name .. \" ===\") print(\"姓名：\" .. name) print(\"等级：\" .. level) print(\"生命值：\" .. health)\nend -- 使用函数，使代码变得更简洁\nshow_player_info(\"小明\", 10, 100)\nshow_player_info(\"小红\", 8, 80)\nshow_player_info(\"小刚\", 12, 120)\nlocal function double_number(x) return x * 2\nend print(\"5的两倍是：\" .. double_number(5)) -- 输出：10\nlocal function calculate_rectangle(width, height) local area = width * height local perimeter = 2 * (width + height) return area, perimeter\nend -- 接收多个返回值\nlocal area, perimeter = calculate_rectangle(4, 3)\nprint(\"长方形：面积=\" .. area .. \", 周长=\" .. perimeter) -- 面积=12, 周长=14\n-- 实际游戏示例：计算伤害\nlocal function calculate_damage(attack, defense, multiplier) local damage = attack - defense if damage &lt; 0 then damage = 0 end damage = damage * (multiplier or 1) -- multiplier可选，默认为1 return damage\nend -- 测试伤害计算\nlocal damage1 = calculate_damage(50, 30, 1.5) -- 攻击50，防御30，倍率1.5\nlocal damage2 = calculate_damage(40, 45, 1.0) -- 攻击40，防御45\nlocal damage3 = calculate_damage(100, 20) -- multiplier未提供，使用默认值1 print(\"伤害1：\" .. damage1) -- 输出：30 ((50-30)*1.5)\nprint(\"伤害2：\" .. damage2) -- 输出：0 ((40-45)为负，设为0)\nprint(\"伤害3：\" .. damage3) -- 输出：80\n-- 对于表类型，参数传递的是引用（表的内容可以被修改）\nlocal function modify_table(t) t.x = t.x * 2 -- 修改表的内容 print(\"函数内 t.x = \" .. t.x)\nend local my_table = {x = 10, y = 20}\nprint(\"调用前 my_table.x = \" .. my_table.x)\t-- 10 modify_table(my_table) -- 函数内 t.x = 20\nprint(\"调用后 my_table.x = \" .. my_table.x)\t-- 20（改变了！） -- 注意：表本身不会被替换\nlocal function replace_table(t) t = {x = 100, y = 200} -- 这不会影响原始表，只是让 t 指向了 {x = 100, y = 200} 这个表 print(\"函数内 t.x = \" .. t.x)\nend local original_table = {x = 10, y = 20}\nprint(\"调用前 original_table.x = \" .. original_table.x)\t-- 10 replace_table(original_table) -- 函数内 t.x = 100\nprint(\"调用后 original_table.x = \" .. original_table.x)\t-- 10（没有改变！）\n这个 t 变量可以理解为箭头（指针）指向表这个“盒子”，给指针 t 赋值，只是让指针指向了另一个表，通过 t.x 访问则是先通过指针找到指向的表然后修改里面的 x 键。示意图：\n<img alt=\"Pasted image 20251208134125.png\" src=\"site-lib/media/pasted-image-20251208134125.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\">-- 数字等值，传递的是 \"值\"\nlocal function modify_value(x) x = x * 2 -- 修改的是副本，不影响原始值 print(\"函数内 x = \" .. x)\nend local num = 10\nprint(\"调用前 num = \" .. num)\t-- 10 modify_value(num) -- 函数内 x = 20\nprint(\"调用后 num = \" .. num)\t-- 10（没有改变！） --[[ 这些类型（值类型）都是直接传递值的副本： local a = 10 -- 数字 local b = true -- 布尔 local c = nil -- nil\n--]] -- 使用 ... 接收可变数量的参数\nlocal function sum(...) local numbers = {...} -- 将参数收集到表中 local total = 0 for i, num in ipairs(numbers) do total = total + num end return total\nend -- 测试变长参数函数\nprint(\"1+2 = \" .. sum(1, 2)) -- 3\nprint(\"1+2+3 = \" .. sum(1, 2, 3)) -- 6\nprint(\"1+2+3+4+5 = \" .. sum(1, 2, 3, 4, 5)) -- 15\nprint(\"空参数 = \" .. sum()) -- 0 -- 混合固定参数和可变参数\nlocal function format_string(separator, ...) local parts = {...} local result = \"\" for i, part in ipairs(parts) do if i &gt; 1 then result = result .. separator end result = result .. tostring(part) end return result\nend -- 测试格式化函数\nprint(format_string(\", \", \"苹果\", \"香蕉\", \"橙子\")) -- 苹果, 香蕉, 橙子\nprint(format_string(\" - \", \"A\", \"B\", \"C\", \"D\")) -- A - B - C - D\nprint(format_string(\" and \", \"猫\", \"狗\")) -- 猫 and 狗 -- 实际应用：计算平均值\nlocal function average(...) local numbers = {...} local count = #numbers if count == 0 then return 0 end local total = sum(...) -- 重用之前的sum函数 return total / count\nend print(\"平均值1：\" .. average(10, 20, 30)) -- 20\nprint(\"平均值2：\" .. average(1, 2, 3, 4, 5)) -- 3\nprint(\"平均值3：\" .. average(100)) -- 100\n-- 返回单个值\nlocal function is_even(number) if number % 2 == 0 then return true else return false end\nend -- 调用单返回值函数\nlocal result = is_even(10)\nprint(\"10是偶数吗？\" .. tostring(result)) -- true -- 更简洁的写法\nlocal function is_odd(number) return number % 2 == 1\nend print(\"7是奇数吗？\" .. tostring(is_odd(7))) -- true -- 注意：返回值后面的代码不会被执行\nlocal function is_odd(number) return number % 2 == 1 print(\"这里不会被执行\")\nend\n-- 实际游戏示例：计算等级所需经验\nfunction get_exp_for_level(level) -- 假设每级所需经验是 level * 100 return level * 100\nend print(\"升到10级需要经验：\" .. get_exp_for_level(10)) -- 1000\n-- 返回多个值\nfunction min_max(numbers) if #numbers == 0 then return nil, nil -- 返回两个nil end local min_val = numbers[1] local max_val = numbers[1] for i = 2, #numbers do if numbers[i] &lt; min_val then min_val = numbers[i] end if numbers[i] &gt; max_val then max_val = numbers[i] end end return min_val, max_val\nend -- 接收多个返回值\nlocal scores = {85, 92, 78, 90, 88}\nlocal min_score, max_score = min_max(scores)\nprint(\"最低分：\" .. min_score) -- 78\nprint(\"最高分：\" .. max_score) -- 92 -- 如果只需要部分返回值，可以用下划线忽略\nlocal _, highest = min_max(scores) -- 只关心最高分\nprint(\"只关心最高分：\" .. highest) -- 返回值和接收值的数量可以不匹配（多余的会被视为 nil）\nlocal a, b, c = min_max(scores)\nprint(\"a = \" .. tostring(a)) -- 78\nprint(\"b = \" .. tostring(b)) -- 92\nprint(\"c = \" .. tostring(c)) -- nil（只有两个返回值）\n-- 游戏示例：获取玩家位置\nfunction get_player_position(player_id) -- 模拟从游戏引擎获取位置 local x = 100 + player_id * 10 local y = 50 + player_id * 5 local z = 0 -- 2D游戏中的高度 return x, y, z\nend -- 获取玩家1的位置\nlocal x1, y1, z1 = get_player_position(1)\nprint(\"玩家1位置：(\" .. x1 .. \", \" .. y1 .. \", \" .. z1 .. \")\") -- 获取玩家2的位置（只关心x和y坐标）\nlocal x2, y2 = get_player_position(2)\nprint(\"玩家2位置：(\" .. x2 .. \", \" .. y2 .. \")\")\n-- 有时返回表比返回多个值更方便\nfunction get_player_stats(player_id) -- 模拟获取玩家状态 return { health = 100 - player_id * 10, mana = 50 + player_id * 5, level = player_id, experience = player_id * 100 }\nend -- 使用返回的表\nlocal stats = get_player_stats(3)\nprint(\"玩家3状态：\")\nprint(\"生命值：\" .. stats.health)\nprint(\"魔法值：\" .. stats.mana)\nprint(\"等级：\" .. stats.level)\nprint(\"经验：\" .. stats.experience) -- 可以直接在表达式中使用\nprint(\"生命值/魔法值比例：\" .. get_player_stats(4).health / get_player_stats(4).mana)\n-- 函数可以返回另一个函数\nfunction create_multiplier(factor) -- 返回一个新的函数 return function(x) return x * factor end\nend -- 创建特定的乘法器\nlocal double = create_multiplier(2)\nlocal triple = create_multiplier(3)\nlocal times_ten = create_multiplier(10) -- 使用返回的函数\nprint(\"2的两倍：\" .. double(2)) -- 4\nprint(\"2的三倍：\" .. triple(2)) -- 6\nprint(\"2的十倍：\" .. times_ten(2)) -- 20 -- 实际应用：创建不同难度的游戏关卡\nfunction create_enemy_generator(difficulty) local health_multiplier = 1 + (difficulty - 1) * 0.5 -- 难度越高，生命值越高 return function(base_health) return base_health * health_multiplier end\nend -- 创建不同难度的敌人生成器\nlocal easy_enemy = create_enemy_generator(1) -- 简单\nlocal normal_enemy = create_enemy_generator(2) -- 普通\nlocal hard_enemy = create_enemy_generator(3) -- 困难 print(\"简单敌人生命值：\" .. easy_enemy(100)) -- 100\nprint(\"普通敌人生命值：\" .. normal_enemy(100)) -- 150\nprint(\"困难敌人生命值：\" .. hard_enemy(100)) -- 200\n有些函数内的判断可以使用卫语句来提前返回，降低镶套与缩进层数，同时也可以提高性能-- 解锁关卡检查\nlocal player_level = 10 local info_level = \"森林\"\t-- 模拟玩家点击关卡\nlocal level_mode = \"夜晚模式\"\nlocal unlocked_level = {forest = true} local function check_level_unlock() if info_level == \"森林\" then if player_level &gt;= 1 then\t-- 玩家等级大于等于 1 if level_mode == \"夜晚模式\" then\t-- 判断关卡模式 if unlocked_level.forest then print(\"玩家进入夜晚的森林\") else return \"错误，玩家未解锁森林\" end elseif level_mode == \"白天模式\" then if unlocked_level.forest then print(\"玩家进入白天的森林\") else return \"错误，玩家未解锁森林\" end else return \"错误，未知模式\" end else return \"错误，玩家等级不足，不能进入森林\" end end\nend -- 改进版本\nlocal function check_level_unlock() if info_level == \"森林\" then if player_level &lt; 1 then\t-- 提前判断等级是否足够，不足直接返回 return \"玩家等级不足，不能进入森林\" end if not unlocked_level.forest then\t-- 提前判断是否解锁关卡，没有解锁直接返回 return \"错误，玩家未解锁森林\" end if level_mode == \"夜晚模式\" then\t-- 判断关卡模式 print(\"玩家进入夜晚的森林\") elseif level_mode == \"白天模式\" then print(\"玩家进入白天的森林\") else return \"错误，未知模式\" end end\nend local err = check_level_unlock()\nif err then print(err)\nend\n匿名函数（也叫 lambda 函数）是没有名字的函数，通常作为值使用。-- 基本匿名函数\nlocal add = function(a, b) return a + b\nend print(\"5 + 3 = \" .. add(5, 3)) -- 8 -- 立即调用的匿名函数（IIFE）\nlocal result = (function(x) return x * x\nend)(5) print(\"5 的平方：\" .. result) -- 25 -- 作为参数传递给其他函数\nlocal numbers = {1, 2, 3, 4, 5} -- 使用匿名函数作为回调\nfunction process_numbers(numbers, processor) for i, num in ipairs(numbers) do numbers[i] = processor(num) end return numbers\nend -- 传入匿名函数处理数组\nlocal doubled = process_numbers({1, 2, 3}, function(x) return x * 2 end)\nprint(\"加倍后的数组：\")\nfor i, v in ipairs(doubled) do print(\" \" .. v) -- 2, 4, 6\nend\nlocal function outer() print(\"进入 outer 函数的局部作用域\") local outer_var = \"局部变量\" function inner()\t-- 全局函数 print(\"inner 函数访问: \" .. outer_var) end -- 调用全局函数 inner() print(\"退出 outer 函数的局部作用域\")\nend outer() -- 注意：inner 函数如果在外部调用，需要先调用 outer 函数定义 inner\n闭包是 Lua 中一个强大而有趣的概念。简单说，闭包就是一个能记住并访问其创建时环境的函数。-- 基本闭包示例\n-- 计数器函数\nlocal function make_counter() local count = 0 -- 局部变量，外部无法直接访问 -- 返回一个函数，这个函数能访问 count return function() count = count + 1 return count end\nend -- 创建两个独立的计数器\nlocal counter1 = make_counter() -- 存储了一个独立的 count，每次调用 counter1 将存储的 count + 1\nlocal counter2 = make_counter() -- 这里创建了一个新的 count print(\"计数器 1:\")\nprint(counter1()) -- 1\nprint(counter1()) -- 2\nprint(counter1()) -- 3 print(\"计数器 2:\")\nprint(counter2()) -- 1（独立计数）\nprint(counter2()) -- 2\nprint(counter2()) -- 3 print(counter1()) -- 4\nprint(counter2()) -- 4\n-- 闭包的实际应用：创建配置器\nlocal function create_configurator(default_config) local config = default_config return { get = function(key) return config[key] end, set = function(key, value) config[key] = value return true end, show = function() print(\"当前配置:\") for k, v in pairs(config) do print(\" \" .. k .. \": \" .. tostring(v)) end end }\nend -- 使用配置器\nlocal game_config = create_configurator({ sound = true, music = true, difficulty = \"normal\", volume = 70\n}) game_config.show()\ngame_config.set(\"difficulty\", \"hard\")\ngame_config.set(\"volume\", 80)\nprint(\"新的难度：\" .. game_config.get(\"difficulty\"))\n--[[ 输出\n当前配置: difficulty: normal music: true sound: true volume: 70\n新的难度：hard\n--]]\n递归是函数调用自身的技术，常用于解决分治问题。-- 经典的阶乘函数\nlocal function factorial(n) if n &lt;= 1 then return 1 end return n * factorial(n - 1)\nend print(\"5 的阶乘: \" .. factorial(5)) -- 120\nprint(\"10 的阶乘: \" .. factorial(10)) -- 3628800 -- 斐波那契数列\nlocal function fibonacci(n) if n &lt;= 0 then return 0 elseif n == 1 then return 1 end return fibonacci(n - 1) + fibonacci(n - 2)\nend print(\"斐波那契数列前 10 项:\")\nfor i = 0, 9 do print(fibonacci(i) .. \" \") -- 0 1 1 2 3 5 8 13 21 34\nend -- 注意：递归要有终止条件，否则会导致栈溢出\nlocal function infinite_recursion() infinite_recursion() -- 无限递归，会导致错误\nend -- infinite_recursion() -- 不要真的调用！\n文档注释类似于类型注解，标注函数作用、每个参数的作用、返回值，同时集成在 vscode 中，鼠标悬浮在函数上即可直接显示参数作用。推荐给你的所有函数增加文档注释，便于阅读代码。---函数作用\n---@param 参数 参数类型 参数作用\n---@return 返回类型 返回描述\n-- 注意：只能写到定义函数的上面 ---对某人说 hello\n---@param name string 名称\n---@return string 完整文本\nlocal function say_hello(name) local text = \"hello \" .. name print(text) return text\nend say_hello(\"bob\")\n-- 输出 hello bob\n鼠标悬浮到 say_hello 函数上面显示：<br>\n<img alt=\"Pasted image 20251211205307.png\" src=\"site-lib/media/pasted-image-20251211205307.png\" target=\"_self\" style=\"width: 345px; max-width: 100%;\"><br>（答案见 <a data-href=\"第 1 节 - 语法/参考答案#练习 6 1：简单的计算器函数库\" href=\"第-1-节-语法/参考答案.html#练习 6 1：简单的计算器函数库\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 6 1：简单的计算器函数库</a>）-- 写几个计算器用的函数，需要有基础四则运算，平均值计算\n-- 使用示例：\n-- 使用函数库\nprint(\"5 + 3 = \" .. add(5, 3))\nprint(\"10 - 4 = \" .. subtract(10, 4))\nprint(\"6 * 7 = \" .. multiply(6, 7)) local result, error_msg = divide(10, 0)\nif error_msg then print(\"错误: \" .. error_msg)\nelse print(\"10 / 2 = \" .. result)\nend print(\"平均值(1,2,3,4,5) = \" .. average(1, 2, 3, 4, 5))\n--[[ 输出\n5 + 3 = 8\n10 - 4 = 6\n6 * 7 = 42\n错误: 除数不能为 0\n平均值(1,2,3,4,5) = 3\n--]]\n<br>（答案见 <a data-href=\"第 1 节 - 语法/参考答案#练习 6 2：提取函数，优化代码\" href=\"第-1-节-语法/参考答案.html#练习 6 2：提取函数，优化代码\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 6 2：提取函数，优化代码</a>）-- 将以下所有代码提取为函数，再改进代码，要求：使用卫语句 -- 购物车商品处理程序 -- 模拟购买的物品\nlocal cart = { { name = \"苹果\", price = 5, quantity = 3 }, { name = \"香蕉\", price = 3, quantity = 2 }, { name = \"橙子\", price = 6, quantity = 4 }, { name = \"葡萄\", price = 8, quantity = 1 }\n} -- 打印商品详细信息\nprint(\"=== 商品详情 ===\") for _, item in ipairs(cart) do local item_total = item.price * item.quantity print(\"商品: \" .. item.name) print(\"单价: \" .. item.price .. \"元\") print(\"数量: \" .. item.quantity) print(\"小计: \" .. item_total .. \"元\") print(\"------------\")\nend -- 计算购物车信息\nlocal total_price = 0\nlocal total_quantity = 0 for _, item in ipairs(cart) do total_price = total_price + (item.price * item.quantity) total_quantity = total_quantity + item.quantity\nend print(\"购物车总价: \" .. total_price .. \"元\") -- 判断是否有优惠（满50减10，满100减25，买10个赠1个）\nif total_price &gt;= 50 and total_price &lt; 100 then if total_quantity &gt;= 10 then print(\"购物车物品总数：\" .. total_quantity .. \"个，赠品1个\") local discount_price = total_price - 10 print(\"符合优惠条件，满50减10\") print(\"优惠后价格: \" .. discount_price .. \"元\") else local discount_price = total_price - 10 print(\"符合优惠条件，满50减10\") print(\"优惠后价格: \" .. discount_price .. \"元\") end\nelseif total_price &gt;= 100 then if total_quantity &gt;= 10 then print(\"购物车物品总数：\" .. total_quantity .. \"个，赠品1个\") local discount_price = total_price - 25 print(\"符合优惠条件，满100减25\") print(\"优惠后价格: \" .. discount_price .. \"元\") else local discount_price = total_price - 25 print(\"符合优惠条件，满100减25\") print(\"优惠后价格: \" .. discount_price .. \"元\") end\nelse print(\"未满50元，无优惠\")\nend print(\"\\n=== 推荐商品 ===\")\n-- 根据购物车推荐相关商品\nlocal recommendations = { { name = \"梨子\", price = 6 }, { name = \"芒果\", price = 10 }\n} for _, cart_item in ipairs(cart) do if cart_item.name == \"苹果\" then print(\"您购买了苹果，可能也喜欢:\") for _, rec in ipairs(recommendations) do local rec_total = rec.price * 1 -- 假设推荐买1个 print(\" \" .. rec.name .. \": \" .. rec.price .. \"元/个\") end end if cart_item.name == \"香蕉\" then print(\"您购买了香蕉，可能也喜欢:\") for _, rec in ipairs(recommendations) do local rec_total = rec.price * 1 print(\" \" .. rec.name .. \": \" .. rec.price .. \"元/个\") end end if cart_item.name == \"橙子\" then print(\"您购买了橙子，可能也喜欢:\") for _, rec in ipairs(recommendations) do local rec_total = rec.price * 1 print(\" \" .. rec.name .. \": \" .. rec.price .. \"元/个\") end end\nend 函数定义： function name(params) ... end 语法\n函数表达式：local name = function(params) ... end\n匿名函数：直接作为值使用 参数传递： 值类型是值传递，表是引用传递\n变长参数：使用 ...\n参数可以有默认值（通过 or 实现） 返回值： 可以返回单个值或多个值\n可以返回函数（高阶函数）\n可以返回表来组织复杂数据 高级概念： 闭包：能记住创建环境的函数\n递归：函数调用自身 文档注释： 使用 --- 进行文档注释\n使用 @param 和 @return 描述参数与返回值作用 -- 1. 函数应该只做一件事（单一职责）\nlocal function calculate_area(width, height) -- 好：只计算面积 return width * height\nend local function calculate_area_and_perimeter(width, height) -- 不太好：做两件事 return width * height, 2 * (width + height)\nend -- 2. 使用有意义的函数名\nlocal function get_player_health(player_id) -- 好：名字说明功能 -- ...\nend local function f1(x) -- 不好：名字没有意义 -- ...\nend -- 3. 参数数量适中（不超过 3-4 个）\nlocal function create_player(name, class, level) -- 好：参数明确 -- ...\nend local function setup_game(player1_name, player1_class, player1_level, player2_name, player2_class, player2_level, map_name, difficulty) -- 不好：参数太多 -- ...\nend -- 4. 使用返回值表示成功/失败\nlocal function load_file(file) if not file then return nil, \"错误，无法加载文件\" -- 失败时返回 nil 和错误信息 end return file\nend -- 5. 局部函数应该声明为 local\nlocal function helper_function() -- 好：不会污染全局命名空间 -- ...\nend -- 6. 使用卫语句提前返回\nlocal function get_player_info(player)\t-- 不好：镶套过多 if not player.dead then if player.level_up then print(\"玩家升级了\") end if player.walk then print(\"玩家移动中...\") end else print(\"玩家已死亡\") return \"玩家已死亡\" end\nend local function get_player_info(player)\t-- 好：较少镶套 if player.dead then print(\"玩家已死亡\") return \"玩家已死亡\" end if player.level_up then print(\"玩家升级了\") end if player.walk then print(\"玩家移动中...\") end\nend\n-- 错误 1：忘记写 return 语句\nfunction add(a, b) local sum = a + b -- 忘记写 return sum\nend local result = add(2, 3)\nprint(result) -- 输出：nil -- 错误 2：递归没有终止条件\nlocal function infinite_recursion(n) print(n) infinite_recursion(n + 1) -- 无限递归！\nend\n-- infinite_recursion(1) -- 会导致栈溢出 -- 错误 3：修改不应该修改的参数\nlocal function process_user_data(user) user = {} -- 错误：这不会影响原始参数 -- 应该修改 user 的字段，而不是替换整个表\nend -- 错误 4：全局变量污染\nlocal function calculate() result = 10 -- 错误：创建了全局变量 local local_result = 10 -- 正确：使用局部变量\nend\n（点击勾选框勾选）\n完成本章后，你应该能够：\n定义和调用函数\n理解参数传递的机制\n使用变长参数处理不定数量的参数\n从函数返回单个或多个值\n创建和使用匿名函数\n理解闭包的概念和用途\n编写递归函数\n设计模块化的函数库 什么时候应该使用多个返回值，什么时候应该返回表？\n闭包和普通函数有什么区别？什么时候应该使用闭包？\n递归有什么优缺点？如何避免递归导致的栈溢出？\n为什么应该优先使用局部函数而不是全局函数？\n如何设计一个良好的函数 API（参数、返回值、错误处理）？ 创建一个简单的银行账户系统，包含存款、取款、查询功能\n实现一个简单的缓存系统，使用闭包来保存缓存数据\n编写一个函数，可以生成不同难度的数学题目\n创建一个事件系统，允许注册回调函数并在特定事件发生时调用\n实现一个简单的状态机，使用函数表示不同状态的行为\n下一章预告：在第 7 章中，我们将深入学习 Lua 的核心数据结构——表（Table）。表是 Lua 中最重要、最灵活的数据结构，它可以用来实现数组、字典、对象、模块等几乎所有复杂数据结构。我们将学习表的创建、操作、遍历以及各种高级用法。学习建议：\n多练习函数的设计和实现\n尝试用函数重构重复的代码\n理解闭包的概念，这是 Lua 的精华之一\n注意函数的命名和参数设计，写出易读易用的代码\n尝试编写一些实用的小工具函数库\n常见问题解答：\nQ: 为什么值类型，参数传递时传递的是副本？\nA: 值类型传递副本是因为它们简单且不可变，复制开销小且语义安全。表传递引用是因为它可能很大且需要共享修改（多个变量操作一个表），传递指针更高效。","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"6.1 函数的基本概念","level":2,"id":"6.1_函数的基本概念_0"},{"heading":"为什么要使用函数？","level":4,"id":"为什么要使用函数？_0"},{"heading":"6.2 函数的定义与调用","level":2,"id":"6.2_函数的定义与调用_0"},{"heading":"6.2.1 函数定义的基本语法","level":3,"id":"6.2.1_函数定义的基本语法_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"6.2.2 改进的玩家信息显示程序","level":3,"id":"6.2.2_改进的玩家信息显示程序_0"},{"heading":"6.3 参数传递","level":2,"id":"6.3_参数传递_0"},{"heading":"6.3.1 基本参数传递","level":3,"id":"6.3.1_基本参数传递_0"},{"heading":"单个参数","level":4,"id":"单个参数_0"},{"heading":"多个参数","level":4,"id":"多个参数_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"6.3.2 参数传递的特性","level":3,"id":"6.3.2_参数传递的特性_0"},{"heading":"引用传递","level":4,"id":"引用传递_0"},{"heading":"值传递","level":4,"id":"值传递_0"},{"heading":"6.3.3 变长参数（可变参数）","level":3,"id":"6.3.3_变长参数（可变参数）_0"},{"heading":"6.4 返回值","level":2,"id":"6.4_返回值_0"},{"heading":"6.4.1 单返回值","level":3,"id":"6.4.1_单返回值_0"},{"heading":"示例","level":4,"id":"示例_2"},{"heading":"6.4.2 多返回值","level":3,"id":"6.4.2_多返回值_0"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"6.4.3 返回表的技巧","level":3,"id":"6.4.3_返回表的技巧_0"},{"heading":"6.4.4 返回函数","level":3,"id":"6.4.4_返回函数_0"},{"heading":"6.5.5 技巧","level":3,"id":"6.5.5_技巧_0"},{"heading":"6.5 匿名函数","level":2,"id":"6.5_匿名函数_0"},{"heading":"6.6 函数的作用域和闭包","level":2,"id":"6.6_函数的作用域和闭包_0"},{"heading":"6.6.1 作用域","level":3,"id":"6.6.1_作用域_0"},{"heading":"6.6.2 闭包","level":3,"id":"6.6.2_闭包_0"},{"heading":"示例","level":4,"id":"示例_4"},{"heading":"6.7 递归函数","level":2,"id":"6.7_递归函数_0"},{"heading":"6.8 文档注释","level":2,"id":"6.8_文档注释_0"},{"heading":"示例","level":4,"id":"示例_5"},{"heading":"6.9 练习","level":2,"id":"6.9_练习_0"},{"heading":"练习 1：简单的计算器函数库","level":3,"id":"练习_1：简单的计算器函数库_0"},{"heading":"练习 2：提取函数，优化代码","level":3,"id":"练习_2：提取函数，优化代码_0"},{"heading":"6.10 本章总结","level":2,"id":"6.10_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"函数设计的最佳实践","level":3,"id":"函数设计的最佳实践_0"},{"heading":"常见错误","level":3,"id":"常见错误_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"},{"heading":"拓展练习","level":3,"id":"拓展练习_0"}],"links":["第-1-节-语法/参考答案.html#练习 6 1：简单的计算器函数库","第-1-节-语法/参考答案.html#练习 6 2：提取函数，优化代码"],"author":"","coverImageURL":".","fullURL":"第-1-节-语法/6.-函数.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251208134125.png","site-lib/media/pasted-image-20251211205307.png"],"createdTime":1765108025706,"modifiedTime":1765936070640,"sourceSize":27532,"sourcePath":"第 1 节 - 语法/6. 函数.md","exportPath":"第-1-节-语法/6.-函数.html","showInTree":true,"treeOrder":7,"backlinks":[],"type":"markdown"},"第-1-节-语法/7.-表.html":{"title":"7. 表","icon":"","description":"表是 Lua 中唯一的数据结构，但它极其强大和灵活。通过表，Lua 可以实现数组、字典、对象、模块等几乎所有复杂数据结构。-- 比喻：表就像一个\"万能容器\"\n-- 想象一下，有一个魔法背包：\n-- 1. 可以按顺序放东西（数组）\n-- 2. 可以给东西贴标签，按名字找（字典）\n-- 3. 可以放其他背包（嵌套）\n-- 4. 甚至可以放\"使用说明\"（函数） -- 实际示例：一个表可以表示一个游戏角色\nlocal player = { name = \"小明\", -- 字符串键 level = 10, -- 字符串键 health = 100, -- 字符串键 [\"武器类型\"] = \"剑\",\t-- 包含特殊字符的键 [123] = \"编号\", -- 数字键 is_online = true\t-- 布尔值键\n} print(\"玩家姓名: \" .. player.name) -- 小明\nprint(\"玩家等级: \" .. player.level) -- 10\nprint(\"特殊键: \" .. player[\"武器类型\"])\t-- 剑\nprint(\"数字键: \" .. player[123]) -- 编号\n-- 创建空表\nlocal empty_table = {} -- 最简单的空表 -- 检查表是否为空\nprint(\"空表大小: \" .. #empty_table) -- 输出: 0\nprint(\"空表类型: \" .. type(empty_table)) -- 输出: table\n-- 注意：Lua的数组索引从1开始！\nlocal monsters = {\"僵尸\", \"骷髅\", \"蜘蛛\", \"土匪\"}\nprint(\"第一个怪物: \" .. monsters[1])\t-- 僵尸\nprint(\"怪物数量: \" .. #monsters) -- 4\nlocal player = { name = \"李雷\", age = 18, class = \"战士\", level = 5\n}\nprint(\"玩家: \" .. player.name) -- 李雷\nprint(\"职业: \" .. player[\"class\"])\t-- 战士 -- 使用方括号的复杂键\nlocal complex_keys = { [\"full name\"] = \"张三\", -- 包含空格的键 [\"score-100\"] = 95, -- 包含连字符的键 [true] = \"布尔键\", -- 布尔值作为键 [function() end] = \"函数键\" -- 函数作为键（不常见但可能）\n} print(complex_keys[\"full name\"]) -- 张三\nprint(complex_keys[true]) -- 布尔键\nlocal mixed = { \"第一个元素\", -- 数组部分，索引1 \"第二个元素\", -- 数组部分，索引2 author = \"小明\",\t-- 字典部分，键\"author\" version = 1.0\t-- 字典部分，键\"version\"\n}\nprint(mixed[1]) -- 第一个元素\nprint(mixed.author) -- 小明\nlocal game_world = { name = \"魔法世界\", players = { {name = \"战士\", level = 10}, {name = \"法师\", level = 8} }, settings = { difficulty = \"normal\", sound = true, graphics = \"high\" }\n} print(\"游戏世界: \" .. game_world.name)\t-- 魔法世界\nprint(\"第一个玩家: \" .. game_world.players[1].name) -- 战士\nprint(\"难度设置: \" .. game_world.settings.difficulty) -- normal\n表传递引用是因为它可能很大且需要共享修改（多个变量操作一个表），传递指针更高效。-- 重要概念：表是引用类型\nlocal original = {x = 10, y = 20}\nlocal reference = original -- 不是复制，是引用同一个表 reference.x = 100 -- 修改引用也会影响原始表\nprint(\"original.x = \" .. original.x) -- 100 -- 如果需要复制表，需要手动操作（后面会讲） -- 表的相等比较是比较引用，不是内容\nlocal a = {1, 2, 3}\nlocal b = {1, 2, 3}\nlocal c = a print(\"a == b ? \" .. tostring(a == b)) -- false（不同对象）\nprint(\"a == c ? \" .. tostring(a == c)) -- true（同一对象）\n我们可以直接通过等于号来增加与修改元素，缺点是数组必须要知道增加位置。-- 列表\nlocal monsters = {\"僵尸\", \"骷髅\", \"蜘蛛\", \"土匪\"}\nmonsters[1] = \"恶魔\"\nprint(\"第一个怪物: \" .. monsters[1])\t-- 恶魔 -- 字典\n-- 创建空表\nlocal inventory = {} -- 添加元素到字典部分\ninventory[\"gold\"] = 100\n-- inventory.gold = 100 -- 等价写法\ninventory.silver = 50\ninventory.copper = 200 for k, v in pairs(inventory) do print(k .. \": \" .. v)\nend\n--[[ 输出\ncopper: 200\nsilver: 50\ngold: 100\n--]]\ntable.insert 会在数组的指定位置插入一个新元素，并将该位置及之后的元素依次后移。-- 不指定增加位置\ntable.insert(表: table, 元素: any)\n-- 指定增加位置\ntable.insert(表: table, 增加位置: any, 元素: any) 增加位置默认为数组末尾\nlocal inventory = {} -- 添加元素到数组末尾\nprint(\"添加元素到数组末尾\")\ntable.insert(inventory, \"药水\")\ntable.insert(inventory, \"钥匙\")\ninventory[#inventory + 1] = \"地图\" -- 等价写法 -- 修改元素\ninventory.gold = 150 -- 修改现有元素\ninventory[2] = \"万能钥匙\" -- 修改数组部分 print(\"库存:\")\nfor k, v in pairs(inventory) do print(k .. \": \" .. v)\nend print(\"\\n插入元素 “剑” 到数组第二个索引，将元素 2 后移。\")\ntable.insert(inventory, 2, \"剑\") print(\"库存:\")\nfor k, v in pairs(inventory) do print(k .. \": \" .. v)\nend\n--[[ 输出\n插入元素到数组末尾\n库存:\n1: 药水\n2: 万能钥匙\n3: 地图\ngold: 150 添加元素 “剑” 到数组第二个索引，将元素 2 后移\n库存:\n1: 药水\n2: 剑\n3: 万能钥匙\n4: 地图\ngold: 150\n--]] -- 示例：模拟queue（队列）操作\nlocal queue = {} local function enqueue(item) table.insert(queue, item)\nend local function dequeue() if #queue &gt; 0 then return table.remove(queue, 1) end return nil\nend -- 测试队列\nenqueue(\"任务1\")\nenqueue(\"任务2\")\nenqueue(\"任务3\") print(\"\\n队列操作:\")\nprint(\"出队: \" .. dequeue()) -- 任务1\nprint(\"出队: \" .. dequeue()) -- 任务2\nprint(\"当前队列长度: \" .. #queue) -- 1\n--[[ 输出\n出队: 任务1\n出队: 任务2\n当前队列长度: 1\n--]]\ntable.remove 用于移除数组中指定位置的元素，并将后续元素前移以填补空缺，保持数组的连续性。table.remove(表: table, 删除位置?: int) -&gt; 删除的元素: any 移除位置默认为数组末尾\n-- 1. 直接删除，缺点：删除数组元素后数组有 “洞”\nlocal items = { \"剑\", \"盾\", \"药水\", \"钥匙\", \"地图\", gold = 100, weight = 50\n} print(\"原始物品:\")\nfor k, v in pairs(items) do print(k .. \": \" .. v)\nend -- 删除数组元素\nitems[2] = nil -- 删除第二个元素（盾）\nprint(\"\\n删除盾牌后:\")\nfor k, v in pairs(items) do print(k .. \": \" .. v)\nend -- 注意：设置nil不会自动调整数组\n-- 数组部分可能会有\"洞\"\nprint(\"\\n有洞的数组遍历（ipairs会在第一个nil停止）:\")\nfor i, v in ipairs(items) do print(i .. \": \" .. v)\nend -- 删除字典元素\nitems.gold = nil\nprint(\"\\n删除金币后:\")\nfor k, v in pairs(items) do print(k .. \": \" .. v)\nend\n--[[ 删除\n原始物品:\n1: 剑\n2: 盾\n3: 药水\n4: 钥匙\n5: 地图\nweight: 50\ngold: 100 删除盾牌后:\n1: 剑\n3: 药水\n4: 钥匙\n5: 地图\nweight: 50\ngold: 100 有洞的数组遍历（ipairs会在第一个nil停止）:\n1: 剑 删除金币后:\n1: 剑\n3: 药水\n4: 钥匙\n5: 地图\nweight: 50\n--]] -- 2. 使用 table.remove 移除后自动调整数组\nlocal items = { \"剑\", \"盾\", \"药水\", \"钥匙\", \"地图\", gold = 100, weight = 50\n} local removed = table.remove(items, 2)\t-- 移除第二个索引的元素（盾） print(\"移除了\" .. removed .. \"，现在第二个索引的元素:\" .. items[2]) print(\"ipairs 遍历（table.remove 自动补洞）:\")\nfor i, v in ipairs(items) do print(i .. \": \" .. v)\nend\n--[[ 输出\n移除了盾，现在第二个索引的元素: 药水 ipairs 遍历（table.remove 自动补洞）:\n1: 剑\n2: 药水\n3: 钥匙\n4: 地图\n--]] -- 实际游戏中删除物品的例子\nlocal backpack = { \"红药水\", \"蓝药水\", \"传送卷轴\", \"回城卷轴\", \"解毒剂\"\n} function remove_item(container, item_name) for i = #container, 1, -1 do -- 从后往前遍历，避免索引变化问题 if container[i] == item_name then table.remove(container, i) print(\"已移除: \" .. item_name) return true end end print(\"未找到物品: \" .. item_name) return false\nend print(\"\\n背包内容:\")\nfor i, v in ipairs(backpack) do print(\" \" .. i .. \": \" .. v)\nend remove_item(backpack, \"传送卷轴\")\nremove_item(backpack, \"不存在的物品\") print(\"\\n移除后的背包:\")\nfor i, v in ipairs(backpack) do print(\" \" .. i .. \": \" .. v)\nend\n--[[ 输出\n背包内容: 1: 红药水 2: 蓝药水 3: 传送卷轴 4: 回城卷轴 5: 解毒剂\n已移除: 传送卷轴\n未找到物品: 不存在的物品 移除后的背包: 1: 红药水 2: 蓝药水 3: 回城卷轴 4: 解毒剂\n--]]\nlocal game_data = { players = { {name = \"小明\", score = 1000}, {name = \"小红\", score = 850}, {name = \"小刚\", score = 920} }, settings = { sound = {volume = 70, enabled = true}, graphics = {quality = \"high\", resolution = \"1920x1080\"} }\n} -- 检查键是否存在\nprint(\"检查键是否存在:\")\nprint(\"有players键吗? \" .. tostring(game_data.players ~= nil)) -- true\nprint(\"有monsters键吗? \" .. tostring(game_data.monsters ~= nil)) -- false\n-- 注意：表中不存在的键值对都是 nil\n-- 使用 game_data.players[1] 如果没有 game_data.players 将会报错，因为 game_data.players 是 nil，nil 无法索引 -- 安全的访问方式：使用逻辑运算符短路求值，如果判断到不存在的键直接停止后续逻辑运算\nlocal player_name = game_data.players and game_data.players[1] and game_data.players[1].name\nprint(\"第一个玩家: \" .. (player_name or \"未知\"))\n-- #操作符用于获取表的数组部分的长度\n-- 注意：它只在数组部分是连续的且从1开始时才准确 -- 连续数组\nlocal arr1 = {1, 2, 3, 4, 5}\nprint(\"arr1长度: \" .. #arr1) -- 5 -- 有\"洞\"的数组\nlocal arr2 = {1, nil, 3, 4, 5}\nprint(\"arr2长度（有洞）: \" .. #arr2) -- 1（遇到第一个nil就停止） local arr3 = {1, 2, 3}\narr3[5] = 5\nprint(\"arr3长度（不连续）: \" .. #arr3) -- 3（只计算连续部分） -- 字典部分不影响长度\nlocal mixed = { \"a\", \"b\", \"c\", name = \"测试\", value = 100\n}\nprint(\"mixed长度: \" .. #mixed) -- 3（只计算数组部分） -- 安全获取表长度的方法\nfunction table_length(t) local count = 0 for _ in pairs(t) do count = count + 1 end return count\nend local test_table = {a = 1, b = 2, c = 3, d = 4}\nprint(\"表总元素数: \" .. table_length(test_table)) -- 4\nprint(\"数组长度操作符: \" .. #test_table) -- 0（没有数组部分）\n-- 实际应用：统计玩家数量\nlocal players = { {name = \"玩家1\", ready = true}, {name = \"玩家2\", ready = false}, {name = \"玩家3\", ready = true}, {name = \"玩家4\", ready = true}\n} print(\"玩家总数: \" .. #players)\nprint(\"就绪玩家数: \" .. (function() local count = 0 for _, player in ipairs(players) do if player.ready then count = count + 1 end end return count\nend)())\n-- ipairs用于遍历数组部分（索引从1开始，连续）\nlocal colors = {\"红色\", \"绿色\", \"蓝色\", \"黄色\", \"紫色\"} print(\"使用ipairs遍历:\")\nfor index, color in ipairs(colors) do print(\" 颜色\" .. index .. \": \" .. color)\nend -- ipairs在遇到nil时会停止\nlocal with_holes = {\"第一\", nil, \"第三\", \"第四\"}\nprint(\"\\n有洞的数组，ipairs遍历:\")\nfor i, v in ipairs(with_holes) do print(\" \" .. i .. \": \" .. v)\nend\n-- 只会输出: 1: 第一\n-- 实际游戏示例：遍历技能列表\nlocal skills = { {name = \"火球术\", damage = 30, mana_cost = 10}, {name = \"治疗术\", heal = 50, mana_cost = 15}, {name = \"冰箭术\", damage = 25, mana_cost = 8, slow = true}\n} print(\"\\n技能列表:\") for i, skill in ipairs(skills) do print(\" 技能\" .. i .. \": \" .. skill.name) if skill.damage then print(\" 伤害: \" .. skill.damage) end if skill.heal then print(\" 治疗: \" .. skill.heal) end print(\" 消耗法力: \" .. skill.mana_cost)\nend\n-- pairs遍历表的所有键值对（包括数组和字典部分）\nlocal student = { \"小明\", -- 数组部分，索引1 age = 18, -- 字典部分 grade = \"高三\", -- 字典部分 \"男\", -- 数组部分，索引2 [\"出生日期\"] = \"2005-03-15\" -- 字典部分\n} print(\"使用pairs遍历:\")\nfor key, value in pairs(student) do print(\" \" .. tostring(key) .. \": \" .. tostring(value))\nend\n-- 注意：pairs的遍历顺序是无序的！\nlocal data = { \"第一个\", \"第二个\", key1 = \"值1\", \"第三个\", key2 = \"值2\"\n} print(\"\\n使用ipairs遍历:\")\nfor i, v in ipairs(data) do print(\" \" .. i .. \": \" .. v) -- 只输出数组部分：1,2,3\nend print(\"\\n使用pairs遍历:\")\nfor k, v in pairs(data) do print(\" \" .. tostring(k) .. \": \" .. tostring(v)) -- 输出所有键值对\nend\n-- 实际应用：遍历物品栏\nlocal inventory = { gold = 150, silver = 300, [\"生命药水\"] = 5, [\"魔法药水\"] = 3, weapons = {\"木剑\", \"铁盾\"}\n} print(\"\\n物品栏内容:\") for item, amount in pairs(inventory) do if type(amount) == \"number\" then print(\" \" .. item .. \": \" .. amount) elseif type(amount) == \"table\" then print(\" \" .. item .. \":\") for i, weapon in ipairs(amount) do print(\" \" .. i .. \". \" .. weapon) end end\nend\n-- 由于 pairs 遍历顺序不确定，有时我们需要特定顺序\nlocal scores = { [\"小明\"] = 85, [\"小红\"] = 92, [\"小刚\"] = 78, [\"李雷\"] = 88, [\"韩梅梅\"] = 95\n} -- 方法1：先收集键，然后排序\nprint(\"按名字排序输出:\") local keys = {} for name in pairs(scores) do table.insert(keys, name)\nend table.sort(keys) -- 按字母顺序排序 for _, name in ipairs(keys) do print(\" \" .. name .. \": \" .. scores[name])\nend -- 方法2：按分数排序\nprint(\"\\n按分数从高到低排序:\")\nlocal entries = {}\nfor name, score in pairs(scores) do table.insert(entries, {name = name, score = score})\nend -- 自定义排序函数\ntable.sort(entries, function(a, b) return a.score &gt; b.score -- 降序排列\nend) for i, entry in ipairs(entries) do print(\" \" .. i .. \". \" .. entry.name .. \": \" .. entry.score)\nend\n-- 实际应用：游戏排行榜\nlocal leaderboard = { {name = \"Player1\", score = 15000, time = 360}, {name = \"Player2\", score = 12000, time = 420}, {name = \"Player3\", score = 18000, time = 300}, {name = \"Player4\", score = 9000, time = 500}\n} -- 按分数降序，分数相同时按时间升序\ntable.sort(leaderboard, function(a, b) if a.score == b.score then return a.time &lt; b.time -- 时间少的排在前面 end return a.score &gt; b.score -- 分数高的排在前面\nend) print(\"\\n游戏排行榜:\")\nfor rank, player in ipairs(leaderboard) do print(string.format(\" 第%d名: %s (分数: %d, 时间: %d秒)\", rank, player.name, player.score, player.time))\nend\nLua 提供了几个内置函数来操作表。table.concat(列表: list, 分隔符?: str, 起始位置?: int, 结束位置?: int) 不指定分隔符则直接进行连接\n不指定起始位置与结束位置默认连接所有元素\n-- table.concat用于连接数组部分的元素\nlocal words = {\"Hello\", \"Lua\", \"World\", \"!\"} -- 简单连接\nlocal sentence = table.concat(words)\nprint(\"简单连接: \" .. sentence) -- HelloLuaWorld! -- 用分隔符连接\nsentence = table.concat(words, \" \")\nprint(\"空格分隔: \" .. sentence) -- Hello Lua World ! -- 指定起始和结束位置\nsentence = table.concat(words, \", \", 2, 3)\nprint(\"部分连接: \" .. sentence) -- Lua, World -- 实际应用：构建路径\nlocal path_parts = {\"home\", \"user\", \"projects\", \"lua\", \"main.lua\"}\nlocal path = table.concat(path_parts, \"/\")\nprint(\"文件路径: \" .. path) -- home/user/projects/lua/main.lua -- 构建SQL查询条件\nlocal conditions = {\"age &gt; 18\", \"status = 'active'\", \"score &gt;= 60\"}\nlocal where_clause = table.concat(conditions, \" AND \")\nprint(\"SQL条件: WHERE \" .. where_clause) -- 构建HTML列表\nlocal items = {\"苹果\", \"香蕉\", \"橙子\"}\nlocal html_list = \"&lt;ul&gt;\\n\"\nfor i, item in ipairs(items) do html_list = html_list .. \" &lt;li&gt;\" .. item .. \"&lt;/li&gt;\\n\"\nend\nhtml_list = html_list .. \"&lt;/ul&gt;\"\nprint(\"\\nHTML列表:\\n\" .. html_list)\ntable.sort(单结构表: list|dict, 匿名函数?: func) 不指定匿名函数则对于字符串将会以字母升序排序，数字以大小升序排序\n为匿名函数传递比较的两个值，匿名函数必须返回布尔值，为真排序在前，为假排序在后\n-- table.sort用于对数组部分进行排序\nlocal numbers = {5, 2, 8, 1, 9, 3} print(\"原始数组: \" .. table.concat(numbers, \", \")) -- 默认排序（升序）\ntable.sort(numbers)\nprint(\"升序排序: \" .. table.concat(numbers, \", \")) -- 降序排序\ntable.sort(numbers, function(a, b) return a &gt; b\nend)\nprint(\"降序排序: \" .. table.concat(numbers, \", \"))\n--[[ 输出\n原始数组: 5, 2, 8, 1, 9, 3\n升序排序: 1, 2, 3, 5, 8, 9\n降序排序: 9, 8, 5, 3, 2, 1\n--]] -- 字符串排序\nlocal letter = { \"b\", \"a\", \"c\", \"y\", \"z\", \"x\" }\ntable.sort(letter)\nprint(\"\\n字母排序: \" .. table.concat(letter, \", \"))\n--[[ 输出\n字母排序: a, b, c, x, y, z\n--]] -- 复杂数据排序\nlocal students = { {name = \"小明\", score = 85, age = 18}, {name = \"小红\", score = 92, age = 17}, {name = \"小刚\", score = 78, age = 19}, {name = \"李雷\", score = 85, age = 18}\n} -- 按分数降序，分数相同时按名字升序\ntable.sort(students, function(a, b) if a.score == b.score then return a.name &lt; b.name end return a.score &gt; b.score\nend) print(\"\\n学生排名:\")\nfor i, student in ipairs(students) do print(string.format(\" 第%d名: %s (分数: %d, 年龄: %d)\", i, student.name, student.score, student.age))\nend -- 自定义排序：按字符串长度\nlocal words = {\"apple\", \"banana\", \"cat\", \"elephant\", \"dog\"} table.sort(words, function(a, b) return #a &lt; #b -- 按长度升序\nend) print(\"\\n按长度排序: \" .. table.concat(words, \", \"))\n-- 浅拷贝（只复制一层）\nlocal function shallow_copy(original) local copy = {} for k, v in pairs(original) do copy[k] = v end return copy\nend -- 测试复制\nlocal original = { name = \"原始表\", data = {1, 2, 3}, nested = { a = \"A\", b = {x = 10, y = 20} }\n} local shallow = shallow_copy(original) -- 修改原表\noriginal.name = \"修改后的原表\"\noriginal.data[1] = 100\noriginal.nested.b.x = 999 print(\"浅复制测试:\")\nprint(\" 原表.name: \" .. original.name) -- 修改后的原表\nprint(\" 浅复制.name: \" .. shallow.name) -- 原始表（字符串被复制）\nprint(\" 原表.data[1]: \" .. original.data[1]) -- 100\nprint(\" 浅复制.data[1]: \" .. shallow.data[1]) -- 100（表是引用！）\n-- 深复制（复制所有嵌套结构）\nlocal function deep_copy(original, seen) seen = seen or {} if type(original) ~= \"table\" then return original end if seen[original] then return seen[original] end local copy = {} seen[original] = copy for k, v in pairs(original) do copy[deep_copy(k, seen)] = deep_copy(v, seen) end return copy\nend -- 测试复制\nlocal original = { name = \"原始表\", data = {1, 2, 3}, nested = { a = \"A\", b = {x = 10, y = 20} }\n} local deep = deep_copy(original) -- 修改原表\noriginal.name = \"修改后的原表\"\noriginal.data[1] = 100\noriginal.nested.b.x = 999 print(\"\\n深复制测试:\")\nprint(\" 深复制.name: \" .. deep.name) -- 原始表\nprint(\" 深复制.data[1]: \" .. deep.data[1]) -- 1（独立副本）\nprint(\" 深复制.nested.b.x: \" .. deep.nested.b.x) -- 10（独立副本）\n-- 合并两个表（浅合并）\nlocal function shallow_merge(t1, t2) local result = {} for k, v in pairs(t1) do result[k] = v end for k, v in pairs(t2) do result[k] = v end return result\nend -- 测试合并\nlocal defaults = { sound = true, volume = 70, graphics = { quality = \"medium\", resolution = \"1280x720\" }\n} local user_settings = { volume = 80, language = \"中文\", graphics = { resolution = \"1920x1080\", shadows = true }\n} local merged = shallow_merge(defaults, user_settings) print(\"合并后的设置:\")\nfor k, v in pairs(merged) do if type(v) == \"table\" then print(\" \" .. k .. \":\") for k2, v2 in pairs(v) do print(\" \" .. k2 .. \": \" .. tostring(v2)) end else print(\" \" .. k .. \": \" .. tostring(v)) end\nend\n--[[ 输出\n合并后的设置: language: 中文 volume: 80 sound: true graphics: shadows: true resolution: 1920x1080\n--]]\n-- 深度合并\nlocal function deep_merge(t1, t2) local result = {} for k, v in pairs(t1) do result[k] = v end for k, v in pairs(t2) do if type(result[k]) == \"table\" and type(v) == \"table\" then result[k] = deep_merge(result[k], v) else result[k] = v end end return result\nend -- 测试合并\nlocal defaults = { sound = true, volume = 70, graphics = { quality = \"medium\", resolution = \"1280x720\" }\n} local user_settings = { volume = 80, language = \"中文\", graphics = { resolution = \"1920x1080\", shadows = true }\n} local merged = deep_merge(defaults, user_settings) print(\"合并后的设置:\")\nfor k, v in pairs(merged) do if type(v) == \"table\" then print(\" \" .. k .. \":\") for k2, v2 in pairs(v) do print(\" \" .. k2 .. \": \" .. tostring(v2)) end else print(\" \" .. k .. \": \" .. tostring(v)) end\nend\n--[[ 输出\n合并后的设置: language: 中文 volume: 80 sound: true graphics: shadows: true quality: medium resolution: 1920x1080\n--]]\n-- 表可以存储函数，模拟对象\nlocal player = { name = \"英雄\", health = 100, level = 1\n} -- 添加方法，注意：这里使用冒号定义\nfunction player:take_damage(amount) self.health = self.health - amount if self.health &lt; 0 then self.health = 0 print(self.name .. \" 倒下了！\") else print(self.name .. \" 受到 \" .. amount .. \" 点伤害，剩余生命: \" .. self.health) end\nend\n-- 以上代码等价于，由于这里是定义到表内的，所以不分局部与全局函数\nfunction player.take_damage(self, amount) self.health = self.health - amount if self.health &lt; 0 then self.health = 0 print(self.name .. \" 倒下了！\") else print(self.name .. \" 受到 \" .. amount .. \" 点伤害，剩余生命: \" .. self.health) end\nend function player:heal(amount) self.health = self.health + amount print(self.name .. \" 恢复了 \" .. amount .. \" 点生命，当前生命: \" .. self.health)\nend function player:level_up() self.level = self.level + 1 self.health = self.health + 20 print(self.name .. \" 升级到 \" .. self.level .. \" 级！\")\nend -- 使用冒号调用方法\nplayer:take_damage(30) -- 英雄 受到 30 点伤害，剩余生命: 70\nplayer:heal(10) -- 英雄 恢复了 10 点生命，当前生命: 80\nplayer:level_up() -- 英雄 升级到 2 级！\n-- 以上代码等价于（需要显式传递self）\nplayer.take_damage(player, 30)\nplayer.heal(player, 10)\nplayer.level_up(player) -- 创建多个\"实例\"\nlocal function create_player(name) local new_player = { name = name, health = 100, level = 1 } -- 使用方法共享（避免每个对象都复制方法） new_player.take_damage = player.take_damage new_player.heal = player.heal new_player.level_up = player.level_up return new_player\nend local player1 = create_player(\"战士\")\nlocal player2 = create_player(\"法师\") player1:take_damage(40) -- 战士 受到 40 点伤害，剩余生命: 60\nplayer2:level_up() -- 法师 升级到 2 级！\n可以使用语法糖 : 冒号来隐式传递 self 参数。-- 定义函数\nfunction player:take_damage(amount) ... end\n-- 这等价于\nfunction player.take_damage(self, amount) ... end -- 调用函数\nplayer:take_damage(40)\n-- 这等价于\nplayer.take_damage(player, 40)\n-- 元表可以改变表的默认行为\n-- 这是Lua最强大的特性之一，我们这里先简单介绍 -- 实现向量加法\n-- 创建两个表\nlocal v1 = {x = 10, y = 20}\nlocal v2 = {x = 5, y = 15} -- 默认情况下，表不能直接相加\n-- print(v1 + v2) -- 错误：尝试对表进行算术运算 -- 创建元表\nlocal mt = {} -- 定义元表的__add方法（用于加法）\nmt.__add = function(a, b) return { x = a.x + b.x, y = a.y + b.y }\nend -- 设置元表\nsetmetatable(v1, mt)\nsetmetatable(v2, mt) -- 现在表可以相加了！\nlocal v3 = v1 + v2\nprint(\"v1 + v2 = {x=\" .. v3.x .. \", y=\" .. v3.y .. \"}\") -- {x = 15, y = 35}\n（答案见 <a data-href=\"第 1 节 - 语法/参考答案#练习 7 1：简单的联系人管理系统\" href=\"第-1-节-语法/参考答案.html#练习 7 1：简单的联系人管理系统\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 7 1：简单的联系人管理系统</a>）-- 实现一个简单的联系人管理系统，要求：可增加联系人到通讯录，可读取联系人，可以打印通讯录所有联系人\n-- 使用示例：\n-- 测试联系人管理系统\nadd_contact(\"张三\", \"13800138000\", \"zhangsan@email.com\")\nadd_contact(\"李四\", \"13900139000\")\nadd_contact(\"王五\", \"13700137000\", \"wangwu@company.com\") list_contacts() find_contact(\"张三\")\nfind_contact(\"赵六\") remove_contact(\"李四\")\nlist_contacts() --[[ 输出\n=== 联系人管理系统 ===\n已添加联系人: 张三\n已添加联系人: 李四\n已添加联系人: 王五\n通讯录为空\n找到联系人 张三: 电话: 17300138000 邮箱: zhangsan@email.com\n未找到联系人: 赵六\n已删除联系人: 李四\n通讯录为空\n--]]\n<br>（答案见 <a data-href=\"第 1 节 - 语法/参考答案#练习 7 2：购物车系统\" href=\"第-1-节-语法/参考答案.html#练习 7 2：购物车系统\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 7 2：购物车系统</a>）-- 实现一个购物车系统，可以向购物车增加与移除商品，然后通过购物车购买，买完清空购物车，要求：自行查资料使用 string.format 格式化价格，让价格仅保留两位小数与对齐（%宽度.小数位数f）\n-- 使用示例：\n-- 测试购物车系统\nprint(\"=== 购物车系统 ===\")\nshopping_cart:add_item(\"苹果\", 5.5, 2)\nshopping_cart:add_item(\"香蕉\", 3.2, 3)\nshopping_cart:add_item(\"苹果\", 5.5, 1) -- 增加苹果数量 shopping_cart:show_cart() shopping_cart:remove_item(\"香蕉\", 1) -- 减少香蕉数量 shopping_cart:show_cart() shopping_cart:clear()\nshopping_cart:show_cart() --[[ 输出\n== 购物车系统 ===\n已添加商品: 苹果 x2\n已添加商品: 香蕉 x3\n已更新商品: 苹果 x1\n=== 购物车 ===\n1. 苹果 单价: 5.50 数量: 3 小计: 16.50\n2. 香蕉 单价: 3.20 数量: 3 小计: 9.60 总计: 38.90 元\n已减少商品: 香蕉 x1，剩余: x2\n=== 购物车 ===\n1. 苹果 单价: 5.50 数量: 3 小计: 16.50\n2. 香蕉 单价: 3.20 数量: 2 小计: 6.40 总计: 35.70 元\n已清空购物车\n购物车为空\n--]] 表的创建和初始化： 使用 {} 创建空表\n构造器语法可以初始化数组和字典部分\n表是引用类型，赋值传递的是引用 表的操作： 增：有洞直接赋值，无洞使用 table.insert\n删：有洞设为 nil ，无洞使用 table.remove\n查：通过键访问，注意处理 nil 值\n长度：# 操作符只计算数组部分 表遍历： ipairs：遍历连续数组部分（索引从 1 开始）\npairs：遍历所有键值对（顺序不确定）\n自定义排序遍历 相关函数 table.concat 将表连接为字符串\ntable.sort 表排序，匿名函数传递两个参数 高级用法： 表的复制（浅复制和深复制）\n表的合并\n表作为对象使用（存储函数）\n使用语法糖 : 冒号来隐式传递 self 参数\n元表基础（改变表的默认行为） -- 模式 1：配置对象\nlocal config = { window = { width = 800, height = 600, title = \"我的游戏\" }, player = { speed = 5, health = 100 }\n} -- 模式 2：数据记录\nlocal student = { id = 1001, name = \"小明\", scores = {85, 92, 78}, average = function(self) local sum = 0 for _, score in ipairs(self.scores) do sum = sum + score end return sum / #self .scores end\n} -- 模式 3：命名空间（模块模式）\nlocal math_utils = {} function math_utils.clamp(value, min, max) if value &lt; min then return min end if value &gt; max then return max end return value\nend function math_utils.lerp(a, b, t) return a + (b - a) * t\nend -- 使用\nlocal value = math_utils.clamp(150, 0, 100) -- 100\n-- 错误 1：误用 #操作符\nlocal t = {}\nt[100] = \"值\"\nprint( #t ) -- 0，不是 100！ -- 错误 2：在循环中修改表\nlocal items = {1, 2, 3, 4, 5}\nfor i, v in ipairs(items) do if v == 2 then table.remove(items, i) -- 这会导致跳过下一个元素 end\nend -- 正确做法：从后往前遍历\nfor i = #items , 1, -1 do if items[i] == 2 then table.remove(items, i) end\nend -- 错误 3：忘记表的引用特性\nlocal original = {data = {1, 2, 3}}\nlocal copy = original -- 这只是引用，不是复制！\ncopy.data[1] = 100 -- 也会修改 original -- 错误 4：混合数组和字典时的不当操作\nlocal mixed = {1, 2, 3, a = \"A\"}\ntable.sort(mixed) -- 错误：不能对混合表排序！ local dict = {a = 1, b = 2}\nlocal l = #dict -- 错误：长度运算符仅适用于字符串与列表，这里 l = 0\n-- 1. 预分配大数组（如果知道大小）\nlocal big_array = {}\nfor i = 1, 10000 do big_array[i] = 0 -- 避免多次重新分配\nend -- 2. 避免在循环中多次计算表长度\nlocal items = {1, 2, 3, 4, 5}\nlocal length = #items -- 先计算一次\nfor i = 1, length do -- 使用缓存的值\nend -- 3. 使用局部引用访问嵌套表的深层元素\nlocal config = { game = { settings = { graphics = { quality = \"high\" } } }\n} -- 不好：多次查找\nprint(config.game.settings.graphics.quality)\nprint(config.game.settings.graphics.resolution) -- 好：使用局部引用\nlocal graphics = config.game.settings.graphics\nprint(graphics.quality)\nprint(graphics.resolution) -- 4. 选择合适的遍历方式\n-- ipairs 比 pairs 快（只遍历数组部分）\n-- 如果需要遍历所有元素，但表主要是数组，先用 ipairs\n（点击勾选框勾选）\n完成本章后，你应该能够：\n创建和初始化各种类型的表\n对表进行增删改查操作\n正确遍历表的数组部分和所有元素\n使用表相关内置函数\n实现表的浅复制和深复制\n使用表模拟对象和命名空间\n理解元表的基本概念\n设计和使用复杂的数据结构 Lua 为什么选择表作为唯一的数据结构？这种设计有什么优缺点？\n什么情况下应该使用数组形式的表，什么情况下应该使用字典形式的表？\n表的引用特性在什么情况下是有用的，什么情况下会带来问题？\n如何设计一个高效的表来存储大量数据？\n元表能实现哪些强大的功能？你能想到什么实际应用场景？ 实现一个简单的数据库系统，支持增删改查操作\n创建一个图数据结构，支持添加节点、边和路径查找\n创建一个事件系统，支持事件的注册、触发和取消\n下一章预告：在第 8 章中，我们将学习字符串处理。字符串是编程中无处不在的数据类型，Lua 提供了强大的字符串操作功能，包括基础操作和强大的模式匹配（类似正则表达式但更简洁）。我们将学习如何创建、操作、搜索和格式化字符串。学习建议：\n多练习表的创建和操作，这是 Lua 的核心\n尝试用表解决各种实际问题\n理解表的引用特性，避免常见错误\n学习表的性能特点，编写高效的代码\n探索表的高级用法，特别是作为对象和模块的使用\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"7.1 什么是表？","level":2,"id":"7.1_什么是表？_0"},{"heading":"表的核心理念","level":3,"id":"表的核心理念_0"},{"heading":"7.2 表的创建和初始化","level":2,"id":"7.2_表的创建和初始化_0"},{"heading":"7.2.1 创建空表","level":3,"id":"7.2.1_创建空表_0"},{"heading":"7.2.2 使用构造器初始化表","level":3,"id":"7.2.2_使用构造器初始化表_0"},{"heading":"作为数组（列表）使用","level":4,"id":"作为数组（列表）使用_0"},{"heading":"作为字典（映射）使用","level":4,"id":"作为字典（映射）使用_0"},{"heading":"混合使用（数组部分+字典部分）","level":4,"id":"混合使用（数组部分+字典部分）_0"},{"heading":"嵌套表","level":4,"id":"嵌套表_0"},{"heading":"7.2.3 表的引用特性","level":3,"id":"7.2.3_表的引用特性_0"},{"heading":"7.3 表的操作","level":2,"id":"7.3_表的操作_0"},{"heading":"7.3.1 直接修改与增加元素","level":3,"id":"7.3.1_直接修改与增加元素_0"},{"heading":"7.3.2 table.insert - 插入元素到数组","level":3,"id":"7.3.2_table.insert_-_插入元素到数组_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"7.3.3 table.remove - 移除数组元素","level":3,"id":"7.3.3_table.remove_-_移除数组元素_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"7.3.4 查询元素","level":3,"id":"7.3.4_查询元素_0"},{"heading":"使用逻辑运算符安全的访问表","level":4,"id":"使用逻辑运算符安全的访问表_0"},{"heading":"7.3.5 表的长度运算符符","level":3,"id":"7.3.5_表的长度运算符符_0"},{"heading":"示例","level":4,"id":"示例_2"},{"heading":"7.4 表遍历","level":2,"id":"7.4_表遍历_0"},{"heading":"7.4.1 ipairs - 遍历数组部分","level":3,"id":"7.4.1_ipairs_-_遍历数组部分_0"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"7.4.2 pairs - 遍历所有元素","level":3,"id":"7.4.2_pairs_-_遍历所有元素_0"},{"heading":"对比ipairs和pairs","level":4,"id":"对比ipairs和pairs_0"},{"heading":"示例","level":4,"id":"示例_4"},{"heading":"7.4.3 自定义遍历顺序","level":3,"id":"7.4.3_自定义遍历顺序_0"},{"heading":"示例","level":4,"id":"示例_5"},{"heading":"7.5 表相关函数","level":2,"id":"7.5_表相关函数_0"},{"heading":"7.5.1 table.concat - 连接为字符串","level":3,"id":"7.5.1_table.concat_-_连接为字符串_0"},{"heading":"示例","level":4,"id":"示例_6"},{"heading":"7.5.2 table.sort - 排序","level":3,"id":"7.5.2_table.sort_-_排序_0"},{"heading":"语法","level":4,"id":"语法_0"},{"heading":"示例","level":4,"id":"示例_7"},{"heading":"7.6 表的高级用法","level":2,"id":"7.6_表的高级用法_0"},{"heading":"7.6.1 表的复制","level":3,"id":"7.6.1_表的复制_0"},{"heading":"浅复制（浅拷贝）","level":4,"id":"浅复制（浅拷贝）_0"},{"heading":"深复制（深拷贝）","level":4,"id":"深复制（深拷贝）_0"},{"heading":"7.6.2 表的合并","level":3,"id":"7.6.2_表的合并_0"},{"heading":"浅合并","level":4,"id":"浅合并_0"},{"heading":"深合并","level":4,"id":"深合并_0"},{"heading":"7.6.3 表作为对象使用","level":3,"id":"7.6.3_表作为对象使用_0"},{"heading":"示例","level":4,"id":"示例_8"},{"heading":"冒号语法糖","level":4,"id":"冒号语法糖_0"},{"heading":"7.6.4 元表（Metatable）基础","level":3,"id":"7.6.4_元表（Metatable）基础_0"},{"heading":"7.7 练习","level":2,"id":"7.7_练习_0"},{"heading":"练习 1：简单的联系人管理系统","level":3,"id":"练习_1：简单的联系人管理系统_0"},{"heading":"练习 2：购物车系统","level":3,"id":"练习_2：购物车系统_0"},{"heading":"7.8 本章总结","level":2,"id":"7.8_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"表的设计模式","level":3,"id":"表的设计模式_0"},{"heading":"常见错误","level":3,"id":"常见错误_0"},{"heading":"性能优化建议","level":3,"id":"性能优化建议_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"},{"heading":"拓展练习","level":3,"id":"拓展练习_0"}],"links":["第-1-节-语法/参考答案.html#练习 7 1：简单的联系人管理系统","第-1-节-语法/参考答案.html#练习 7 2：购物车系统"],"author":"","coverImageURL":"","fullURL":"第-1-节-语法/7.-表.html","pathToRoot":"..","attachments":[],"createdTime":1765173921839,"modifiedTime":1765936076523,"sourceSize":34415,"sourcePath":"第 1 节 - 语法/7. 表.md","exportPath":"第-1-节-语法/7.-表.html","showInTree":true,"treeOrder":8,"backlinks":[],"type":"markdown"},"第-1-节-语法/8.-字符串.html":{"title":"8. 字符串","icon":"","description":"字符串是编程中最常用的数据类型之一。在 Lua 中，字符串是不可变的，但提供了丰富的操作函数。-- Lua有几种创建字符串的方式 -- 1. 双引号\nlocal str1 = \"Hello, Lua!\"\nprint(\"双引号: \" .. str1) -- 2. 单引号\nlocal str2 = 'Hello, World!'\nprint(\"单引号: \" .. str2) -- 3. 长括号（多行字符串）\nlocal str3 = [[\n这是多行字符串\n可以包含换行和\"各种引号\"\n而无需转义]]\nprint(\"长括号:\\n\" .. str3) -- 4. 带有等号的长括号（可以嵌套）\nlocal str4 = [=[\n多层嵌套 [[不会结束字符串]]\n]=]\nprint(\"带等号的长括号: \" .. str4)\n-- 转义字符，用于输入特殊字符\nlocal escaped = \"第一行\\n换行\\t制表符（缩进）\\\"引号\\\\反斜杠\"\nprint(\"转义字符示例:\\n\" .. escaped) -- 特殊字符的表示\nprint(\"Unicode字符: \\u{4F60}\\u{597D}\") -- 你好\nprint(\"十六进制: \\x48\\x65\\x6C\\x6C\\x6F\") -- Hello\n所有转义符见 <a data-href=\"6. 字符串#转义字符\" href=\"总结/6.-字符串.html#转义字符\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">6. 字符串 &gt; 转义字符</a>-- 重要概念：Lua字符串是不可变的\nlocal original = \"Hello\"\nprint(\"原始字符串: \" .. original)\nprint(\"原始字符串内存地址（通过tostring）: \" .. tostring(original)) -- 看起来像是\"修改\"了字符串\noriginal = original .. \" World\"\nprint(\"修改后: \" .. original)\nprint(\"修改后内存地址: \" .. tostring(original))\n-- 注意：实际上是创建了一个新的字符串 -- 证明不可变性\nlocal a = \"Hello\"\nlocal b = \"Hello\"\nprint(\"\\na和b相同吗？ \" .. tostring(a == b)) -- true\nprint(\"a的内存地址: \" .. tostring(a))\nprint(\"b的内存地址: \" .. tostring(b))\n-- Lua会复用相同的字符串，所以a和b可能指向同一内存 -- 实际影响：大量字符串操作时要注意性能\nfunction slow_string_build() local result = \"\" for i = 1, 10000 do result = result .. \"x\" -- 每次都会创建新字符串 end return result\nend -- 更好的方式：使用table.concat\nfunction fast_string_build() local parts = {} for i = 1, 10000 do parts[i] = \"x\" end return table.concat(parts)\nend print(\"\\n字符串构建方式比较:\")\n-- 注意：在实际中，fast_string_build会比slow_string_build快得多\n-- 使用 # 运算符符获取字符串长度\nprint(\"=== 字符串长度 ===\") local str = \"Hello, Lua!\"\nprint(\"字符串: \" .. str)\nprint(\"长度: \" .. #str) -- 11（英文和标点）\nprint(\"长度: \" .. string.len(str))\t-- 使用 string.len，与上面等价，但是只能操作字符串 -- 中文字符\nlocal chinese = \"你好，世界！\"\nprint(\"\\n中文字符串: \" .. chinese)\nprint(\"长度: \" .. #chinese) -- 18（每个中文字符算三个长度）\nprint(\"长度: \" .. string.len(chinese)) -- 包含特殊字符\nlocal special = \"Line1\\nLine2\\tTab\"\nprint(\"\\n特殊字符字符串: \" .. special)\nprint(\"长度: \" .. #special) -- 15（\\n算一个字符，\\t算一个字符）\nprint(\"长度: \" .. string.len(special)) -- 空字符串\nlocal empty = \"\"\nprint(\"\\n空字符串长度: \" .. #empty) -- 0\n-- 使用 .. 连接字符串\n-- 基本连接\nlocal greeting = \"Hello\" .. \", \" .. \"World!\"\nprint(\"连接结果: \" .. greeting) -- 连接不同类型的值\nlocal name = \"小明\"\nlocal age = 18\nlocal info = \"姓名: \" .. name .. \", 年龄: \" .. age\nprint(\"信息: \" .. info) -- 大量连接时的性能问题\nlocal start_time = os.clock()\nlocal result = \"\" for i = 1, 1000 do result = result .. \"x\" -- 每次创建新字符串\nend local end_time = os.clock()\nprint(\"\\n直接连接1000次耗时: \" .. (end_time - start_time) .. \"秒\") -- 使用table.concat提高性能\nstart_time = os.clock()\nlocal parts = {} for i = 1, 1000 do parts[i] = \"x\"\nend result = table.concat(parts)\nend_time = os.clock()\nprint(\"使用table.concat耗时: \" .. (end_time - start_time) .. \"秒\") -- table.concat的高级用法\nlocal words = {\"Hello\", \"World\", \"from\", \"Lua\"}\nlocal sentence = table.concat(words, \" \", 2, 4) -- 从第2个到第4个，用空格连接\nprint(\"\\n部分连接: \" .. sentence) -- \"World from Lua\" -- 实际应用：构建SQL查询\nlocal conditions = {\"age &gt; 18\", \"status = 'active'\", \"score &gt;= 60\"}\nlocal where_clause = \"WHERE \" .. table.concat(conditions, \" AND \")\nprint(\"SQL查询: SELECT * FROM users \" .. where_clause) -- 实际应用：构建URL\nlocal base_url = \"https://api.example.com\"\nlocal path = \"users\"\nlocal query_params = {\"limit=10\", \"offset=0\", \"sort=name\"}\nlocal url = base_url .. \"/\" .. path .. \"?\" .. table.concat(query_params, \"&amp;\")\nprint(\"URL: \" .. url)\nstring.rep(重复的字符串: str, 重复次数: int) -&gt; 字符串结果: str\n-- 基本重复\nlocal stars = string.rep(\"*\", 10)\nprint(\"10个星号: \" .. stars)\n-- 输出 10个星号: ********** -- 带分隔符的重复\nlocal dashed_line = string.rep(\"-\", 30)\nprint(\"分隔线: \" .. dashed_line)\n-- 输出 分隔线: ------------------------------ -- 重复多个字符\nlocal pattern = string.rep(\"*-\", 15)\nprint(\"模式: \" .. pattern)\n-- 输出 模式: *-*-*-*-*-*-*-*-*-*-*-*-*-*-*- -- 实际应用：进度条\nlocal function create_progress_bar(percentage, width) local filled = math.floor(percentage * width / 100) local empty = width - filled local bar = \"[\" .. string.rep(\"=\", filled) .. string.rep(\" \", empty) .. \"] \" .. string.format(\"%3d%%\", percentage) return bar\nend print(\"\\n进度条:\")\nfor i = 0, 100, 10 do print(create_progress_bar(i, 20))\nend\n--[[ 输出\n进度条:\n[ ] 0%\n[== ] 10%\n[==== ] 20%\n[====== ] 30%\n[======== ] 40%\n[========== ] 50%\n[============ ] 60%\n[============== ] 70%\n[================ ] 80%\n[================== ] 90%\n[====================] 100%\n--]] -- 实际应用：缩进文本\nlocal function indent_text(text, indent_level) local indent = string.rep(\" \", indent_level) return indent .. text\nend print(\"\\n缩进文本:\")\nlocal lines = { \"第一级\", \"第二级\", \"第三级\"\n} for i, line in ipairs(lines) do print(indent_text(line, i-1))\nend\n--[[ 输出\n缩进文本:\n第一级 第二级 第三级\n--]] -- 创建表格边框\nlocal function create_table_border(width) local border = \"+\" .. string.rep(\"-\", width-2) .. \"+\" return border\nend print(\"\\n表格边框:\")\nprint(create_table_border(25))\nprint(\"| 内容 |\")\nprint(create_table_border(25)) --[[ 输出\n表格边框:\n+-----------------------+\n| 内容 |\n+-----------------------+\n--]]\nstring.find(字符串: str, 查找的字符串: str, 搜索位置?: int, 是否不使用正则模式?: bool) -&gt; 起始索引: int, 结束索引: int| nil 搜索位置可以一个负数，表示从后往前数的字符个数\nlocal text = \"Hello, Lua programming is fun!\" -- 查找子串\nlocal start_pos, end_pos = string.find(text, \"Lua\")\nif start_pos then print(\"找到'Lua'在位置: \" .. start_pos .. \"-\" .. end_pos) print(\"子串: \" .. string.sub(text, start_pos, end_pos))\nelse print(\"未找到\")\nend -- 从指定位置开始查找\nlocal pos = string.find(text, \"o\", 6) -- 从第5个字符开始找\nprint(\"\\n从第5位开始找'o': \" .. (pos or \"未找到\")) -- 14 -- 查找最后一个匹配\nlocal function find_last(str, pattern) local last_pos local current_pos = 1 while true do local start, finish = string.find(str, pattern, current_pos) if not start then break end last_pos = start current_pos = start + 1 end return last_pos\nend local last_o = find_last(text, \"o\")\nprint(\"最后一个'o'在位置: \" .. (last_o or \"未找到\")) -- 查找所有匹配\nlocal function find_all(str, pattern) local positions = {} local current_pos = 1 while true do local start, finish = string.find(str, pattern, current_pos) if not start then break end table.insert(positions, {start = start, finish = finish}) current_pos = start + 1 end return positions\nend print(\"\\n 查找所有'o':\")\nlocal all_o = find_all(text, \"o\")\nfor i, pos in ipairs(all_o) do print(\" 匹配\" .. i .. \": 位置\" .. pos.start .. \"-\" .. pos.finish)\nend -- 实际应用：查找邮箱地址\nlocal email_text = \"联系我: user@example.com 或 admin@test.org \"\nlocal email_pattern = \"[%w%.%-]+@[%w%.%-]+%.[%w]+\" local email_start, email_end = string.find(email_text, email_pattern)\nif email_start then print(\"\\n 找到邮箱: \" .. string.sub(email_text, email_start, email_end))\nend\nstring.sub(字符串: str, 截取起始位置: int, 截取结束位置?: int) -&gt; 字符串: str 截取结束位置默认为 -1（截取到最后一个）\nlocal sentence = \"The quick brown fox jumps over the lazy dog\" -- 提取子串\nlocal first_word = string.sub(sentence, 1, 3)\nprint(\"第一个单词: \" .. first_word) -- The -- 使用负索引（从末尾开始）\nlocal last_word = string.sub(sentence, -3) -- 最后 3 个字符\nprint(\"最后三个字符: \" .. last_word) -- dog -- 提取中间部分\nlocal middle = string.sub(sentence, 5, 14)\nprint(\"第 5-14 个字符: \" .. middle) -- quick bro -- 实际应用：提取文件名和扩展名\nlocal function find_last(str, pattern) local last_pos local current_pos = 1 while true do local start, finish = string.find(str, pattern, current_pos) if not start then break end last_pos = start current_pos = start + 1 end return last_pos\nend local function split_filename(filename) local name_without_ext = filename local ext = \"\" -- 查找最后一个点 local dot_pos = find_last(filename, \"%.\") if dot_pos and dot_pos &gt; 1 then name_without_ext = string.sub(filename, 1, dot_pos - 1) ext = string.sub(filename, dot_pos + 1) end return name_without_ext, ext\nend local files = {\"document.pdf\", \"image.jpg\", \"no_extension\", \".hidden\", \"archive.tar.gz\"} print(\"\\n 文件名分割:\")\nfor _, filename in ipairs(files) do local name, ext = split_filename(filename) print(string.format(\" %-20s -&gt; 名称: %-15s 扩展名: %s\", filename, name, ext))\nend -- 实际应用：提取 URL 各部分\nfunction parse_url(url) local protocol, domain, path -- 查找协议 local protocol_end = string.find(url, \"://\") if protocol_end then protocol = string.sub(url, 1, protocol_end - 1) url = string.sub(url, protocol_end + 3) end -- 查找路径 local path_start = string.find(url, \"/\") if path_start then domain = string.sub(url, 1, path_start - 1) path = string.sub(url, path_start) else domain = url path = \"/\" end return protocol, domain, path\nend print(\"\\nURL 解析:\")\nlocal urls = { \"https://www.example.com/path/to/page\", \"http://localhost:8080\", \"ftp://files.server.com/download/file.zip\"\n} for _, url in ipairs(urls) do local protocol, domain, path = parse_url(url) print(string.format(\" %-40s -&gt; 协议: %-6s 域名: %-20s 路径: %s\", url, protocol or \"无\", domain, path))\nend\n-- Lua 没有内置的字符串分割函数，需要自己实现\n-- 按分隔符分割字符串\nlocal function string_split(str, delimiter) local result = {} local pattern = string.format(\"([^%s]+)\", delimiter) for match in string.gmatch(str, pattern) do table.insert(result, match) end return result\nend -- 按空格分割\nlocal sentence = \"The quick brown fox jumps over the lazy dog\"\nlocal words = string_split(sentence, \" \") print(\"\\n 句子单词:\") for i, word in ipairs(words) do print(\" 单词\" .. i .. \": \" .. word)\nend\n--[[ 输出\n句子单词: 单词1: The 单词2: quick 单词3: brown 单词4: fox 单词5: jumps 单词6: over 单词7: the 单词8: lazy 单词9: dog\n--]] -- 按行分割\nlocal multi_line = \"第一行\\n 第二行\\n 第三行\"\nlocal lines = string_split(multi_line, \"\\n\") print(\"\\n 按行分割:\") for i, line in ipairs(lines) do print(\" 行\" .. i .. \": \" .. line)\nend\n--[[ 输出\n按行分割: 行1: 第一行 行2: 第二行 行3: 第三行\n--]]\nLua 的模式匹配（pattern matching）是一种轻量级的正则表达式，功能强大但语法更简单，使用具有特殊意义的符号（修饰符）表示各种字符。<br>所有模式匹配修饰符见 <a data-href=\"6. 字符串#模式匹配修饰符\" href=\"总结/6.-字符串.html#模式匹配修饰符\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">6. 字符串 &gt; 模式匹配修饰符</a>string.match(字符串: str, 匹配模式: pattern, 起始位置?: init) -&gt; 匹配结果: str\n-- Lua 模式匹配的特殊字符 -- . 匹配任意字符\nprint(\"'.'匹配任意字符: \" .. string.match(\"abc123\", \".\")) -- %a 匹配字母\nprint(\"'%a'匹配字母: \" .. string.match(\"abc123!@#\", \"%a\")) -- %d 匹配数字\nprint(\"'%d'匹配数字: \" .. string.match(\"abc123!@#\", \"%d\")) --[[ 输出\n'.'匹配任意字符: a\n'%a'匹配字母: a\n'%d'匹配数字: 1\n--]]\nstring.gmatch(字符串: str, 匹配模式: str) -&gt; 迭代器函数: func\n-- . 匹配任意字符\nlocal matches = {}\nfor match in string.gmatch(\"abc123\", \".\") do\t-- 迭代器函数用于遍历，每次调用 string.match 匹配字符串中下一个结果 table.insert(matches, match)\nend\nprint(\"'.'匹配任意字符: \" .. table.concat(matches, \", \")) -- %a 匹配字母\nmatches = {}\nfor match in string.gmatch(\"abc123!@#\", \"%a\") do table.insert(matches, match)\nend\nprint(\"'%a'匹配字母: \" .. table.concat(matches, \", \")) -- %d 匹配数字\nmatches = {}\nfor match in string.gmatch(\"abc123!@#\", \"%d\") do table.insert(matches, match)\nend\nprint(\"'%d'匹配数字: \" .. table.concat(matches, \", \")) --[[ 输出\n'.'匹配任意字符: a, b, c, 1, 2, 3\n'%a'匹配字母: a, b, c\n'%d'匹配数字: 1, 2, 3\n--]]\n-- 字符类：用 [] 定义自定义字符集\nlocal text = \"abc123!@ #DEF \" -- [abc] 匹配 a、b 或 c\nlocal matches = {}\nfor match in string.gmatch(text, \"[abc]\") do table.insert(matches, match)\nend\nprint(\"[abc]匹配: \" .. table.concat(matches, \", \")) -- [0-9] 匹配数字\nmatches = {}\nfor match in string.gmatch(text, \"[0-9]\") do table.insert(matches, match)\nend\nprint(\"[0-9]匹配: \" .. table.concat(matches, \", \")) -- [A-Z] 匹配大写字母\nmatches = {}\nfor match in string.gmatch(text, \"[A-Z]\") do table.insert(matches, match)\nend\nprint(\"[A-Z]匹配: \" .. table.concat(matches, \", \")) -- [^abc] 匹配除了 a、b、c 之外的字符\nmatches = {}\nfor match in string.gmatch(text, \"[^abc]\") do table.insert(matches, match)\nend\nprint(\"[^abc]匹配: \" .. table.concat(matches, \", \")) -- 组合字符类\nmatches = {}\nfor match in string.gmatch(text, \"[a-z0-9]\") do table.insert(matches, match)\nend\nprint(\"[a-z0-9]匹配: \" .. table.concat(matches, \", \")) -- 实际应用：验证用户名\nfunction validate_username(username) -- 用户名要求：字母开头，只能包含字母、数字、下划线，长度 3-20 local pattern = \"^[a-zA-Z][%w_]{2,19}$\" return string.match(username, pattern) ~= nil\nend print(\"\\n 用户名验证:\")\nlocal test_usernames = {\"abc\", \"123\", \"a_1\", \"a\", \"very_long_username_here\", \"user-name\"}\nfor _, name in ipairs(test_usernames) do print(string.format(\" %-25s -&gt; %s\", name, validate_username(name) and \"有效\" or \"无效\"))\nend -- 实际应用：提取颜色代码\nfunction extract_color_codes(text) local colors = {} -- 匹配 #RRGGBB 或 #RGB 格式 for code in string.gmatch(text, \"#[0-9a-fA-F]+\") do if #code == 4 or #code == 7 then -- #RGB 或 #RRGGBB table.insert(colors, code) end end return colors\nend local color_text = \"背景色: #FFFFFF , 文字色: #000 , 高亮: #FF0000 , 无效: #12345 \"\nprint(\"\\n 提取颜色代码:\")\nlocal colors = extract_color_codes(color_text)\nfor _, color in ipairs(colors) do print(\" 颜色: \" .. color)\nend\n-- 重复修饰符控制匹配次数\nlocal text = \"aaabbcccddddeeee\" -- * 匹配 0 次或多次（贪婪）\nlocal matches = {}\nfor match in string.gmatch(text, \"a*\") do if #match &gt; 0 then table.insert(matches, \"'\" .. match .. \"'\") end\nend\nprint(\"*匹配（贪婪）: \" .. table.concat(matches, \", \")) -- + 匹配 1 次或多次\nmatches = {}\nfor match in string.gmatch(text, \"a+\") do table.insert(matches, \"'\" .. match .. \"'\")\nend\nprint(\"+匹配: \" .. table.concat(matches, \", \")) -- ? 匹配 0 次或 1 次\nmatches = {}\nfor match in string.gmatch(text, \"a?\") do table.insert(matches, \"'\" .. match .. \"'\")\nend\nprint(\"?匹配: \" .. table.concat(matches, \", \")) -- - 匹配 0 次或多次（非贪婪）\nmatches = {}\nfor match in string.gmatch(\"aaaa\", \"a-\") do table.insert(matches, \"'\" .. match .. \"'\")\nend\nprint(\"-匹配（非贪婪）: \" .. table.concat(matches, \", \"))\n--[[ 输出\n*匹配（贪婪）: 'aaa'\n+匹配: 'aaa'\n?匹配: 'a', 'a', 'a', '', '', '', '', '', '', '', '', '', '', '', '', '', ''\n-匹配（非贪婪）: '', '', '', '', ''\n--]] -- 实际应用：匹配浮点数\nlocal function extract_numbers(text) local numbers = {} -- 匹配整数和浮点数 for num in string.gmatch(text, \"[+-]?%d+%.?%d*\") do -- 过滤掉单独的点和无效格式 if num ~= \".\" and num ~= \"+\" and num ~= \"-\" then table.insert(numbers, num) end end return numbers\nend local number_text = \"价格: 12.5, -3.14, +100, .5, 3., abc, 123\"\nprint(\"\\n 提取数字:\")\nlocal numbers = extract_numbers(number_text) for _, num in ipairs(numbers) do print(\" 数字: \" .. num)\nend\n--[[ 输出\n提取数字: 数字: 12.5 数字: -3.14 数字: +100 数字: 5 数字: 3. 数字: 123\n--]] -- 实际应用：匹配 HTML 标签\nfunction extract_html_tags(html) local tags = {} -- 简单匹配标签（不包括属性） for tag in string.gmatch(html, \"&lt;([^&gt;]+)&gt;\") do table.insert(tags, tag) end return tags\nend local html = \"&lt;div class='container'&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;br/&gt;&lt;img src='test.jpg'&gt;&lt;/div&gt;\"\nprint(\"\\n 提取 HTML 标签:\")\nlocal tags = extract_html_tags(html) for _, tag in ipairs(tags) do print(\" 标签: &lt;\" .. tag .. \"&gt;\")\nend\n--[[ 输出\n提取 HTML 标签: 标签: &lt;div class='container'&gt; 标签: &lt;p&gt; 标签: &lt;/p&gt; 标签: &lt;br/&gt; 标签: &lt;img src='test.jpg'&gt; 标签: &lt;/div&gt;\n--]]\n-- 使用()进行捕获\n-- 基本捕获\nlocal date = \"2024-12-27\"\nlocal year, month, day = string.match(date, \"(%d+)-(%d+)-(%d+)\")\nprint(\"日期解析:\")\nprint(\" 年: \" .. (year or \"无\"))\nprint(\" 月: \" .. (month or \"无\"))\nprint(\" 日: \" .. (day or \"无\"))\n--[[ 输出\n日期解析: 年: 2024 月: 12 日: 27\n--]] -- 捕获邮箱的用户名和域名\nlocal email = \" user@example.com \"\nlocal username, domain = string.match(email, \"([%w%.%-]+)@([%w%.%-]+%.[%w]+)\")\nprint(\"\\n 邮箱解析:\")\nprint(\" 用户名: \" .. (username or \"无\"))\nprint(\" 域名: \" .. (domain or \"无\"))\n--[[ 输出\n邮箱解析: 用户名: user 域名: example.com\n--]] -- 使用 gmatch 进行多次捕获\nlocal text = \"alice:18,jack:20,bob:22\"\nprint(\"\\n 解析键值对:\") for name, age in string.gmatch(text, \"([%u%l]+):(%d+)\") do print(\" 姓名: \" .. name .. \", 年龄: \" .. age)\nend\n--[[ 输出\n解析键值对: 姓名: alice, 年龄: 18 姓名: jack, 年龄: 20 姓名: bob, 年龄: 22\n--]] -- 捕获 URL 各部分\nfunction parse_url_detail(url) local pattern = \"^([%w]+)://([^/]+)(.*)$\" local protocol, host, path = string.match(url, pattern) return protocol, host, path\nend -- 实际应用：提取和格式化日期\nlocal function reformat_date(date_str) -- 支持多种日期格式 local patterns = { \"(%d%d%d%d)[-/](%d%d)[-/](%d%d)\", -- YYYY-MM-DD \"(%d%d)[-/](%d%d)[-/](%d%d%d%d)\" -- MM-DD-YYYY } for _, pattern in ipairs(patterns) do local y, m, d = string.match(date_str, pattern) if y and m and d then -- 如果年份是 2 位数，假设是 19xx 或 20xx if #y == 2 then local temp = y y = d d = temp end return string.format(\"%s 年 %s 月 %s 日\", y, m, d) end end return date_str -- 无法解析，返回原样\nend print(\"\\n 日期格式化:\")\nlocal dates = {\"2024-12-27\", \"12/27/2024\", \"24-01-15\", \"无效日期\"}\nfor _, date in ipairs(dates) do print(\" \" .. date .. \" -&gt; \" .. reformat_date(date))\nend\n--[[ 输出\n日期格式化: 2024-12-27 -&gt; 2024 年 12 月 27 日 12/27/2024 -&gt; 2024 年 27 月 12 日 24-01-15 -&gt; 24-01-15 无效日期 -&gt; 无效日期\n--]]\nstring.gsub(字符串: str, 匹配模式: str, 替换为: str, 替换次数?: int) -&gt; 替换后的字符串: str, 替换次数: int 不指定替换次数将会替换所有匹配的字符串\n-- 基本替换\nlocal text = \"Hello World\"\nlocal replaced = string.gsub(text, \"World\", \"Lua\")\nprint(\"基本替换: \" .. replaced)\n-- 输出 基本替换: Hello Lua -- 限制替换次数\nlocal text = \"Hello World World World\"\nlocal replaced = string.gsub(text, \"World\", \"Lua\", 2)\nprint(\"替换两次: \" .. replaced)\n-- 输出 替换两次: Hello Lua Lua World -- 使用模式匹配替换\nlocal text = \"Price: $10.99, Discount: 20%\"\nlocal replaced = string.gsub(text, \"%$%d+%.%d%d\", \"[价格隐藏]\")\nprint(\"隐藏价格: \" .. replaced)\n-- 输出 隐藏价格: Price: [价格隐藏], Discount: 20% -- 使用函数进行替换\nlocal text = \"The temperature is 25C and humidity is 60%\"\nlocal replaced = string.gsub(text, \"(%d+)(%a?)\", function(value, unit) if unit == \"C\" then -- 摄氏度转华氏度 local f = tonumber(value) * 9/5 + 32 return string.format(\"%.1fF\", f) end return value .. unit\nend) print(\"单位转换: \" .. replaced)\n-- 输出 单位转换: The temperature is 77.0F and humidity is 60% -- 使用%n 引用捕获\n-- %1, %2 等引用之前的捕获\nlocal text = \"Hello World\"\nlocal swapped = string.gsub(text, \"(%S+)%s+(%S+)\", \"%2 %1\")\nprint(\"\\n 交换单词:\")\nprint(\" 原始: \" .. text)\nprint(\" 交换后: \" .. swapped)\n--[[ 输出\n交换单词: 原始: Hello World 交换后: World Hello\n--]] -- 实际应用：模板渲染（更好的方法是字符串格式化）\nlocal function render_template(template, data) local result = string.gsub(template, \"{{([%w_]+)}}\", function(key) return data[key] or \"\" end) return result\nend local template = \"尊敬的 {{name}} ：您订购的 {{product}} 已发货，订单号： {{order_id}} \"\nlocal data = { name = \"张三\", product = \"Lua 编程书籍\", order_id = \"20241227001\"\n} print(\"\\n 模板渲染:\")\nprint(\" 模板: \" .. template)\nprint(\" 数据: \" .. \"name=\" .. data.name .. \", product=\" .. data.product .. \", order_id=\" .. data.order_id)\nprint(\" 结果: \" .. render_template(template, data))\n--[[ 输出\n模板渲染: 模板: 尊敬的 {{name}} ：您订购的 {{product}} 已发货，订单号： {{order_id}} 数据: name=张三, product=Lua 编程书籍, order_id=20241227001 结果: 尊敬的 张三 ：您订购的 Lua 编程书籍 已发货，订单号： 20241227001 --]]\n简单来说字符串格式化就是将占位符替换为实际值，同时替换时根据占位符来对实际值进行额外处理。string.format(被格式化的字符串: str, 替换值: str...) -&gt; 格式化后的字符串: str\n<br>所有格式化修饰符见 <a data-href=\"6. 字符串#格式化修饰符\" href=\"总结/6.-字符串.html#格式化修饰符\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">6. 字符串 &gt; 格式化修饰符</a>-- 基本格式化，%s 表示替换值是字符串，%d 表示替换值是数字\nlocal name = \"小明\"\nlocal age = 18\nlocal formatted = string.format(\"姓名: %s, 年龄: %d\", name, age)\nprint(\"基本格式化: \" .. formatted)\n-- 输出 姓名: 小明, 年龄: 18\nlocal price = 19.99\nprint(\"\\n 数字格式化:\")\n-- %f 表示浮点数（小数）默认小数精度 6 位\nprint(\" 默认: \" .. string.format(\"%f\", price))\n-- %.nf 表示小数精度\nprint(\" 两位小数: \" .. string.format(\"%.2f\", price))\n-- %d 表示整数，与替换值类型不符会自动转化，如果替换值为浮点会截断小数部分，数字字符串自动转化为数字\nprint(\" 整数: \" .. string.format(\"%d\", price))\n-- %e 对替换值进行处理，改为科学计数法表示\nprint(\" 科学计数法: \" .. string.format(\"%e\", price))\n-- %nd 组合使用：整数 %d + n 右对齐\nprint(\" 宽度 10，右对齐: \" .. string.format(\"%10d\", price))\n-- %-nd 组合使用：整数 %d + -n 左对齐\nprint(\" 宽度 10，左对齐: \" .. string.format(\"%-10d\", price))\n-- %0nd 前导零\nprint(\" 前导零: \" .. string.format(\"%04d\", price))\n--[[ 输出 默认: 19.990000 两位小数: 19.99 整数: 19 科学计数法: 1.999000e+001 宽度 10，右对齐: 19 宽度 10，左对齐: 19 前导零: 0019\n]]\nlocal text = \"Hello\"\nprint(\"\\n 字符串格式化:\")\n-- %s 表示字符串，同上与替换值类型不符会自动转化，数字自动转化为数字字符串\nprint(\" 默认: \" .. string.format(\"%s\", text))\n-- 同上\nprint(\" 宽度 10，右对齐: \" .. string.format(\"%10s\", text))\nprint(\" 宽度 10，左对齐: \" .. string.format(\"%-10s\", text))\n-- %.ns 字符串截断\nprint(\" 截断为 3 字符: \" .. string.format(\"%.3s\", text))\n--[[ 输出 默认: Hello 宽度 10，右对齐: Hello 宽度 10，左对齐: Hello 截断为 3 字符: Hel\n--]]\n-- 实际应用：创建表格\nfunction create_table(data) local rows = {} -- 表头 table.insert(rows, string.format(\"%-20s %-10s %-10s\", \"姓名\", \"年龄\", \"分数\")) table.insert(rows, string.rep(\"-\", 42)) -- 数据行 for _, student in ipairs(data) do local row = string.format(\"%-20s %-10d %-10.1f\", student.name, student.age, student.score) table.insert(rows, row) end return table.concat(rows, \"\\n\")\nend local students = { {name = \"张三\", age = 18, score = 85.5}, {name = \"李四\", age = 19, score = 92.0}, {name = \"王五\", age = 20, score = 78.5}\n} print(\"\\n 学生表格:\")\nprint(create_table(students))\n--[[ 输出 学生表格:\n姓名 年龄 分数 ------------------------------------------\n张三 18 85.5 李四 19 92.0 王五 20 78.5 --]]\ntostring(值: any) -&gt; 字符串:str\nlocal num = 123.456\nlocal str_num = tostring(123.456)\nprint(\"数字转字符串:\")\nprint(string.format(\" 数字: %.3f，类型： %s\", num, type(num)))\nprint(string.format(\" 字符串: \\\"%s\\\"，类型：%s\", str_num, type(str_num)))\n--[[ 输出\n数字: 123.456，类型： number\n字符串: \"123.456\"，类型：string\n--]] -- 连接或格式化时自动会将数字转化为字符串\nprint(\"连接自动转化字符串：\" .. num)\nprint(string.format(\"格式化自动转化字符串：%.3f\", num))\n--[[ 输出\n连接自动转化字符串：123.456\n格式化自动转化字符串：123.456000\n--]] -- 可以查看内存地址\nprint(\"表的内存地址：\" .. tostring({123, 10}))\nprint(\"函数的内存地址：\" .. tostring(function() return 123, 10\nend))\n--[[ 输出\n表的内存地址：table: 00D49D00\n函数的内存地址：function: 00D4C390\n--]]\ntonumber(要转化的字符串: str, 转化的基数?: 2-36) -&gt; 字符串: str\nlocal str = \"123.456\"\nlocal num = tonumber(str)\nprint(\"字符串转数字:\")\nprint(string.format(\" 字符串: \\\"%s\\\"，类型：%s\", str, type(str)))\nprint(string.format(\" 数字: %.3f，类型： %s\", num, type(num)))\n--[[ 输出 字符串: \"123.456\"，类型：string 数字: 123.456，类型： number\n--]] -- 转换基数\nprint(\"\\n 不同基数的转换:\")\nlocal hex_str = \"FF\"\nlocal dec_num = tonumber(hex_str, 16)\nprint(\" 十六进制 \" .. hex_str .. \" -&gt; 十进制 \" .. dec_num)\nlocal bin_str = \"1010\"\nlocal bin_num = tonumber(bin_str, 2)\nprint(\" 二进制 \" .. bin_str .. \" -&gt; 十进制 \" .. bin_num)\n--[[ 输出 十六进制 FF -&gt; 十进制 255 二进制 1010 -&gt; 十进制 10\n--]] -- 解析字符串中的数字\nlocal function extract_numbers_from_string(str) local numbers = {} for num_str in string.gmatch(str, \"[+-]?%d+%.?%d*\") do local num = tonumber(num_str) if num then table.insert(numbers, num) end end return numbers\nend local mixed_text = \"攻击 10 次，伤害 25 点\"\nprint(\"\\n 从字符串提取数字:\")\nlocal numbers = extract_numbers_from_string(mixed_text) for i, num in ipairs(numbers) do print(\" 数字\" .. i .. \": \" .. num)\nend\n--[[ 输出\n数字1: 10\n数字2: 25\n--]]\n-- 错误1：混淆模式匹配修饰符 %、格式化修饰符 % 以及转义符 /\nlocal wrong = string.format(\"文件名: %s, 模式: %d+\", s1, s2) -- 错误：这里 %d+ 与模式匹配混淆了，+ 不是有效格式符\n<br>（答案见<a data-href=\"第 1 节 - 语法/参考答案#练习 8 1：简单的文本分析器\" href=\"第-1-节-语法/参考答案.html#练习 8 1：简单的文本分析器\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 8 1：简单的文本分析器</a>）-- 写一个文本分析器，可以分析给定的字符串有几行文本，有多少个单词，总字符数，统计最频繁的单词\n-- 使用示例：\n-- 测试文本分析器\nlocal test_text = [[\nLua is a powerful, efficient, lightweight, embeddable scripting language.\nIt supports procedural programming, object-oriented programming, functional\nprogramming, data-driven programming, and data description. Lua combines simple procedural syntax with powerful data description\nconstructs based on associative arrays and extensible semantics.\nLua is dynamically typed, runs by interpreting bytecode with a\nregister-based virtual machine, and has automatic memory management with\nincremental garbage collection, making it ideal for configuration,\nscripting, and rapid prototyping.\n]] print(\"=== 文本分析器 ===\")\nanalysis:analyze_text(test_text) local data = analysis.data print(\"基本统计:\")\nprint(\" 总字符数: \" .. data.total_chars)\nprint(\" 行数: \" .. data.lines)\nprint(\" 单词数: \" .. data.word_count) print(\"\\n 最频繁的单词:\")\nfor i, item in ipairs(data.most_frequent) do print(string.format(\" %2d. %-15s: %d 次\", i, item.word, item.count))\nend\n--[[ 输出\n基本统计: 总字符数: 582 行数: 11 单词数: 70 最频繁的单词: 1. and : 4 次 2. programming : 4 次 3. lua : 3 次 4. with : 3 次 5. a : 2 次\n--]] 字符串基础： 三种字符串字面量：双引号、单引号、长括号\n字符串是不可变的，操作会创建新字符串\n使用 # 获取长度，注意多字节字符\n使用 \\ 转义字符 字符串操作： 连接：.. 运算符\n重复：string.rep\n性能优化：大量连接时使用 table.concat 字符串查找和提取： string.find：查找子串位置\nstring.sub：提取子串 字符串模式匹配： 字符类：%a（字母）、%d（数字）、%s（空白）等\n重复修饰符：*、+、?、-、{n,m}\n捕获和分组：()\nstring.match：单次模式匹配和捕获\nstring.gmatch：多次模式匹配和捕获\nstring.gsub：模式匹配替换 字符串格式化： string.format：格式化字符串\n格式修饰符：%s（字符串）、%d（整数）、%f（浮点数）等 字符串转换： tostring：转换为字符串\ntonumber：转换为数字，支持指定基数 -- 1. 对于大量字符串使用表连接\n-- 不好\nlocal result = \"\" for i = 1, 1000 do result = result .. \"x\" -- 创建 1000 个新字符串\nend -- 好\nlocal parts = {} for i = 1, 1000 do parts[i] = \"x\"\nend local result = table.concat(parts) -- 2. 对于少量字符串连接使用字符串格式化 -- 不好\nlocal current_path = \"D/Program Files/\"\nlocal filepath = current_path .. \"steam/\" .. \"common/\" .. \"game\" -- 好\nlocal current_path = \"D/Program Files\"\nlocal filepath = string.format(\"%s/%s/%s/%s\", current_path, \"steam\", \"common\", \"game\") -- 3. 重用模式对象（对于频繁使用的模式）\nlocal pattern = \"[%w%.%-]+@[%w%.%-]+%.[%w]+\"\n-- 然后多次使用这个 pattern -- 4. 使用 string.gmatch 代替多次 string.find\n-- 当需要找到所有匹配时\nfor match in string.gmatch(text, pattern) do -- 处理每个匹配\nend\n-- 错误 1：误用 string.len 和 #操作符\nlocal str = \"你好\"\nprint( #str ) -- 2（正确）\nprint(string.len(str)) -- 6（UTF-8 字节数） -- 错误 2：忘记字符串不可变\nlocal s = \"Hello\"\ns = string.gsub(s, \"H\", \"J\") -- 正确：创建新字符串并赋值\n-- string.gsub(s, \"H\", \"J\") -- 错误：不会修改原字符串 -- 错误 3：模式匹配中的贪婪匹配\nlocal text = \"&lt;div&gt;content&lt;/div&gt;\"\n-- 贪婪匹配\nlocal greedy = string.match(text, \"&lt;.-&gt;\") -- 整个字符串\n-- 非贪婪匹配\nlocal non_greedy = string.match(text, \"&lt;.- &gt;\") -- &lt;div&gt; -- 错误 4：转义特殊字符\nlocal pattern = \"10.5\" -- .在模式中匹配任意字符\nlocal text = \"10x5\"\nprint(string.match(text, pattern)) -- 会匹配！\n-- 应该转义\npattern = \"10\\.5\" -- 错误 5：忽略多行字符串的换行符\nlocal str = [[第一行\n第二行]]\nprint( #str ) -- 注意：包含换行符\n（点击勾选框勾选）\n完成本章后，你应该能够：\n理解字符串的不可变性及其影响\n使用各种方式创建字符串\n进行字符串的连接、重复和长度计算\n查找、提取和分割字符串\n使用 Lua 模式匹配进行复杂的字符串操作\n进行字符串的替换和格式化\n在字符串和数字之间进行转换\n编写性能良好的字符串处理代码 为什么 Lua 选择使用不可变字符串？这种设计有什么优缺点？\nLua 的模式匹配和正则表达式有什么区别？各有什么适用场景？\n在处理大量文本数据时，如何优化字符串操作的性能？\n如何正确处理包含多字节字符（如中文、emoji）的字符串？\n在什么情况下应该使用 string.gsub 的函数替换功能？ 编写一个 JSON 解析器（简化版），将 JSON 字符串转换为 Lua 表\n开发一个数据验证库，验证各种格式的数据（邮箱、URL、日期等）\n下一章预告：在第 9 章中，我们将学习模块和包。模块是组织和重用代码的重要方式，我们将学习如何创建模块、使用模块、管理依赖，以及了解 Lua 的标准库。学习建议：\n多练习模式匹配，这是 Lua 字符串处理的精华\n理解字符串不可变性的影响，编写性能良好的代码\n熟悉常用的字符串操作函数\n尝试用字符串处理解决实际问题，如文本分析、数据提取等\n注意处理多字节字符时的特殊考虑\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"8.1 字符串基础","level":2,"id":"8.1_字符串基础_0"},{"heading":"8.1.1 字符串的创建","level":3,"id":"8.1.1_字符串的创建_0"},{"heading":"转义符","level":4,"id":"转义符_0"},{"heading":"8.1.2 字符串是不可变的","level":3,"id":"8.1.2_字符串是不可变的_0"},{"heading":"8.2 字符串基本操作","level":2,"id":"8.2_字符串基本操作_0"},{"heading":"8.2.1 # - 字符串长度","level":3,"id":"8.2.1_#_-_字符串长度_0"},{"heading":"8.2.2 .. / table.concat - 字符串连接","level":3,"id":"8.2.2_.._/_table.concat_-_字符串连接_0"},{"heading":"8.2.3 string.rep - 字符串重复","level":3,"id":"8.2.3_string.rep_-_字符串重复_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"8.3 字符串查找和提取","level":2,"id":"8.3_字符串查找和提取_0"},{"heading":"8.3.1 string.find - 字符串查找","level":3,"id":"8.3.1_string.find_-_字符串查找_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"8.3.2 string.sub - 字符串截取","level":3,"id":"8.3.2_string.sub_-_字符串截取_0"},{"heading":"示例","level":4,"id":"示例_2"},{"heading":"8.3.3 字符串分割","level":3,"id":"8.3.3_字符串分割_0"},{"heading":"8.4 - 字符串模式匹配","level":2,"id":"8.4_-_字符串模式匹配_0"},{"heading":"8.4.1 string.match - 匹配单个模式","level":3,"id":"8.4.1_string.match_-_匹配单个模式_0"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"8.4.2 string.gmatch - 匹配多个模式","level":3,"id":"8.4.2_string.gmatch_-_匹配多个模式_0"},{"heading":"示例","level":4,"id":"示例_4"},{"heading":"8.4.3 [] - 字符类","level":3,"id":"8.4.3_[]_-_字符类_0"},{"heading":"8.4.4 重复修饰符","level":3,"id":"8.4.4_重复修饰符_0"},{"heading":"8.4.5 () - 捕获和分组","level":3,"id":"8.4.5_()_-_捕获和分组_0"},{"heading":"8.4.6 string.gsub - 字符串替换","level":3,"id":"8.4.6_string.gsub_-_字符串替换_0"},{"heading":"示例","level":4,"id":"示例_5"},{"heading":"8.5 string.format - 字符串格式化","level":2,"id":"8.5_string.format_-_字符串格式化_0"},{"heading":"示例","level":4,"id":"示例_6"},{"heading":"数字字符串格式化","level":4,"id":"数字字符串格式化_0"},{"heading":"字符串格式化","level":4,"id":"字符串格式化_0"},{"heading":"示例","level":4,"id":"示例_7"},{"heading":"8.6 字符串与数字转换","level":2,"id":"8.6_字符串与数字转换_0"},{"heading":"8.6.1 tostring - 字符串转化","level":3,"id":"8.6.1_tostring_-_字符串转化_0"},{"heading":"示例","level":4,"id":"示例_8"},{"heading":"8.6.2 tonumber - 字符串转数字","level":3,"id":"8.6.2_tonumber_-_字符串转数字_0"},{"heading":"示例","level":4,"id":"示例_9"},{"heading":"8.7 常见错误","level":2,"id":"8.7_常见错误_0"},{"heading":"8.8 练习","level":2,"id":"8.8_练习_0"},{"heading":"练习 1：简单的文本分析器","level":3,"id":"练习_1：简单的文本分析器_0"},{"heading":"8.9 本章总结","level":2,"id":"8.9_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"性能优化技巧","level":3,"id":"性能优化技巧_0"},{"heading":"常见错误","level":3,"id":"常见错误_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"},{"heading":"拓展练习","level":3,"id":"拓展练习_0"}],"links":["总结/6.-字符串.html#转义字符","总结/6.-字符串.html#模式匹配修饰符","总结/6.-字符串.html#格式化修饰符","第-1-节-语法/参考答案.html#练习 8 1：简单的文本分析器"],"author":"","coverImageURL":"","fullURL":"第-1-节-语法/8.-字符串.html","pathToRoot":"..","attachments":[],"createdTime":1765186221153,"modifiedTime":1766659248275,"sourceSize":36335,"sourcePath":"第 1 节 - 语法/8. 字符串.md","exportPath":"第-1-节-语法/8.-字符串.html","showInTree":true,"treeOrder":9,"backlinks":[],"type":"markdown"},"第-1-节-语法/9.-模块.html":{"title":"9. 模块","icon":"","description":"当一个 Lua 文件被另一个 Lua 文件加载，并且返回一个表或其他值时这个 Lua 文件被称为模块（Module）模块主要用于：\n分类，将相关函数与变量组织在一个模块，避免将所有代码写到同一个文件内\n便于模块化代码复用\n独立命名空间，避免命名冲突\n在编写大型程序时，将所有代码放在一个文件中会变得难以管理。模块系统可以帮助我们管理：-- 不使用模块的问题示例\n-- 假设我们在开发一个游戏，所有代码都在一个文件里： -- main.lua（糟糕的代码组织）\n-- 游戏配置\nlocal game_config = { width = 800, height = 600 } -- 玩家相关函数\nlocal player_name = \"英雄\"\nlocal player_health = 100 local function take_damage(amount) player_health = player_health - amount if player_health &lt; 0 then player_health = 0 end\nend local function heal(amount) player_health = player_health + amount\nend -- 怪物相关函数\nlocal monsters = {} local function create_monster(name, health) table.insert(monsters, {name = name, health = health})\nend local function attack_monster(index, damage) if monsters[index] then monsters[index].health = monsters[index].health - damage end\nend -- UI相关函数\nlocal function show_hud() print(\"生命值: \" .. player_health)\nend -- 游戏循环\nlocal function game_loop() -- 很多代码...\nend -- 问题：\n-- 1. 所有代码混在一起，难以维护\n-- 2. 命名冲突风险高\n-- 3. 无法重用代码\n-- 4. 多人协作困难\n-- 创建一个 Lua 文件：math_utils.lua\n-- 数学工具模块 local math_utils = {} -- 模块表，最后返回 -- 1. 定义模块函数\nfunction math_utils.add(a, b) return a + b\nend function math_utils.subtract(a, b) return a - b\nend function math_utils.multiply(a, b) return a * b\nend function math_utils.divide(a, b) if b == 0 then return nil, \"除数不能为0\" end return a / b\nend -- 2. 模块常量\nmath_utils.PI = 3.1415926535898\nmath_utils.E = 2.7182818284590 -- 3. 内部辅助函数（不对外暴露）\nlocal function check_number(value) return type(value) == \"number\"\nend -- 4. 复杂的模块函数\nfunction math_utils.average(...) local numbers = {...} local sum = 0 local count = 0 for i, num in ipairs(numbers) do if check_number(num) then sum = sum + num count = count + 1 end end if count == 0 then return nil, \"没有有效数字\" end return sum / count\nend -- 5. 返回模块，一个模块可以也理解为一个函数，注意：一定要最后返回，与函数相同返回后后面的代码不会执行\nreturn math_utils\n-- 创建一个 Lua 文件在里面中使用刚刚创建的模块 -- 使用 require 加载模块\nlocal math_utils = require(\"math_utils\") -- 使用模块函数\nprint(\"5 + 3 = \" .. math_utils.add(5, 3))\nprint(\"10 - 4 = \" .. math_utils.subtract(10, 4))\nprint(\"6 × 7 = \" .. math_utils.multiply(6, 7)) local result, err = math_utils.divide(10, 2) if err then print(\"错误: \" .. err)\nelse print(\"10 ÷ 2 = \" .. result)\nend -- 使用模块常量\nprint(\"π ≈ \" .. math_utils.PI)\nprint(\"自然常数 e ≈ \" .. math_utils.E) -- 使用复杂函数\nlocal avg, avg_err = math_utils.average(10, 20, 30, \"无效\", 40) if avg_err then print(\"平均值错误: \" .. avg_err)\nelse print(\"平均值: \" .. avg) -- (10+20+30+40)/4 = 25\nend\n--[[ 输出\n5 + 3 = 8\n10 - 4 = 6\n6 × 7 = 42\n10 ÷ 2 = 5\nπ ≈ 3.1415926535898\n自然常数 e ≈ 2.718281828459\n平均值: 25\n--]] -- 尝试访问内部函数（会失败）\n-- local result = math_utils.check_number(5) -- 错误：nil值\nrequire(模块名: str) -&gt; any\nrequire&nbsp;会执行以下步骤：\n在 package.loaded 中检查模块是否已加载\n如果已加载，直接返回缓存\n否则在&nbsp;package.path 指定的路径按从左到右的顺序查找指定名字的模块\n加载并执行该文件，并返回返回值\n以 package.loaded[模块名] = 返回值 缓存\n-- package.path 具有默认值，通常在 main 模块中增加额外路径\n-- 查看package.path\nprint(\"Lua模块路径: \" .. package.path)\n-- 输出 Lua模块路径: ;.\\?.lua;C:\\Program Files (x86)\\Lua\\5.1\\lua\\?.lua;C:\\Program Files (x86)\\Lua\\5.1\\lua\\?\\init.lua;C:\\Program Files (x86)\\Lua\\5.1\\?.lua;C:\\Program Files (x86)\\Lua\\5.1\\?\\init.lua;C:\\Program Files (x86)\\Lua\\5.1\\lua\\?.luac\n-- “?” 加载模块时会格式化为加载的模块名称，用 “;” 分隔每个路径，“.” 会格式化为加载模块的 Lua 文件的目录 -- require的缓存机制演示\nlocal module1 = require(\"math_utils\")\nlocal module2 = require(\"math_utils\") print(\"两个require返回的是同一个表吗？ \" .. tostring(module1 == module2)) -- true -- 手动清除缓存\npackage.loaded.math_utils = nil\nlocal module3 = require(\"math_utils\")\t-- 重新加载，此时会创建一个新表 print(\"清除缓存后重新加载，是同一个表吗？ \" .. tostring(module1 == module3)) -- false\n-- 模块可以有多种返回方式 -- 方式1：直接返回表（最常见）\n-- module1.lua\nlocal M = {}\nM.version = \"1.0\" return M -- 方式2：返回函数\n-- module2.lua\nreturn function(config) local module = {} module.config = config module.run = function() print(\"运行中...\") end return module\nend -- 使用：\n-- local create_module = require(\"module2\")\n-- local my_module = create_module({setting = \"value\"}) -- 方式3：在模块中设置全局变量（不推荐，但某些情况需要）\n-- module3.lua\nGLOBAL_MODULE = {}\nGLOBAL_MODULE.name = \"全局模块\"\nreturn GLOBAL_MODULE -- 方式4：修改传入的表\n-- module4.lua\nreturn function(t) t.add = function(a, b) return a + b end t.version = \"1.0\" return t -- 通常返回修改后的表\nend -- 使用：\n-- local mod = require(\"module4\")({})\nLua 中所有全局变量，与 Lua 的内置函数都存储在一个名叫 _G 的全局表（Global Table）中\n所有模块的默认环境&nbsp;（Environment）都是指向 _G 表。可以通过 setfenv 修改指针将环境指向另一个表。-- 使用setfenv控制模块环境（Lua 5.1特性） -- 创建一个干净的模块环境\nlocal module_env = {} -- 设置环境的基本函数\nmodule_env.print = print -- 创建待编译模块\nlocal my_module_code = [[\n-- 在这个环境中，只有环境设定的函数可用\nlocal M = {} function M.say_hello() print(\"Hello World!\")\t-- 这里如果没有给环境设定 print 将会报错\nend return M\n]] -- 加载并执行代码\n-- 使用 loadstring 将以上字符串编译为可调用的函数\nlocal chunk = loadstring(my_module_code)\n-- 使用 setfenv 设定环境，将这个模块内的环境从 _G 修改为 module_env\nsetfenv(chunk, module_env) -- 执行被编译后的模块\nlocal module = chunk() module.say_hello()\n-- 模块可以依赖其他模块 -- 创建一个日志模块\n-- logger.lua\nlocal logger = {} function logger.info(msg) print(\"[INFO] \" .. msg)\nend function logger.warn(msg) print(\"[WARN] \" .. msg)\nend function logger.error(msg) print(\"[ERROR] \" .. msg)\nend return logger -- 创建一个数据库模块，依赖日志模块\n-- database.lua\nlocal logger = require(\"logger\") local database = {} function database.connect(connection_string) logger.info(\"连接到数据库: \" .. connection_string) -- 模拟连接逻辑 return {connected = true}\nend function database.query(conn, sql) logger.info(\"执行查询: \" .. sql) -- 模拟查询 return {{id = 1, name = \"测试数据\"}}\nend function database.disconnect(conn) logger.info(\"断开数据库连接\") conn.connected = false\nend return database -- 主程序使用有依赖的模块\nlocal db = require(\"database\") local conn = db.connect(\"server=localhost;database=test\")\nlocal results = db.query(conn, \"SELECT * FROM users\")\ndb.disconnect(conn) -- 环形依赖问题\n-- module_a.lua 需要 module_b\n-- module_b.lua 需要 module_a\n-- 这会导致问题！应该避免环形依赖\nLua 自带了一些非常有用的标准库模块。-- 基本数学函数\nprint(\"绝对值: math.abs(-10) = \" .. math.abs(-10))\nprint(\"平方根: math.sqrt(16) = \" .. math.sqrt(16))\nprint(\"幂运算: math.pow(2, 3) = \" .. math.pow(2, 3)) -- 也可以用 2^3\nprint(\"指数: math.exp(1) = \" .. math.exp(1)) -- e^1\nprint(\"自然对数: math.log(math.exp(1)) = \" .. math.log(math.exp(1))) -- 三角函数（参数为弧度）\nlocal angle = math.pi / 4 -- 45度\nprint(\"\\n三角函数（45度）:\")\nprint(\" sin: \" .. math.sin(angle))\nprint(\" cos: \" .. math.cos(angle))\nprint(\" tan: \" .. math.tan(angle)) -- 反三角函数\nprint(\"\\n反三角函数:\")\nprint(\" asin(0.5): \" .. math.asin(0.5))\nprint(\" acos(0.5): \" .. math.acos(0.5))\nprint(\" atan(1): \" .. math.atan(1)) -- 取整函数\nlocal num = 3.7\nprint(\"\\n取整函数:\")\nprint(\" 原始值: \" .. num)\nprint(\" math.floor: \" .. math.floor(num)) -- 向下取整\nprint(\" math.ceil: \" .. math.ceil(num)) -- 向上取整\nprint(\" math.modf: \" .. select(1, math.modf(num))) -- 返回整数和小数部分 -- 随机数\nprint(\"\\n随机数:\")\nmath.randomseed(os.time()) -- 设置随机种子\nprint(\" 随机整数(1-100): \" .. math.random(1, 100))\nprint(\" 随机小数[0-1): \" .. math.random()) -- 最大值和最小值\nprint(\"\\n极值:\")\nprint(\" 最大值: \" .. math.max(10, 20, 5, 30, 15))\nprint(\" 最小值: \" .. math.min(10, 20, 5, 30, 15)) -- 常量\nprint(\"\\n数学常量:\")\nprint(\" π: \" .. math.pi)\nprint(\" 无穷大: \" .. math.huge) -- 弧度与角度转换\nprint(\"\\n角度弧度转换:\")\nlocal degrees = 180\nlocal radians = math.rad(degrees)\nprint(\" \" .. degrees .. \"度 = \" .. radians .. \"弧度\")\nprint(\" \" .. radians .. \"弧度 = \" .. math.deg(radians) .. \"度\")\n我们之前学过的字符串操作函数其实都是使用的这个库，这里仅补充。-- string.byte 和 string.char\nlocal str = \"ABC\"\nprint(\"string.byte:\")\nfor i = 1, #str do print(\" 位置 \" .. i .. \": \" .. string.byte(str, i))\nend print(\"\\nstring.char:\")\nprint(\" 65,66,67 -&gt; \" .. string.char(65, 66, 67)) -- string.reverse 反转字符串\nprint(\"\\nstring.reverse:\")\nprint(\" 'hello' -&gt; '\" .. string.reverse(\"hello\") .. \"'\") -- string.lower 和 string.upper\nprint(\"\\n大小写转换:\")\nprint(\" 'Hello World' -&gt; 小写: '\" .. string.lower(\"Hello World\") .. \"'\")\nprint(\" 'Hello World' -&gt; 大写: '\" .. string.upper(\"Hello World\") .. \"'\") -- string.dump 函数序列化\nprint(\"\\nstring.dump（函数序列化）:\")\nlocal func = function(x) return x * 2 end\nlocal dumped = string.dump(func)\nprint(\" 函数序列化后长度: \" .. #dumped) -- 重新加载函数\nlocal loaded_func = loadstring(dumped)\nprint(\" 重新加载后执行: loaded_func(5) = \" .. loaded_func(5))\n-- 我们已经学过table.insert, table.remove, table.concat, table.sort\n-- 这里补充其他函数 -- table.maxn (Lua 5.1特有，返回最大数字索引)\nlocal t = {1, 2, 3}\nt[10] = 10\nprint(\"table.maxn: \" .. table.maxn(t)) -- 10 -- 自带的库功能较少一些函数需要自行实现\n-- table.copy 浅复制\nfunction table.shallow_copy(original) local copy = {} for k, v in pairs(original) do copy[k] = v end return copy\nend -- table.deep_copy 深复制\nfunction table.deep_copy(original, seen) seen = seen or {} if type(original) ~= \"table\" then return original end if seen[original] then return seen[original] end local copy = {} seen[original] = copy for k, v in pairs(original) do copy[table.deep_copy(k, seen)] = table.deep_copy(v, seen) end return copy\nend -- table.merge 合并表\nfunction table.merge(t1, t2) local result = {} for k, v in pairs(t1) do result[k] = v end for k, v in pairs(t2) do result[k] = v end return result\nend -- table.keys 获取所有键\nfunction table.keys(t) local keys = {} for k in pairs(t) do table.insert(keys, k) end return keys\nend -- table.values 获取所有值\nfunction table.values(t) local values = {} for _, v in pairs(t) do table.insert(values, v) end return values\nend\n-- os.time 获取当前时间\nlocal current_time = os.time()\nprint(\"当前时间戳: \" .. current_time) -- os.date 格式化时间\nprint(\"\\nos.date格式化:\")\nprint(\" 默认格式: \" .. os.date())\nprint(\" 自定义格式: \" .. os.date(\"%Y-%m-%d %H:%M:%S\"))\nprint(\" 只获取年份: \" .. os.date(\"%Y\"))\nprint(\" 星期几: \" .. os.date(\"%A\"))\nprint(\" 月份: \" .. os.date(\"%B\")) -- 时间戳转换\nprint(\"\\n时间戳转换:\")\nlocal timestamp = os.time({year=2024, month=12, day=27, hour=14, min=30, sec=0})\nprint(\" 2024-12-27 14:30:00 的时间戳: \" .. timestamp)\nprint(\" 转换回来: \" .. os.date(\"%Y-%m-%d %H:%M:%S\", timestamp)) -- os.difftime 时间差\nlocal start_time = os.time()\n-- 模拟耗时操作\nfor i = 1, 1000000 do end\nlocal end_time = os.time()\nprint(\"\\n时间差: \" .. os.difftime(end_time, start_time) .. \"秒\") -- os.execute 执行系统命令\nprint(\"\\nos.execute执行命令:\")\n-- 注意：在某些环境中，这个可能被禁用\nlocal result = os.execute(\"echo Hello from OS\")\nprint(\" 返回值: \" .. tostring(result)) -- os.getenv 获取环境变量\nprint(\"\\nos.getenv环境变量:\")\nlocal path = os.getenv(\"PATH\")\nprint(\" PATH长度: \" .. (path and #path or \"无\"))\nprint(\" HOME: \" .. (os.getenv(\"HOME\") or \"无\")) -- os.remove 删除文件\nprint(\"\\nos.remove删除文件:\")\n-- 先创建测试文件\nlocal test_file = \"test_temp.txt\"\nlocal file = io.open(test_file, \"w\")\nif file then file:write(\"测试内容\") file:close() print(\" 创建测试文件: \" .. test_file) local success, err = os.remove(test_file) if success then print(\" 删除成功\") else print(\" 删除失败: \" .. tostring(err)) end\nend -- os.rename 重命名文件\nprint(\"\\nos.rename重命名文件:\")\n-- 类似操作，这里省略 -- os.tmpname 生成临时文件名\nlocal temp_name = os.tmpname()\nprint(\"临时文件名: \" .. temp_name)\n-- 文件操作\nprint(\"文件操作示例:\") -- 写入文件\nlocal filename = \"test_output.txt\"\nlocal file = io.open(filename, \"w\") if file then file:write(\"第一行\\n\") file:write(string.format(\"第二行: 数字 %d\\n\", 42)) file:write(\"第三行\\n\") file:close() print(\" 写入文件: \" .. filename)\nelse print(\" 无法打开文件: \" .. filename)\nend -- 读取文件\nprint(\"\\n读取文件:\")\nfile = io.open(filename, \"r\") if file then print(\" 整个文件内容:\") local content = file:read(\"*all\") print(content) file:close()\nelse print(\" 无法打开文件\")\nend -- 逐行读取\nprint(\"\\n逐行读取:\")\nfile = io.open(filename, \"r\") if file then local line_number = 1 for line in file:lines() do print(\" 行\" .. line_number .. \": \" .. line) line_number = line_number + 1 end file:close()\nend -- 标准输入输出\nprint(\"\\n标准输入输出:\")\n-- io.write 不会自动添加换行\nio.write(\"请输入你的名字: \")\n-- 在实际环境中，这里可以读取用户输入\n-- local name = io.read()\nlocal name = \"测试用户\" -- 模拟输入\nprint(\"你好, \" .. name .. \"!\") -- 文件位置操作\nprint(\"\\n文件位置操作:\")\nfile = io.open(filename, \"r\")\nif file then -- 读取前10个字符 local first_10 = file:read(10) print(\" 前10字符: \" .. first_10) -- 获取当前位置 local pos = file:seek() print(\" 当前位置: \" .. pos) -- 跳转到文件开始 file:seek(\"set\", 0) -- 再次读取 local again = file:read(10) print(\" 跳转后读取: \" .. again) file:close()\nend -- 清理测试文件\nos.remove(filename)\nprint(\"\\n清理测试文件\")\n-- debug库主要用于调试和元编程\n-- 注意：在生产代码中应谨慎使用 -- debug.getinfo 获取函数信息\nlocal function test_function(x, y) local sum = x + y return sum\nend local info = debug.getinfo(test_function)\nprint(\"函数信息:\")\nprint(\" 名称: \" .. (info.name or \"匿名\"))\nprint(\" 定义位置: \" .. info.source)\nprint(\" 当前行: \" .. info.currentline)\nprint(\" 参数数量: \" .. info.nparams)\nprint(\" 是否可变参数: \" .. tostring(info.isvararg)) -- debug.getlocal 获取局部变量\nlocal function test_locals() local a = 10 local b = \"hello\" local c = {1, 2, 3} -- 获取局部变量信息 print(\"\\n局部变量:\") for i = 1, math.huge do local name, value = debug.getlocal(2, i) -- 2表示上一层调用栈 if not name then break end print(\" \" .. name .. \" = \" .. tostring(value)) end\nend test_locals() -- debug.traceback 获取调用栈\nlocal function function_a() function_b()\nend local function function_b() function_c()\nend local function function_c() print(\"\\n调用栈追踪:\") print(debug.traceback(\"错误发生位置\", 2))\nend function_a() -- debug.sethook 设置钩子（用于调试）\nprint(\"\\n调试钩子示例:\")\nlocal hook_calls = 0 -- 设置一个简单的钩子，统计函数调用次数\ndebug.sethook(function(event, line) if event == \"call\" then hook_calls = hook_calls + 1 end\nend, \"c\") -- 'c' 表示在函数调用时触发 -- 执行一些函数调用\nlocal function recursive_func(n) if n &gt; 0 then recursive_func(n - 1) end\nend recursive_func(5)\nprint(\" 函数调用次数: \" .. hook_calls) -- 清除钩子\ndebug.sethook()\nprint(\" 钩子已清除\") -- debug.upvalue 访问闭包的上值\nprint(\"\\n闭包上值访问:\")\nlocal function create_counter() local count = 0 return function() count = count + 1 return count end\nend local counter = create_counter()\ncounter() -- count = 1\ncounter() -- count = 2 -- 获取上值\nlocal name, value = debug.getupvalue(counter, 1)\nprint(\" 上值 '\" .. name .. \"' = \" .. value) -- 修改上值\ndebug.setupvalue(counter, 1, 100)\nprint(\" 修改后: \" .. counter()) -- 101\nLuaRocks 是 Lua 的包管理器，类似于Python的pip\nLuaRocks 官网：\n<a data-tooltip-position=\"top\" aria-label=\"https://luarocks.org/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://luarocks.org/\" target=\"_self\">LuaRocks - The Lua package manager</a>\nluarocks install 库名\n<br><img alt=\"Pasted image 20251210202636.png\" src=\"site-lib/media/pasted-image-20251210202636.png\" target=\"_self\" style=\"width: 675px; max-width: 100%;\">\n以上命令会将 Lua 库安装到 C:/Users/用户名/AppData/Local/VirtualStore/Program Files (x86)/Lua/5.1/lua\n由于服务器位于国外，下载较慢耐心等待即可-- 以 dkjson 库为例\n-- 需要确保安装此库： luarocks install dkjson\nlocal dkjson = require(\"dkjson\") -- 将 lua 表编译为 json\nprint(dkjson.encode({foo = \"bar\", baz = 123}))\n-- 输出 {\"baz\":123,\"foo\":\"bar\"}\n单例模式：确保一个类只有一个实例-- 配置管理器（单例）\nlocal config_manager = {}\nconfig_manager.__index = config_manager function config_manager.get_instance() if not config_manager.instance then local instance = setmetatable({}, config_manager) instance.settings = {} config_manager.instance = instance end return config_manager.instance\nend function config_manager:set(key, value) self.settings[key] = value\nend function config_manager:get(key) return self.settings[key]\nend -- 测试单例\nlocal config1 = config_manager.get_instance()\nconfig1:set(\"volume\", 80) local config2 = config_manager.get_instance()\nprint(\"config1 音量: \" .. config1:get(\"volume\"))\nprint(\"config2 音量: \" .. config2:get(\"volume\"))\nprint(\"是同一个实例吗？ \" .. tostring(config1 == config2))\n--[[ 输出\nconfig1 音量: 80\nconfig2 音量: 80\n是同一个实例吗？ true\n--]] -- 尝试直接创建新实例（会失败）\n-- local config3 = config_manager:new() -- 错误：没有new方法\n工厂模式：通过工厂函数创建对象-- 形状工厂\nlocal shape_factory = {} function shape_factory.create_circle(radius) local circle = { type = \"circle\", radius = radius, area = function(self) return math.pi * self.radius * self.radius end, draw = function(self) print(\"绘制圆形，半径: \" .. self.radius) end } return circle\nend function shape_factory.create_rectangle(width, height) local rectangle = { type = \"rectangle\", width = width, height = height, area = function(self) return self.width * self.height end, draw = function(self) print(\"绘制矩形，宽: \" .. self.width .. \", 高: \" .. self.height) end } return rectangle\nend function shape_factory.create_square(side) -- 复用createRectangle return shape_factory.create_rectangle(side, side)\nend -- 使用工厂\nlocal shapes = { shape_factory.create_circle(5), shape_factory.create_rectangle(4, 6), shape_factory.create_square(3)\n} for i, shape in ipairs(shapes) do print(\"形状\" .. i .. \" (\" .. shape.type .. \"):\") print(\" 面积: \" .. shape:area()) shape:draw()\nend\n--[[ 输出\n形状1 (circle): 面积: 78.539816339745\n绘制圆形，半径: 5\n形状2 (rectangle): 面积: 24\n绘制矩形，宽: 4, 高: 6\n形状3 (rectangle): 面积: 9\n绘制矩形，宽: 3, 高: 3\n--]]\n观察者模式：对象间的一对多依赖关系-- 事件管理器\nlocal event_manager = {}\nevent_manager.__index = event_manager function event_manager.new() local instance = setmetatable({}, event_manager) instance.listeners = {} return instance\nend function event_manager:subscribe(event, callback) if not self.listeners[event] then self.listeners[event] = {} end table.insert(self.listeners[event], callback)\nend function event_manager:unsubscribe(event, callback) if self.listeners[event] then for i, cb in ipairs(self.listeners[event]) do if cb == callback then table.remove(self.listeners[event], i) break end end end\nend function event_manager:publish(event, ...) if self.listeners[event] then for _, callback in ipairs(self.listeners[event]) do callback(...) end end\nend -- 使用观察者模式\nlocal events = event_manager.new() -- 定义观察者\nlocal function player_joined(player_name) print(\"系统: 玩家 \" .. player_name .. \" 加入了游戏\")\nend local function player_left(player_name) print(\"系统: 玩家 \" .. player_name .. \" 离开了游戏\")\nend local function achievement_unlocked(player_name, achievement) print(\"成就: \" .. player_name .. \" 解锁了 '\" .. achievement .. \"'\")\nend -- 订阅事件\nevents:subscribe(\"player_join\", player_joined)\nevents:subscribe(\"player_leave\", player_left)\nevents:subscribe(\"achievement\", achievement_unlocked) -- 发布事件\nevents:publish(\"player_join\", \"小明\")\nevents:publish(\"player_join\", \"小红\")\nevents:publish(\"achievement\", \"小明\", \"首次登录\")\nevents:publish(\"player_leave\", \"小红\") -- 取消订阅\nevents:unsubscribe(\"player_leave\", player_left)\nevents:publish(\"player_leave\", \"小明\") -- 这个不会触发回调\n--[[ 输出\n系统: 玩家 小明 加入了游戏\n系统: 玩家 小红 加入了游戏\n成就: 小明 解锁了 '首次登录'\n系统: 玩家 小红 离开了游戏\n--]]\n模块配置模式：灵活的模块配置-- 灵活的日志模块\nlocal logger = {} function logger.new(config) config = config or {} local instance = { level = config.level or \"INFO\", output = config.output or function(msg) print(msg) end, format = config.format or \"[%LEVEL%] %MESSAGE%\" } function instance:log(level, message) -- 检查日志级别 local levels = {DEBUG = 1, INFO = 2, WARN = 3, ERROR = 4} if levels[level] &lt; levels[self.level] then return end -- 格式化消息 local formatted = self.format formatted = string.gsub(formatted, \"%%LEVEL%%\", level) formatted = string.gsub(formatted, \"%%MESSAGE%%\", message) -- 输出 self.output(formatted) end function instance:debug(msg) self:log(\"DEBUG\", msg) end function instance:info(msg) self:log(\"INFO\", msg) end function instance:warn(msg) self:log(\"WARN\", msg) end function instance:error(msg) self:log(\"ERROR\", msg) end return instance\nend -- 使用不同配置\nprint(\"控制台日志:\")\nlocal console_logger = logger.new()\nconsole_logger:info(\"系统启动\")\nconsole_logger:debug(\"详细调试信息\") -- 默认级别为INFO，DEBUG不会输出 print(\"\\n文件日志:\")\nlocal file_logger = logger.new{ level = \"DEBUG\", output = function(msg) -- 模拟写入文件 print(\"[文件] \" .. msg) end, format = \"%LEVEL% - %MESSAGE%\"\n}\nfile_logger:debug(\"详细调试信息\") -- 这次会输出\nfile_logger:error(\"发生错误\") print(\"\\n自定义格式:\")\nlocal fancy_logger = logger.new{ format = \"✨ %LEVEL% ✨ =&gt; %MESSAGE%\"\n}\nfancy_logger:info(\"系统运行正常\")\n--[[ 输出\n控制台日志:\n[INFO] 系统启动 文件日志:\n[文件] DEBUG - 详细调试信息\n[文件] ERROR - 发生错误 自定义格式:\n✨ INFO ✨ =&gt; 系统运行正常\n--]]\n<br>（答案见<a data-href=\"第 1 节 - 语法/参考答案#练习 9 1：创建一个日志模块\" href=\"第-1-节-语法/参考答案.html#练习 9 1：创建一个日志模块\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 9 1：创建一个日志模块</a>）-- 创建一个调试用的日志模块，增加多个打印模式，错误、信息等，同时可以自动格式化 -- 示例：\nlocal log = require(\"log\"):new(\"module_name\") log.error(\"无法加载模块 %s\", \"log\")\n-- 输出 [ERROR] module_name: 无法加载模块 log log.info(\"加载模块中...\")\n-- 输出 [INFO] module_name: 加载模块中... 模块基础： 使用 local M = {} 创建模块表\n通过 return M 导出模块\n使用 require 加载模块 模块机制： package.path 定义模块搜索路径\npackage.loaded 缓存已加载模块 标准库模块： math：数学运算\nstring：字符串处理\ntable：表操作\nos：操作系统接口\nio：输入输出\ndebug：调试工具 LuaRocks 包管理器： 在终端使用 luarocks install 安装包\n安装到 C:/Users/用户名/AppData/Local/VirtualStore/Program Files (x86)/Lua/5.1/lua 模块设计模式： 单例模式\n工厂模式\n观察者模式\n模块配置模式 -- 1. 清晰的模块结构\n-- module/\n-- ├── init.lua -- 模块入口\n-- ├── core.lua -- 核心功能\n-- ├── utils.lua -- 工具函数\n-- └── constants.lua -- 常量定义 -- 2. 良好的命名规范\nlocal MyModule = {} -- 模块表\nlocal private_var -- 局部变量（私有）\nMyModule.PUBLIC_CONSTANT = 100 -- 公共常量 -- 3. 错误处理\nfunction MyModule.safe_operation() local success, result = pcall(function() -- 可能失败的操作 return risky_operation() end) if not success then return nil, result -- 返回错误信息 end return result\nend -- 4. 文档化\n--- 计算两个数的和\n-- @param a 第一个数\n-- @param b 第二个数\n-- @return 两数之和\nfunction MyModule.add(a, b) return a + b\nend -- 5. 版本控制\nMyModule.VERSION = \"1.0.0\"\nMyModule.AUTHOR = \"Your Name\"\n-- 错误 1：忘记 return 模块\nlocal M = {}\n-- 做一些设置...\n-- 忘记写: return M -- 错误 2：污染全局命名空间\n-- 在模块中直接创建全局变量\nGLOBAL_VAR = 100 -- 不好！ -- 错误 3：循环依赖\n-- module_a.lua 需要 module_b\n-- module_b.lua 需要 module_a\n-- 解决方案：重构代码，提取公共部分 -- 错误 4：过度使用 require\n-- 在循环中反复 require 同一个模块\nfor i = 1, 100 do local mod = require(\"some_module\") -- 每次都会检查缓存，但仍然有开销\nend -- 错误 5：模块路径问题\n-- 不设置正确的 package.path\n-- 解决方案：在程序开始时设置\npackage.path = package.path .. \";./lib/?.lua\"\n-- 1. 延迟加载（Lazy Loading）\nlocal LazyModule = {}\nlocal _loaded_module = nil function LazyModule.do_something() if not _loaded_module then _loaded_module = require(\"heavy_module\") end return _loaded_module:do_work()\nend -- 2. 模块缓存\nlocal cached_modules = {} function get_module(name) if not cached_modules[name] then cached_modules[name] = require(name) end return cached_modules[name]\nend -- 3. 避免在模块初始化时做太多工作\n-- 不好：模块加载时连接数据库\nlocal db = connect_to_database() -- 模块加载变慢 -- 好：需要时再连接\nlocal function get_db() if not _db then _db = connect_to_database() end return _db\nend\n（点击勾选框勾选）\n完成本章后，你应该能够：\n创建和使用 Lua 模块\n理解模块加载机制\n使用 Lua 标准库模块\n使用 LuaRocks 管理第三方包\n设计良好的模块结构\n实现常见的模块设计模式\n处理模块依赖和循环引用\n创建可配置的模块系统 Lua 模块系统和面向对象语言（如 Java、Python）的包系统有什么异同？\n什么时候应该将代码拆分为多个模块？模块划分的原则是什么？\n如何处理模块间的循环依赖问题？\nLua 的require机制如何避免重复加载同一模块？\n在设计一个库时，如何平衡灵活性和易用性？ 实现一个国际化的模块，支持多语言文本\n创建一个数据验证模块，支持各种数据格式验证\n实现一个事件总线系统，支持跨模块通信\n下一章预告：在第 10 章中，我们将学习调试与错误处理。编写健壮的程序需要妥善调试并处理错误和异常，我们将学习 Lua 的调试技巧与错误处理机制，包括断点、 pcall、xpcall、error、assert 等，以及如何创建自定义错误类型和错误处理策略。学习建议：\n多实践模块的创建和使用，理解模块化编程的好处\n熟悉标准库模块，它们能解决很多常见问题\n学习使用 LuaRocks 管理依赖\n尝试重构现有代码，将其模块化\n注意模块设计的边界和接口设计\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"9.1 什么是模块？","level":2,"id":"9.1_什么是模块？_0"},{"heading":"9.2 创建你的第一个模块","level":2,"id":"9.2_创建你的第一个模块_0"},{"heading":"9.2.1 简单的模块示例","level":3,"id":"9.2.1_简单的模块示例_0"},{"heading":"9.2.2 使用模块","level":3,"id":"9.2.2_使用模块_0"},{"heading":"9.2.3 模块加载机制","level":3,"id":"9.2.3_模块加载机制_0"},{"heading":"9.3 模块的高级特性","level":2,"id":"9.3_模块的高级特性_0"},{"heading":"9.3.1 模块的多种返回方式","level":3,"id":"9.3.1_模块的多种返回方式_0"},{"heading":"9.3.2 模块环境","level":3,"id":"9.3.2_模块环境_0"},{"heading":"全局表（_G）","level":4,"id":"全局表（\\_G）_0"},{"heading":"设定环境","level":4,"id":"设定环境_0"},{"heading":"9.3.3 模块依赖","level":3,"id":"9.3.3_模块依赖_0"},{"heading":"9.4 Lua 标准库模块","level":2,"id":"9.4_Lua_标准库模块_0"},{"heading":"9.4.1 math 数学库","level":3,"id":"9.4.1_math_数学库_0"},{"heading":"9.4.2 string 字符串库","level":3,"id":"9.4.2_string_字符串库_0"},{"heading":"9.4.3 table 表库","level":3,"id":"9.4.3_table_表库_0"},{"heading":"9.4.4 os 操作系统库","level":3,"id":"9.4.4_os_操作系统库_0"},{"heading":"9.4.5 io 输入输出库","level":3,"id":"9.4.5_io_输入输出库_0"},{"heading":"9.4.6 debug 调试库","level":3,"id":"9.4.6_debug_调试库_0"},{"heading":"9.5 使用 LuaRocks 安装库","level":2,"id":"9.5_使用_LuaRocks_安装库_0"},{"heading":"9.5.1 在终端安装库","level":4,"id":"9.5.1_在终端安装库_0"},{"heading":"9.5.2 使用","level":4,"id":"9.5.2_使用_0"},{"heading":"9.6 模块设计模式","level":2,"id":"9.6_模块设计模式_0"},{"heading":"9.6.1 单例模式","level":3,"id":"9.6.1_单例模式_0"},{"heading":"9.6.2 工厂模式","level":3,"id":"9.6.2_工厂模式_0"},{"heading":"9.6.3 观察者模式","level":3,"id":"9.6.3_观察者模式_0"},{"heading":"9.6.4 模块配置模式","level":3,"id":"9.6.4_模块配置模式_0"},{"heading":"9.7 练习","level":2,"id":"9.7_练习_0"},{"heading":"练习 1：创建一个简单日志模块","level":3,"id":"练习_1：创建一个简单日志模块_0"},{"heading":"9.8 本章总结","level":2,"id":"9.8_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"模块设计最佳实践","level":3,"id":"模块设计最佳实践_0"},{"heading":"常见错误","level":3,"id":"常见错误_0"},{"heading":"性能优化建议","level":3,"id":"性能优化建议_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"},{"heading":"拓展练习","level":3,"id":"拓展练习_0"}],"links":["第-1-节-语法/参考答案.html#练习 9 1：创建一个日志模块"],"author":"","coverImageURL":".","fullURL":"第-1-节-语法/9.-模块.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251210202636.png"],"createdTime":1765270771743,"modifiedTime":1766650016822,"sourceSize":31761,"sourcePath":"第 1 节 - 语法/9. 模块.md","exportPath":"第-1-节-语法/9.-模块.html","showInTree":true,"treeOrder":10,"backlinks":[],"type":"markdown"},"第-1-节-语法/10.-调试与错误处理.html":{"title":"10. 调试与错误处理","icon":"","description":"在程序开发过程中，调试是必不可少的一环。之前都是使用 print 语句进行调试，但随着程序复杂度增加，print 调试的局限性逐渐显现。print 调试的缺点：\n效率低下：每次调试都需要手动添加 print 语句，调试完成后还需逐一清理\n信息有限：只能显示特定变量的值，无法查看完整的调用链和执行上下文\n表结构查看困难：需要手动拼接输出，复杂嵌套表需要递归处理\n缺乏控制：无法暂停程序、单步执行，只能看到固定的输出结果\n断点调试的优点：\n高效便捷：设置一次断点，多次运行生效\n信息全面：查看作用域内所有变量、调用堆栈、内存地址\n可视化表结构：自动展开显示复杂嵌套表\n完全控制：单步执行、条件断点、批量管理等高级功能\n在代码行左侧增加断点\n<img alt=\"Pasted image 20251225185539.png\" src=\"site-lib/media/pasted-image-20251225185539.png\" target=\"_self\" style=\"width: 227px; max-width: 100%;\">使用 DEBUG 模式运行<br>\n<img alt=\"Pasted image 20251225185723.png\" src=\"site-lib/media/pasted-image-20251225185723.png\" target=\"_self\" style=\"width: 375px; max-width: 100%;\">可以看到程序在第一行中断了（DEBUG 模式默认在第一行打了断点）<br>\n<img alt=\"Pasted image 20251225185853.png\" src=\"site-lib/media/pasted-image-20251225185853.png\" target=\"_self\" style=\"width: 294px; max-width: 100%;\">\n可以在控制栏继续运行<br>\n<img alt=\"Pasted image 20251225190026.png\" src=\"site-lib/media/pasted-image-20251225190026.png\" target=\"_self\">继续后在运行与调试选项中可以查看变量值，或者鼠标光标悬停在变量上<br>\n<img alt=\"Pasted image 20251225190451.png\" src=\"site-lib/media/pasted-image-20251225190451.png\" target=\"_self\" style=\"width: 475px; max-width: 100%;\">运行下一行代码，可以看到 a 变为了 2<br>\n<img alt=\"Pasted image 20251225191640.png\" src=\"site-lib/media/pasted-image-20251225191640.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\">继续（快捷键 F5）：运行程序直到触发下一个断点\n逐过程（快捷键 F10）：运行下一行代码，遇到函数直接执行整个函数\n单步调试（快捷键 F11）：运行下一行代码，遇到函数进入函数内单步运行\n单步跳出（快捷键 shift + F11）：跳出当前代码块local current_num = 0 local function third() current_num = 3 print(\"执行 third 函数\") -- 断点打这里\nend local function second() current_num = 2 print(\"执行 second 函数\") third()\nend local function first() current_num = 1 print(\"执行 first 函数\") second()\nend first()\n可以在调用堆栈查看调用堆栈，点击 second 可以跳转到调用 third 的代码行查看其作用域内的变量<br>\n<img alt=\"Pasted image 20251225195034.png\" src=\"site-lib/media/pasted-image-20251225195034.png\" target=\"_self\">\n调用堆栈解读：\n最顶部：当前暂停位置 (third)\n从上到下：函数调用顺序\n每个层级：显示函数名、参数值、所在文件\n点击任意层级：跳转到对应的代码位置，查看当时的变量状态\n调试控制台可以直接执行 Lua 代码：-- 使用调试控制台进行交互\nlocal inventory = { items = { { id = 1, name = \"药水\", count = 5 }, { id = 2, name = \"武器\", count = 2 }, { id = 3, name = \"防具\", count = 3 } }, gold = 1000\n} local function find_item_by_name(name) for _, item in ipairs(inventory.items) do if item.name == name then return item end end return nil\nend print(\"断点打这里\")\n-- 断点后在调试控制台中可以：\n-- 1. 查看变量: &gt; inventory\n-- 2. 调用函数: &gt; find_item_by_name(\"药水\")\n-- 3. 修改值: &gt; inventory.gold = 1500\n-- 4. 执行表达式: &gt; #inventory.items\n<br><img alt=\"Pasted image 20251225203906.png\" src=\"site-lib/media/pasted-image-20251225203906.png\" target=\"_self\">监视变量用于在大量变量与复杂镶套中快速查看指定变量值-- 调试复杂表达式\nlocal complex_data = { users = { {name = \"Alice\", scores = {85, 92, 78}}, {name = \"Bob\", scores = {88, 76, 95}}, {name = \"Charlie\", scores = {92, 89, 91}} }, config = { weights = {0.3, 0.4, 0.3}, threshold = 80 }\n} local function calculate_weighted_scores() local results = {} for i, user in ipairs(complex_data.users) do -- 在调试时添加监视表达式： -- 1. user.name -- 2. #user.scores -- 3. complex_data.config.weights[1] local weighted_sum = 0 -- 断点打这里 for j, score in ipairs(user.scores) do weighted_sum = weighted_sum + score * complex_data.config.weights[j] end table.insert(results, { name = user.name, score = weighted_sum, passed = weighted_sum &gt;= complex_data.config.threshold }) end return results\nend local results = calculate_weighted_scores()\n<br><img alt=\"Pasted image 20251225201739.png\" src=\"site-lib/media/pasted-image-20251225201739.png\" target=\"_self\">右键断点可以编辑断点设置其他类型的断点。<br>\n<img alt=\"Pasted image 20251225202221.png\" src=\"site-lib/media/pasted-image-20251225202221.png\" target=\"_self\" style=\"width: 725px; max-width: 100%;\">条件断点允许输入条件来在指定条件下触发断点，适合过滤无关触发。-- 条件断点示例\nlocal function find_special_num(num) for i = 1, num do local current_num = i if i == 100 then -- 可以设置条件断点：i == 99 提前一步暂停 print(\"找到特殊数字！\") end end\nend find_special_num(100)\n命中断点允许在断点被触发特定次数后才暂停程序执行，适合调试循环或重复调用的情况。-- 调试循环中的特定迭代\nlocal function process_items(items) local processed = {} local total_value = 0 for i, item in ipairs(items) do local value = item.price * item.quantity\t-- 设置命中次数断点：== 3 在第3次迭代时暂停 total_value = total_value + value table.insert(processed, { id = item.id, name = item.name, value = value, cumulative = total_value }) print(string.format(\"处理第%d项: %s = %d\", i, item.name, value)) end return processed, total_value\nend local inventory = { {id = 1, name = \"苹果\", price = 5, quantity = 10}, {id = 2, name = \"香蕉\", price = 3, quantity = 15}, {id = 3, name = \"橙子\", price = 4, quantity = 8}, -- 我们想检查这一项 {id = 4, name = \"葡萄\", price = 8, quantity = 6}, {id = 5, name = \"西瓜\", price = 15, quantity = 3}\n} local results, total = process_items(inventory)\nprint(\"总计价值:\", total)\n日志断点不会暂停程序，而是在触发时输出信息到控制台，适合在不中断流程的情况下跟踪程序状态。\n日志断点类似于 print，花括号 {} 内可以输入变量。local a = 1 for i = 1, 10 do a = a + 1\t-- 增加日志断点：触发断点 i = {i}\nend\n--[[ 输出\n触发断点 i = 1.0\n触发断点 i = 2.0\n触发断点 i = 3.0\n触发断点 i = 4.0\n触发断点 i = 5.0\n触发断点 i = 6.0\n触发断点 i = 7.0\n触发断点 i = 8.0\n触发断点 i = 9.0\n触发断点 i = 10.0\n--]]\n等待断点指定的另一个断点触发后，等待断点才会触发，适合在不重复设定复杂条件断点的情况下应用其条件。local a = 1 for i = 1, 100 do print(a)\t-- 增加条件断点：i == 50 print(-a)\t-- 增加等待断点：指定上面的断点 a = a + 1\nend\n-- 将会在 i = 50 时先后触发两个断点\nlocal function debug_loop() local matrix = {} -- 初始化矩阵 for i = 1, 3 do matrix[i] = {} for j = 1, 3 do matrix[i][j] = i * j -- 在此行添加断点，观察循环变量 end end -- 处理矩阵 local sum = 0 for i = 1, #matrix do for j = 1, #matrix[i] do sum = sum + matrix[i][j] end end return matrix, sum\nend debug_loop()\nlocal function factorial(n) if n &lt;= 1 then return 1 end local v = n * factorial(n - 1) return v\t-- 打断点观察阶乘值\nend local function fibonacci(n) if n &lt;= 1 then return n end local v = fibonacci(n - 1) + fibonacci(n - 2) return v\t-- 打断点观察数列值\nend -- 测试递归函数\nprint(\"5的阶乘:\", factorial(5))\nprint(\"斐波那契第6项:\", fibonacci(6))\n查看调用堆栈可方便查看调用链，在特定位置断点查看变量值可辅助理解代码含义，使用单步可让程序自动跳转到执行位置。-- 简单的购物车系统 - 通过断点理解代码逻辑 -- 1. 商品数据\n-- 断点: 查看商品初始化\nlocal products = { { id = 1, name = \"苹果\", price = 5.5, stock = 100 }, { id = 2, name = \"香蕉\", price = 3.2, stock = 80 }, { id = 3, name = \"橙子\", price = 4.8, stock = 60 }, { id = 4, name = \"葡萄\", price = 8.9, stock = 40 }\n} -- 2. 购物车数据\n-- 断点: 观察购物车初始化\nlocal shopping_cart = { items = {}, -- 购买的商品 total = 0, -- 总金额 item_count = 0 -- 商品数量\n} -- 3. 查找商品函数\n-- 断点: 了解如何查找商品\nlocal function find_product(product_id) for _, product in ipairs(products) do if product.id == product_id then return product end end return nil\nend -- 4. 添加商品到购物车\n-- 断点: 查看核心逻辑\nlocal function add_to_cart(product_id, quantity) quantity = quantity or 1 -- 默认数量为1 -- 查找商品 local product = find_product(product_id) if not product then return false, \"商品不存在\" end -- 检查库存 if product.stock &lt; quantity then return false, \"库存不足\" end -- 更新购物车 local existing_item = shopping_cart.items[product_id] if existing_item then -- 已存在，增加数量 existing_item.quantity = existing_item.quantity + quantity existing_item.subtotal = existing_item.quantity * product.price else -- 新商品 shopping_cart.items[product_id] = { product_id = product_id, name = product.name, price = product.price, quantity = quantity, subtotal = product.price * quantity } shopping_cart.item_count = shopping_cart.item_count + 1 end -- 更新库存 product.stock = product.stock - quantity -- 更新总金额 shopping_cart.total = shopping_cart.total + (product.price * quantity) return true, \"添加成功\"\nend -- 5. 从购物车移除商品\n-- 断点: 理解移除逻辑\nlocal function remove_from_cart(product_id, quantity) local item = shopping_cart.items[product_id] if not item then return false, \"商品不在购物车中\" end quantity = quantity or item.quantity -- 默认移除全部 if quantity &gt; item.quantity then quantity = item.quantity end -- 更新购物车 if quantity == item.quantity then -- 移除整个商品 shopping_cart.items[product_id] = nil shopping_cart.item_count = shopping_cart.item_count - 1 else -- 减少数量 item.quantity = item.quantity - quantity item.subtotal = item.quantity * item.price end -- 恢复库存 local product = find_product(product_id) if product then product.stock = product.stock + quantity end -- 更新总金额 shopping_cart.total = shopping_cart.total - (item.price * quantity) -- 如果总金额为负，设为0 if shopping_cart.total &lt; 0 then shopping_cart.total = 0 end return true, \"移除成功\"\nend -- 6. 显示购物车\n-- 断点: 查看显示逻辑\nlocal function show_cart() if shopping_cart.item_count == 0 then print(\"购物车为空\") return end print(\"\\n=== 购物车内容 ===\") print(string.format(\"%-5s %-10s %-8s %-8s %-8s\", \"ID\", \"商品名\", \"单价\", \"数量\", \"小计\")) print(string.rep(\"-\", 45)) local count = 0 for _, item in pairs(shopping_cart.items) do count = count + 1 print(string.format(\"%-5d %-10s %-8.2f %-8d %-8.2f\", item.product_id, item.name, item.price, item.quantity, item.subtotal)) end print(string.rep(\"-\", 45)) print(string.format(\"总计: %.2f 元\", shopping_cart.total)) print(string.format(\"商品总数: %d 件\", shopping_cart.item_count))\nend -- 7. 显示商品列表\n-- 断点: 查看商品展示\nlocal function show_products() print(\"\\n=== 商品列表 ===\") print(string.format(\"%-5s %-10s %-8s %-8s\", \"ID\", \"商品名\", \"价格\", \"库存\")) print(string.rep(\"-\", 35)) for _, product in ipairs(products) do print(string.format(\"%-5d %-10s %-8.2f %-8d\", product.id, product.name, product.price, product.stock)) end\nend -- 8. 结算函数\n-- 断点: 了解结算过程\nlocal function checkout() if shopping_cart.item_count == 0 then return false, \"购物车为空\" end print(\"\\n=== 结算 ===\") show_cart() -- 应用折扣（满100减10） local discount = 0 if shopping_cart.total &gt;= 100 then discount = 10 print(string.format(\"\\n折扣: -%.2f 元\", discount)) end local final_total = shopping_cart.total - discount print(string.format(\"实付金额: %.2f 元\", final_total)) -- 清空购物车 for product_id, item in pairs(shopping_cart.items) do shopping_cart.items[product_id] = nil end shopping_cart.total = 0 shopping_cart.item_count = 0 return true, \"结算成功\"\nend -- 9. 主程序流程\n-- 断点: 开始跟踪整个流程\nlocal function main() print(\"欢迎使用购物车系统!\") -- 初始状态 show_products() -- 测试购物车操作 print(\"\\n[测试1] 添加商品到购物车\") -- 断点: 跟踪添加过程 local success, message = add_to_cart(1, 3) -- 3个苹果 print(\"添加苹果:\", message) success, message = add_to_cart(2, 2) -- 2个香蕉 print(\"添加香蕉:\", message) success, message = add_to_cart(3, 5) -- 5个橙子 print(\"添加橙子:\", message) -- 查看购物车 show_cart() print(\"\\n[测试2] 再次添加相同商品\") -- 断点: 观察重复添加 success, message = add_to_cart(1, 2) -- 再添加2个苹果 print(\"再添加苹果:\", message) show_cart() show_products() -- 查看库存变化 print(\"\\n[测试3] 移除部分商品\") -- 断点: 跟踪移除过程 success, message = remove_from_cart(3, 2) -- 移除2个橙子 print(\"移除橙子:\", message) show_cart() show_products() -- 查看库存恢复 print(\"\\n[测试4] 尝试结算\") -- 断点: 观察结算流程 success, message = checkout() print(\"结算结果:\", message) print(\"\\n[测试5] 结算后查看状态\") show_cart() print(\"\\n谢谢使用!\")\nend -- 10. 运行程序\nmain()\n在现实的程序中，错误是不可避免的。没有错误处理的程序就像没有刹车的汽车一样危险。-- 没有错误处理的危险程序\nlocal function get_table_value(t, k1, k2) return t[k1][k2]\nend local t = {}\nget_table_value(t, \"key1\", \"key2\")\t-- t.key1 为 nil，t.key1.key2 会报错：尝试索引 nil 值\n-- 程序会在这里抛出错误，程序终止\nprint(\"这行代码不会执行\")\n-- 1. 忘记写值\nlocal x =\n-- 错误: unexpected symbol near '&lt;eof&gt;' -- 2. 代码块没有闭合\nlocal t = { 1, 2, 3\n-- 错误: '}' expected (to close '{' at line 1)\nif a then\n-- 错误: 'end' expected (to close 'if' at line 1) near '&lt;eof&gt;'\n-- 索引 nil 值\nprint(undefined_table.v)\n-- 错误: attempt to index global 'undefined_table' (a nil value) 尝试索引 nil 值\n-- 程序能运行，结果不对\nlocal function calculate_average(numbers) local sum = 0 for i = 1, #numbers do sum = sum + numbers[i] end return sum / #numbers -- 如果numbers为空表，会除以0，返回 1.#INF\nend\n-- 1. 文件不存在\nlocal file, err = io.open(\"nonexistent.txt\", \"r\")\nif not file then print(err) -- 输出: nonexistent.txt: No such file or directory\nend -- 2. 内存不足\nlocal huge_table = {}\nfor i = 1, math.huge do huge_table[i] = string.rep(\"x\", 1000000)\nend\n-- 报错: not enough memory -- 3. 栈溢出\nlocal function err_fn() err_fn()\nend\nerr_fn()\n-- 报错: stack overflow\nlocal function test_fn() a.b.c = 123\nend test_fn()\n--[[ 输出\nlua: test.lua:2: attempt to index global 'a' (a nil value)\nstack traceback: test.lua:2: in function 'test_fn' test.lua:5: in main chunk [C]: ?\n--]]\ntest.lua:2 为错误的路径模块与行数\nattempt to index global 'a' (a nil value) 为错误信息：尝试索引 nil 值\nstack traceback 调用堆栈（从下往上看）\ntest.lua:5: in main chunk 在主代码块先执行了第 5 行代码\ntest.lua:2: in function 'test_fn' 最后执行了 test_fn 函数中的第 2 行pcall (protected call) 是Lua最基本的错误处理机制，以保护模式调用函数。函数中的任何错误不会抛出；取而代之的是 pcall&nbsp;会将错误捕获。pcall(保护函数: func, 函数参数: any...) -&gt; 是否有错误: bool, 返回值|错误信息: any|str...\n-- pcall处理多个返回值\nlocal function multiple_returns() return 1, 2, 3, 4, 5\nend local function failing_function() error(\"出错了！\", 0)\nend print(\"\\n多返回值处理:\")\nsuccess, a, b, c, d, e = pcall(multiple_returns)\nif success then print(\" 成功返回: \" .. a .. \", \" .. b .. \", \" .. c .. \", \" .. d .. \", \" .. e)\nelse print(\" 错误: \" .. a) -- 注意：错误信息在第一个返回值\nend success, err = pcall(failing_function)\nif not success then print(\" 捕获错误: \" .. err)\nend\n--[[ 输出\n成功返回: 1, 2, 3, 4, 5\n捕获错误: 出错了！\n--]]\nxpcall 比 pcall 更强大，可以指定错误信息处理函数xpcall(保护函数: func, 信息处理函数: func, 函数参数: any...) -&gt; 是否有错误: bool, 返回值|处理后的信息: any|str...\n-- 错误处理函数\nlocal function error_handler(err) -- err参数是错误信息 local debug_info = debug.traceback(\"错误追踪:\", 2) return string.format(\"发生错误: %s\\n%s\", err, debug_info)\nend local function risky_operation() local t = {1, 2, 3} return t[10] * 2 -- t[10]是nil，nil * 2会出错\nend print(\"xpcall示例1:\")\nlocal success, result = xpcall(risky_operation, error_handler)\nif success then print(\" 结果: \" .. result)\nelse print(\" 错误处理:\\n\" .. result)\nend\n--[[ 输出\n发生错误: test.lua:10: attempt to perform arithmetic on field '?' (a nil value)\n错误追踪:\nstack traceback: test.lua:10: in function &lt;test.lua:8&gt; [C]: in function 'xpcall' test.lua:14: in main chunk [C]: ?\n--]]\nerror(信息: str, 错误级别?: int) 错误级别默认为 1\n-- 示例1：基本错误抛出\nlocal function validate_age(age) if type(age) ~= \"number\" then error(\"年龄必须是数字\", 2) -- level=2表示错误在调用者的位置 end if age &lt; 0 then error(\"年龄不能为负数\", 2) end if age &gt; 150 or age == 0 then error(\"年龄不合理\", 2) end return true\nend print(\"年龄验证测试:\")\nlocal test_ages = {25, -5, \"二十\", 200, 0} for i, age in ipairs(test_ages) do local success, result = pcall(validate_age, age) if success then print(\" 年龄 \" .. age .. \": 有效\") else print(\" 年龄 \" .. age .. \": \" .. result) end\nend\n--[[ 输出\n年龄 25: 有效\n年龄 -5: 年龄不能为负数\n年龄 二十: 年龄必须是数字\n年龄 200: 年龄不合理\n年龄 0: 有效\n--]] -- 示例2：错误级别的作用\nlocal function level_demo() print(\"\\n错误级别演示:\") local function inner_function() error(\"错误发生在inner_function\", 0) -- level 0: 不添加位置信息 end local function middle_function() error(\"错误发生在middle_function\", 1) -- level 1: 调用error的位置 end local function outer_function() error(\"错误发生在outer_function\", 2) -- level 2: 调用者的位置 end -- 测试不同level local function test_error(func, level_desc) local success, err = pcall(func) if not success then print(\" \" .. level_desc .. \": \" .. err) end end test_error(inner_function, \"level 0\") test_error(middle_function, \"level 1\") test_error(outer_function, \"level 2\")\nend level_demo()\nassert 用于检查条件，如果条件为假则抛出错误assert(条件: bool, 错误信息?: str, 参数?: any...) -&gt; 参数: any... 错误信息默认为 \"assertion failed!\"\n-- 示例1：基本断言\nfunction calculate_bmi(weight, height) -- 参数验证 assert(type(weight) == \"number\", \"体重必须是数字\") assert(type(height) == \"number\", \"身高必须是数字\") assert(weight &gt; 0, \"体重必须大于0\") assert(height &gt; 0, \"身高必须大于0\") return weight / (height * height)\nend print(\"BMI计算测试:\")\nlocal test_cases = { {70, 1.75}, -- 有效 {-70, 1.75}, -- 无效体重 {70, -1.75}, -- 无效身高 {\"70\", 1.75}, -- 字符串体重\n} for i, case in ipairs(test_cases) do local success, result = pcall(calculate_bmi, case[1], case[2]) if success then print(string.format(\" 体重%.1fkg, 身高%.2fm -&gt; BMI: %.1f\", case[1], case[2], result)) else print(\" 错误: \" .. result) end\nend -- 示例2：assert与error的区别\nprint(\"\\nassert vs error:\") function using_assert(value) assert(value ~= nil, \"值不能为nil\") return value * 2\nend function using_error(value) if value == nil then error(\"值不能为nil\", 2) end return value * 2\nend -- 两个函数的功能相同，但assert更简洁\nlocal test_values = {5, nil} for i, value in ipairs(test_values) do print(\"\\n测试值: \" .. tostring(value)) local success1, result1 = pcall(using_assert, value) if success1 then print(\" assert版本: \" .. result1) else print(\" assert版本错误: \" .. result1) end local success2, result2 = pcall(using_error, value) if success2 then print(\" error版本: \" .. result2) else print(\" error版本错误: \" .. result2) end\nend -- 示例3：在生产环境中禁用断言\n-- 在开发时使用断言检查，发布时可以关闭\nlocal DEBUG_MODE = true function release_assert(condition, message) if DEBUG_MODE then assert(condition, message) elseif not condition then -- 在生产环境中，记录错误但不抛出 print(\"[生产环境错误] \" .. (message or \"断言失败\")) return false end return true\nend print(\"\\n生产环境断言:\")\nlocal function test_function(x) if not release_assert(x &gt; 0, \"x必须大于0\") then return nil end return x * 2\nend -- 测试模式\nDEBUG_MODE = true\nprint(\"调试模式:\")\nlocal success, result = pcall(test_function, -5)\nif not success then print(\" 错误: \" .. result)\nend -- 生产模式\nDEBUG_MODE = false\nprint(\"\\n生产模式:\")\nlocal result = test_function(-5)\nif result then print(\" 结果: \" .. result)\nelse print(\" 函数返回nil（不抛出错误）\")\nend\n假设一切可能出错，并提前处理-- 示例1：安全的表访问\nlocal function safe_table_access(t, key, default) if type(t) ~= \"table\" then return default end local value = t[key] if value == nil then return default end return value\nend print(\"安全表访问:\")\nlocal config = {theme = \"dark\", language = \"zh-CN\"}\nprint(\" 主题: \" .. safe_table_access(config, \"theme\", \"light\"))\nprint(\" 音量: \" .. safe_table_access(config, \"volume\", 70)) -- 使用默认值\nprint(\" 非表: \" .. safe_table_access(\"不是表\", \"key\", \"默认\"))\n--[[ 输出\n主题: dark\n音量: 70\n非表: 默认\n--]] -- 示例2：安全的函数调用\nlocal function safe_call(func, ...) if type(func) ~= \"function\" then return nil, \"不是函数\" end local success, result = pcall(func, ...) if not success then return nil, result end return result\nend print(\"\\n安全函数调用:\")\nlocal function add(a, b) return a + b\nend\nlocal result, err = safe_call(add, 5, 3)\nif result then print(\" 5 + 3 = \" .. result)\nelse print(\" 错误: \" .. err)\nend result, err = safe_call(\"不是函数\", 5, 3)\nif result then print(\" 结果: \" .. result)\nelse print(\" 错误: \" .. err)\nend\n--[[ 输出\n5 + 3 = 8 错误: 不是函数\n--]] -- 示例3：验证输入数据\nlocal function validate_user_input(input) -- 多层验证 if not input then return nil, \"输入不能为空\" end if type(input) ~= \"table\" then return nil, \"输入必须是表\" end -- 验证必填字段 local required = {\"username\", \"email\", \"password\"} for _, field in ipairs(required) do if not input[field] or #tostring(input[field]) == 0 then return nil, \"字段 '\" .. field .. \"' 不能为空\" end end -- 验证邮箱格式 local email = input.email if not string.match(email, \"^[%w%.%-]+@[%w%.%-]+%.[%a]+$\") then return nil, \"邮箱格式无效\" end -- 验证密码强度 local password = input.password if #password &lt; 8 then return nil, \"密码至少需要8个字符\" end return true\nend print(\"\\n输入验证:\")\nlocal inputs = { {username = \"user1\", email = \"test@example.com\", password = \"secure123\"}, {username = \"\", email = \"test@example.com\", password = \"short\"}, -- 用户名为空 {username = \"user2\", email = \"invalid-email\", password = \"password123\"}, -- 邮箱无效 {username = \"user3\", email = \"test@example.com\", password = \"123\"}, -- 密码太短\n} for i, input in ipairs(inputs) do local valid, err = validate_user_input(input) if valid then print(\" 输入 \" .. i .. \": 有效\") else print(\" 输入 \" .. i .. \": 无效 - \" .. err) end\nend\n--[[ 输出 输入 1: 有效 输入 2: 无效 - 字段 'username' 不能为空 输入 3: 无效 - 邮箱格式无效 输入 4: 无效 - 密码至少需要8个字符\n--]]\n-- 错误恢复：从错误中恢复并继续执行\n-- 策略1：重试机制\nlocal function retry_operation(operation, max_attempts, delay) max_attempts = max_attempts or 3 delay = delay or 1 -- 默认延迟1秒 for attempt = 1, max_attempts do local success, result = pcall(operation) if success then return result end print(string.format(\" 尝试 %d/%d 失败: %s\", attempt, max_attempts, result)) if attempt &lt; max_attempts then print(string.format(\" 等待 %.1f 秒后重试...\", delay)) -- 在实际应用中，这里应该使用 os.execute 或类似方法等待 -- 为了示例简化，我们只是打印 end end return nil, \"所有重试尝试都失败\"\nend print(\"重试机制:\")\nlocal function unreliable_operation() math.randomseed(os.time()) if math.random() &lt; 0.7 then -- 70%失败率 error(\"操作失败: 随机错误\") end return \"操作成功\"\nend local result, err = retry_operation(unreliable_operation, 5, 0.5)\nif result then print(\" 最终结果: \" .. result)\nelse print(\" 最终错误: \" .. err)\nend -- 策略2：降级服务\nprint(\"\\n降级服务:\")\nlocal function fetch_data(source, fallback_source) -- 尝试主数据源 local success, data = pcall(source.fetch) if success then print(\" 使用主数据源\") return data end print(\" 主数据源失败: \" .. data) print(\" 尝试备用数据源...\") -- 尝试备用数据源 success, data = pcall(fallback_source.fetch) if success then print(\" 使用备用数据源\") return data end print(\" 备用数据源也失败: \" .. data) -- 返回缓存或默认数据 print(\" 返回缓存数据\") return {cached = true, data = \"默认数据\"}\nend -- 模拟数据源\nlocal primary_source = { fetch = function() if math.random() &lt; 0.5 then error(\"主数据源不可用\") end return {source = \"primary\", data = \"新鲜数据\"} end\n} local fallback_source = { fetch = function() if math.random() &lt; 0.3 then error(\"备用数据源不可用\") end return {source = \"fallback\", data = \"稍旧的数据\"} end\n} for i = 1, 3 do print(\"\\n尝试 \" .. i .. \":\") local data = fetch_data(primary_source, fallback_source) print(\" 获取的数据: \" .. data.data .. \" (来源: \" .. (data.source or \"缓存\") .. \")\")\nend -- 策略3：优雅降级\nprint(\"\\n优雅降级:\")\nlocal function render_ui(use_advanced_features) local features = {} -- 基础功能总是可用的 features.basic = true -- 高级功能可能不可用 if use_advanced_features then local success = pcall(function() -- 模拟需要特定库或环境的功能 if not package.loaded[\"advanced_graphics\"] then error(\"高级图形库未安装\") end features.advanced_graphics = true end) if not success then print(\" 警告: 高级图形功能不可用，使用基础渲染\") features.advanced_graphics = false end else features.advanced_graphics = false end -- 根据可用功能渲染UI if features.advanced_graphics then print(\" 使用高级UI渲染\") else print(\" 使用基础UI渲染\") end return features\nend print(\"渲染测试:\")\nrender_ui(true)\nrender_ui(false) -- 策略4：隔离故障\nprint(\"\\n故障隔离:\")\nlocal function isolated_operation(operation_name, operation_func) -- 在独立的协程中执行操作，防止一个操作失败影响其他操作 local co = coroutine.create(function() local success, result = pcall(operation_func) if not success then print(\" 操作 '\" .. operation_name .. \"' 失败: \" .. result) return nil, result end return result end) local success, result = coroutine.resume(co) if success and coroutine.status(co) == \"dead\" then return result else return nil, \"操作未完成\" end\nend print(\"隔离执行:\")\nlocal results = {} results.op1 = isolated_operation(\"操作1\", function() error(\"操作1故意失败\")\nend) results.op2 = isolated_operation(\"操作2\", function() return \"操作2成功\"\nend) results.op3 = isolated_operation(\"操作3\", function() error(\"操作3也失败\")\nend) print(\"\\n所有操作结果:\")\nfor name, result in pairs(results) do if result then print(\" \" .. name .. \": \" .. result) else print(\" \" .. name .. \": 失败\") end\nend\n-- 创建结构化的错误类型，便于处理\n-- 错误类型定义\nlocal ErrorTypes = { VALIDATION = { code = 100, name = \"VALIDATION_ERROR\", description = \"输入验证失败\" }, DATABASE = { code = 200, name = \"DATABASE_ERROR\", description = \"数据库操作失败\" }, NETWORK = { code = 300, name = \"NETWORK_ERROR\", description = \"网络通信失败\" }, PERMISSION = { code = 400, name = \"PERMISSION_ERROR\", description = \"权限不足\" }, INTERNAL = { code = 500, name = \"INTERNAL_ERROR\", description = \"内部服务器错误\" }\n} -- 错误创建函数\nlocal function create_error(error_type, message, details) local error_info = ErrorTypes[error_type] if not error_info then error_info = ErrorTypes.INTERNAL end return { type = error_type, code = error_info.code, name = error_info.name, message = message or error_info.description, details = details, timestamp = os.time(), stack_trace = debug.traceback(\"\", 2) }\nend -- 错误抛出函数\nlocal function throw_error(error_type, message, details) error(create_error(error_type, message, details), 2)\nend -- 错误处理函数\nlocal function handle_error(err, context) -- 如果是我们的自定义错误 if type(err) == \"table\" and err.code then print(string.format(\"[错误处理] 类型: %s (%d)\", err.name, err.code)) print(string.format(\" 消息: %s\", err.message)) if err.details then print(string.format(\" 详情: %s\", tostring(err.details))) end if context then print(string.format(\" 上下文: %s\", context)) end print(\" 调用栈:\") print(err.stack_trace) -- 根据错误类型采取不同措施 if err.type == \"VALIDATION\" then return nil, \"输入错误，请检查后重试\" elseif err.type == \"PERMISSION\" then return nil, \"权限不足，请联系管理员\" elseif err.type == \"NETWORK\" then -- 可以尝试重试 return nil, \"网络错误，请稍后重试\" else return nil, \"系统错误，请联系技术支持\" end else -- 其他类型的错误 return nil, \"未知错误: \" .. tostring(err) end\nend -- 使用自定义错误\nprint(\"自定义错误演示:\") local function register_user(user_data) -- 验证输入 if not user_data or not user_data.username then throw_error(\"VALIDATION\", \"用户名不能为空\", user_data) end if #user_data.username &lt; 3 then throw_error(\"VALIDATION\", \"用户名至少需要3个字符\", {username = user_data.username, length = #user_data.username}) end -- 模拟数据库操作 local success, db_result = pcall(function() -- 模拟数据库错误 if user_data.username == \"admin\" then error(\"用户名已存在\") end return {id = 123, username = user_data.username} end) if not success then throw_error(\"DATABASE\", \"创建用户失败\", {error = db_result}) end -- 模拟权限检查 if user_data.username == \"root\" then throw_error(\"PERMISSION\", \"不允许注册root用户\") end return db_result\nend -- 测试不同的错误情况\nlocal test_cases = { {username = \"\"}, -- 验证错误 {username = \"ab\"}, -- 用户名太短 {username = \"admin\"}, -- 数据库错误 {username = \"root\"}, -- 权限错误 {username = \"正常用户\"}, -- 成功\n} for i, test_case in ipairs(test_cases) do print(string.format(\"\\n测试用例 %d: 用户名='%s'\", i, test_case.username)) local success, result = pcall(register_user, test_case) if success then print(\" 成功: 用户ID = \" .. result.id) else local _, user_message = handle_error(result, \"用户注册\") print(\" 失败: \" .. user_message) end\nend\n--[[ 输出\n测试用例 1: 用户名=''\n[错误处理] 类型: VALIDATION_ERROR (100) 消息: 用户名至少需要3个字符 详情: table: 00C22798 上下文: 用户注册 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:99: in function &lt;test.lua:92&gt; [C]: in function 'pcall' test.lua:136: in main chunk [C]: ? 失败: 输入错误，请检查后重试 测试用例 2: 用户名='ab'\n[错误处理] 类型: VALIDATION_ERROR (100) 消息: 用户名至少需要3个字符 详情: table: 00C22B30 上下文: 用户注册 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:99: in function &lt;test.lua:92&gt; [C]: in function 'pcall' test.lua:136: in main chunk [C]: ? 失败: 输入错误，请检查后重试 测试用例 3: 用户名='admin'\n[错误处理] 类型: DATABASE_ERROR (200) 消息: 创建用户失败 详情: table: 00C22C20 上下文: 用户注册 调用栈: stack traceback: test.lua:51: in function 'throw_error' est.lua:113: in function &lt;test.lua:92&gt; [C]: in function 'pcall' test.lua:136: in main chunk [C]: ? 失败: 系统错误，请联系技术支持 测试用例 4: 用户名='root'\n[错误处理] 类型: PERMISSION_ERROR (400) 消息: 不允许注册root用户 上下文: 用户注册 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:118: in function &lt;test.lua:92&gt; [C]: in function 'pcall' test.lua:136: in main chunk [C]: ? 失败: 权限不足，请联系管理员 测试用例 5: 用户名='正常用户' 成功: 用户ID = 123\n--]]\nlocal GradeSystem = { students = {}, courses = {}, grades = {}, statistics = { total_students = 0, total_courses = 0, average_scores = {} }\n} local function generate_id(prefix, existing_ids) local max_id = 0 for id, _ in pairs(existing_ids) do local num = tonumber(id:match(\"%d+$\")) if num and num &gt; max_id then max_id = num end end return string.format(\"%s%04d\", prefix, max_id + 1)\nend local function calculate_weighted_average(scores, credits) local total_score = 0 local total_credit = 0 for course_id, score in pairs(scores) do local credit = credits[course_id] or 1 total_score = total_score + score * credit total_credit = total_credit + credit end return total_credit &gt; 0 and total_score / total_credit or 0\nend function GradeSystem:add_student(name, major, class) local student_id = generate_id(\"STU\", self.students) self.students[student_id] = { id = student_id, name = name, major = major or \"未分配\", class = class or \"未知班级\", enrolled_courses = {}, enroll_date = os.date(\"%Y-%m-%d\") } self.statistics.total_students = self.statistics.total_students + 1 return student_id\nend function GradeSystem:add_course(name, credit, teacher) local course_id = generate_id(\"COU\", self.courses) self.courses[course_id] = { id = course_id, name = name, credit = credit or 1, teacher = teacher or \"待分配\", enrolled_students = {} } self.statistics.total_courses = self.statistics.total_courses + 1 return course_id\nend function GradeSystem:enroll_course(student_id, course_id) local student = self.students[student_id] local course = self.courses[course_id] if not student or not course then return false, \"学生或课程不存在\" end if student.enrolled_courses[course_id] then return false, \"该课程已选\" end student.enrolled_courses[course_id] = true student.enrolled_courses[course.name] = course_id course.enrolled_students[student_id] = true self.grades[student_id] = self.grades[student_id] or {} self.grades[student_id][course_id] = nil return true, \"选课成功\"\nend function GradeSystem:record_grade(student_id, course_id, score) local student = self.students[student_id] if (not self.grades[student_id] or not self.grades[student_id][course_id]) and (not student or not student.enrolled_courses[course_id]) then return false, \"学生未选此课程\" end if score &lt; 0 or score &gt; 100 then return false, \"分数必须在0-100之间\" end self.grades[student_id] = self.grades[student_id] or {} self.grades[student_id][course_id] = score self:update_statistics() return true, \"成绩录入成功\"\nend function GradeSystem:update_statistics() local course_scores = {} local course_counts = {} for student_id, courses in pairs(self.grades) do for course_id, score in pairs(courses) do if score then course_scores[course_id] = (course_scores[course_id] or 0) + score course_counts[course_id] = (course_counts[course_id] or 0) + 1 end end end for course_id, total_score in pairs(course_scores) do local count = course_counts[course_id] or 1 self.statistics.average_scores[course_id] = total_score / count end\nend function GradeSystem:get_student_report(student_id) local student = self.students[student_id] if not student then return nil, \"学生不存在\" end local report = { student_id = student_id, name = student.name, major = student.major, class = student.class, courses = {}, total_average = 0, weighted_average = 0 } local total_score = 0 local total_courses = 0 local scores_with_credits = {} local credits = {} for course_id, _ in pairs(student.enrolled_courses) do if type(course_id) == \"string\" and course_id:match(\"^COU\") then local course = self.courses[course_id] local score = self.grades[student_id] and self.grades[student_id][course_id] if course then local course_info = { id = course_id, name = course.name, credit = course.credit, teacher = course.teacher, score = score or \"未录入\" } table.insert(report.courses, course_info) if score then total_score = total_score + score total_courses = total_courses + 1 scores_with_credits[course_id] = score credits[course_id] = course.credit end end end end if total_courses &gt; 0 then report.total_average = total_score / total_courses report.weighted_average = calculate_weighted_average(scores_with_credits, credits) end table.sort(report.courses, function(a, b) local score_a = a.score or 0 local score_b = b.score or 0 return score_a &gt; score_b end) return report\nend function GradeSystem:get_course_report(course_id) local course = self.courses[course_id] if not course then return nil, \"课程不存在\" end local report = { course_id = course_id, name = course.name, credit = course.credit, teacher = course.teacher, enrolled_count = 0, graded_count = 0, average_score = 0, score_distribution = { excellent = { name = \"优秀\", count = 0 }, good = { name = \"良好\", count = 0 }, medium = { name = \"中等\", count = 0 }, pass = { name = \"及格\", count = 0 }, fail = { name = \"不及格\", count = 0 } }, student_list = {} } local total_score = 0 for student_id, _ in pairs(course.enrolled_students) do report.enrolled_count = report.enrolled_count + 1 local score = self.grades[student_id] and self.grades[student_id][course_id] if score then report.graded_count = report.graded_count + 1 total_score = total_score + score score_dis = report.score_distribution if score &gt;= 90 then score_dis.excellent.count = score_dis.excellent.count + 1 elseif score &gt;= 80 then score_dis.good.count = score_dis.good.count + 1 elseif score &gt;= 70 then score_dis.medium.count = score_dis.medium.count + 1 elseif score &gt;= 60 then score_dis.pass.count = score_dis.pass.count + 1 else score_dis.fail.count = score_dis.fail.count + 1 end local student = self.students[student_id] if student then table.insert(report.student_list, { student_id = student_id, name = student.name, score = score, grade = score &gt;= 90 and \"优秀\" or score &gt;= 80 and \"良好\" or score &gt;= 70 and \"中等\" or score &gt;= 60 and \"及格\" or \"不及格\" }) end end end if report.graded_count &gt; 0 then report.average_score = total_score / report.graded_count end table.sort(report.student_list, function(a, b) return a.score &gt; b.score end) return report\nend function GradeSystem:find_top_students(min_average, limit) local qualified_students = {} for student_id, student in pairs(self.students) do local report = self:get_student_report(student_id) if report and report.weighted_average &gt;= (min_average or 85) then table.insert(qualified_students, { student_id = student_id, name = student.name, major = student.major, class = student.class, weighted_average = report.weighted_average, course_count = #report.courses }) end end table.sort(qualified_students, function(a, b) return a.weighted_average &gt; b.weighted_average end) if limit and limit &gt; 0 then qualified_students = { unpack(qualified_students, 1, limit) } end return qualified_students\nend local function initialize_test_data(system) local math_id = system:add_course(\"高等数学\", 4, \"张教授\") local english_id = system:add_course(\"大学英语\", 3, \"王老师\") local programming_id = system:add_course(\"程序设计\", 3, \"李教授\") local physics_id = system:add_course(\"大学物理\", 3, \"赵教授\") local history_id = system:add_course(\"中国近代史\", 2, \"刘老师\") local stu1 = system:add_student(\"张三\", \"计算机科学\", \"计科2001\") local stu2 = system:add_student(\"李四\", \"软件工程\", \"软工2001\") local stu3 = system:add_student(\"王五\", \"信息安全\", \"信安2001\") local stu4 = system:add_student(\"赵六\", \"计算机科学\", \"计科2001\") local stu5 = system:add_student(\"钱七\", \"软件工程\", \"软工2001\") system:enroll_course(stu1, math_id) system:enroll_course(stu1, english_id) system:enroll_course(stu1, programming_id) system:enroll_course(stu2, math_id) system:enroll_course(stu2, english_id) system:enroll_course(stu2, physics_id) system:enroll_course(stu3, programming_id) system:enroll_course(stu3, physics_id) system:enroll_course(stu3, history_id) system:enroll_course(stu4, math_id) system:enroll_course(stu4, programming_id) system:enroll_course(stu4, physics_id) system:enroll_course(stu4, history_id) system:enroll_course(stu5, english_id) system:enroll_course(stu5, programming_id) system:enroll_course(stu5, history_id) local scores = { [stu1] = { [math_id] = 88, [english_id] = 92, [programming_id] = 95 }, [stu2] = { [math_id] = 76, [english_id] = 85, [physics_id] = 82 }, [stu3] = { [programming_id] = 91, [physics_id] = 78, [history_id] = 88 }, [stu4] = { [math_id] = 94, [programming_id] = 89, [physics_id] = 86, [history_id] = 92 }, [stu5] = { [english_id] = 79, [programming_id] = 83, [history_id] = 85 } } for student_id, course_scores in pairs(scores) do for course_id, score in pairs(course_scores) do system:record_grade(student_id, course_id, score) end end print(string.format(\"已添加 %d 名学生，%d 门课程\", system.statistics.total_students, system.statistics.total_courses))\nend local function demonstrate_system_workflow() initialize_test_data(GradeSystem) print(\"\\n查询学生成绩单\") local report, err = GradeSystem:get_student_report(\"STU0004\") if report then print(string.format(\"学生: %s (%s - %s)\", report.name, report.major, report.class)) print(string.format(\"加权平均分: %.2f, 简单平均分: %.2f\", report.weighted_average, report.total_average)) print(\"各科成绩:\") for i, course in ipairs(report.courses) do print(string.format(\" %s (%s): %s (学分: %d)\", course.name, course.teacher, course.score, course.credit)) end else print(\"错误:\", err) end print(\"\\n查询课程统计\") local course_report, course_err = GradeSystem:get_course_report(\"COU0003\") if course_report then print(string.format(\"课程: %s (%s)\", course_report.name, course_report.teacher)) print(string.format(\"选课人数: %d, 已录入成绩: %d\", course_report.enrolled_count, course_report.graded_count)) print(string.format(\"平均分: %.2f\", course_report.average_score)) print(\"成绩分布:\") local distribution = {} for _, dis in pairs(course_report.score_distribution) do if dis.count &gt; 0 then print(string.format(\" %s: %d人\", dis.name, dis.count)) end end print(\"成绩前3名:\") for i = 1, math.min(3, #course_report.student_list) do local student = course_report.student_list[i] print(string.format(\" %d. %s: %.1f (%s)\", i, student.name, student.score, student.grade)) end else print(\"错误:\", course_err) end print(\"\\n查找成绩优异学生(平均分≥85)\") local top_students = GradeSystem:find_top_students(85, 5) print(string.format(\"找到 %d 名符合条件的学生:\", #top_students)) for i, student in ipairs(top_students) do print(string.format(\" %d. %s (%s) - 平均分: %.2f, 已修课程: %d门\", i, student.name, student.major, student.weighted_average, student.course_count)) end print(\"\\n模拟新操作流程\") local new_student_id = GradeSystem:add_student(\"孙八\", \"人工智能\", \"智能2001\") print(string.format(\"添加新学生: %s\", new_student_id)) local success, msg = GradeSystem:enroll_course(new_student_id, \"COU0001\") print(string.format(\"选课结果: %s - %s\", success and \"成功\" or \"失败\", msg)) success, msg = GradeSystem:record_grade(new_student_id, \"COU0001\", 96) print(string.format(\"成绩录入: %s - %s\", success and \"成功\" or \"失败\", msg)) local new_report, new_err = GradeSystem:get_student_report(new_student_id) if new_report then print(string.format(\"新学生成绩单: 平均分 %.2f, 已修 %d 门课\", new_report.weighted_average, #new_report.courses)) end print(\"\\n系统统计信息\") print(string.format(\"系统概况: %d 名学生, %d 门课程\", GradeSystem.statistics.total_students, GradeSystem.statistics.total_courses)) print(\"各课程平均分:\") for course_id, avg_score in pairs(GradeSystem.statistics.average_scores) do local course = GradeSystem.courses[course_id] if course then print(string.format(\" %s: %.2f\", course.name, avg_score)) end end\nend local function main() local start_time = os.clock() demonstrate_system_workflow() local end_time = os.clock() print(string.format(\"\\n程序执行时间: %.3f 秒\", end_time - start_time))\nend -- 运行主程序\nmain()\n<br>（答案见<a data-href=\"第 1 节 - 语法/参考答案#练习 10.2：模拟数据库操作错误处理\" href=\"第-1-节-语法/参考答案.html#练习 10.2：模拟数据库操作错误处理\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 10.2：模拟数据库操作错误处理</a>）-- 模拟数据库操作的错误处理\n-- 使用示例：\n-- 使用数据库\nprint(\"数据库操作测试:\")\nlocal db = data_base.new { host = \"localhost\", database = \"mydb\", username = \"admin\", password = \"secret\"\n} -- 包装数据库操作为安全操作\nfunction safe_database_operation(db, operation_name, operation, ...) print(\"\\n操作: \" .. operation_name) local result, err = db:safe_execute(operation, ...) if result then print(\" 成功\") return result else local _, user_msg = handle_error(err, operation_name) print(\" 失败: \" .. user_msg) return nil, err end\nend -- 测试各种操作\n-- 连接数据库\nsafe_database_operation(db, \"连接数据库\", db.connect) -- 查询数据\nlocal users, err = safe_database_operation(db, \"查询用户\", function(self) return self:query(\"SELECT * FROM users WHERE status = 'active'\")\nend) if users then print(\" 查询到 \" .. #users .. \" 个用户\")\nend -- 测试插入重复数据\nlocal insert_result, err = safe_database_operation(db, \"插入用户\", function(self) return self:query(\"INSERT INTO users (name, email) VALUES (?, ?)\", { \"测试用户\", \"duplicate@example.com\" })\nend) -- 测试事务\nprint(\"\\n测试事务操作:\")\nlocal transaction_success, transaction_err = pcall(function() db:begin_transaction() -- 多个操作 db:query(\"UPDATE accounts SET balance = balance - 100 WHERE id = 1\") db:query(\"UPDATE accounts SET balance = balance + 100 WHERE id = 2\") db:commit() print(\" 事务执行成功\")\nend) if not transaction_success then print(\" 事务失败: \" .. tostring(transaction_err)) if db.transaction_active then db:rollback() end\nend -- 断开连接\nsafe_database_operation(db, \"断开连接\", db.disconnect)\n--[[ 输出\n操作: 连接数据库 连接数据库 localhost:3306...\n[错误处理] 类型: NETWORK_ERROR (300) 消息: 数据库连接失败 详情: table: 00E5CEA0 上下文: 连接数据库 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:114: in function &lt;test.lua:104&gt; [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:267: in main chunk [C]: ? 失败: 网络错误，请稍后重试 操作: 查询用户 检测到连接问题，尝试重连... 连接数据库 localhost:3306...\n[错误处理] 类型: DATABASE_ERROR (200) 消息: 数据库未连接 上下文: 查询用户 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:126: in function &lt;test.lua:124&gt; (tail call): ? [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:270: in main chunk [C]: ? 失败: 系统错误，请联系技术支持 操作: 插入用户 检测到连接问题，尝试重连... 连接数据库 localhost:3306...\n[错误处理] 类型: DATABASE_ERROR (200) 消息: 数据库未连接 上下文: 插入用户 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:126: in function &lt;test.lua:124&gt; (tail call): ? [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:279: in main chunk [C]: ? 失败: 系统错误，请联系技术支持 测试事务操作: 开始事务 事务失败: table: 00E5CF68 回滚事务 操作: 断开连接 断开数据库连接 成功\n--]] 断点的使用： 代码行左侧打断点\n使用控制栏控制程序运行\n使用调用堆栈查看函数调用链\n在调试控制台执行 Lua 代码\n使用监视变量快速查找指定变量 控制栏的使用： 继续：继续运行程序\n逐过程：运行下一行代码\n单步：运行下一行代码，包括函数内\n单步跳出：跳出当前代码块 特殊断点： 条件断点：判断通过触发，过滤无关触发\n命中断点：命中指定次数触发，适合递归与循环\n日志断点：不中断程序，打印临时日志\n等待断点：指定断点触发后触发 错误类型： 语法错误：代码块未闭合\n运行错误：索引 nil\n逻辑错误：结果错误\n资源错误：未找到文件、内存不足、栈溢出 错误处理： pcall：保护调用，捕获错误\nxpcall：带错误处理函数的保护调用\nerror：主动抛出错误\nassert：条件断言，失败时抛出错误 错误处理策略： 防御性编程\n错误恢复（重试、降级、隔离）\n错误日志和监控\n自定义错误类型 最佳实践： 输入验证\n资源清理\n错误传播\n用户友好错误消息 -- 模式 1：立即返回错误\nfunction process_data(data) if not data then return nil, \"数据不能为空\" end -- 处理数据... return result\nend -- 模式 2：抛出异常\nfunction validate_input(input) if not input then error(\"输入不能为空\", 2) end -- 验证通过...\nend -- 模式 3：使用断言\nfunction critical_operation(param) assert(param ~= nil, \"参数不能为 nil\") -- 关键操作...\nend -- 模式 4：错误转换\nfunction api_wrapper(func) return function(...) local success, result = pcall(func, ...) if not success then -- 转换为 API 错误格式 return {success = false, error = result} end return {success = true, data = result} end\nend\n-- 陷阱 1：忽略错误\nlocal file = io.open(\"missing.txt\", \"r\")\nlocal content = file:read(\"*all\") -- 如果文件不存在，file 是 nil，这里会崩溃\nfile:close() -- 正确做法\nlocal file, err = io.open(\"missing.txt\", \"r\")\nif not file then print(\"错误: \" .. err) return\nend -- 陷阱 2：错误信息不明确\nlocal function bad_error_handling() local success, result = pcall(some_operation) if not success then print(\"错误\") -- 不明确 end\nend -- 正确做法\nlocal function good_error_handling() local success, result = pcall(some_operation) if not success then print(\"操作失败: \" .. result) print(\"调用栈: \" .. debug.traceback()) end\nend -- 陷阱 3：过度使用 pcall\nlocal function overuse_pcall() -- 每个操作都用 pcall 包装，性能差且代码冗长 local s1, r1 = pcall(operation1) local s2, r2 = pcall(operation2) local s3, r3 = pcall(operation3) -- ...\nend -- 正确做法：在合适的层级处理错误\nlocal function proper_error_handling() local function inner() operation1() operation2() operation3() end local success, err = pcall(inner) if not success then -- 统一处理错误 handle_error(err) end\nend -- 陷阱 4：资源泄漏\nlocal function resource_leak() local file = io.open(\"test.txt\", \"w\") file:write(\"数据\") -- 忘记关闭文件！ -- 如果后面发生错误，文件永远不会关闭\nend -- 正确做法：确保资源释放\nlocal function proper_resource_handling() local file, err = io.open(\"test.txt\", \"w\") if not file then return nil, err end local success, result = pcall(function() file:write(\"数据\") -- 其他可能失败的操作... end) -- 无论如何都关闭文件 file:close() if not success then return nil, result end return true\nend\n-- 错误处理对性能的影响 -- 1. pcall 有一定开销，避免在紧循环中使用\nlocal function benchmark_pcall() local start = os.clock() -- 直接调用 for i = 1, 100000 do local _ = math.sqrt(i) end local time1 = os.clock() - start start = os.clock() -- 使用 pcall for i = 1, 100000 do local success, result = pcall(math.sqrt, i) end local time2 = os.clock() - start print(\"直接调用: \" .. time1 .. \"秒\") print(\"pcall 调用: \" .. time2 .. \"秒\") print(\"开销: \" .. (time2 - time1) .. \"秒\")\nend -- 2. 在适当层级处理错误，避免不必要的包装\n-- 不好：每个函数都用 pcall\nlocal function process_data_unsafe(data) local s1, r1 = pcall(validate, data) local s2, r2 = pcall(transform, data) local s3, r3 = pcall(save, data) -- 检查每个结果...\nend -- 好：在高层统一处理\nlocal function process_data_safe(data) local function process() validate(data) transform(data) save(data) end local success, err = pcall(process) if not success then return nil, err end return true\nend\n（点击勾选框勾选）\n完成本章后，你应该能够：\n会使用各种调试功能\n理解 Lua 的错误处理机制\n使用 pcall 和 xpcall 保护代码执行\n使用 error 和 assert 主动抛出错误\n实现防御性编程策略\n设计错误恢复机制\n创建和使用自定义错误类型\n记录和监控错误信息\n避免常见的错误处理陷阱 为什么需要这么多调试功能？\n什么时候应该返回错误码，什么时候应该抛出异常？\n如何处理不可恢复的错误（如内存不足）？\n如何在分布式系统中传播和处理错误？\n错误处理策略如何影响代码的可读性和可维护性？\n如何平衡错误处理的完整性和性能开销？ 实现一个完整的错误处理框架，支持错误分类，包括完整日志模块\n实现一个智能重试机制，根据错误类型动态调整重试策略\n下一章预告：在第 11 章中，我们将学习迭代器和泛型 for。这是 Lua 中非常强大的特性，让我们能够以统一的方式遍历各种数据结构，包括自定义的数据结构。我们将学习如何创建和使用迭代器，理解泛型 for 的工作原理，以及如何实现各种复杂的遍历模式。学习建议：\n多使用断点，了解错误都会在什么情况下触发\n在实际编码中养成错误处理的习惯\n从简单错误处理开始，逐步实现更复杂的策略\n注意区分可恢复错误和不可恢复错误\n记录错误信息，便于调试和维护\n定期审查错误处理代码，确保其正确性和完整性\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"10.1 为什么要使用断点调试？","level":3,"id":"10.1_为什么要使用断点调试？_0"},{"heading":"10.2 断点基础使用","level":2,"id":"10.2_断点基础使用_0"},{"heading":"10.1.2 控制栏说明","level":3,"id":"10.1.2_控制栏说明_0"},{"heading":"10.1.3 调用堆栈","level":3,"id":"10.1.3_调用堆栈_0"},{"heading":"10.3 调试控制台","level":2,"id":"10.3_调试控制台_0"},{"heading":"10.4 监视变量","level":2,"id":"10.4_监视变量_0"},{"heading":"10.5 特殊断点","level":2,"id":"10.5_特殊断点_0"},{"heading":"10.5.1 条件断点（表达式）","level":3,"id":"10.5.1_条件断点（表达式）_0"},{"heading":"10.5.2 命中断点（命中次数）","level":3,"id":"10.5.2_命中断点（命中次数）_0"},{"heading":"10.5.3 日志断点（记录点）","level":3,"id":"10.5.3_日志断点（记录点）_0"},{"heading":"10.3.4 等待断点（触发的断点）","level":3,"id":"10.3.4_等待断点（触发的断点）_0"},{"heading":"10.6 常见调试场景","level":2,"id":"10.6_常见调试场景_0"},{"heading":"1. 循环调试","level":3,"id":"1._循环调试_0"},{"heading":"2. 递归函数调试","level":3,"id":"2._递归函数调试_0"},{"heading":"3. 辅助阅读代码","level":3,"id":"3._辅助阅读代码_0"},{"heading":"10.7 为什么需要错误处理？","level":2,"id":"10.7_为什么需要错误处理？_0"},{"heading":"10.8 Lua 的错误类型","level":2,"id":"10.8_Lua_的错误类型_0"},{"heading":"1. 语法错误","level":4,"id":"1._语法错误_0"},{"heading":"2. 运行时错误","level":4,"id":"2._运行时错误_0"},{"heading":"3. 逻辑错误","level":4,"id":"3._逻辑错误_0"},{"heading":"4. 资源错误","level":4,"id":"4._资源错误_0"},{"heading":"10.9 错误信息","level":2,"id":"10.9_错误信息_0"},{"heading":"10.10 错误处理","level":2,"id":"10.10_错误处理_0"},{"heading":"10.10.1 pcall - 保护调用","level":3,"id":"10.10.1_pcall_-_保护调用_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"10.10.2 xpcall - 带错误处理的保护调用","level":3,"id":"10.10.2_xpcall_-_带错误处理的保护调用_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"10.10.3 error - 抛出错误","level":3,"id":"10.10.3_error_-_抛出错误_0"},{"heading":"示例","level":4,"id":"示例_2"},{"heading":"10.10.4 assert - 断言","level":3,"id":"10.10.4_assert_-_断言_0"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"10.11 错误处理策略","level":2,"id":"10.11_错误处理策略_0"},{"heading":"10.11.1 防御性编程","level":3,"id":"10.11.1_防御性编程_0"},{"heading":"10.11.2 错误恢复策略","level":3,"id":"10.11.2_错误恢复策略_0"},{"heading":"10.12 自定义错误类型","level":2,"id":"10.12_自定义错误类型_0"},{"heading":"10.13 练习","level":2,"id":"10.13_练习_0"},{"heading":"练习 1：使用断点阅读代码","level":3,"id":"练习_1：使用断点阅读代码_0"},{"heading":"练习 2：模拟数据库操作错误处理","level":3,"id":"练习_2：模拟数据库操作错误处理_0"},{"heading":"10.14 本章总结","level":2,"id":"10.14_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"错误处理模式","level":3,"id":"错误处理模式_0"},{"heading":"常见错误处理陷阱","level":3,"id":"常见错误处理陷阱_0"},{"heading":"性能考虑","level":3,"id":"性能考虑_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"},{"heading":"拓展练习","level":3,"id":"拓展练习_0"}],"links":["第-1-节-语法/参考答案.html#练习 10.2：模拟数据库操作错误处理"],"author":"","coverImageURL":".","fullURL":"第-1-节-语法/10.-调试与错误处理.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251225185539.png","site-lib/media/pasted-image-20251225185723.png","site-lib/media/pasted-image-20251225185853.png","site-lib/media/pasted-image-20251225190026.png","site-lib/media/pasted-image-20251225190451.png","site-lib/media/pasted-image-20251225191640.png","site-lib/media/pasted-image-20251225195034.png","site-lib/media/pasted-image-20251225203906.png","site-lib/media/pasted-image-20251225201739.png","site-lib/media/pasted-image-20251225202221.png"],"createdTime":1765335739434,"modifiedTime":1766744878665,"sourceSize":63901,"sourcePath":"第 1 节 - 语法/10. 调试与错误处理.md","exportPath":"第-1-节-语法/10.-调试与错误处理.html","showInTree":true,"treeOrder":11,"backlinks":[],"type":"markdown"},"第-1-节-语法/11.-迭代器与泛型for.html":{"title":"11. 迭代器与泛型for","icon":"","description":"在编程中，我们经常需要遍历集合中的元素。迭代器提供了一种统一的方式来访问各种数据结构。-- 不使用迭代器的问题\nlocal fruits = {\"苹果\", \"香蕉\", \"橙子\", \"葡萄\"} -- 方式1：使用数值for循环\nprint(\"方式1 - 数值for循环:\")\nfor i = 1, #fruits do print(\" 水果\" .. i .. \": \" .. fruits[i])\nend -- 问题：需要知道数据结构（是数组），需要知道长度\n-- 对于不是数组的表，这种方法无效 local student = { name = \"小明\", age = 18, grade = \"高三\"\n} -- 方式2：使用pairs（但不是标准迭代器方式）\nprint(\"\\n方式2 - 使用pairs:\")\nfor k, v in pairs(student) do print(\" \" .. k .. \": \" .. v)\nend -- 问题：顺序不确定，不能控制遍历逻辑 -- 迭代器可以解决这些问题！\nprint(\"\\n使用迭代器的优势:\")\nprint(\" 1. 统一的遍历接口\")\nprint(\" 2. 封装遍历逻辑\")\nprint(\" 3. 支持复杂遍历模式\")\nprint(\" 4. 惰性求值（需要时才计算）\")\n迭代器是一个能够生成序列中下一个值的函数。在 Lua 中，迭代器通常遵循以下模式：-- 迭代器三要素：\n-- 1. 迭代器函数：每次调用返回下一个值\n-- 2. 不可变状态：遍历过程中不变的数据\n-- 3. 控制变量：当前遍历位置 -- 简单的迭代器示例：生成数字序列\nlocal function number_iterator(max) local i = 0 -- 控制变量（初始值） -- 迭代器函数 return function() i = i + 1 if i &lt;= max then return i -- 返回下一个值 end -- 返回nil表示结束 end\nend print(\"数字序列迭代器:\")\nlocal iter = number_iterator(5) print(\" 第一次调用: \" .. (iter() or \"nil\"))\nprint(\" 第二次调用: \" .. (iter() or \"nil\"))\nprint(\" 第三次调用: \" .. (iter() or \"nil\"))\nprint(\" 第四次调用: \" .. (iter() or \"nil\"))\nprint(\" 第五次调用: \" .. (iter() or \"nil\"))\nprint(\" 第六次调用: \" .. (iter() or \"nil\")) -- 超过范围，返回nil\n--[[ 输出\n第一次调用: 1\n第二次调用: 2\n第三次调用: 3\n第四次调用: 4\n第五次调用: 5\n第六次调用: nil\n--]]\n泛型 for 循环是 Lua 中使用迭代器的主要方式：for -&gt;迭代器返回的参数: any... in 迭代器函数: func, 不可变状态: any, 控制变量: any do -- 循环体\nend\n-- 基本示例\nprint(\"基本示例 - 遍历数组:\")\nlocal colors = {\"红色\", \"绿色\", \"蓝色\", \"黄色\"} for i, color in ipairs(colors) do print(\" 颜色\" .. i .. \": \" .. color)\nend\n--[[ 输出\n颜色1: 红色\n颜色2: 绿色\n颜色3: 蓝色\n颜色4: 黄色\n--]] -- ipairs实际上是一个迭代器工厂，返回上述三个值\nprint(\"\\nipairs的工作原理:\")\nlocal iter, t, i = ipairs(colors)\nprint(\" 迭代器函数: \" .. type(iter))\nprint(\" 不可变状态: \" .. tostring(t))\nprint(\" 控制变量: \" .. tostring(i))\n--[[ 输出\n迭代器函数: function\n不可变状态: table: 00D99EA0\n控制变量: 0\n--]] -- 手动模拟泛型for循环\nprint(\"\\n手动模拟泛型for循环:\")\nlocal iterator_func, invariant_state, control_var = ipairs(colors)\nlocal var1, var2 = iterator_func(invariant_state, control_var) while var1 do print(\" 索引: \" .. var1 .. \", 值: \" .. var2) var1, var2 = iterator_func(invariant_state, var1)\nend\n--[[ 输出\n索引: 1, 值: 红色\n索引: 2, 值: 绿色\n索引: 3, 值: 蓝色\n索引: 4, 值: 黄色\n--]]\n-- 这等价于：\n-- for i, color in ipairs(colors) do\n-- print(\" 索引: \" .. i .. \", 值: \" .. color)\n-- end\n-- 1. 初始化：获取三要素\nlocal iterator_func, state, control_var = ipairs(colors) -- 2. 第一次调用，为迭代器函数传递不可变状态与控制变量\ncontrol_var, value... = iterator_func(state, control_var) -- control_var = 0 -&gt; 1 -- 3. 循环直到返回 nil\nwhile control_var do -- 使用控制变量和其他返回值 print(control_var, value...) -- 下一次调用，更新控制变量和其他返回值，注意：不可变状态依旧使用第一次调用时的，不会更新！ control_var, value... = iterator_func(state, control_var)\nend\n示意图：\n<img alt=\"Pasted image 20251211142754.png\" src=\"site-lib/media/pasted-image-20251211142754.png\" target=\"_self\" style=\"width: 1125px; max-width: 100%;\">-- 泛型 for（简洁、安全）\nfor i, v in ipairs(t) do print(i, v)\nend -- 手动实现（理解原理）\nlocal iter, state, var = ipairs(t)\nlocal var1, var2 = iter(state, var)\nwhile var1 do print(var1, var2) var1, var2 = iter(state, var1)\nend\nipairs 用于遍历数组部分（索引从 1 开始）for -&gt;索引: int, -&gt;值: any in ipairs(表: table) do -- 循环体\nend\n-- 基本用法\nlocal numbers = {10, 20, 30, 40, 50}\nprint(\"遍历数组:\")\nfor i, num in ipairs(numbers) do print(\" numbers[\" .. i .. \"] = \" .. num)\nend -- ipairs的特性\nprint(\"\\nipairs的特性:\")\nlocal mixed_table = { \"第一个\", -- 索引1 \"第二个\", -- 索引2 name = \"小明\", -- 键值对，不在数组部分 \"第三个\", -- 索引3 age = 18 -- 键值对\n} print(\"混合表的ipairs遍历:\")\nfor i, value in ipairs(mixed_table) do print(\" 索引 \" .. i .. \": \" .. value)\nend\n-- 注意：只遍历数组部分（索引1, 2, 3），跳过键值对\n--[[ 输出\n混合表的ipairs遍历: 索引 1: 第一个 索引 2: 第二个 索引 3: 第三个\n--]] -- 有\"洞\"的数组\nprint(\"\\n有洞数组的ipairs:\")\nlocal array_with_holes = {\"A\", nil, \"C\", \"D\"}\nfor i, value in ipairs(array_with_holes) do print(\" 索引 \" .. i .. \": \" .. (value or \"nil\"))\nend\n--[[ 输出 索引 1: A\n--]]\n-- 注意：遇到第一个nil就停止，所以只输出索引1\n-- 实现自定义的ipairs（理解原理）\nlocal function my_ipairs(t) local function iterator(state, index) index = index + 1 local value = state[index] if value ~= nil then return index, value end end return iterator, t, 0\nend print(\"\\n自定义ipairs测试:\")\nfor i, value in my_ipairs(numbers) do print(\" numbers[\" .. i .. \"] = \" .. value)\nend\n--[[ 输出\nnumbers[1] = 10\nnumbers[2] = 20\nnumbers[3] = 30\nnumbers[4] = 40\nnumbers[5] = 50\n--]]\npairs用于遍历表的所有键值对。for -&gt;键: any, -&gt;键值: any in ipairs(表: table) do -- 循环体\nend\n-- 基本用法\nlocal student = { name = \"李雷\", age = 16, grade = \"高一\", class = \"1班\", scores = {85, 92, 78}\n} print(\"遍历学生信息:\")\nfor key, value in pairs(student) do if type(value) == \"table\" then print(\" \" .. key .. \": [表]\") else print(\" \" .. key .. \": \" .. tostring(value)) end\nend -- pairs的特性\nprint(\"\\npairs的特性:\")\nprint(\" 1. 遍历所有键值对（包括数组部分和字典部分）\")\nprint(\" 2. 遍历顺序不确定（依赖表的实现）\")\nprint(\" 3. 可以遍历任何类型的键（除了nil）\") -- 包含各种类型键的表\nlocal complex_table = { [1] = \"数字键1\", [\"1\"] = \"字符串键1\", [true] = \"布尔键\", [function() end] = \"函数键\", -- 不常见但可能 normal = \"普通键\"\n} print(\"\\n复杂键表的pairs遍历:\")\nfor k, v in pairs(complex_table) do local key_type = type(k) if key_type == \"function\" then print(\" 函数键: \" .. v) else print(\" \" .. key_type .. \"键 '\" .. tostring(k) .. \"': \" .. v) end\nend\nlocal function my_pairs(t) local function iterator(state, key) -- 获取下一个键值对 local next_key, next_value = next(state, key) return next_key, next_value end return iterator, t, nil\nend print(\"\\n自定义pairs测试:\")\nlocal count = 0\nfor key, value in my_pairs(student) do if count &lt; 3 then -- 只显示前3个 print(\" \" .. key .. \": \" .. tostring(value)) end count = count + 1\nend\nprint(\" 总键值对数: \" .. count)\n--[[ 输出\nscores: table: 00E09E50\nname: 李雷\nclass: 1班\n总键值对数: 5\n--]]\n-- next函数的使用\nprint(\"\\nnext函数演示:\")\nlocal t = {a = 1, b = 2, c = 3}\nlocal key, value = next(t) -- 第一个键值对\nprint(\" 第一个: \" .. key .. \" = \" .. value) key, value = next(t, key) -- 第二个键值对\nprint(\" 第二个: \" .. key .. \" = \" .. value) key, value = next(t, key) -- 第三个键值对\nprint(\" 第三个: \" .. key .. \" = \" .. value) key, value = next(t, key) -- 没有更多，返回nil\nprint(\" 第四个: \" .. tostring(key) .. \" = \" .. tostring(value))\n--[[ 输出\n第一个: a = 1\n第二个: c = 3\n第三个: b = 2\n第四个: nil = nil\n--]]\nstring.gmatch 用于匹配多个模式。string.gmatch(字符串: str, 匹配模式: str) -&gt; 迭代器函数: func\n-- 基本用法：遍历单词\nlocal sentence = \"The quick brown fox jumps over the lazy dog\"\nprint(\"句子: \" .. sentence)\nprint(\"\\n遍历单词:\") for word in string.gmatch(sentence, \"%a+\") do print(\" 单词: \" .. word)\nend -- 提取特定模式\nlocal data = \"姓名: 张三, 年龄: 25, 城市: 北京, 职业: 工程师\"\nprint(\"\\n提取键值对:\") for key, value in string.gmatch(data, \"(%a+):%s*([^,]+)\") do print(\" \" .. key .. \": \" .. value)\nend -- 解析CSV行\nlocal csv_line = \"苹果,5,2.5,12.5\"\nprint(\"\\n解析CSV:\")\nlocal index = 1\nfor field in string.gmatch(csv_line, \"([^,]+)\") do print(\" 字段\" .. index .. \": \" .. field) index = index + 1\nend -- 解析多行文本\nlocal multiline_text = [[\n第一行内容\n第二行内容\n第三行内容\n第四行内容\n]] print(\"\\n遍历文本行:\")\nlocal line_number = 1\nfor line in string.gmatch(multiline_text, \"([^\\n]+)\") do print(\" 行\" .. line_number .. \": \" .. line) line_number = line_number + 1\nend -- 提取URL参数\nlocal url = \"https://example.com/search?q=lua&amp;page=2&amp;sort=recent\"\nprint(\"\\n提取URL参数:\") -- 找到查询字符串部分\nlocal query_string = string.match(url, \"%?(.+)\") or \"\"\nfor param in string.gmatch(query_string, \"([^&amp;]+)\") do local key, value = string.match(param, \"([^=]+)=?(.*)\") print(\" 参数: \" .. key .. \" = \" .. (value ~= \"\" and value or \"true\"))\nend -- 实现自定义的字符串分割迭代器\nlocal function split_string(str, delimiter) delimiter = delimiter or \" \" local pattern = string.format(\"([^%s]+)\", delimiter) return string.gmatch(str, pattern)\nend print(\"\\n自定义字符串分割:\")\nlocal text = \"苹果 香蕉 橙子 葡萄 西瓜\"\nfor fruit in split_string(text) do print(\" 水果: \" .. fruit)\nend\n--[[ 输出\n水果: 苹果\n水果: 香蕉\n水果: 橙子\n水果: 葡萄\n水果: 西瓜\n--]]\n-- 更高级的字符串迭代器：逐字符遍历\nlocal function chars(str) local chars = {} local i = 1 local len = #str while i &lt;= len do local b = string.byte(str, i) local char_len -- UTF-8 字符长度检测 if b &lt; 128 then -- ASCII char_len = 1 elseif b &gt;= 194 and b &lt;= 223 then char_len = 2 elseif b &gt;= 224 and b &lt;= 239 then char_len = 3 elseif b &gt;= 240 and b &lt;= 244 then char_len = 4 else char_len = 1 -- 无效字节 end table.insert(chars, string.sub(str, i, i + char_len - 1)) i = i + char_len end return chars\nend local chars = chars(\"你好 Hello 世界!\")\nfor i, char in ipairs(chars) do print(\" 字符 \" .. i .. \": '\" .. char .. \"' (字节长度: \" .. #char .. \", ASCII: \" .. string.byte(char) .. \")\")\nend\n--[[ 输出\n字符 1: '你' (字节长度: 3, ASCII: 228)\n字符 2: '好' (字节长度: 3, ASCII: 229)\n字符 3: ' ' (字节长度: 1, ASCII: 32)\n字符 4: 'H' (字节长度: 1, ASCII: 72)\n字符 5: 'e' (字节长度: 1, ASCII: 101)\n字符 6: 'l' (字节长度: 1, ASCII: 108)\n字符 7: 'l' (字节长度: 1, ASCII: 108)\n字符 8: 'o' (字节长度: 1, ASCII: 111)\n字符 9: ' ' (字节长度: 1, ASCII: 32)\n字符 10: '世' (字节长度: 3, ASCII: 228)\n字符 11: '界' (字节长度: 3, ASCII: 231)\n字符 12: '!' (字节长度: 1, ASCII: 33)\n--]]\n无状态迭代器不保存任何状态，所有状态都通过参数传递。-- 示例：遍历数组的无状态迭代器\nlocal function array_iterator(t, index) index = index + 1 local value = t[index] if value then return index, value end\nend local function iter_array(t) return array_iterator, t, 0\nend -- 使用\nlocal fruits = {\"苹果\", \"香蕉\", \"橙子\"}\nprint(\"无状态迭代器遍历数组:\")\nfor i, fruit in iter_array(fruits) do print(\" fruits[\" .. i .. \"] = \" .. fruit)\nend -- 对比：有状态迭代器（使用闭包）\nlocal function stateful_array_iterator(t) local i = 0 return function() i = i + 1 local value = t[i] if value then return i, value end end\nend print(\"\\n有状态迭代器遍历数组:\")\nfor i, fruit in stateful_array_iterator(fruits) do print(\" fruits[\" .. i .. \"] = \" .. fruit)\nend -- 无状态迭代器的优势\nprint(\"\\n无状态迭代器优势:\")\nprint(\" 1. 更高效：不创建闭包\")\nprint(\" 2. 可复用：相同的迭代器函数可用于多个表\")\nprint(\" 3. 更简单：状态管理由泛型for处理\") -- 实现一个无状态迭代器来遍历表的键值对\nlocal function next_pair(t, key) return next(t, key)\nend local function iter_pairs(t) return next_pair, t, nil\nend print(\"\\n无状态pairs迭代器:\")\nlocal colors = {red = \"红色\", green = \"绿色\", blue = \"蓝色\"}\nfor key, value in iter_pairs(colors) do print(\" \" .. key .. \": \" .. value)\nend\n-- 创建各种无状态迭代器 -- 1. 数字范围迭代器\nlocal function range_iterator(limit, current) current = current + 1 if current &lt;= limit then return current end\nend local function range(from, to) return range_iterator, to, from - 1 -- 注意：控制变量初始化为from-1\nend print(\"数字范围迭代器:\")\nfor i in range(5, 10) do print(\" i = \" .. i)\nend\n--[[ 输出\ni = 5\ni = 6\ni = 7\ni = 8\ni = 9\ni = 10\n--]] -- 2. 质数迭代器\nlocal function is_prime(n) if n &lt; 2 then return false end if n == 2 then return true end if n % 2 == 0 then return false end for i = 3, math.sqrt(n), 2 do if n % i == 0 then return false end end return true\nend local function prime_iterator(limit, current) -- 找到下一个质数 repeat current = current + 1 if current &gt; limit then return nil end until is_prime(current) return current\nend local function primes(limit) return prime_iterator, limit, 1 -- 从1开始（实际从2开始检查）\nend print(\"\\n质数迭代器（小于50的质数）:\")\nfor prime in primes(50) do io.write(prime .. \" \")\nend\nprint()\n-- 输出 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 -- 3. 文件行迭代器\nlocal function lines_iterator(file, lines) return table.remove(file, 1)\nend local function lines(file) -- 返回迭代器函数、文件和nil（初始控制变量） return lines_iterator, file, nil\nend print(\"\\n文件行迭代器（模拟）:\")\n-- 为了演示，我们模拟文件内容\nlocal mock_file_content = { \"第一行内容\", \"第二行内容\", \"第三行内容\", nil -- 文件结束\n} for line in lines(mock_file_content) do print(\" \" .. line)\nend\n--[[ 输出\n第一行内容\n第二行内容\n第三行内容\n--]] -- 4. 表格行迭代器\nlocal function table_rows_iterator(t, row_index) row_index = row_index + 1 local row = t[row_index] if row then return row_index, unpack(row) end\nend local function table_rows(t) return table_rows_iterator, t, 0\nend local data_table = { { \"张三\", 18, \"男\" }, { \"李四\", 19, \"女\" }, { \"王五\", 20, \"男\" }\n} print(\"\\n表格行迭代器:\")\nfor row_index, name, age, gender in table_rows(data_table) do print(string.format(\" 行%d: 姓名=%s, 年龄=%d, 性别=%s\", row_index, name, age, gender))\nend\n--[[ 输出\n行1: 姓名=张三, 年龄=18, 性别=男\n行2: 姓名=李四, 年龄=19, 性别=女\n行3: 姓名=王五, 年龄=20, 性别=男\n--]]\n有状态迭代器使用闭包来保存状态，更灵活但可能效率稍低。-- 有状态迭代器：使用闭包保存状态 -- 1. 计数器迭代器\nlocal function counter(max) local count = 0 return function() count = count + 1 if count &lt;= max then return count end end\nend print(\"计数器迭代器:\")\nfor num in counter(5) do print(\" 计数: \" .. num)\nend\n--[[ 输出 计数: 1 计数: 2 计数: 3 计数: 4 计数: 5\n--]] -- 2. 斐波那契数列迭代器\nlocal function fibonacci_iterator(limit) local a, b = 0, 1 local count = 0 return function() if count &gt;= limit then return nil end local result = a a, b = b, a + b count = count + 1 return result end\nend print(\"\\n斐波那契数列迭代器（前10项）:\")\nfor num in fibonacci_iterator(10) do io.write(num .. \" \")\nend\nprint()\n-- 输出\n0 1 1 2 3 5 8 13 21 34 -- 3. 随机数迭代器\nlocal function random_iterator(count, min, max) math.randomseed(os.time()) local generated = 0 return function() if generated &gt;= count then return nil end generated = generated + 1 return math.random(min, max) end\nend print(\"\\n随机数迭代器（5个1-100的随机数）:\")\nfor num in random_iterator(5, 1, 100) do io.write(num .. \" \")\nend\nprint()\n-- 输出 68 74 70 95 72（以实际为准） -- 4. 目录遍历迭代器（模拟）\nlocal function directory_iterator(dir_path) -- 模拟的目录内容 local mock_files = { {name = \"file1.txt\", type = \"file\", size = 1024}, {name = \"file2.txt\", type = \"file\", size = 2048}, {name = \"subdir1\", type = \"dir\", size = 0}, {name = \"file3.txt\", type = \"file\", size = 3072}, } local index = 0 return function() index = index + 1 local item = mock_files[index] if item then return item.name, item.type, item.size end end\nend print(\"\\n目录遍历迭代器:\")\nfor filename, filetype, filesize in directory_iterator(\"/mock/path\") do local type_desc = filetype == \"dir\" and \"目录\" or \"文件\" print(string.format(\" %s (%s, %d 字节)\", filename, type_desc, filesize))\nend\n--[[ 输出\nfile1.txt (文件, 1024 字节)\nfile2.txt (文件, 2048 字节)\nsubdir1 (目录, 0 字节)\nfile3.txt (文件, 3072 字节)\n--]] -- 5. 数据库查询结果迭代器（模拟）\nlocal function db_query_iterator(query) -- 模拟查询结果 local mock_results = { {id = 1, name = \"张三\", age = 25}, {id = 2, name = \"李四\", age = 30}, {id = 3, name = \"王五\", age = 28}, {id = 4, name = \"赵六\", age = 35}, } local index = 0 return function() index = index + 1 local row = mock_results[index] if row then return row.id, row.name, row.age end end\nend print(\"\\n数据库查询迭代器:\")\nfor id, name, age in db_query_iterator(\"SELECT * FROM users\") do print(string.format(\" ID: %d, 姓名: %s, 年龄: %d\", id, name, age))\nend\n--[[ 输出\nID: 1, 姓名: 张三, 年龄: 25\nID: 2, 姓名: 李四, 年龄: 30\nID: 3, 姓名: 王五, 年龄: 28\nID: 4, 姓名: 赵六, 年龄: 35\n--]]\n-- 1. 分页数据迭代器\nlocal function paged_data_iterator(page_size, total_items) local current_page = 0 local current_item = 0 return function() -- 计算当前页 if current_item % page_size == 0 then current_page = current_page + 1 print(string.format(\" 加载第%d页...\", current_page)) end current_item = current_item + 1 if current_item &gt; total_items then return nil end -- 模拟数据项 return current_item, \"项目\" .. current_item end\nend print(\"分页数据迭代器（每页3项，共10项）:\")\nfor id, name in paged_data_iterator(3, 10) do print(string.format(\" ID: %d, 名称: %s\", id, name))\nend\n--[[ 输出\n加载第1页... ID: 1, 名称: 项目1 ID: 2, 名称: 项目2 ID: 3, 名称: 项目3\n加载第2页... ID: 4, 名称: 项目4 ID: 5, 名称: 项目5 ID: 6, 名称: 项目6\n加载第3页... ID: 7, 名称: 项目7 ID: 8, 名称: 项目8 ID: 9, 名称: 项目9\n加载第4页... ID: 10, 名称: 项目10\n--]] -- 2. 过滤器迭代器\nlocal function filtered_iterator(original_iterator, filter_func) return function() while true do local values = {original_iterator()} if values[1] == nil then return nil -- 原始迭代器结束 end if filter_func(unpack(values)) then return unpack(values) end -- 如果不满足条件，继续下一个 end end\nend print(\"\\n过滤器迭代器:\")\nlocal numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} function number_iterator_from_table(t) local index = 0 return function() index = index + 1 return t[index] end\nend -- 只返回偶数\nlocal even_filter = function(num) return num % 2 == 0\nend print(\"偶数过滤器:\")\nfor num in filtered_iterator(number_iterator_from_table(numbers), even_filter) do io.write(num .. \" \")\nend\nprint()\n-- 输出 2 4 6 8 10 -- 3. 转换迭代器\nlocal function transformed_iterator(original_iterator, transform_func) return function() local values = {original_iterator()} if values[1] == nil then return nil end return transform_func(unpack(values)) end\nend print(\"\\n转换迭代器:\")\n-- 将数字转换为平方\nlocal square_transform = function(num) return num, num * num\nend print(\"平方转换:\")\nfor num, square in transformed_iterator(number_iterator_from_table(numbers), square_transform) do print(string.format(\" %d² = %d\", num, square))\nend\n--[[ 输出\n1² = 1\n2² = 4\n3² = 9\n4² = 16\n5² = 25\n6² = 36\n7² = 49\n8² = 64\n9² = 81\n10² = 100\n--]] -- 4. 组合多个迭代器\nlocal function zip_iterators(...) local iterators = {...} local current_values = {} return function() -- 收集每个迭代器的下一个值 for i, iter in ipairs(iterators) do current_values[i] = {iter()} -- 如果任何一个迭代器结束，就全部结束 if current_values[i][1] == nil then return nil end end -- 返回所有值 local result = {} for i, values in ipairs(current_values) do for j, value in ipairs(values) do table.insert(result, value) end end return unpack(result) end\nend print(\"\\n组合迭代器（zip）:\")\nlocal names = {\"张三\", \"李四\", \"王五\"}\nlocal ages = {25, 30, 28}\nlocal cities = {\"北京\", \"上海\", \"广州\"} local name_iter = number_iterator_from_table(names)\nlocal age_iter = number_iterator_from_table(ages)\nlocal city_iter = number_iterator_from_table(cities) for name, age, city in zip_iterators(name_iter, age_iter, city_iter) do print(string.format(\" 姓名: %s, 年龄: %d, 城市: %s\", name, age, city))\nend\n--[[ 输出\n姓名: 张三, 年龄: 25, 城市: 北京\n姓名: 李四, 年龄: 30, 城市: 上海\n姓名: 王五, 年龄: 28, 城市: 广州\n--]]\n-- 树结构的迭代器\n-- 定义树节点\nlocal tree_node = {} function tree_node.new(value) local node = { value = value, children = {}, add_child = tree_node.add_child } return node\nend function tree_node:add_child(child) table.insert(self.children, child) return self\nend -- 创建一棵树\nlocal root = tree_node.new(\"root\")\nlocal node_a = tree_node.new(\"A\")\nlocal node_b = tree_node.new(\"B\")\nlocal node_a1 = tree_node.new(\"a1\")\nlocal node_a2 = tree_node.new(\"a2\")\nlocal node_b1 = tree_node.new(\"b1\")\nlocal node_b2 = tree_node.new(\"b2\") root:add_child(node_a):add_child(node_b)\nnode_a:add_child(node_a1):add_child(node_a2)\nnode_b:add_child(node_b1):add_child(node_b2)\nprint([[ 创建树： root / \\ A B / \\ / \\\na1 a2 b1 b2\n--]]) -- 先序遍历迭代器（沿着一个分支走到底，再遍历下一个分支）\nlocal function preorder_iterator(node) local stack = { node } local index = 1 return function() if index &gt; #stack then return nil end local current = stack[index] index = index + 1 -- 将子节点逆序加入栈（保证左子节点先处理） for i = #current.children, 1, -1 do table.insert(stack, index, current.children[i]) end return current.value end\nend print(\"先序遍历:\")\nfor value in preorder_iterator(root) do io.write(value .. \" \")\nend\nprint() -- 广度优先遍历迭代器（按层级遍历，先访问同一层的所有节点）\nlocal function bfs_iterator(node) local queue = { node } local index = 1 return function() if index &gt; #queue then return nil end local current = queue[index] index = index + 1 -- 将子节点加入队列 for _, child in ipairs(current.children) do table.insert(queue, child) end return current.value end\nend print(\"广度优先遍历:\")\nfor value in bfs_iterator(root) do io.write(value .. \" \")\nend\nprint()\n--[[ 输出\n创建树： root / \\ A B / \\ / \\\na1 a2 b1 b2 先序遍历:\nroot A a1 a2 B b1 b2 广度优先遍历:\nroot A B a1 a2 b1 b2 --]]\n-- 图结构的迭代器\n-- 定义图\nlocal Graph = {} function Graph.new() local graph = { vertices = {}, edges = {}, add_vertex = Graph.add_vertex, add_edge = Graph.add_edge } return graph\nend function Graph:add_vertex(name) self.vertices[name] = { name = name, neighbors = {} } return self.vertices[name]\nend function Graph:add_edge(v1_name, v2_name, weight) weight = weight or 1 local v1 = self.vertices[v1_name] local v2 = self.vertices[v2_name] if v1 and v2 then table.insert(v1.neighbors, { vertex = v2, weight = weight }) table.insert(v2.neighbors, { vertex = v1, weight = weight }) -- 无向图 return true end return false\nend -- 创建图\nlocal graph = Graph.new()\ngraph:add_vertex(\"A\")\ngraph:add_vertex(\"B\")\ngraph:add_vertex(\"C\")\ngraph:add_vertex(\"D\")\ngraph:add_vertex(\"E\") graph:add_edge(\"A\", \"B\", 1)\ngraph:add_edge(\"A\", \"C\", 2)\ngraph:add_edge(\"B\", \"D\", 3)\ngraph:add_edge(\"C\", \"D\", 1)\ngraph:add_edge(\"D\", \"E\", 2)\nprint([[创建图：\nA -- B (1)\n| |\nC D (3) \\ / D (1) | E (2)\n]]) -- 深度优先遍历图的迭代器\nlocal function graph_dfs_iterator(graph, start_vertex_name) local visited = {} local stack = { graph.vertices[start_vertex_name] } return function() while #stack &gt; 0 do local current = table.remove(stack) if not visited[current.name] then visited[current.name] = true -- 将未访问的邻居加入栈 for i = #current.neighbors, 1, -1 do local neighbor = current.neighbors[i].vertex if not visited[neighbor.name] then table.insert(stack, neighbor) end end return current.name end end return nil end\nend print(\"图的深度优先遍历（从A开始）:\")\nfor vertex_name in graph_dfs_iterator(graph, \"A\") do io.write(vertex_name .. \" \")\nend\nprint() -- 广度优先遍历图的迭代器\nlocal function graph_bfs_iterator(graph, start_vertex_name) local visited = {} local queue = { graph.vertices[start_vertex_name] } local index = 1 return function() while index &lt;= #queue do local current = queue[index] index = index + 1 if not visited[current.name] then visited[current.name] = true -- 将未访问的邻居加入队列 for _, neighbor_info in ipairs(current.neighbors) do local neighbor = neighbor_info.vertex if not visited[neighbor.name] then table.insert(queue, neighbor) end end return current.name end end return nil end\nend print(\"图的广度优先遍历（从A开始）:\")\nfor vertex_name in graph_bfs_iterator(graph, \"A\") do io.write(vertex_name .. \" \")\nend\nprint() -- 最短路径迭代器（Dijkstra算法简化版）\nlocal function shortest_path_iterator(graph, start_vertex_name, end_vertex_name) local distances = {} local previous = {} local unvisited = {} -- 初始化 for name, vertex in pairs(graph.vertices) do distances[name] = math.huge -- 无穷大 previous[name] = nil table.insert(unvisited, name) end distances[start_vertex_name] = 0 return function() while #unvisited &gt; 0 do -- 找到未访问节点中距离最小的 local min_distance = math.huge local min_vertex = nil local min_index = 0 for i, name in ipairs(unvisited) do if distances[name] &lt; min_distance then min_distance = distances[name] min_vertex = graph.vertices[name] min_index = i end end if not min_vertex or min_distance == math.huge then break -- 没有可达的节点了 end -- 从unvisited中移除 table.remove(unvisited, min_index) -- 如果到达目标节点，构建路径并返回 if min_vertex.name == end_vertex_name then local path = {} local current = end_vertex_name while current do table.insert(path, 1, current) current = previous[current] end return path, distances[end_vertex_name] end -- 更新邻居的距离 for _, neighbor_info in ipairs(min_vertex.neighbors) do local neighbor = neighbor_info.vertex local alt = distances[min_vertex.name] + neighbor_info.weight if alt &lt; distances[neighbor.name] then distances[neighbor.name] = alt previous[neighbor.name] = min_vertex.name end end end return nil -- 没有路径 end\nend print(\"\\n最短路径查找（从A到E）:\")\nfor path, distance in shortest_path_iterator(graph, \"A\", \"E\") do print(\" 路径: \" .. table.concat(path, \" -&gt; \")) print(\" 总距离: \" .. distance)\nend\n--[[ 输出\n创建图：\nA -- B (1)\n| |\nC D (3) \\ / D (1) | E (2) 图的深度优先遍历（从A开始）:\nA B D C E 图的广度优先遍历（从A开始）:\nA B C D E 最短路径查找（从A到E）: 路径: A -&gt; C -&gt; D -&gt; E 总距离: 5\n--]]\n惰性求值：需要时才计算值-- 1. 无限序列迭代器\nlocal function infinite_sequence(start, step) local current = start - (step or 1) return function() current = current + (step or 1) return current end\nend print(\"自然数序列（惰性）:\")\nlocal natural_numbers = infinite_sequence(1)\nfor i = 1, 10 do io.write(natural_numbers() .. \" \")\nend\nprint()\n-- 输出 1 2 3 4 5 6 7 8 9 10 -- 2. 斐波那契数列（惰性无限）\nlocal function fibonacci_generator() local a, b = 0, 1 return function() local result = a a, b = b, a + b return result end\nend print(\"\\n斐波那契数列（惰性无限，前15项）:\")\nlocal fib = fibonacci_generator()\nfor i = 1, 15 do io.write(fib() .. \" \")\nend\nprint()\n-- 输出 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 -- 3. 网络数据流迭代器（模拟）\nlocal function network_stream_iterator(url, buffer_size) buffer_size = buffer_size or 4096 local bytes_sent = 0 local total_bytes = 10240 -- 模拟10KB数据 return function() if bytes_sent &gt;= total_bytes then return nil end local chunk_size = math.min(buffer_size, total_bytes - bytes_sent) bytes_sent = bytes_sent + chunk_size -- 模拟数据块 return string.rep(\"X\", chunk_size) end\nend print(\"网络数据流迭代器（模拟）:\")\nlocal network_stream = network_stream_iterator(\"http://example.com/data\")\nlocal chunk_count = 0\nlocal total_size = 0 for chunk in network_stream do chunk_count = chunk_count + 1 total_size = total_size + #chunk print(string.format(\" 收到块%d: %d字节\", chunk_count, #chunk))\nend print(string.format(\" 总共收到%d块，总大小%d字节\", chunk_count, total_size))\n--[[ 输出\n收到块1: 4096字节\n收到块2: 4096字节\n收到块3: 2048字节\n总共收到3块，总大小10240字节\n--]] -- 4. 数据库查询流迭代器（惰性获取）\nlocal function database_stream_iterator(query, page_size) page_size = page_size or 100 local current_page = 0 local current_index = 0 local current_data = nil return function() -- 如果需要新的一页数据 if current_data == nil or current_index &gt;= #current_data then current_page = current_page + 1 current_index = 0 print(string.format(\" 查询第%d页数据...\", current_page)) -- 模拟数据库查询（实际中这里会有真正的查询） current_data = {} for i = 1, page_size do local item_id = (current_page - 1) * page_size + i if item_id &gt; 250 then -- 模拟总共250条数据 current_data = nil break end table.insert(current_data, { id = item_id, name = \"项目\" .. item_id, value = math.random(100, 1000) }) end if current_data == nil then return nil -- 没有更多数据 end end -- 返回当前数据项 current_index = current_index + 1 local item = current_data[current_index] return item.id, item.name, item.value end\nend print(\"\\n数据库查询流迭代器:\")\nlocal item_count = 0\nfor id, name, value in database_stream_iterator(\"SELECT * FROM items\", 50) do item_count = item_count + 1 if item_count &lt;= 3 or item_count &gt;= 248 then -- 只显示头尾几个 print(string.format(\" ID: %d, 名称: %s, 值: %d\", id, name, value)) elseif item_count == 4 then print(\" ...\") end\nend\nprint(\" 总共查询到 \" .. item_count .. \" 条记录\")\n--[[ 输出\n查询第1页数据...\nID: 1, 名称: 项目1, 值: 101\nID: 2, 名称: 项目2, 值: 607\nID: 3, 名称: 项目3, 值: 274\n...\n查询第2页数据...\n查询第3页数据...\n查询第4页数据...\n查询第5页数据...\nID: 248, 名称: 项目248, 值: 729\nID: 249, 名称: 项目249, 值: 626\nID: 250, 名称: 项目250, 值: 416\n查询第6页数据...\n总共查询到 250 条记录\n--]]\n<br>（答案见<a data-href=\"第 1 节 - 语法/参考答案#练习 11 1：实现一个数据管道系统\" href=\"第-1-节-语法/参考答案.html#练习 11 1：实现一个数据管道系统\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 11 1：实现一个数据管道系统</a>）-- 实现一个数据管道系统，组合多个迭代器处理数据（先收集操作，最后迭代时统一处理数据）\n-- 使用示例：\n-- 构建管道\nlocal pipeline = pipeline_sys.new(number_source(1, 20))\npipeline:filter(function(x) return x % 2 == 0 end) -- 只保留偶数\npipeline:map(function(x) return x * 2 end) -- 乘以2\npipeline:skip(3) -- 跳过前3个\npipeline:take(5) -- 取5个 print(\"管道处理结果:\")\nfor value in pipeline:iterator() do io.write(value .. \" \")\nend\nprint()\n--[[ 输出\n管道处理结果:\n8 12 16 20 24 --]] 迭代器基础： 迭代器是生成序列值的函数\n迭代器三要素：迭代器函数：每次调用返回下一个值，不可变状态：遍历过程中不变的数据，控制变量：当前遍历位置\n泛型 for 循环：for var1, var2, ... in iter, state, init do ... end\nLua 内置迭代器：ipairs, pairs, string.gmatch 无状态迭代器： 所有状态通过参数传递\n更高效，不创建闭包\n示例：ipairs 的实现原理 有状态迭代器： 使用闭包保存状态\n更灵活，可以实现复杂逻辑\n示例：计数器、斐波那契数列 高级迭代器模式： 树和图遍历迭代器\n惰性求值迭代器\n数据管道和查询构建器 -- 1. 简单迭代器模式\nlocal function simple_iterator(data) local index = 0 return function() index = index + 1 return data[index] end\nend -- 2. 无状态迭代器模式\nlocal function stateless_iter(state, index) -- 计算下一个值 local next_index, next_value = ... return next_index, next_value\nend local function iter_factory(data) return stateless_iter, data, initial_index\nend -- 3. 生成器模式\nlocal function generator(pattern) return function() -- 每次生成下一个值 return next_value end\nend -- 4. 转换器模式\nlocal function transformer(iterator, transform_func) return function() local values = {iterator()} if values[1] then return transform_func(unpack(values)) end end\nend\n-- 迭代器的性能特点 -- 1. 无状态 vs 有状态\n-- 无状态迭代器通常更高效，但不适合复杂状态 -- 2. 惰性求值的优势\n-- 只计算需要的值，节省内存和计算资源 -- 3. 避免在迭代器中做耗时操作\n-- 迭代器应该快速返回下一个值 -- 4. 大数据集的处理\n-- 考虑使用流式迭代器，避免一次性加载所有数据 -- 性能测试示例\nlocal function array_iterator(t, index) index = index + 1 local value = t[index] if value then return index, value end\nend local function iter_array(t) return array_iterator, t, 0\nend local function stateful_array_iterator(t) local i = 0 return function() i = i + 1 local value = t[i] if value then return i, value end end\nend local data = {}\nfor i = 1, 1000000 do data[i] = i\nend -- 测试ipairs\nlocal start = os.clock()\nfor i, v in ipairs(data) do -- 空循环\nend\nprint(\"ipairs: \" .. (os.clock() - start) .. \"秒\") -- 测试自定义无状态迭代器\nstart = os.clock()\nfor i, v in iter_array(data) do -- 空循环\nend\nprint(\"无状态迭代器: \" .. (os.clock() - start) .. \"秒\") -- 测试有状态迭代器\nstart = os.clock()\nfor v in stateful_array_iterator(data) do -- 空循环\nend\nprint(\"有状态迭代器: \" .. (os.clock() - start) .. \"秒\")\n--[[ 输出\nipairs: 0.051秒\n无状态迭代器: 0.073秒\n有状态迭代器: 0.087秒\n--]]\n-- 1. 修改迭代中的表\nlocal t = {1, 2, 3, 4, 5}\nfor i, v in ipairs(t) do if v == 3 then table.remove(t, i) -- 这会改变表，可能导致意外行为 end\nend -- 正确做法：收集要删除的项，然后批量删除\nlocal to_remove = {}\nfor i, v in ipairs(t) do if v == 3 then table.insert(to_remove, i) end\nend\nfor i = #to_remove, 1, -1 do table.remove(t, to_remove[i])\nend -- 2. 迭代器函数调用错误\nlocal function bad_iterator() return 1, 2, 3 -- 应该返回函数，而不是值\nend -- 错误：for v in bad_iterator() do ... end -- 3. 忘记处理nil值\nlocal function iterator_with_nil() local data = {1, nil, 3, nil, 5} local i = 0 return function() i = i + 1 return data[i] -- 可能返回nil，但迭代应该继续 end\nend -- 4. 无限迭代器缺少终止条件\nlocal function infinite_iterator() local i = 0 return function() i = i + 1 return i -- 永远不返回nil！ end\nend -- 使用时要小心\nfor i in infinite_iterator() do if i &gt; 100 then break\t-- 必须手动break end print(i)\nend\n-- 1. 保持迭代器简单\n-- 迭代器应该只负责生成下一个值，不处理复杂业务逻辑 -- 2. 提供清晰的接口\nlocal function create_user_iterator(condition) -- 返回迭代器和其他信息 return iterator, total_count, other_info\nend -- 3. 处理边界情况\nlocal function robust_iterator(data) if not data or #data == 0 then -- 返回一个立即结束的迭代器 return function() return nil end end -- 正常迭代器 local index = 0 return function() index = index + 1 return data[index] end\nend -- 4. 文档化迭代器行为\n--- 遍历表的键值对\n-- @param t 要遍历的表\n-- @return 迭代器函数\n-- @return 表t（不可变状态）\n-- @return nil（初始控制变量）\nlocal function my_pairs(t) -- 实现...\nend\n（点击勾选框勾选）\n完成本章后，你应该能够：\n理解迭代器的基本概念和工作原理\n使用 Lua 内置迭代器（ipairs, pairs, string.gmatch）\n创建无状态迭代器和有状态迭代器\n实现复杂的遍历模式（树、图等）\n使用惰性求值提高性能\n构建数据管道\n选择适合场景的迭代器类型\n避免常见的迭代器错误 无状态迭代器和有状态迭代器各有什么优缺点？如何选择？\n如何实现一个迭代器来遍历嵌套的复杂数据结构？\n惰性求值迭代器在什么场景下特别有用？\n迭代器模式如何提高代码的可复用性和可维护性？\n如何处理迭代过程中的错误和异常？\n下一章预告：在第 12 章中，我们将学习协程，让我们能够协作式进行多任务处理。学习建议：\n多实践创建各种类型的迭代器\n理解无状态和有状态迭代器的区别\n尝试用迭代器解决实际问题\n注意迭代器的性能特点\n学习现有的迭代器模式，理解其设计思想\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"11.1 为什么需要迭代器？","level":2,"id":"11.1_为什么需要迭代器？_0"},{"heading":"11.2 迭代器基础概念","level":2,"id":"11.2_迭代器基础概念_0"},{"heading":"11.2.1 什么是迭代器？","level":3,"id":"11.2.1_什么是迭代器？_0"},{"heading":"11.2.2 泛型 for 循环","level":3,"id":"11.2.2_泛型_for_循环_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"工作流程","level":4,"id":"工作流程_0"},{"heading":"泛型 for vs 手动 while","level":4,"id":"泛型_for_vs_手动_while_0"},{"heading":"11.3 Lua 内置迭代器","level":2,"id":"11.3_Lua_内置迭代器_0"},{"heading":"11.3.1 ipairs - 数组迭代器","level":3,"id":"11.3.1_ipairs_-_数组迭代器_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"实现自定义的 ipairs","level":4,"id":"实现自定义的_ipairs_0"},{"heading":"11.3.2 pairs - 通用迭代器","level":3,"id":"11.3.2_pairs_-_通用迭代器_0"},{"heading":"示例","level":4,"id":"示例_2"},{"heading":"实现自定义的pairs（简化版）","level":4,"id":"实现自定义的pairs（简化版）_0"},{"heading":"next 函数的使用","level":4,"id":"next_函数的使用_0"},{"heading":"11.3.3 string.gmatch - 字符串迭代器","level":3,"id":"11.3.3_string.gmatch_-_字符串迭代器_0"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"实现自定义字符串迭代器","level":4,"id":"实现自定义字符串迭代器_0"},{"heading":"11.4 无状态迭代器","level":2,"id":"11.4_无状态迭代器_0"},{"heading":"11.4.1 理解无状态迭代器","level":3,"id":"11.4.1_理解无状态迭代器_0"},{"heading":"11.4.2 创建无状态迭代器","level":3,"id":"11.4.2_创建无状态迭代器_0"},{"heading":"11.5 有状态迭代器","level":2,"id":"11.5_有状态迭代器_0"},{"heading":"11.5.1 创建有状态迭代器","level":3,"id":"11.5.1_创建有状态迭代器_0"},{"heading":"11.5.2 复杂的有状态迭代器","level":3,"id":"11.5.2_复杂的有状态迭代器_0"},{"heading":"11.6 高级迭代器模式","level":2,"id":"11.6_高级迭代器模式_0"},{"heading":"11.6.1 树遍历迭代器","level":3,"id":"11.6.1_树遍历迭代器_0"},{"heading":"11.6.2 图形遍历迭代器","level":3,"id":"11.6.2_图形遍历迭代器_0"},{"heading":"11.6.3 惰性求值迭代器","level":3,"id":"11.6.3_惰性求值迭代器_0"},{"heading":"11.7 练习","level":2,"id":"11.7_练习_0"},{"heading":"练习 1：实现一个数据管道系统","level":3,"id":"练习_1：实现一个数据管道系统_0"},{"heading":"11.8 本章总结","level":2,"id":"11.8_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"迭代器设计模式","level":3,"id":"迭代器设计模式_0"},{"heading":"性能考虑","level":3,"id":"性能考虑_0"},{"heading":"常见错误","level":3,"id":"常见错误_0"},{"heading":"最佳实践","level":3,"id":"最佳实践_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"}],"links":["第-1-节-语法/参考答案.html#练习 11 1：实现一个数据管道系统"],"author":"","coverImageURL":".","fullURL":"第-1-节-语法/11.-迭代器与泛型for.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251211142754.png"],"createdTime":1765335828615,"modifiedTime":1765936106060,"sourceSize":44075,"sourcePath":"第 1 节 - 语法/11. 迭代器与泛型for.md","exportPath":"第-1-节-语法/11.-迭代器与泛型for.html","showInTree":true,"treeOrder":12,"backlinks":[],"type":"markdown"},"第-1-节-语法/12.-协程.html":{"title":"12. 协程","icon":"","description":"协程是 Lua 中强大的协作式多任务处理机制。与线程不同，协程是用户态的任务，由代码显式控制切换。协程可理解为有一台机器可以进行各种任务，但是一次只能进行一个任务（单线程），如果正在进行某个任务，此时要想进行另一个任务就需要暂停当前任务（让出），转而执行另一个任务，执行完毕后继续此前的任务（进度不丢失）不用协程时机器执行任务时，会一直等待直到任务完成（阻塞）才会进行下一个任务，期间什么别的都不能做。效率极低。使用协程执行任务时可随意切换任务，不至于阻塞程序。local enemy = {} function enemy.update() while true do\t-- 游戏中敌人的更新函数通常为死循环 if enemy.dead then print(\"敌人已死亡\") break end if enemy.walk then print(\"敌人移动中...\") end print(\"死循环中...\") end\nend enemy.update()\n-- 由于程序一直在死循环检测敌人，程序完全被阻塞，任何其他代码无法执行\nprint(\"这行代码无法执行到\")\n--[[ 输出\n死循环中...\n...\n--]]\n使用协程即可解决以上问题。协程 Coroutine：\n协作式（非抢占式）：由代码控制切换（主动让出）\n资源开销：轻量级，创建开销小\n单线程：同一时间只有一个协程执行\n可暂停：可以在任意点暂停和恢复\n可预测性：可阅读代码了解执行顺序\n线程 Thread：\n抢占式多任务：操作系统控制（强制切换）\n资源开销：内核态实现，较重\n操作系统调度\n可以并行执行\n不可预测性\n-- 创建协程\nlocal co = coroutine.create(function() print(\"协程开始\") coroutine.yield() -- 让出 print(\"协程继续\")\nend) -- 启动/恢复协程\ncoroutine.resume(co) -- 获取状态\nprint(coroutine.status(co)) -- suspended\nlocal enemy = {} function enemy.update() while true do\t-- 游戏中敌人的更新函数通常为死循环 if enemy.dead then print(\"敌人已死亡\") break end if enemy.walk then print(\"敌人移动中...\") end print(\"死循环中...\") coroutine.yield() end\nend local co = coroutine.create(enemy.update)\ncoroutine.resume(co) -- 现在不会阻塞程序了\nprint(\"这行代码无法执行到\")\n-- 通常游戏有个主循环每帧重启所有协程\ncoroutine.resume(co)\n--[[ 输出\n死循环中...\n这行代码无法执行到\n死循环中...\n--]] suspended：挂起（创建后或让出后）\nrunning：运行中\nnormal：正常（恢复其他协程时）\ndead: 结束（函数执行完毕）\n<img alt=\"Pasted image 20251215100819.png\" src=\"site-lib/media/pasted-image-20251215100819.png\" target=\"_self\" style=\"width: 750px; max-width: 100%;\">coroutine.create(主体函数: func) -&gt; 创建的协程: thread 创建的协程默认状态为挂起\n运行时函数报错时不会抛出\nlocal function simple_task(name) print(\" 协程 \" .. name .. \" 开始执行\") print(\" 第一步: 处理数据\") coroutine.yield() -- 让出执行权 print(\" 第二步: 保存结果\") coroutine.yield() -- 再次让出 print(\" 第三步: 清理资源\") return \"任务完成\"\nend -- 创建协程（此时是挂起状态）\nlocal co1 = coroutine.create(simple_task)\nprint(\" 协程已创建，状态: \" .. coroutine.status(co1)) -- suspended -- 运行协程\nlocal success, result = coroutine.resume(co1, \"任务A\")\nprint(\" 第一次resume结果: success=\" .. tostring(success) .. \", result=\" .. tostring(result))\nprint(\" 协程状态: \" .. coroutine.status(co1)) -- suspended -- 继续运行\nsuccess, result = coroutine.resume(co1)\nprint(\" 第二次resume结果: success=\" .. tostring(success))\nprint(\" 协程状态: \" .. coroutine.status(co1)) -- suspended success, result = coroutine.resume(co1)\nprint(\" 第三次resume结果: success=\" .. tostring(success) .. \", result=\" .. tostring(result))\nprint(\" 协程状态: \" .. coroutine.status(co1)) -- dead\n--[[ 输出\n协程已创建，状态: suspended\n协程 任务A 开始执行\n第一步: 处理数据\n第一次resume结果: success=true, result=nil\n协程状态: suspended\n第二步: 保存结果\n第二次resume结果: success=true\n协程状态: suspended\n第三步: 清理资源\n第三次resume结果: success=true, result=任务完成\n协程状态: dead\n--]]\ncoroutine.resume(协程: thread, 传递的参数: any...) -&gt; 是否成功: bool, 主体函数返回值|或让出时传递的参数: any\ncoroutine.yield(参数: any...) -&gt; 传递的参数: any...\ncoroutine.status(协程: thread) -&gt; 协程状态: \"dead\"|\"normal\"|\"running\"|\"suspended\"\nlocal function status_example() print(\" 协程内部状态: \" .. coroutine.status(coroutine.running())) coroutine.yield() print(\" 恢复执行\")\nend local co = coroutine.create(status_example) print(\" 创建后状态: \" .. coroutine.status(co))\ncoroutine.resume(co)\nprint(\" 第一次yield后状态: \" .. coroutine.status(co))\ncoroutine.resume(co)\nprint(\" 完成后状态: \" .. coroutine.status(co))\n--[[ 输出 创建后状态: suspended 协程内部状态: running 第一次yield后状态: suspended 恢复执行 完成后状态: dead\n--]]\n创建一个新协程。返回一个函数，每次调用该函数都会运行该协程。coroutine.wrap(主体函数: func) -&gt; 包装后的函数: func\nlocal function counter(max) for i = 1, max do print(\" 计数: \" .. i) coroutine.yield(i) end return \"计数完成\"\nend -- wrap返回一个函数，而不是协程对象\nlocal count_func = coroutine.wrap(counter) print(\" 第一次调用:\")\nlocal result1 = count_func(5) -- 相当于 resume\nprint(\" 结果: \" .. tostring(result1)) print(\"\\n 第二次调用:\")\nlocal result2 = count_func()\nprint(\" 结果: \" .. tostring(result2)) print(\"\\n 继续调用直到完成:\")\nfor i = 3, 6 do local result = count_func() print(\" 第\" .. i .. \"次结果: \" .. tostring(result))\nend\n--[[ 输出\n第一次调用:\n计数: 1\n结果: 1 第二次调用:\n计数: 2\n结果: 2 继续调用直到完成:\n计数: 3\n第3次结果: 3\n计数: 4\n第4次结果: 4\n计数: 5\n第5次结果: 5\n第6次结果: 计数完成\n--]]\ncoroutine.running() -&gt; 当前协程: thread 如果在主线程调用将会返回 nil\nlocal function get_current_coroutine() local running_co = coroutine.running() print(\" 当前协程: \" .. tostring(running_co)) if not running_co then print(\" 在主线程中运行\") else print(\" 在协程中运行\") end\nend print(\" 直接调用函数（在主线程）:\")\nget_current_coroutine() print(\"\\n 在协程中调用:\")\nlocal co_test = coroutine.create(get_current_coroutine)\ncoroutine.resume(co_test)\n--[[ 输出 直接调用函数（在主线程）: 当前协程: nil 在主线程中运行 在协程中调用: 当前协程: thread: 0x00d51d78 在协程中运行\n--]]\nprint(\"协程的参数传递\")\nlocal function parameter_example(name, count) print(\" 接收参数: name=\" .. name .. \", count=\" .. count) for i = 1, count do print(\" 处理第\" .. i .. \"项\") local received = coroutine.yield(\"进度: \" .. i .. \"/\" .. count) if received then print(\" 收到外部数据: \" .. received) end end return \"处理完成: \" .. name\nend local co_param = coroutine.create(parameter_example) -- 第一次resume传递参数\nprint(\" 第一次resume:\")\nlocal success, progress = coroutine.resume(co_param, \"数据导入\", 3)\nprint(\" 结果: success=\" .. tostring(success) .. \", progress=\" .. tostring(progress)) -- 后续resume传递数据给yield\nprint(\"\\n 第二次resume（带数据）:\")\nsuccess, progress = coroutine.resume(co_param, \"继续处理\")\nprint(\" 结果: success=\" .. tostring(success) .. \", progress=\" .. tostring(progress)) print(\"\\n 第三次resume（带数据）:\")\nsuccess, progress = coroutine.resume(co_param, \"最后一步\")\nprint(\" 结果: success=\" .. tostring(success) .. \", progress=\" .. tostring(progress)) print(\"\\n 第四次resume（获取最终结果）:\")\nsuccess, progress = coroutine.resume(co_param)\nprint(\" 结果: success=\" .. tostring(success) .. \", progress=\" .. tostring(progress))\n--[[ 输出\n第一次resume:\n接收参数: name=数据导入, count=3\n处理第1项\n结果: success=true, progress=进度: 1/3 第二次resume（带数据）:\n收到外部数据: 继续处理\n处理第2项\n结果: success=true, progress=进度: 2/3 第三次resume（带数据）:\n收到外部数据: 最后一步\n处理第3项\n结果: success=true, progress=进度: 3/3 第四次resume（获取最终结果）:\n结果: success=true, progress=处理完成: 数据导入\n--]]\n一般协程之间的通信都是使用通道作为中介传递参数。-- 使用通道进行协程通信\nlocal channels = {} local function create_channel(name) channels[name] = {} local queue = channels[name] return { send = function(value) table.insert(queue, value) coroutine.yield() -- 发送后让出 end, receive = function() while #queue == 0 do coroutine.yield() -- 等待数据 end return table.remove(queue, 1) end }\nend local ch = create_channel(\"comm\") local sender = coroutine.create(function() for i = 1, 3 do print(\"发送: 消息\" .. i) ch.send(\"消息\" .. i) end\nend) local receiver = coroutine.create(function() for i = 1, 3 do local msg = ch.receive() print(\"接收: \" .. msg) end\nend) -- 交替执行\nfor i = 1, 6 do coroutine.resume(sender) coroutine.resume(receiver)\nend\n--[[ 输出\n发送: 消息1\n接收: 消息1\n发送: 消息2\n接收: 消息2\n发送: 消息3\n接收: 消息3\n--]]\nprint(\"协程的处理\")\nlocal function error_example() print(\" 开始执行\") coroutine.yield(\"第一步正常\") error(\"故意出错！\") -- 抛出错误 print(\" 这行不会执行\")\nend local co_error = coroutine.create(error_example) print(\" 第一次resume（正常）:\")\nlocal success, result = coroutine.resume(co_error)\nprint(\" 结果: success=\" .. tostring(success) .. \", result=\" .. tostring(result)) print(\"\\n 第二次resume（触发错误）:\")\nsuccess, result = coroutine.resume(co_error)\nif not success then print(\" 错误发生: \" .. result)\nend\nprint(\" 协程状态: \" .. coroutine.status(co_error)) -- dead\n--[[ 输出 第一次resume（正常）: 开始执行 结果: success=true, result=第一步正常 第二次resume（触发错误）: 错误发生: d:\\KR\\VScode_KR_workspace\\test.lua:4: 故意出错！ 协程状态: dead\n--]] -- 安全执行模式，捕获错误\nlocal function safe_execute(co, ...) local ok, err = coroutine.resume(co, ...) if not ok then print(\"协程错误: \" .. err) print(\"协程状态: \" .. coroutine.status(co)) return false, err end return true, err\nend local function risky_task() error(\"错误！\") return \"成功\"\nend local co = coroutine.create(risky_task)\nlocal ok, result = safe_execute(co)\nprint(\"执行结果: \" .. tostring(result))\n--[[ 输出\n协程错误: test.lua:15: 错误！\n协程状态: dead\n执行结果: test.lua:15: 错误！\n--]]\n-- 生产者\nlocal function producer(items) for i = 1, items do print(\"生产: 产品\" .. i) coroutine.yield(\"产品\" .. i) -- 生产一个就让出 end return \"生产完成\"\nend -- 消费者\nlocal function consumer(co) while true do local success, product = coroutine.resume(co, 5) if not success or product == \"生产完成\" then break end print(\"消费: \" .. product) end print(\"消费完成\")\nend local producer_co = coroutine.create(producer)\nconsumer(producer_co)\n--[[ 输出\n生产: 产品1\n消费: 产品1\n生产: 产品2\n消费: 产品2\n生产: 产品3\n消费: 产品3\n生产: 产品4\n消费: 产品4\n生产: 产品5\n消费: 产品5\n消费完成\n--]]\nlocal tasks = {} -- 任务队列 local function add_task(func, ...) local co = coroutine.create(func) table.insert(tasks, {co = co, args = {...}})\nend local function scheduler() while #tasks &gt; 0 do local task = table.remove(tasks, 1) local ok, result = coroutine.resume(task.co, unpack(task.args)) if coroutine.status(task.co) == \"suspended\" then -- 任务还未完成，放回队列 table.insert(tasks, task) end end\nend -- 添加任务\nadd_task(function(name) print(\"任务 \" .. name .. \" 开始\") coroutine.yield() print(\"任务 \" .. name .. \" 继续\") coroutine.yield() print(\"任务 \" .. name .. \" 完成\")\nend, \"A\") add_task(function(name) print(\"任务 \" .. name .. \" 步骤1\") coroutine.yield() print(\"任务 \" .. name .. \" 步骤2\")\nend, \"B\") -- 运行调度器\nscheduler()\n--[[ 输出\n任务 A 开始\n任务 B 步骤1\n任务 A 继续\n任务 B 步骤2\n任务 A 完成\n--]]\n-- 使用协程实现迭代器\nlocal function walk_list(list) return coroutine.wrap(function() for i = 1, #list do coroutine.yield(i, list[i]) end end)\nend -- 使用示例\nlocal list = { \"a\", \"b\", \"c\"\n} for i, v in walk_list(list) do print(i .. \": \" .. v)\nend\n--[[ 输出\n1: a\n2: b\n3: c\n--]]\n<br>（答案见<a data-href=\"第 1 节 - 语法/参考答案#练习 12 1：使用协程实现生成器\" href=\"第-1-节-语法/参考答案.html#练习 12 1：使用协程实现生成器\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 1 节 - 语法/参考答案 &gt; 练习 12 1：使用协程实现生成器</a>）-- 使用协程实现一个范围生成器\n-- 使用示例：\nfor i in range(1, 10, 2) do print(i)\nend\n--[[ 输出\n1\n3\n5\n7\n9\n--]] 协程核心概念： 协作式多任务：由程序控制切换（主动让出）\n四种状态：suspended、running、normal、dead\n轻量级：比线程轻量，适合 I/O 密集型任务\n可预测性：可阅读代码预测执行顺序 核心函数： coroutine.create - 创建协程\ncoroutine.resume - 启动/恢复执行\ncoroutine.yield - 让出执行权\ncoroutine.status - 获取状态\ncoroutine.wrap - 包装为函数\ncoroutine.running - 获取当前协程 数据传递： resume 参数传递给函数或 yield\nyield 返回值给 resume\n支持多值传递\n协程之间的通信 错误处理： resume 返回 success 标志\n协程内错误不会影响主线程 实用模式： 生产者-消费者模式\n异步任务调度\n迭代器实现 -- 错误：resume 重启已结束的协程\nlocal co = coroutine.create(function() return \"done\"\nend)\ncoroutine.resume(co) -- 正确\ncoroutine.resume(co) -- 错误！协程已dead -- 技巧：使用wrap简化调用\nlocal gen = coroutine.wrap(function() for i = 1, 3 do coroutine.yield(i) end\nend)\nprint(gen(), gen(), gen()) -- 1, 2, 3 -- 注意：yield不能在某些C函数中使用\nlocal function bad_example() table.sort({}, function() coroutine.yield() -- 错误！ end)\nend -- 技巧：使用协程实现状态保持\nlocal function counter() local count = 0 return coroutine.wrap(function() while true do count = count + 1 coroutine.yield(count) end end)\nend local c = counter()\nprint(c(), c(), c()) -- 1, 2, 3\n（点击勾选框勾选）\n完成本章后，你应该能够：\n理解协程与线程的区别\n创建、启动和暂停协程\n在协程间传递数据\n使用协程实现生产者-消费者模式\n处理协程执行中的错误\n使用协程创建迭代器 为什么 Lua 选择使用协程，而不是线程？\n协程的 \"协作式\" 与线程的 \"抢占式\" 有什么根本区别？\n协程的 yield 和 return 在数据传递上有什么不同？\n如何用协程实现一个简单的状态机？\n下一章预告：在第 13 章中，我们将学习元表，让我们能够控制其他表的各种行为，实现面向对象编程，向量加减等。","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"12.1 什么是协程？","level":2,"id":"12.1_什么是协程？_0"},{"heading":"12.1.1 为什么需要协程？","level":3,"id":"12.1.1_为什么需要协程？_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"12.1.2 协程基础概念","level":3,"id":"12.1.2_协程基础概念_0"},{"heading":"协程 vs 线程","level":4,"id":"协程_vs_线程_0"},{"heading":"协程核心操作","level":4,"id":"协程核心操作_0"},{"heading":"使用协程解决以上问题","level":4,"id":"使用协程解决以上问题_0"},{"heading":"12.2 协程四种状态与生命周期","level":2,"id":"12.2_协程四种状态与生命周期_0"},{"heading":"13.4 创建和运行协程","level":2,"id":"13.4_创建和运行协程_0"},{"heading":"13.4.1 coroutine.create - 创建协程","level":3,"id":"13.4.1_coroutine.create_-_创建协程_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"13.4.2 coroutine.resume - 运行协程","level":3,"id":"13.4.2_coroutine.resume_-_运行协程_0"},{"heading":"13.4.3 coroutine.yield - 协程让出","level":3,"id":"13.4.3_coroutine.yield_-_协程让出_0"},{"heading":"13.4.4 coroutine.status - 获取协程状态","level":3,"id":"13.4.4_coroutine.status_-_获取协程状态_0"},{"heading":"示例","level":4,"id":"示例_2"},{"heading":"13.4.5 coroutine.wrap - 包装函数","level":3,"id":"13.4.5_coroutine.wrap_-_包装函数_0"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"13.4.6 coroutine.running - 获取当前运行的协程","level":3,"id":"13.4.6_coroutine.running_-_获取当前运行的协程_0"},{"heading":"示例","level":4,"id":"示例_4"},{"heading":"13.5 协程的参数传递与错误处理","level":2,"id":"13.5_协程的参数传递与错误处理_0"},{"heading":"13.5.1 参数传递","level":3,"id":"13.5.1_参数传递_0"},{"heading":"12.5.2 协程间通信","level":3,"id":"12.5.2_协程间通信_0"},{"heading":"13.5.3 错误处理","level":3,"id":"13.5.3_错误处理_0"},{"heading":"12.6 协程实用模式","level":2,"id":"12.6_协程实用模式_0"},{"heading":"12.6.1 生产者-消费者模式","level":3,"id":"12.6.1_生产者-消费者模式_0"},{"heading":"12.6.2 异步任务调度","level":3,"id":"12.6.2_异步任务调度_0"},{"heading":"12.6.3 迭代器实现","level":3,"id":"12.6.3_迭代器实现_0"},{"heading":"12.7 练习","level":2,"id":"12.7_练习_0"},{"heading":"练习 1：使用协程实现生成器","level":3,"id":"练习_1：使用协程实现生成器_0"},{"heading":"12.8 本章总结","level":2,"id":"12.8_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"常见错误与技巧","level":3,"id":"常见错误与技巧_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"}],"links":["第-1-节-语法/参考答案.html#练习 12 1：使用协程实现生成器"],"author":"","coverImageURL":".","fullURL":"第-1-节-语法/12.-协程.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251215100819.png"],"createdTime":1765609117143,"modifiedTime":1766546428697,"sourceSize":17270,"sourcePath":"第 1 节 - 语法/12. 协程.md","exportPath":"第-1-节-语法/12.-协程.html","showInTree":true,"treeOrder":13,"backlinks":[],"type":"markdown"},"第-1-节-语法/13.-元表.html":{"title":"13. 元表","icon":"","description":"元表（Metatable）是 Lua 中一种特殊的表，可以定义其他表的\"行为\"。它允许我们改变表的默认操作，比如加法、减法、索引访问等。\n运算符重载：让表支持算术运算\n自定义行为：改变表的索引和赋值\n面向对象：实现继承、私有性等特性\n保护数据：创建只读表、受限表\nlocal vector1 = {x = 10, y = 20}\nlocal vector2 = {x = 5, y = 15} -- 尝试相加两个表（会报错）\nlocal sum = vector1 + vector2 -- 错误！table 不支持加法\nprint(sum) -- 尝试比较两个表（比较的是引用，不是值）\nprint(vector1 == vector2) -- false（即使值相同也是false）\nprint(tostring(vector1)) -- table: 0x000001（不是我们想要的格式）\nsetmetatable(表: table, 元表: table) -&gt; 设置元表后的表: table\n-- 创建一个普通表\nlocal mytable = {} -- 创建一个元表\nlocal metatable = { __add = function() return \"add\" end\n} -- 设置元表\nsetmetatable(mytable, metatable) -- 可简化为\nlocal mytable = setmetatable({}, { __add = function() return \"add\" end\n})\ngetmetatable(表: table) -&gt; 元表: table\nlocal mytable = {} local metatable = { __add = function() return \"add\" end\n} setmetatable(mytable, metatable) local mt = getmetatable(mytable)\nprint(mt == metatable) -- true\n元方法分为以下几类：\n算术元方法：__add、__sub 、__mul、__div、__mod、__pow、__unm（负号）\n关系元方法：__eq、__lt、__le\n库元方法：__tostring、__concat\n索引元方法：__index、__newindex\n调用元方法：__call\nlocal Vector = {}\nVector.__index = Vector function Vector.new(x, y) local v = { x = x, y = y } setmetatable(v, Vector) return v\nend -- 定义 __add 元方法\nfunction Vector.__add(a, b) return Vector.new(a.x + b.x, a.y + b.y)\nend -- 定义 __tostring 元方法\nfunction Vector.__tostring(self) return string.format(\"Vector(%d, %d)\", self.x, self.y)\nend -- 使用示例\nlocal v1 = Vector.new(10, 20)\nlocal v2 = Vector.new(5, 15)\nlocal v3 = v1 + v2 -- 现在可以相加了！ print(v1) -- Vector(10, 20)\nprint(v2) -- Vector(5, 15)\nprint(v3) -- Vector(15, 35)\n-- 复数类示例\nlocal Complex = {}\nComplex.__index = Complex function Complex.new(real, imag) local c = {real = real, imag = imag} setmetatable(c, Complex) return c\nend -- 加法\nfunction Complex.__add(a, b) return Complex.new(a.real + b.real, a.imag + b.imag)\nend -- 减法\nfunction Complex.__sub(a, b) return Complex.new(a.real - b.real, a.imag - b.imag)\nend -- 乘法\nfunction Complex.__mul(a, b) -- (a+bi)(c+di) = (ac-bd) + (ad+bc)i local real = a.real * b.real - a.imag * b.imag local imag = a.real * b.imag + a.imag * b.real return Complex.new(real, imag)\nend -- 负号\nfunction Complex.__unm(a) return Complex.new(-a.real, -a.imag)\nend -- 字符串表示\nfunction Complex.__tostring(self) if self.imag &gt;= 0 then return string.format(\"(%d+%di)\", self.real, self.imag) else return string.format(\"(%d%di)\", self.real, self.imag) end\nend -- 使用示例\nlocal c1 = Complex.new(3, 4) -- 3+4i\nlocal c2 = Complex.new(1, 2) -- 1+2i print(c1) -- (3+4i)\nprint(c2) -- (1+2i)\nprint(c1 + c2) -- (4+6i)\nprint(c1 - c2) -- (2+2i)\nprint(c1 * c2) -- (-5+10i)\nprint(-c1) -- (-3-4i)\n-- 分数类示例\nlocal Fraction = {}\nFraction.__index = Fraction function Fraction.new(numerator, denominator) local f = { num = numerator, den = denominator or 1 } setmetatable(f, Fraction) return f\nend -- 相等判断（约分后比较）\nfunction Fraction.__eq(a, b) return a.num * b.den == b.num * a.den\nend -- 小于判断\nfunction Fraction.__lt(a, b) return a.num * b.den &lt; b.num * a.den\nend -- 小于等于判断\nfunction Fraction.__le(a, b) return a.num * b.den &lt;= b.num * a.den\nend function Fraction.__tostring(self) return string.format(\"%d/%d\", self.num, self.den)\nend -- 使用示例\nlocal f1 = Fraction.new(1, 2) -- 1/2\nlocal f2 = Fraction.new(2, 4) -- 2/4\nlocal f3 = Fraction.new(3, 4) -- 3/4 print(f1 == f2) -- true（1/2 == 2/4）\nprint(f1 &lt; f3) -- true（1/2 &lt; 3/4）\nprint(f3 &lt;= f2) -- false（3/4 &lt;= 1/2）\nprint(f1 &lt;= f2) -- true（1/2 &lt;= 1/2）\n不存在大于关系元方法，但是可以通过交换小于关系原方法的操作数来巧妙实现。我们这里不用实现，因为 Lua 已经帮我们实现了：-- 理解大于关系原理\nlocal debugFraction = {}\ndebugFraction.__index = debugFraction function debugFraction.new(value) local f = {value = value} setmetatable(f, debugFraction) return f\nend function debugFraction.__lt(a, b) print(string.format(\"调用 __lt: %s &lt; %s, 结果: %s\", a.value, b.value, tostring(a.value &lt; b.value)))\nend function debugFraction.__le(a, b) print(string.format(\"调用 __le: %s &lt;= %s, 结果: %s\", a.value, b.value, tostring(a.value &lt;= b.value)))\nend local a = debugFraction.new(1)\nlocal b = debugFraction.new(2) _ = a &lt; b\n_ = a &lt;= b\n_ = a &gt; b\n_ = a &gt;= b\n--[[ 输出\n调用 __lt: 1 &lt; 2, 结果: true\n调用 __le: 1 &lt;= 2, 结果: true\n调用 __lt: 2 &lt; 1, 结果: false\n调用 __le: 2 &lt;= 1, 结果: false\n--]]\n索引表中不存在键时调用元表中的 __index 函数，如果 __index 是一个表将会在这个表中索引键。-- 示例1：使用函数作为 __index\nlocal john = {name = \"John\", age = 25}\nsetmetatable(john, { __index = function(table, key) if key == \"birthYear\" then return 2025 - table.age elseif key == \"info\" then return table.name .. \", \" .. table.age .. \" years old\" else return nil -- 返回nil表示不存在 end end\n}) print(john.name) -- John（直接访问）\nprint(john.age) -- 25（直接访问）\nprint(john.birthYear) -- 2000（不存在，调用 __index）\nprint(john.info) -- John, 25 years old（不存在，调用 __index）\nprint(john.sayHello) -- nil -- 示例2：使用表作为 __index（实现继承）\nlocal Animal = { sound = \"???\", makeSound = function(self) return self.sound end\n} local Dog = setmetatable({}, { __index = Animal\n}) -- Dog继承Animal Dog.sound = \"Woof!\"\nDog.bark = function(self) return self:makeSound() .. \" \" .. self:makeSound()\nend print(Dog:makeSound()) -- Woof!\nprint(Dog:bark()) -- Woof! Woof!\n给表中不存在的键赋值时调用-- 示例1：限制特定键的赋值\nlocal Config = {} local metatable = { __newindex = function(table, key, value) if key == \"version\" then print(\"Cannot modify version!\") elseif key == \"author\" then print(\"Cannot modify author!\") else rawset(table, key, value) -- 使用rawset绕过元方法 end end\n} setmetatable(Config, metatable) Config.version = \"2.0\" -- Cannot modify version!\nConfig.port = 8080 -- 成功添加新字段\nprint(Config.port) -- 8080 -- 示例2：自动类型检查\nlocal Student = {} local student_meta = { __newindex = function(table, key, value) if key == \"grade\" then if type(value) ~= \"number\" or value &lt; 0 or value &gt; 100 then print(\"Grade must be a number between 0 and 100\") end elseif key == \"name\" then if type(value) ~= \"string\" then print(\"Name must be a string\") end end rawset(table, key, value) end\n} local s1 = {}\nsetmetatable(s1, student_meta) s1.grade = \"A\" -- Grade must be a number between 0 and 100\ns1.name = 123 -- Name must be a string\nrawget(表: table, 索引: any)\nlocal DangerTable = setmetatable({}, { __index = function(table, key) return table[key] end\n}) -- print(DangerTable.v)\t-- 栈会溢出 -- 使用rawget绕过元方法，避免栈溢出\nprint(rawget(DangerTable, \"v\")) -- nil\nrawset(表: table, 索引: any, 值: any)\nlocal SecureTable = setmetatable({}, { __newindex = function(table, key, value) if key == \"ban_key\" then print(string.format(\"Cannot set key: %s!\", key)) end end\n}) SecureTable.ban_key = \"new\" -- Cannot set key: ban_key!\nprint(SecureTable.ban_key) -- nil -- 使用rawset绕过元方法，为被禁止键赋值\nrawset(SecureTable, \"ban_key\", \"new\")\nprint(SecureTable.ban_key) -- new\n不存在索引元方法，但是可以通过代理表来巧妙实现。local function createTable(t) local new_table = t local proxy = setmetatable({}, { __index = function(table, key) print(string.format(\"索引: %s\", key)) return new_table[key] end, __newindex = function(table, key, value) print(string.format(\"赋值: %s\", value)) new_table[key] = value end }) return proxy\nend local new_table = createTable() -- 实际在操作 proxy 空表\nnew_table.a = 1\nnew_table.b = 2\n_ = new_table.a\nb = new_table.b\n--[[ 输出\n赋值: 1\n赋值: 2\n索引: a\n索引: b\n--]]\n让表可以像函数一样被调用。-- 示例1：函数对象\nlocal Counter = { count = 0\n} local counter_meta = { __call = function(self, increment) self.count = self.count + increment return self.count end\n} setmetatable(Counter, counter_meta) print(Counter()) -- 1\nprint(Counter(5)) -- 6\nprint(Counter(2)) -- 8 -- 示例2：带参数的构造函数\nlocal Point = { x = 0, y = 0\n} local point_meta = { __call = function(self, x, y) local p = { x = x or self.x, y = y or self.y } setmetatable(p, getmetatable(self)) return p end, __tostring = function(self) return string.format(\"Point(%d, %d)\", self.x, self.y) end\n} setmetatable(Point, point_meta) local p1 = Point() -- 使用默认值\nlocal p2 = Point(10, 20) -- 指定值\nlocal p3 = Point(30) -- 只指定x print(p1) -- Point(0, 0)\nprint(p2) -- Point(10, 20)\nprint(p3) -- Point(30, 0)\n自定义表的字符串表示。local Book = { title = \"\", author = \"\", pages = 0\n} local book_meta = { __tostring = function(self) return string.format('\"%s\" by %s (%d pages)', self.title, self.author, self.pages) end\n} function Book.new(title, author, pages) local book = { title = title, author = author, pages = pages } setmetatable(book, book_meta) return book\nend local book1 = Book.new(\"Lua Programming\", \"John Doe\", 350)\nlocal book2 = Book.new(\"Metatables Guide\", \"Jane Smith\", 200) print(book1) -- \"Lua Programming\" by John Doe (350 pages)\nprint(book2) -- \"Metatables Guide\" by Jane Smith (200 pages)\n自定义连接操作符(..)。local StringWrapper = {} function StringWrapper.new(str) local wrapper = {value = str or \"\"} setmetatable(wrapper, { __concat = function(a, b) local a_val = type(a) == \"table\" and a.value or a local b_val = type(b) == \"table\" and b.value or b return StringWrapper.new(a_val .. b_val) end, __tostring = function(self) return self.value end }) return wrapper\nend local s1 = StringWrapper.new(\"Hello\")\nlocal s2 = StringWrapper.new(\" World\")\nlocal s3 = s1 .. s2 .. \"!\" print(s3) -- Hello World!\nprint(type(s3)) -- table（仍然是StringWrapper对象）\n-- 实现一个简单的类系统\nlocal Class = {} function Class.create(name, super) local class = {} class.name = name class.super = super -- 设置继承链 if super then setmetatable(class, { __index = super }) end -- 类构造函数 class.new = function(...) local instance = {} setmetatable(instance, { __index = class }) -- 调用初始化方法 if instance.init then instance:init(...) end return instance end return class\nend -- 基类：Animal\nlocal Animal = Class.create(\"Animal\") function Animal:init(name) self.name = name\nend function Animal:speak() return \"???\"\nend function Animal:introduce() return \"I am \" .. self.name .. \", I say \" .. self:speak()\nend -- 派生类：Dog\nlocal Dog = Class.create(\"Dog\", Animal) function Dog:speak() return \"Woof!\"\nend function Dog:wagTail() return self.name .. \" is wagging tail\"\nend -- 派生类：Cat\nlocal Cat = Class.create(\"Cat\", Animal) function Cat:speak() return \"Meow!\"\nend function Cat:purr() return self.name .. \" is purring\"\nend -- 使用示例\nlocal dog = Dog.new(\"Buddy\")\nlocal cat = Cat.new(\"Whiskers\") print(dog:introduce()) -- I am Buddy, I say Woof!\nprint(cat:introduce()) -- I am Whiskers, I say Meow!\nprint(dog:wagTail()) -- Buddy is wagging tail\nprint(cat:purr()) -- Whiskers is purring -- 调用父类的函数\nprint(cat.super:speak())-- ??? -- 检查继承关系\nprint(getmetatable(Dog).__index == Animal) -- true local function readOnly(t) local proxy = {} local metatable = { __index = t, __newindex = function(table, key, value) print(\"Attempt to modify read-only table\", 2) end, __metatable = \"Read-only table\" -- 保护元表本身 } setmetatable(proxy, metatable) return proxy\nend local config = { version = \"1.0\", port = 8080, host = \"localhost\"\n} local readOnlyConfig = readOnly(config) print(readOnlyConfig.version) -- 1.0\nprint(readOnlyConfig.port) -- 8080 readOnlyConfig.port = 9090 -- Attempt to modify read-only table\nreadOnlyConfig.newKey = \"test\" -- Attempt to modify read-only table -- 尝试获取元表\nprint(getmetatable(readOnlyConfig)) -- Read-only table\nfunction createDefaultTable(defaultValue) local t = {} local metatable = { __index = function(table, key) return defaultValue end } setmetatable(t, metatable) return t\nend -- 示例1：默认值为0\nlocal scores = createDefaultTable(0)\nscores.Alice = 95\nscores.Bob = 87 print(scores.Alice) -- 95\nprint(scores.Bob) -- 87\nprint(scores.Charlie) -- 0（默认值）\nprint(scores.David) -- 0（默认值） -- 示例2：默认值为空表\nlocal groups = createDefaultTable({})\ngroups.admin = { \"Alice\", \"Bob\" }\ntable.insert(groups.users, \"Charlie\") print(#groups.admin) -- 2\nprint(#groups.users) -- 1\nprint(type(groups.guests)) -- table（默认空表）\n-- 错误1：递归调用导致的栈溢出\nlocal t = {}\nlocal mt = { __index = function(table, key) return table[key] -- 错误！递归调用 end\n}\nsetmetatable(t, mt)\n-- print(t.x) -- 栈溢出 -- 正确做法\nlocal t2 = {}\nlocal mt2 = { __index = function(table, key) return rawget(table, key) -- 使用rawget避免递归 end\n} -- 错误2：忘记表传递的是引用，修改元表影响所有实例\nlocal A = {x = 1}\nlocal mt = {}\nsetmetatable(A, mt) local B = {x = 2}\nsetmetatable(B, mt) -- 和A共享元表 mt.__index = function() return 100 end print(A.y) -- 100（可能不是期望的行为）\nprint(B.y) -- 100 -- 正确做法：每个实例使用独立的元表\nlocal function createInstance(value) local obj = {x = value} setmetatable(obj, { __index = function(self, key) if key == \"double\" then return self.x * 2 end end }) return obj\nend local a = createInstance(10)\nlocal b = createInstance(20) print(a.double) -- 20\nprint(b.double) -- 40\n-- 性能测试：元表访问 vs 直接访问\nlocal iterations = 10000000 -- 直接访问\nlocal directTable = { value = 42 }\nlocal start1 = os.clock()\nfor i = 1, iterations do local v = directTable[i]\nend\nlocal time1 = os.clock() - start1 -- 通过元表访问\nlocal metaTable = {}\nlocal proxiedTable = { value = 42 }\nsetmetatable(proxiedTable, { __index = function(t, k) return rawget(t, k) end\n}) local start2 = os.clock()\nfor i = 1, iterations do local v = proxiedTable[i]\nend\nlocal time2 = os.clock() - start2 print(string.format(\"直接访问: %.4f 秒\", time1))\nprint(string.format(\"元表访问: %.4f 秒\", time2))\nprint(string.format(\"开销: %.2f%%\", (time2 - time1) / time1 * 100))\n--[[ 输出\n直接访问: 0.1740 秒\n元表访问: 0.8650 秒\n开销: 370%\n--]]\n-- 要求：\n-- 1. 实现 Vector 类，支持 x, y 坐标\n-- 2. 支持加法、减法、乘法（点积）\n-- 3. 支持负号操作\n-- 4. 支持字符串表示 -- 使用示例：\nlocal v1 = Vector.new(3, 4)\nlocal v2 = Vector.new(1, 2) print(v1) -- Vector(3, 4)\nprint(v2) -- Vector(1, 2)\nprint(v1 + v2) -- Vector(4, 6)\nprint(v1 - v2) -- Vector(2, 2)\nprint(v1 * v2) -- 11 (点积)\nprint(-v1) -- Vector(-3, -4)\n-- 要求：\n-- 1. 跟踪以上向量类的各种访问，加减点积等\n-- 2. 可打印访问历史记录 -- 使用示例：\nprint(\"\\n\\n=== 练习2：带日志的向量类测试 ===\")\nlocal v1 = TrackedVector.new(3, 4)\nlocal v2 = TrackedVector.new(1, 2) print(\"v1 = \" .. tostring(v1)) -- Vector(3, 4)\nprint(\"v2 = \" .. tostring(v2)) -- Vector(1, 2) local sum = v1 + v2\nprint(\"v1 + v2 = \" .. tostring(sum)) -- Vector(4, 6) local diff = v1 - v2\nprint(\"v1 - v2 = \" .. tostring(diff)) -- Vector(2, 2) local dot = v1 * v2\nprint(\"v1 * v2 = \" .. dot) -- 11 local neg = -v1\nprint(\"-v1 = \" .. tostring(neg)) -- Vector(-3, -4) print(\"\\n=== v1的操作日志 ===\")\nlocal v1_logs = v1:get_log()\nprint(table.concat(v1_logs, \"\\n\")) print(\"\\n=== v2的操作日志 ===\")\nlocal v2_logs = v2:get_log()\nprint(table.concat(v2_logs, \"\\n\"))\n--[[ 输出\n=== 练习2：带日志的向量类测试 ===\nv1 = Vector(3, 4)\nv2 = Vector(1, 2)\nv1 + v2 = Vector(4, 6)\nv1 - v2 = Vector(2, 2)\nv1 * v2 = 11\n-v1 = Vector(-3, -4) === v1的操作日志 ===\n向量: Vector(3, 4)\n1. 创建向量: Vector(3, 4)\n2. 被加: 与 Vector(1, 2) 运算, 结果: Vector(4, 6)\n3. 被减: 与 Vector(1, 2) 运算, 结果: Vector(2, 2)\n4. 点积: 与 Vector(1, 2) 运算, 结果: 11\n5. 取负: 运算, 结果: Vector(-3, -4) === v2的操作日志 ===\n向量: Vector(1, 2)\n1. 创建向量: Vector(1, 2)\n2. 加数: 与 Vector(3, 4) 运算, 结果: Vector(4, 6)\n3. 减数: 与 Vector(3, 4) 运算, 结果: Vector(2, 2)\n4. 点积: 与 Vector(3, 4) 运算, 结果: 11\n--]] 元表基础： setmetatable(t, mt) - 设置元表\ngetmetatable(t) - 获取元表\n元表可以改变表的默认行为 算术和关系元方法： __add 加、__sub 减、__mul 乘、__div 除 - 四则运算\n__eq、__lt、__le - 等于与小于关系比较\n__unm - 负号操作\n__mod、__pow - 取模和幂运算\n大于关系的原理：交换操作数 索引相关元方法： __index - 索引不存在的键时调用，如果是表则在该表索引\n__newindex - 给不存在的键赋值时调用\nrawget - 绕过 __index 索引\nrawset - 绕过 __newindex 赋值\n使用代理表在每次索引时调用元方法 其他元方法： __tostring - 自定义字符串表示\n__call - 让表可被调用\n__concat - 连接操作符 高级应用： 面向对象编程（继承、多态）\n只读表和受保护表\n默认值表\n访问跟踪和日志 完成本章后，你应该能够：\n理解元表的作用和原理\n设置和获取元表\n实现基本的算术和关系运算重载\n理解大于关系原理\n使用 __index、__newindex 和代理表控制索引与赋值\n实现表的只读保护\n使用元表实现简单的类继承\n理解 rawget 和 rawset 的作用\n实现表的自定义字符串表示\n让表可以像函数一样被调用 元表和原型继承有什么关系？\n为什么 Lua 使用元表而不是传统的类继承？\n如何实现多重继承？\n元表和协程结合可以解决什么问题？\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"13.1 什么是元表？","level":2,"id":"13.1_什么是元表？_0"},{"heading":"13.1.1 为什么需要元表？","level":3,"id":"13.1.1_为什么需要元表？_0"},{"heading":"示例：没有元表的限制","level":4,"id":"示例：没有元表的限制_0"},{"heading":"13.2 元表基础概念","level":2,"id":"13.2_元表基础概念_0"},{"heading":"13.2.1 setmetatable - 设置元表","level":3,"id":"13.2.1_setmetatable_-_设置元表_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"13.2.2 getmetatable - 获取元表","level":3,"id":"13.2.2_getmetatable_-_获取元表_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"13.2.3 元方法类型","level":3,"id":"13.2.3_元方法类型_0"},{"heading":"示例","level":4,"id":"示例_2"},{"heading":"13.3 算术和关系元方法","level":2,"id":"13.3_算术和关系元方法_0"},{"heading":"13.3.1 算术元方法","level":3,"id":"13.3.1_算术元方法_0"},{"heading":"13.3.2 关系元方法","level":3,"id":"13.3.2_关系元方法_0"},{"heading":"13.3.3 大于关系元方法","level":3,"id":"13.3.3_大于关系元方法_0"},{"heading":"13.4 索引相关元方法","level":2,"id":"13.4_索引相关元方法_0"},{"heading":"13.4.1 <code>__index</code> - 索引不存在键","level":3,"id":"13.4.1_`_index`_-_索引不存在键_0"},{"heading":"13.4.2 <code>__newindex</code> - 不存在索引赋值","level":3,"id":"13.4.2_`_newindex`_-_不存在索引赋值_0"},{"heading":"13.4.3 rawget - 绕过元方法索引","level":3,"id":"13.4.3_rawget_-_绕过元方法索引_0"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"13.4.4 rawset - 绕过元方法赋值","level":3,"id":"13.4.4_rawset_-_绕过元方法赋值_0"},{"heading":"示例","level":4,"id":"示例_4"},{"heading":"13.4.5 每次索引调用元方法","level":3,"id":"13.4.5_每次索引调用元方法_0"},{"heading":"13.5 其他重要元方法","level":2,"id":"13.5_其他重要元方法_0"},{"heading":"13.5.1 <code>__call</code> 元方法","level":3,"id":"13.5.1_`_call`_元方法_0"},{"heading":"13.5.2 <code>__tostring</code> 元方法","level":3,"id":"13.5.2_`_tostring`_元方法_0"},{"heading":"13.5.3 <code>__concat</code> 元方法","level":3,"id":"13.5.3_`_concat`_元方法_0"},{"heading":"13.6 元表的高级应用","level":2,"id":"13.6_元表的高级应用_0"},{"heading":"13.6.1 面向对象编程","level":3,"id":"13.6.1_面向对象编程_0"},{"heading":"13.6.2 只读表","level":3,"id":"13.6.2_只读表_0"},{"heading":"13.6.3 默认值表","level":3,"id":"13.6.3_默认值表_0"},{"heading":"13.7 元表的限制与注意事项","level":2,"id":"13.7_元表的限制与注意事项_0"},{"heading":"13.7.1 常见错误","level":3,"id":"13.7.1_常见错误_0"},{"heading":"13.7.2 性能考虑","level":3,"id":"13.7.2_性能考虑_0"},{"heading":"13.8 练习","level":2,"id":"13.8_练习_0"},{"heading":"练习 1：实现向量类","level":3,"id":"练习_1：实现向量类_0"},{"heading":"练习 2：跟踪向量的修改","level":3,"id":"练习_2：跟踪向量的修改_0"},{"heading":"13.9 本章总结","level":2,"id":"13.9_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"第-1-节-语法/13.-元表.html","pathToRoot":"..","attachments":[],"createdTime":1766488904769,"modifiedTime":1766548775792,"sourceSize":21641,"sourcePath":"第 1 节 - 语法/13. 元表.md","exportPath":"第-1-节-语法/13.-元表.html","showInTree":true,"treeOrder":14,"backlinks":[],"type":"markdown"},"第-1-节-语法/14.-luajit.html":{"title":"14. LuaJIT","icon":"","description":"LuaJIT 是一个高性能的 Lua 解释器和即时编译器（JIT），它完全兼容 Lua 5.1，但性能通常比标准 Lua 快得多。LuaJIT 的主要特性：\n高性能 JIT 编译器\n提供 FFI 允许直接调用 C 函数和使用 C 数据结构\n内存使用更少\n完全兼容 Lua 5.1\n支持更多字节码指令\n同 <a data-href=\"2. 基础语法规则#2 1 2 修复无法中文乱码\" href=\"第-1-节-语法/2.-基础语法规则.html#2 1 2 修复无法中文乱码\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">2. 基础语法规则 &gt; 2 1 2 修复无法中文乱码</a>\n切换到 LuaJIT 运行程序即可。JIT 编译器用于将 Lua 字节码动态编译为本地机器码，提高 2-15 倍性能。-- 性能测试：标准Lua vs LuaJIT\nlocal function benchmark_loop() local sum = 0 for i = 1, 10000000 do sum = sum + i end return sum\nend local start1 = os.clock()\nlocal result = benchmark_loop()\nlocal time1 = os.clock() - start1 -- 启用 JIT 编译器\njit.on()\nlocal start2 = os.clock()\nlocal result = benchmark_loop()\nlocal time2 = os.clock() - start2 print(string.format(\"Lua 执行时间: %.4f秒\", time1))\nprint(string.format(\"JIT 执行时间: %.4f秒\", time2))\nprint(string.format(\"性能提高: %.2f%%\", (time1 - time2) / time2 * 100))\n--[[ 输出\nLua 执行时间: 0.0410秒\nJIT 执行时间: 0.0110秒\n性能提高: 270%\n--]]\ngoto&nbsp;语句提供了一种低级的控制流跳转机制，可以在代码块内直接跳转到指定标签位置。\n可以使用 goto 来模拟 continue 跳过单次循环。::跳转标签名称::\t-- 定义跳转位置 goto 跳转到的标签\n-- Lua 没有 continue 关键字，用 goto 实现\nfor i = 1, 10 do if i % 2 == 0 then -- 跳过偶数 print(\"跳过偶数: \" .. i) goto continue end print(\"处理奇数: \" .. i) ::continue:: -- 循环末尾的标签\nend\n--[[ 输出\n处理奇数: 1\n跳过偶数: 2\n处理奇数: 3\n跳过偶数: 4\n处理奇数: 5\n跳过偶数: 6\n处理奇数: 7\n跳过偶数: 8\n处理奇数: 9\n跳过偶数: 10\n--]]\nfor i = 1, 3 do for j = 1, 3 do if i == 2 and j == 2 then print(\"找到目标，跳出所有循环\") goto exit_loops end print(i, j) end\nend ::exit_loops::\nprint(\"继续执行后续代码\")\n--[[ 输出\n1\t1\n1\t2\n1\t3\n2\t1\n找到目标，跳出所有循环\n继续执行后续代码\n--]]\n-- 在非函数中模拟\"提前返回\"逻辑\nlocal x = -1 ::validate::\nif x &lt;= 0 then print(\"x 必须大于0\") goto end_process\nend if x &gt; 100 then print(\"x 不能超过100\") goto end_process\nend print(\"x 有效: \" .. x) ::end_process::\nprint(\"验证完成\")\n--[[ 输出\nx 必须大于0\n验证完成\n--]]\n-- 不允许：跳进函数\nlocal function test() ::inside_func::\nend goto inside_func -- 不允许：跳进其他代码块\nif condition then local x = 10 ::label3::\nend goto label3 -- 不允许：跳过局部变量定义\ngoto lable1 local a = 123 ::lable1::\n-- 合法标签名（字母、数字、下划线）\n::valid_label::\n::Label123::\n::_start:: -- 不合法标签名\n::123start:: -- 不能以数字开头\n::my-label:: -- 不能包含连字符\n::end:: -- 不能用保留字\n-- 1. bit库 - 位运算\nprint(\"1. bit库 - 位运算:\")\nlocal bit = require(\"bit\") local a = 0x0F -- 00001111\nlocal b = 0xF0 -- 11110000 print(string.format(\"a = 0x%X (%d)\", a, a))\nprint(string.format(\"b = 0x%X (%d)\", b, b))\nprint(string.format(\"bit.band(a, b) = 0x%X\", bit.band(a, b))) -- 与\nprint(string.format(\"bit.bor(a, b) = 0x%X\", bit.bor(a, b))) -- 或\nprint(string.format(\"bit.bxor(a, b) = 0x%X\", bit.bxor(a, b))) -- 异或\nprint(string.format(\"bit.bnot(a) = 0x%X\", bit.bnot(a))) -- 非\nprint(string.format(\"bit.lshift(a, 2) = 0x%X\", bit.lshift(a, 2))) -- 左移\nprint(string.format(\"bit.rshift(b, 2) = 0x%X\", bit.rshift(b, 2))) -- 右移 -- 2. 表操作优化\n-- jit.on()\nprint(\"\\n2. 表操作优化:\")\nlocal large_table = {}\nlocal start_time = os.clock() -- 插入大量数据\nfor i = 1, 1000000 do large_table[i] = i * 2\nend local insert_time = os.clock() - start_time\nprint(\"插入100万条数据耗时: \" .. string.format(\"%.3f\", insert_time) .. \"秒\") -- 访问数据\nstart_time = os.clock()\nlocal sum = 0\nfor i = 1, 1000000 do sum = sum + large_table[i]\nend\nlocal access_time = os.clock() - start_time\nprint(\"访问100万条数据耗时: \" .. string.format(\"%.3f\", access_time) .. \"秒\")\nprint(\"总和: \" .. sum) -- 3. 协程优化\nprint(\"\\n3. 协程优化:\")\nlocal sum = 0 local function coroutine_test() local co = coroutine.create(function() for i = 1, 5 do coroutine.yield(i) end end) for i = 1, 5 do local success, value = coroutine.resume(co) if success then sum = sum + value end end\nend local start = os.clock()\nfor i = 1, 10000 do coroutine_test()\nend\nlocal elapsed = os.clock() - start\nprint(string.format(\"总和 %s\", sum))\nprint(string.format(\"执行10000次协程测试耗时: %.3f秒\", elapsed)) -- 4. 垃圾回收优化\nprint(\"\\n4. 垃圾回收优化:\") -- 显示GC统计\nlocal gc_stats = { count = collectgarbage(\"count\"), step = collectgarbage(\"step\"), isrunning = collectgarbage(\"isrunning\")\n} print(\"GC统计:\")\nprint(\" 内存使用: \" .. string.format(\"%.2f\", gc_stats.count) .. \" KB\")\nprint(\" GC是否运行: \" .. tostring(gc_stats.isrunning)) -- 手动触发GC\ncollectgarbage(\"collect\")\nprint(\"手动触发GC后内存: \" .. string.format(\"%.2f\", collectgarbage(\"count\")) .. \" KB\")\n--[[ 输出\n1. bit库 - 位运算:\na = 0xF (15)\nb = 0xF0 (240)\nbit.band(a, b) = 0x0\nbit.bor(a, b) = 0xFF\nbit.bxor(a, b) = 0xFF\nbit.bnot(a) = 0xFFFFFFFFFFFFFFF0\nbit.lshift(a, 2) = 0x3C\nbit.rshift(b, 2) = 0x3C 2. 表操作优化:\n插入100万条数据耗时: 0.016秒\n访问100万条数据耗时: 0.008秒\n总和: 1000001000000 3. 协程优化:\n总和 150000\n执行10000次协程测试耗时: 0.006秒 4. 垃圾回收优化:\nGC统计: 内存使用: 13410.04 KB GC是否运行: true\n手动触发GC后内存: 8252.30 KB\n--]]\nFFI 是 LuaJIT 最强大的特性之一，允许直接调用 C 函数、使用 C 数据类型和内存操作，无需编写 C 扩展模块。\nFFI 提供了 Lua 与 C 世界之间的桥梁，通过合理使用可以显著提升性能，但需要谨慎处理内存和类型安全问题。-- FFI使用示例\nlocal ffi = require(\"ffi\") -- 1. 声明C函数和类型\nffi.cdef [[ // 标准库函数 int strlen(const char *s); void *malloc(size_t size); void free(void *ptr); // 数学函数 double sin(double x); double cos(double x); double sqrt(double x); // 系统调用 int system(const char *command); // 自定义结构体 typedef struct { int x; int y; } Point; typedef struct { char name[32]; int age; float score; } Student;\n]] -- 2. 调用C函数\nprint(\"调用C标准库函数:\")\nlocal str = \"Hello, World!\"\nlocal length = ffi.C.strlen(str)\nprint(\"字符串长度: \" .. length) -- 3. 使用数学函数\nlocal angle = 45 * math.pi / 180\nlocal sin_value = ffi.C.sin(angle)\nlocal cos_value = ffi.C.cos(angle)\nprint(string.format(\"\\n数学函数: sin(45°)=%.3f, cos(45°)=%.3f\", sin_value, cos_value)) -- 4. 创建和使用C结构体\nprint(\"\\nC结构体使用:\")\n-- 创建Point结构体\nlocal point = ffi.new(\"Point\")\npoint.x = 10\npoint.y = 20\nprint(\"Point: x=\" .. point.x .. \", y=\" .. point.y) -- 创建Student结构体\nlocal student = ffi.new(\"Student\")\nffi.copy(student.name, \"张三\")\nstudent.age = 18\nstudent.score = 95.5 print(string.format(\"Student: name=%s, age=%d, score=%.1f\", ffi.string(student.name), student.age, student.score)) -- 5. 内存管理\nprint(\"\\n内存管理:\")\nlocal size = 100 * ffi.sizeof(\"int\")\nlocal buffer = ffi.C.malloc(size)\nprint(\"分配内存: \" .. size .. \" 字节\") if buffer ~= ffi.NULL then -- 将buffer转换为int数组 local int_array = ffi.cast(\"int*\", buffer) -- 初始化数组 for i = 0, 99 do int_array[i] = i * 2 end -- 访问数组元素 print(\"int_array[50] = \" .. int_array[50]) -- 释放内存 ffi.C.free(buffer) print(\"内存已释放\")\nend -- 6. 调用系统命令\nprint(\"\\n系统调用:\")\nlocal result = ffi.C.system(\"echo 'Hello from system call'\")\nprint(\"系统命令返回值: \" .. result)\n--[[ 输出\n调用C标准库函数:\n字符串长度: 13 数学函数: sin(45°)=0.707, cos(45°)=0.707 C结构体使用:\nPoint: x=10, y=20\nStudent: name=张三, age=18, score=95.5 内存管理:\n分配内存: 400 字节\nint_array[50] = 100\n内存已释放 系统调用:\n系统命令返回值: 0\n'Hello from system call'\n--]]\nlocal ffi = require(\"ffi\") 声明 C 类型和函数\n调用 C 函数\n管理 C 数据\nffi.cdef [[ // 基础类型 typedef int bool; typedef char int8_t; typedef short int16_t; typedef int int32_t; typedef long long int64_t; typedef unsigned char uint8_t; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef unsigned long long uint64_t; typedef float float32_t; typedef double float64_t; // 指针类型 typedef void* pointer; typedef const char* cstring; // 标准库类型 typedef long time_t; typedef struct tm tm_t;\n]]\nffi.cdef [[ // 简单结构体 typedef struct { int x; int y; } Point; // 嵌套结构体 typedef struct { Point start; Point end; } Line; // 数组作为成员 typedef struct { char name[64]; int scores[10]; } Student; // 位字段 typedef struct { unsigned int flag1 : 1; unsigned int flag2 : 1; unsigned int : 6; // 未使用位 unsigned int value : 8; } BitField; // 联合体 typedef union { int i; float f; char bytes[4]; } DataUnion;\n]]\nffi.cdef [[ // 标准库函数 // 字符串操作 size_t strlen(const char *s); char *strcpy(char *dest, const char *src); char *strcat(char *dest, const char *src); int strcmp(const char *s1, const char *s2); char *strstr(const char *haystack, const char *needle); // 内存操作 void *malloc(size_t size); void *calloc(size_t num, size_t size); void *realloc(void *ptr, size_t size); void free(void *ptr); void *memcpy(void *dest, const void *src, size_t n); void *memset(void *s, int c, size_t n); // 数学函数 double sin(double x); double cos(double x); double tan(double x); double sqrt(double x); double pow(double x, double y); double log(double x); double exp(double x); double fabs(double x); // 输入输出 int printf(const char *format, ...); int sprintf(char *str, const char *format, ...); int scanf(const char *format, ...); int puts(const char *s); // 系统调用 int system(const char *command); time_t time(time_t *t); char *ctime(const time_t *timer); // 自定义函数原型 double calculate_average(double *array, int length); void process_data(void *data, size_t size);\n]]\n-- 直接调用C标准库函数\nprint(\"字符串长度:\", ffi.C.strlen(\"Hello, World!\"))\nprint(\"正弦值:\", ffi.C.sin(math.pi / 2))\nprint(\"平方根:\", ffi.C.sqrt(2.0))\n-- 调用系统命令\nlocal result = ffi.C.system(\"ls -la\")\nprint(\"命令返回值:\", result) -- 获取当前时间\nlocal time_ptr = ffi.new(\"time_t[1]\")\nffi.C.time(time_ptr)\nlocal time_str = ffi.C.ctime(time_ptr)\nprint(\"当前时间:\", ffi.string(time_str))\n-- 创建结构体（自动初始化为0）\nlocal point = ffi.new(\"Point\")\npoint.x = 10\npoint.y = 20\nprint(\"Point:\", point.x, point.y) -- 创建并初始化\nlocal point2 = ffi.new(\"Point\", {x = 30, y = 40}) -- 创建结构体数组\nlocal points = ffi.new(\"Point[5]\")\npoints[0].x = 1\npoints[0].y = 2\npoints[1] = {x = 3, y = 4} -- 创建包含数组的结构体\nlocal student = ffi.new(\"Student\")\nffi.copy(student.name, \"Alice\")\nfor i = 0, 9 do student.scores[i] = math.random(60, 100)\nend\n-- 动态分配内存\nlocal size = 100 * ffi.sizeof(\"int\")\nlocal buffer = ffi.C.malloc(size)\nprint(\"分配了\", size, \"字节内存\") if buffer ~= ffi.NULL then -- 转换为特定类型指针 local int_array = ffi.cast(\"int*\", buffer) -- 初始化数组 for i = 0, 99 do int_array[i] = i * i end -- 访问元素 print(\"int_array[50] =\", int_array[50]) -- 重新分配内存 local new_size = 200 * ffi.sizeof(\"int\") local new_buffer = ffi.C.realloc(buffer, new_size) -- 释放内存 ffi.C.free(new_buffer) print(\"内存已释放\")\nend -- 使用calloc（初始化为0）\nlocal zero_buffer = ffi.C.calloc(10, ffi.sizeof(\"double\"))\n-- 创建C字符串\nlocal cstr = ffi.new(\"char[64]\")\nffi.copy(cstr, \"Hello from C string\") -- 转换为Lua字符串\nlocal lua_str = ffi.string(cstr)\nprint(\"Lua字符串:\", lua_str) -- 使用sprintf格式化\nlocal buffer = ffi.new(\"char[256]\")\nffi.C.sprintf(buffer, \"格式化输出: %s, 数值: %d, 浮点数: %.2f\", \"测试\", 123, 45.678)\nprint(ffi.string(buffer))\nffi.cdef [[ // 回调函数类型 typedef void (*callback_t)(int status, const char *message); // 接受回调的函数 void register_callback(callback_t cb); void trigger_event(int event_id);\n]] -- Lua回调函数\nlocal function lua_callback(status, message) print(\"回调被调用:\") print(\" 状态:\", status) print(\" 消息:\", ffi.string(message))\nend -- 将Lua函数转换为C回调\nlocal cb = ffi.cast(\"callback_t\", lua_callback) -- 注意：回调函数会被垃圾回收，需要保持引用\n_G.keep_alive = cb\nlocal var = ffi.new(\"int\", 42) print(\"类型信息:\")\nprint(\" ffi.typeof(var):\", ffi.typeof(var))\nprint(\" ffi.istype('int', var):\", ffi.istype('int', var))\nprint(\" ffi.sizeof(var):\", ffi.sizeof(var))\nprint(\" ffi.alignof('int'):\", ffi.alignof('int'))\nprint(\" ffi.offsetof('Student', 'name'):\", ffi.offsetof('Student', 'name'))\n-- 基本类型转换\nlocal int_val = ffi.new(\"int\", 42)\nlocal ptr = ffi.cast(\"void*\", int_val)\nlocal int_ptr = ffi.cast(\"int*\", ptr) -- 指针算术\nlocal array = ffi.new(\"int[10]\")\nfor i = 0, 9 do array[i] = i * 10\nend -- 获取元素指针\nlocal elem_ptr = array + 5 -- 指向array[5]\nprint(\"array[5] =\", elem_ptr[0])\nlocal function vector_operations() ffi.cdef [[ typedef struct { double x, y, z; } Vector3; double dot_product(Vector3 a, Vector3 b); Vector3 cross_product(Vector3 a, Vector3 b); double vector_length(Vector3 v); ]] local vec1 = ffi.new(\"Vector3\", {x=1, y=2, z=3}) local vec2 = ffi.new(\"Vector3\", {x=4, y=5, z=6}) -- 点积（模拟） local dot = vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z print(\"点积:\", dot) -- 叉积（模拟） local cross = ffi.new(\"Vector3\") cross.x = vec1.y * vec2.z - vec1.z * vec2.y cross.y = vec1.z * vec2.x - vec1.x * vec2.z cross.z = vec1.x * vec2.y - vec1.y * vec2.x print(\"叉积:\", cross.x, cross.y, cross.z)\nend\nlocal function binary_data_processing() -- 创建二进制缓冲区 local buffer_size = 1024 local buffer = ffi.new(\"uint8_t[?]\", buffer_size) -- 填充数据 for i = 0, buffer_size - 1 do buffer[i] = math.random(0, 255) end -- 计算校验和 local checksum = 0 for i = 0, buffer_size - 1 do checksum = checksum + buffer[i] end checksum = checksum % 256 print(\"缓冲区大小:\", buffer_size) print(\"校验和:\", checksum) -- 查找特定字节 local target = 0xAA for i = 0, buffer_size - 1 do if buffer[i] == target then print(\"找到\", string.format(\"0x%02X\", target), \"在位置\", i) end end\nend\nlocal function system_interaction() -- 注意：这部分代码依赖于操作系统 ffi.cdef [[ // Windows API示例 #ifdef _WIN32 #include &lt;windows.h&gt; void Sleep(DWORD milliseconds); DWORD GetTickCount(); #endif // POSIX示例 #ifndef _WIN32 #include &lt;unistd.h&gt; unsigned int sleep(unsigned int seconds); #endif ]] -- 跨平台休眠 local function msleep(milliseconds) if ffi.os == \"Windows\" then ffi.C.Sleep(milliseconds) else ffi.C.usleep(milliseconds * 1000) end end print(\"开始休眠...\") msleep(1000) -- 休眠1秒 print(\"休眠结束\")\nend 平台依赖性：FFI 代码可能在不同平台表现不同\n类型安全：错误的类型使用可能导致崩溃\n内存泄漏：需要手动管理内存\n回调函数：Lua 回调可能被垃圾回收\n-- 启用调试信息\nffi.cdef [[ // 添加详细的错误检查\n]] -- 使用assert进行运行时检查\nlocal ptr = ffi.C.malloc(100)\nassert(ptr ~= ffi.NULL, \"内存分配失败\") -- 添加日志记录\nlocal function debug_alloc(size) print(\"分配内存:\", size, \"字节\") local ptr = ffi.C.malloc(size) print(\"返回指针:\", tostring(ptr)) return ptr\nend\n-- 优先方案：使用函数和返回值\nlocal function processItem(item) if not isValid(item) then return false -- 代替 goto end -- 正常处理 return true\nend -- 次选方案：goto 用于简单循环控制\nfor i = 1, 10 do if shouldSkip(i) then goto continue end process(i) ::continue::\nend\n-- 难以理解：过度使用 goto\ngoto step1\n::step3::\nprint(\"步骤3\")\ngoto end\n::step1::\nprint(\"步骤1\")\ngoto step2\n::step2::\nprint(\"步骤2\")\ngoto step3\n::end:: -- 清晰明了：限制使用范围\nfor i = 1, 5 do if i == 3 then goto skip_print end print(\"正常: \" .. i) ::skip_print::\nend\n-- 1. 复用类型对象\nlocal Point_type = ffi.typeof(\"Point\")\nlocal points = {}\nfor i = 1, 1000 do points[i] = Point_type() -- 比ffi.new更快\nend -- 2. 批量操作\nlocal function process_batch(data, count) local buffer = ffi.new(\"double[?]\", count) for i = 0, count - 1 do buffer[i] = data[i + 1] * 2 end -- 批量处理buffer return buffer\nend -- 3. 避免频繁的类型转换\nlocal cached_type = ffi.typeof(\"int[100]\")\nlocal array = cached_type()\n-- 1. 使用gc来管理内存\nlocal function create_large_buffer() local buf = ffi.gc(ffi.C.malloc(1024 * 1024), ffi.C.free) -- buf会在垃圾回收时自动释放 return buf\nend -- 2. 显式内存管理\nlocal function manual_memory_management() local buffers = {} local function allocate(name, size) local buf = ffi.C.malloc(size) if buf == ffi.NULL then error(\"内存分配失败\") end buffers[name] = buf return buf end local function cleanup() for name, buf in pairs(buffers) do ffi.C.free(buf) buffers[name] = nil end end -- 使用... local data = allocate(\"data\", 1024) -- 清理... cleanup()\nend LuaJIT 核心特性： 高性能 JIT 编译器 - 动态编译字节码为机器码\nFFI（外部函数接口） - 直接调用 C 函数和使用 C 数据结构\n完全兼容 Lua 5.1 - 无缝迁移现有代码\n更低的内存占用 - 优化内存管理 JIT 编译器： jit.on() - 启用 JIT 编译\njit.off() - 禁用 JIT 编译\n性能提升 2-15 倍 - 特别适合循环和数值计算\n动态编译 - 运行时将热点代码编译为机器码 FFI 外部函数接口： ffi.cdef - 声明 C 函数和类型\nffi.C - 调用标准 C 库函数\nffi.new - 创建 C 结构体实例\nffi.cast - 类型转换\nffi.string - 转换 C 字符串为 Lua 字符串\nffi.copy - 复制数据到 C 缓冲区\n直接内存管理 - 使用 malloc/free goto 语句： ::label:: - 定义标签\ngoto label - 跳转到标签\n模拟 continue - Lua 原生无 continue\n跳出多重嵌套 - 简化复杂控制流\n卫语句模式 - 提前返回逻辑 其他增强功能： bit 库 - 位运算操作\n表操作优化 - 大规模数据处理\n协程优化 - 轻量级并发\n垃圾回收优化 - 更高效的内存管理 完成本章后，你应该能够：\n理解 LuaJIT 的性能优势和应用场景\n启用和禁用 JIT 编译器\n使用 FFI 调用 C 标准库函数\n创建和使用 C 结构体\n进行 C 风格的内存分配和管理\n正确使用 goto 实现流程控制\n理解 goto 的作用域限制\n使用 bit 库进行位运算\n利用 LuaJIT 优化大规模数据处理\n手动控制垃圾回收机制 JIT 编译器在什么场景下性能提升最明显？什么场景下可能效果有限？\nFFI 与传统的 Lua C API 扩展方式相比有什么优势和劣势？\n为什么 goto 在大多数编程语言中都不推荐使用？Lua 中的 goto 有哪些特殊限制？\n使用 FFI 直接操作内存时需要注意哪些安全问题？\n如何平衡代码可读性和使用 goto 带来的便利性？\nQ: 为什么 goto 有这么多限制？\nA: 为了避免创建\"面条代码\"，确保程序结构清晰，防止跳过变量初始化等危险操作。Q: 什么时候应该使用 goto？\nA: 仅当：\n需要模拟 continue\n简单跳出多重循环\n没有更清晰的结构化替代方案\nQ: goto 的性能影响？\nA: Lua 的 goto 是编译期处理，运行时几乎没有性能开销。","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"14.1 LuaJIT 简介","level":3,"id":"14.1_LuaJIT_简介_0"},{"heading":"14.2 使用 LuaJIT","level":2,"id":"14.2_使用_LuaJIT_0"},{"heading":"14.3 JIT 编译器","level":2,"id":"14.3_JIT_编译器_0"},{"heading":"14.4 goto - 代码跳转","level":2,"id":"14.4_goto_-_代码跳转_0"},{"heading":"核心用途","level":4,"id":"核心用途_0"},{"heading":"1. 模拟 continue 语句","level":5,"id":"1._模拟_`continue`_语句_0"},{"heading":"2. 跳出多重嵌套","level":5,"id":"2._跳出多重嵌套_0"},{"heading":"3. 卫语句模式（提前返回）","level":5,"id":"3._卫语句模式（提前返回）_0"},{"heading":"重要限制与规则","level":4,"id":"重要限制与规则_0"},{"heading":"1. 作用域限制（最重要！）","level":5,"id":"1._作用域限制（最重要！）_0"},{"heading":"2. 标签定义规则","level":5,"id":"2._标签定义规则_0"},{"heading":"14.5 其他功能","level":2,"id":"14.5_其他功能_0"},{"heading":"14.6 FFI（外部函数接口）","level":2,"id":"14.6_FFI（外部函数接口）_0"},{"heading":"14.6.1 FFI 基础","level":3,"id":"14.6.1_FFI_基础_0"},{"heading":"加载 FFI 模块","level":4,"id":"加载_FFI_模块_0"},{"heading":"基本工作流程","level":4,"id":"基本工作流程_0"},{"heading":"14.6.2 声明 C 类型","level":3,"id":"14.6.2_声明_C_类型_0"},{"heading":"基本类型声明","level":4,"id":"基本类型声明_0"},{"heading":"结构体声明","level":4,"id":"结构体声明_0"},{"heading":"函数声明","level":4,"id":"函数声明_0"},{"heading":"14.6.3 调用 C 函数","level":3,"id":"14.6.3_调用_C_函数_0"},{"heading":"访问标准库","level":4,"id":"访问标准库_0"},{"heading":"调用系统函数","level":4,"id":"调用系统函数_0"},{"heading":"14.6.4 创建和操作 C 数据","level":3,"id":"14.6.4_创建和操作_C_数据_0"},{"heading":"创建结构体实例","level":4,"id":"创建结构体实例_0"},{"heading":"内存分配和管理","level":4,"id":"内存分配和管理_0"},{"heading":"字符串操作","level":4,"id":"字符串操作_0"},{"heading":"14.6.5 回调函数和函数指针","level":3,"id":"14.6.5_回调函数和函数指针_0"},{"heading":"定义回调函数类型","level":4,"id":"定义回调函数类型_0"},{"heading":"14.6.6 类型检查和转换","level":3,"id":"14.6.6_类型检查和转换_0"},{"heading":"类型检查","level":4,"id":"类型检查_0"},{"heading":"类型转换","level":4,"id":"类型转换_0"},{"heading":"14.6.7 实用示例","level":3,"id":"14.6.7_实用示例_0"},{"heading":"示例 1：高性能数学计算","level":4,"id":"示例_1：高性能数学计算_0"},{"heading":"示例 2：处理二进制数据","level":4,"id":"示例_2：处理二进制数据_0"},{"heading":"示例 3：与系统 API 交互","level":4,"id":"示例_3：与系统_API_交互_0"},{"heading":"14.6.8 限制和注意事项","level":3,"id":"14.6.8_限制和注意事项_0"},{"heading":"FFI 的限制","level":4,"id":"FFI_的限制_0"},{"heading":"调试技巧","level":4,"id":"调试技巧_0"},{"heading":"14.7 最佳实践建议","level":2,"id":"14.7_最佳实践建议_0"},{"heading":"1. goto 使用场景优先级","level":4,"id":"1._goto_使用场景优先级_0"},{"heading":"2. 代码可读性维护","level":4,"id":"2._代码可读性维护_0"},{"heading":"3. 性能优化技巧","level":4,"id":"3._性能优化技巧_0"},{"heading":"4. 内存管理最佳实践","level":4,"id":"4._内存管理最佳实践_0"},{"heading":"14.8 本章总结","level":2,"id":"14.8_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"},{"heading":"常见问题解答","level":3,"id":"常见问题解答_0"}],"links":["第-1-节-语法/2.-基础语法规则.html#2 1 2 修复无法中文乱码"],"author":"","coverImageURL":"","fullURL":"第-1-节-语法/14.-luajit.html","pathToRoot":"..","attachments":[],"createdTime":1765335834818,"modifiedTime":1766749999612,"sourceSize":23357,"sourcePath":"第 1 节 - 语法/14. LuaJIT.md","exportPath":"第-1-节-语法/14.-luajit.html","showInTree":true,"treeOrder":15,"backlinks":[],"type":"markdown"},"第-1-节-语法/15.-love-2d.html":{"title":"15. Love 2D","icon":"","description":"Love 2D 是一个免费的开源 2D 游戏引擎，使用 Lua 作为脚本语言。Love 2D 主要特性:\n简单易用的 API\n跨平台支持（Windows, macOS, Linux, Android, iOS）\n内置物理引擎（Box2D）\n支持多种图像、音频格式\n强大的着色器支持\n网络功能\n文件系统访问\n-- LOVE2D 基础示例 -- LOVE2D 回调函数结构\nprint(\"\\nLOVE2D 主要回调函数:\")\nprint(\" love.load() -- 游戏初始化\")\nprint(\" love.update(dt) -- 游戏逻辑更新\")\nprint(\" love.draw() -- 游戏渲染\")\nprint(\" love.keypressed() -- 键盘按下\")\nprint(\" love.mousepressed() -- 鼠标按下\") -- 简单的 LOVE2D 程序结构\nlocal function love_template() return [[\nfunction love.load() -- 初始化代码 print(\"游戏加载完成!\")\nend function love.update(dt) -- 每帧更新逻辑 -- dt 是帧时间（秒）\nend function love.draw() -- 每帧绘制 love.graphics.print(\"Hello LOVE2D!\", 400, 300)\nend function love.keypressed(key) if key == \"escape\" then love.event.quit() end\nend\n]]\nend print(\"\\n 基本程序结构示例:\")\nprint(love_template())\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"15.1 Love 2D 简介","level":3,"id":"15.1_Love_2D_简介_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"第-1-节-语法/15.-love-2d.html","pathToRoot":"..","attachments":[],"createdTime":1765502579627,"modifiedTime":1766484568767,"sourceSize":1202,"sourcePath":"第 1 节 - 语法/15. Love 2D.md","exportPath":"第-1-节-语法/15.-love-2d.html","showInTree":true,"treeOrder":16,"backlinks":[],"type":"markdown"},"第-1-节-语法/参考答案.html":{"title":"参考答案","icon":"","description":" playerName ✓\n2ndPlayer ✗（以数字开头）\nplayer_score ✓\nlocal ✗（关键字）\n_internal ✓\nmy-var ✗（包含连字符）\n玩家1 ✗（中文）\n-- 基本信息\nlocal name = \"张三\"\nlocal age = 25\nlocal interests = \"编程、游戏、阅读\"\nlocal goal = \"掌握Lua编程，开发自己的小游戏\" -- 输出信息\nprint(\"姓名: \" .. name)\nprint(\"年龄: \" .. age .. \"岁\")\nprint(\"兴趣爱好: \" .. interests)\nprint(\"学习目标: \" .. goal)\nlocal function describe_value(value) local t = type(value) local description if t == \"nil\" then description = \"空值\" elseif t == \"boolean\" then description = \"布尔值\" elseif t == \"number\" then description = \"数字\" elseif t == \"string\" then description = \"字符串\" elseif t == \"table\" then description = \"表\" elseif t == \"function\" then description = \"函数\" end print(description)\nend -- 测试输出\ndescribe_value(nil) -- 输出 空值\ndescribe_value(true) -- 输出 布尔值\ndescribe_value(123) -- 输出 数字\ndescribe_value(\"string\") -- 输出 字符串\ndescribe_value({1, 2, 3}) -- 输出 表\ndescribe_value(describe_value)\t-- 输出 函数\nlocal operator = \"+\"\t-- 模拟用户输入\nlocal a = 5\nlocal b = 3 if operator == \"+\" then print(a + b)\nelseif operator == \"-\" then print(a - b)\nelseif operator == \"*\" then print(a * b)\nelseif operator == \"/\" then print(a / b)\nelseif operator == \"%\" then print(a % b)\nelseif operator == \"^\" then print(a ^ b)\nend\nprint(\"我已经想好了一个1-100之间的数字\") -- 生成随机数\nmath.randomseed(os.time()) -- 设置随机种子\nlocal random_number = math.random(1, 100)\nlocal guess_count = 0\nlocal max_guesses = 4 print(\"你有\" .. max_guesses .. \"次机会猜中这个数字\") while guess_count &lt; max_guesses do guess_count = guess_count + 1 local remaining_guesses = max_guesses - guess_count + 1 print(\"\\n第\" .. guess_count .. \"次尝试，还剩\" .. remaining_guesses .. \"次机会\") print(\"请输入你的猜测（1-100）:\") -- 模拟用户输入 local guess if guess_count == 1 then guess = 50 -- 第一次猜50 elseif guess_count == 2 then guess = 25 -- 第二次猜25 else guess = secret_number -- 第三次猜中 end print(\"你猜的是：\" .. guess) if guess &lt; secret_number then print(\"太小了！\") elseif guess &gt; secret_number then print(\"太大了！\") else print(\"恭喜你！猜对了！\") print(\"你用了\" .. guess_count .. \"次猜中数字\" .. secret_number) break end if guess_count == max_guesses then print(\"\\n很遗憾，你没有在\" .. max_guesses .. \"次内猜中\") print(\"正确答案是：\" .. secret_number) end\nend print(\"游戏结束\")\n--[[ 输出\n我已经想好了一个1-100之间的数字\n你有4次机会猜中这个数字 第1次尝试，还剩10次机会\n请输入你的猜测（1-100）:\n你猜的是：50\n太大了！ 第2次尝试，还剩9次机会\n请输入你的猜测（1-100）:\n你猜的是：25\n太小了！ 第3次尝试，还剩8次机会\n请输入你的猜测（1-100）:\n你猜的是：26\n恭喜你！猜对了！\n你用了3次猜中数字26\n游戏结束\n--]]\n-- 1. 打印直角三角形\nprint(\"\\n1. 直角三角形:\")\nlocal height = 5\nfor i = 1, height do for j = 1, i do io.write(\"* \") end print()\nend -- 2. 打印倒直角三角形\nprint(\"\\n2. 倒直角三角形:\")\nfor i = height, 1, -1 do for j = 1, i do io.write(\"* \") end print()\nend -- 3. 打印等腰三角形\nprint(\"\\n3. 等腰三角形:\")\nfor i = 1, height do -- 打印空格 for j = 1, height - i do io.write(\" \") end -- 打印星号 for j = 1, 2 * i - 1 do io.write(\"*\") end print()\nend -- 4. 打印空心菱形\nprint(\"\\n4. 空心菱形:\")\nlocal diamond_height = 8\nlocal half = diamond_height / 2 + 1 -- 上半部分\nfor i = 1, half do for j = 1, half - i do io.write(\" \") end io.write(\"*\") if i &gt; 1 then for j = 1, 2 * i - 3 do io.write(\" \") end io.write(\"*\") end print()\nend -- 下半部分\nfor i = half - 1, 1, -1 do for j = 1, half - i do io.write(\" \") end io.write(\"*\") if i &gt; 1 then for j = 1, 2 * i - 3 do io.write(\" \") end io.write(\"*\") end print()\nend\n--[[ 输出\n1. 直角三角形:\n* * * * * * * * * * * * * * * 2. 倒直角三角形:\n* * * * * * * * * * * * * * * 3. 等腰三角形: * *** ***** *******\n********* 4. 空心菱形: * * * * * * *\n* * * * * * * * *\n--]]\n-- 加法\nlocal function add(a, b) return a + b\nend -- 减法\nlocal function subtract(a, b) return a - b\nend -- 乘法\nlocal function multiply(a, b) return a * b\nend -- 除法（带错误检查）\nlocal function divide(a, b) if b == 0 then return nil, \"除数不能为 0\" end return a / b\nend -- 平均值\nlocal function average(...) local numbers = {...} local sum = 0 for _, num in ipairs(numbers) do sum = sum + num end return sum / #numbers\nend -- 使用函数库\nprint(\"5 + 3 = \" .. add(5, 3))\nprint(\"10 - 4 = \" .. subtract(10, 4))\nprint(\"6 * 7 = \" .. multiply(6, 7)) local result, error_msg = divide(10, 0)\nif error_msg then print(\"错误: \" .. error_msg)\nelse print(\"10 / 2 = \" .. result)\nend print(\"平均值(1,2,3,4,5) = \" .. average(1, 2, 3, 4, 5))\n--[[ 输出\n5 + 3 = 8\n10 - 4 = 6\n6 * 7 = 42\n错误: 除数不能为 0\n平均值(1,2,3,4,5) = 3\n--]]\n-- 模拟购买的物品\nlocal function get_cart_item() return { { name = \"苹果\", price = 5, quantity = 3 }, { name = \"香蕉\", price = 3, quantity = 2 }, { name = \"橙子\", price = 6, quantity = 4 }, { name = \"葡萄\", price = 8, quantity = 1 } }\nend -- 打印商品详细信息\nlocal function print_item_info(cart) print(\"=== 商品详情 ===\") for _, item in ipairs(cart) do local item_total = item.price * item.quantity print(\"商品: \" .. item.name) print(\"单价: \" .. item.price .. \"元\") print(\"数量: \" .. item.quantity) print(\"小计: \" .. item_total .. \"元\") print(\"------------\") end\nend -- 计算购物车总价\nlocal function calculate_cart_info(cart) local total_price, total_quantity = 0, 0 for _, item in ipairs(cart) do total_price = total_price + (item.price * item.quantity) total_quantity = total_quantity + item.quantity end print(\"购物车总价: \" .. total_price .. \"元\") return total_price, total_quantity\nend -- 判断是否有优惠（满50减10，满100减25，买10个赠1个）\nlocal function check_discount(total_price, total_quantity) if total_price &lt; 50 then print(\"未满50元，无优惠\") return end if total_quantity &gt;= 10 then print(\"购物车物品总数：\" .. total_quantity .. \"个，赠品1个\") end local discount_price = total_price if total_price &gt;= 100 then discount_price = total_price - 25 print(\"符合优惠条件，满100减25\") elseif total_price &gt;= 50 then discount_price = total_price - 10 print(\"符合优惠条件，满50减10\") end print(\"优惠后价格: \" .. discount_price .. \"元\")\nend local function rec_item(recommendations) for _, rec in ipairs(recommendations) do local rec_total = rec.price * 1 -- 假设推荐买1个 print(\" \" .. rec.name .. \": \" .. rec.price .. \"元/个\") end\nend -- 根据购物车推荐相关商品\nlocal function recommendations_item(cart) print(\"\\n=== 推荐商品 ===\") local recommendations = { { name = \"梨子\", price = 6 }, { name = \"芒果\", price = 10 } } for _, cart_item in ipairs(cart) do if cart_item.name == \"苹果\" then print(\"您购买了苹果，可能也喜欢:\") rec_item(recommendations) elseif cart_item.name == \"香蕉\" then print(\"您购买了香蕉，可能也喜欢:\") rec_item(recommendations) elseif cart_item.name == \"橙子\" then print(\"您购买了橙子，可能也喜欢:\") rec_item(recommendations) end end\nend -- 主程序\nlocal function main() -- 获取购物车物品 local cart = get_cart_item() -- 打印商品信息 print_item_info(cart) -- 计算总价和总数量 local total_price, total_quantity = calculate_cart_info(cart) -- 检查优惠 check_discount(total_price, total_quantity) -- 推荐相关商品 recommendations_item(cart)\nend -- 运行主程序\nmain()\n--[[ 输出\n=== 商品详情 ===\n商品: 苹果\n单价: 5元\n数量: 3\n小计: 15元\n------------\n商品: 香蕉\n单价: 3元\n数量: 2\n小计: 6元\n------------\n商品: 橙子\n单价: 6元\n数量: 4\n小计: 24元\n------------\n商品: 葡萄\n单价: 8元\n数量: 1\n小计: 8元\n------------\n购物车总价: 53元\n购物车物品总数：10个，赠品1个\n符合优惠条件，满50减10\n优惠后价格: 43元 === 推荐商品 ===\n您购买了苹果，可能也喜欢: 梨子: 6元/个 芒果: 10元/个\n您购买了香蕉，可能也喜欢: 梨子: 6元/个 芒果: 10元/个\n您购买了橙子，可能也喜欢: 梨子: 6元/个 芒果: 10元/个\n--]]\nlocal contacts = {} local function add_contact(name, phone, email) if contacts[name] then print(\"联系人 \" .. name .. \" 已存在\") return false end contacts[name] = { phone = phone, email = email or \"\" } print(\"已添加联系人: \" .. name) return true\nend local function find_contact(name) local contact = contacts[name] if not contact then print(\"未找到联系人: \" .. name) return nil end print(\"找到联系人 \" .. name .. \":\") print(\" 电话: \" .. contact.phone) print(\" 邮箱: \" .. (contact.email ~= \"\" and contact.email or \"无\")) return contact\nend local function list_contacts() if #contacts == 0 then print(\"通讯录为空\") return end print(\"=== 通讯录 ===\") local count = 0 for name, info in pairs(contacts) do count = count + 1 print(count .. \". \" .. name .. \" - \" .. info.phone) end print(\"总计: \" .. count .. \" 个联系人\")\nend local function remove_contact(name) if not contacts[name] then print(\"联系人不存在: \" .. name) return false end contacts[name] = nil print(\"已删除联系人: \" .. name) return true\nend -- 测试联系人管理系统\nadd_contact(\"张三\", \"13800138000\", \"zhangsan@email.com\")\nadd_contact(\"李四\", \"13900139000\")\nadd_contact(\"王五\", \"13700137000\", \"wangwu@company.com\") list_contacts() find_contact(\"张三\")\nfind_contact(\"赵六\") remove_contact(\"李四\")\nlist_contacts() --[[ 输出\n=== 联系人管理系统 ===\n已添加联系人: 张三\n已添加联系人: 李四\n已添加联系人: 王五\n通讯录为空\n找到联系人 张三: 电话: 17300138000 邮箱: zhangsan@email.com\n未找到联系人: 赵六\n已删除联系人: 李四\n通讯录为空\n--]]\nlocal shopping_cart = { items = {}, -- 商品列表 total_price = 0 -- 总价\n} function shopping_cart:add_item(name, price, quantity) quantity = quantity or 1 -- 检查是否已存在 for _, item in ipairs(self.items) do if item.name == name then item.quantity = item.quantity + quantity item.subtotal = item.price * item.quantity self.total_price = self.total_price + price * quantity print(\"已更新商品: \" .. name .. \" x\" .. quantity) return end end -- 新商品 local new_item = { name = name, price = price, quantity = quantity, subtotal = price * quantity } table.insert(self.items, new_item) self.total_price = self.total_price + new_item.subtotal print(\"已添加商品: \" .. name .. \" x\" .. quantity)\nend function shopping_cart:remove_item(name, quantity) quantity = quantity or 99999 -- 默认移除全部 for i, item in ipairs(self.items) do if item.name == name then local remove_qty = math.min(quantity, item.quantity) item.quantity = item.quantity - remove_qty item.subtotal = item.price * item.quantity self.total_price = self.total_price - item.price * remove_qty if item.quantity &lt;= 0 then table.remove(self.items, i) print(\"已移除商品: \" .. name) else print(\"已减少商品: \" .. name .. \" x\" .. remove_qty .. \"，剩余: x\" .. item.quantity) end return end end print(\"商品不存在: \" .. name)\nend function shopping_cart:show_cart() if #self.items == 0 then print(\"购物车为空\") return end print(\"=== 购物车 ===\") for i, item in ipairs(self.items) do print(string.format(\"%d. %-15s 单价: %6.2f 数量: %3d 小计: %8.2f\", i, item.name, item.price, item.quantity, item.subtotal)) end print(string.format(\"\\n总计: %.2f 元\", self.total_price))\nend function shopping_cart:clear() self.items = {} self.total_price = 0 print(\"已清空购物车\")\nend -- 测试购物车系统\nprint(\"=== 购物车系统 ===\")\nshopping_cart:add_item(\"苹果\", 5.5, 2)\nshopping_cart:add_item(\"香蕉\", 3.2, 3)\nshopping_cart:add_item(\"苹果\", 5.5, 1) -- 增加苹果数量 shopping_cart:show_cart() shopping_cart:remove_item(\"香蕉\", 1) -- 减少香蕉数量 shopping_cart:show_cart() shopping_cart:clear()\nshopping_cart:show_cart() --[[ 输出\n== 购物车系统 ===\n已添加商品: 苹果 x2\n已添加商品: 香蕉 x3\n已更新商品: 苹果 x1\n=== 购物车 ===\n1. 苹果 单价: 5.50 数量: 3 小计: 16.50\n2. 香蕉 单价: 3.20 数量: 3 小计: 9.60 总计: 38.90 元\n已减少商品: 香蕉 x1，剩余: x2\n=== 购物车 ===\n1. 苹果 单价: 5.50 数量: 3 小计: 16.50\n2. 香蕉 单价: 3.20 数量: 2 小计: 6.40 总计: 35.70 元\n已清空购物车\n购物车为空\n--]]\nlocal analysis = { data = {}\n} function analysis:analyze_text(text) local data = self.data -- 基本统计 data.total_chars = #text local _, lines = string.gsub(text, \"\\n\", \"\") data.lines = lines + 1 -- 单词统计 local word_pattern = \"[%a\\128-\\255]+[%w\\128-\\255%-']*\" local words = {} for word in string.gmatch(text, word_pattern) do word = string.lower(word) words[word] = (words[word] or 0) + 1 end data.word_count = 0 data.most_frequent = {} for word, count in pairs(words) do data.word_count = data.word_count + count -- 记录最频繁的单词 table.insert(data.most_frequent, { word = word, count = count }) end -- 按频率排序 table.sort(data.most_frequent, function(a, b) if a.count == b.count then return a.word &lt; b.word end return a.count &gt; b.count end) -- 只保留前 5 个 if #data.most_frequent &gt; 5 then for i = 6, #data.most_frequent do data.most_frequent[i] = nil end end\nend -- 测试文本分析器\nlocal test_text = [[\nLua is a powerful, efficient, lightweight, embeddable scripting language.\nIt supports procedural programming, object-oriented programming, functional\nprogramming, data-driven programming, and data description. Lua combines simple procedural syntax with powerful data description\nconstructs based on associative arrays and extensible semantics.\nLua is dynamically typed, runs by interpreting bytecode with a\nregister-based virtual machine, and has automatic memory management with\nincremental garbage collection, making it ideal for configuration,\nscripting, and rapid prototyping.\n]] print(\"=== 文本分析器 ===\")\nanalysis:analyze_text(test_text) local data = analysis.data print(\"基本统计:\")\nprint(\" 总字符数: \" .. data.total_chars)\nprint(\" 行数: \" .. data.lines)\nprint(\" 单词数: \" .. data.word_count) print(\"\\n 最频繁的单词:\")\nfor i, item in ipairs(data.most_frequent) do print(string.format(\" %2d. %-15s: %d 次\", i, item.word, item.count))\nend\n--[[ 输出\n基本统计: 总字符数: 582 行数: 11 单词数: 70 最频繁的单词: 1. and : 4 次 2. programming : 4 次 3. lua : 3 次 4. with : 3 次 5. a : 2 次\n--]]\nlocal log = {} log.LEVEL_NAMES = { \"INFO\", \"ERROR\"\n} -- 创建新的日志实例\nfunction log:new(name) local logger = {} -- 添加日志方法 for _, level_name in ipairs(self.LEVEL_NAMES) do logger[string.lower(level_name)] = function(message, ...) log:_log(level_name, name, message, ...) end end return logger\nend -- 内部日志方法\nfunction log:_log(level_name, name, message, ...) -- 格式化消息 message = string.format(message, ...) -- 构建日志前缀 local log_line = string.format(\"[%s] %s: %s\", level_name, name, message) print(log_line)\nend return log\n-- 创建结构化的错误类型，便于处理\n-- 错误类型定义\nlocal error_types = { VALIDATION = { code = 100, name = \"VALIDATION_ERROR\", description = \"输入验证失败\" }, DATABASE = { code = 200, name = \"DATABASE_ERROR\", description = \"数据库操作失败\" }, NETWORK = { code = 300, name = \"NETWORK_ERROR\", description = \"网络通信失败\" }, PERMISSION = { code = 400, name = \"PERMISSION_ERROR\", description = \"权限不足\" }, INTERNAL = { code = 500, name = \"INTERNAL_ERROR\", description = \"内部服务器错误\" }\n} -- 错误创建函数\nlocal function create_error(error_type, message, details) local error_info = error_types[error_type] if not error_info then error_info = error_types.INTERNAL end return { type = error_type, code = error_info.code, name = error_info.name, message = message or error_info.description, details = details, timestamp = os.time(), stack_trace = debug.traceback(\"\", 2) }\nend -- 错误抛出函数\nlocal function throw_error(error_type, message, details) error(create_error(error_type, message, details), 2)\nend -- 错误处理函数\nlocal function handle_error(err, context) -- 如果是我们的自定义错误 if type(err) == \"table\" and err.code then print(string.format(\"[错误处理] 类型: %s (%d)\", err.name, err.code)) print(string.format(\" 消息: %s\", err.message)) if err.details then print(string.format(\" 详情: %s\", tostring(err.details))) end if context then print(string.format(\" 上下文: %s\", context)) end print(\" 调用栈:\") print(err.stack_trace) -- 根据错误类型采取不同措施 if err.type == \"VALIDATION\" then return nil, \"输入错误，请检查后重试\" elseif err.type == \"PERMISSION\" then return nil, \"权限不足，请联系管理员\" elseif err.type == \"NETWORK\" then -- 可以尝试重试 return nil, \"网络错误，请稍后重试\" else return nil, \"系统错误，请联系技术支持\" end else -- 其他类型的错误 return nil, \"未知错误: \" .. tostring(err) end\nend -- 模拟数据库连接\nlocal data_base = {} function data_base.new(config) local instance = { host = config.host or \"localhost\", port = config.port or 3306, username = config.username or \"root\", password = config.password or \"\", database = config.database or \"test\", connected = false, transaction_active = false } -- 连接数据库 function instance:connect() if self.connected then return true end print(string.format(\" 连接数据库 %s:%d...\", self.host, self.port)) -- 模拟连接错误 throw_error(\"NETWORK\", \"数据库连接失败\", { host = self.host, port = self.port }) self.connected = true print(\" 连接成功\") return true end -- 执行查询 function instance:query(sql, params) if not self.connected then throw_error(\"DATABASE\", \"数据库未连接\") end print(string.format(\" 执行查询: %s\", sql)) if params then print(\" 参数: \" .. tostring(params)) end -- 模拟查询错误 if sql:find(\"DROP TABLE\") or sql:find(\"DELETE\") then if not self.transaction_active then throw_error(\"DATABASE\", \"危险操作需要在事务中执行\", { sql = sql }) end end if sql:find(\"SELECT\") and sql:find(\"nonexistent\") then throw_error(\"DATABASE\", \"查询的表不存在\", { sql = sql }) end if sql:find(\"INSERT\") and params and params.email then -- 模拟唯一约束冲突 if params.email == \"duplicate@example.com\" then throw_error(\"DATABASE\", \"重复的邮箱地址\", { sql = sql, email = params.email }) end end -- 模拟成功响应 if sql:find(\"SELECT\") then return { { id = 1, name = \"用户1\", email = \"user1@example.com\" }, { id = 2, name = \"用户2\", email = \"user2@example.com\" } } elseif sql:find(\"INSERT\") then return { affected_rows = 1, last_insert_id = 100 } elseif sql:find(\"UPDATE\") then return { affected_rows = 1 } elseif sql:find(\"DELETE\") then return { affected_rows = 1 } end return {} end -- 开始事务 function instance:begin_transaction() if self.transaction_active then throw_error(\"DATABASE\", \"事务已在进行中\") end self.transaction_active = true print(\" 开始事务\") return true end -- 提交事务 function instance:commit() if not self.transaction_active then throw_error(\"DATABASE\", \"没有活动的事务\") end self.transaction_active = false print(\" 提交事务\") return true end -- 回滚事务 function instance:rollback() if not self.transaction_active then throw_error(\"DATABASE\", \"没有活动的事务\") end self.transaction_active = false print(\" 回滚事务\") return true end -- 断开连接 function instance:disconnect() if self.transaction_active then self:rollback() end self.connected = false print(\" 断开数据库连接\") return true end -- 安全执行（带错误处理） function instance:safe_execute(operation, ...) local success, result = pcall(operation, self, ...) if not success then -- 如果是数据库错误，尝试重连 if type(result) == \"table\" and result.type == \"DATABASE\" then if result.message:find(\"连接\") or result.message:find(\"断开\") then print(\" 检测到连接问题，尝试重连...\") self.connected = false local reconnect_success = pcall(self.connect, self) if reconnect_success then print(\" 重连成功，重试操作...\") success, result = pcall(operation, self, ...) end end end end if not success then return nil, result end return result end return instance\nend -- 使用数据库\nprint(\"数据库操作测试:\")\nlocal db = data_base.new { host = \"localhost\", database = \"mydb\", username = \"admin\", password = \"secret\"\n} -- 包装数据库操作为安全操作\nfunction safe_database_operation(db, operation_name, operation, ...) print(\"\\n操作: \" .. operation_name) local result, err = db:safe_execute(operation, ...) if result then print(\" 成功\") return result else local _, user_msg = handle_error(err, operation_name) print(\" 失败: \" .. user_msg) return nil, err end\nend -- 测试各种操作\n-- 连接数据库\nsafe_database_operation(db, \"连接数据库\", db.connect) -- 查询数据\nlocal users, err = safe_database_operation(db, \"查询用户\", function(self) return self:query(\"SELECT * FROM users WHERE status = 'active'\")\nend) if users then print(\" 查询到 \" .. #users .. \" 个用户\")\nend -- 测试插入重复数据\nlocal insert_result, err = safe_database_operation(db, \"插入用户\", function(self) return self:query(\"INSERT INTO users (name, email) VALUES (?, ?)\", { \"测试用户\", \"duplicate@example.com\" })\nend) -- 测试事务\nprint(\"\\n测试事务操作:\")\nlocal transaction_success, transaction_err = pcall(function() db:begin_transaction() -- 多个操作 db:query(\"UPDATE accounts SET balance = balance - 100 WHERE id = 1\") db:query(\"UPDATE accounts SET balance = balance + 100 WHERE id = 2\") db:commit() print(\" 事务执行成功\")\nend) if not transaction_success then print(\" 事务失败: \" .. tostring(transaction_err)) if db.transaction_active then db:rollback() end\nend -- 断开连接\nsafe_database_operation(db, \"断开连接\", db.disconnect)\n--[[ 输出\n操作: 连接数据库 连接数据库 localhost:3306...\n[错误处理] 类型: NETWORK_ERROR (300) 消息: 数据库连接失败 详情: table: 00E5CEA0 上下文: 连接数据库 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:114: in function &lt;test.lua:104&gt; [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:267: in main chunk [C]: ? 失败: 网络错误，请稍后重试 操作: 查询用户 检测到连接问题，尝试重连... 连接数据库 localhost:3306...\n[错误处理] 类型: DATABASE_ERROR (200) 消息: 数据库未连接 上下文: 查询用户 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:126: in function &lt;test.lua:124&gt; (tail call): ? [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:270: in main chunk [C]: ? 失败: 系统错误，请联系技术支持 操作: 插入用户 检测到连接问题，尝试重连... 连接数据库 localhost:3306...\n[错误处理] 类型: DATABASE_ERROR (200) 消息: 数据库未连接 上下文: 插入用户 调用栈: stack traceback: test.lua:51: in function 'throw_error' test.lua:126: in function &lt;test.lua:124&gt; (tail call): ? [C]: in function 'pcall' test.lua:213: in function 'safe_execute' test.lua:253: in function 'safe_database_operation' test.lua:279: in main chunk [C]: ? 失败: 系统错误，请联系技术支持 测试事务操作: 开始事务 事务失败: table: 00E5CF68 回滚事务 操作: 断开连接 断开数据库连接 成功\n--]]\n-- 定义管道操作\nlocal pipeline_sys = {} function pipeline_sys.new(source_iterator) local pipeline = { source = source_iterator, operations = {} } function pipeline:map(transform_func) table.insert(self.operations, { type = \"map\", func = transform_func }) return self end function pipeline:filter(predicate_func) table.insert(self.operations, { type = \"filter\", func = predicate_func }) return self end function pipeline:take(n) table.insert(self.operations, { type = \"take\", count = n }) return self end function pipeline:skip(n) table.insert(self.operations, { type = \"skip\", count = n }) return self end function pipeline:iterator() local source_iter = self.source local skip_count = 0 local take_count = math.huge -- 从操作中获取初始的skip和take值 for _, op in ipairs(self.operations) do if op.type == \"skip\" then skip_count = op.count elseif op.type == \"take\" then take_count = op.count end end -- 创建处理链 return function() while true do if take_count &lt;= 0 then return nil end local values = { source_iter() } if values[1] == nil then return nil end local processed = values local should_emit = true if skip_count &gt; 0 then skip_count = skip_count - 1 should_emit = false else -- 应用所有操作 for _, op in ipairs(self.operations) do if op.type == \"map\" then processed = { op.func(unpack(processed)) } elseif op.type == \"filter\" then if not op.func(unpack(processed)) then should_emit = false break end end end end if should_emit then take_count = take_count - 1 return unpack(processed) end end end end return pipeline\nend -- 测试数据管道\nprint(\"数据管道测试:\") -- 创建数据源\nfunction number_source(from, to) local current = from - 1 return function() current = current + 1 if current &lt;= to then return current end end\nend -- 构建管道\nlocal pipeline = pipeline_sys.new(number_source(1, 20))\npipeline:filter(function(x) return x % 2 == 0 end) -- 只保留偶数\npipeline:map(function(x) return x * 2 end) -- 乘以2\npipeline:skip(3) -- 跳过前3个\npipeline:take(5) -- 取5个 print(\"管道处理结果:\")\nfor value in pipeline:iterator() do io.write(value .. \" \")\nend\nprint() -- 复杂管道示例\nprint(\"\\n复杂管道示例:\") -- 模拟用户数据\nfunction user_data_source() local users = { { id = 1, name = \"张三\", age = 25, score = 85 }, { id = 2, name = \"李四\", age = 30, score = 92 }, { id = 3, name = \"王五\", age = 22, score = 78 }, { id = 4, name = \"赵六\", age = 35, score = 88 }, { id = 5, name = \"钱七\", age = 28, score = 95 }, { id = 6, name = \"孙八\", age = 19, score = 65 }, { id = 7, name = \"周九\", age = 32, score = 82 }, { id = 8, name = \"吴十\", age = 26, score = 90 }, } local index = 0 return function() index = index + 1 local user = users[index] if user then return user.id, user.name, user.age, user.score end end\nend -- 用户数据处理管道\nlocal user_pipeline = pipeline_sys.new(user_data_source())\nuser_pipeline:filter(function(id, name, age, score) return age &gt;= 20 and age &lt;= 30 -- 年龄在20-30之间\nend)\nuser_pipeline:filter(function(id, name, age, score) return score &gt;= 80 -- 分数80以上\nend)\nuser_pipeline:map(function(id, name, age, score) -- 添加评级 local rating if score &gt;= 90 then rating = \"优秀\" elseif score &gt;= 85 then rating = \"良好\" else rating = \"合格\" end return id, name, age, score, rating\nend) print(\"符合条件的用户:\")\nfor id, name, age, score, rating in user_pipeline:iterator() do print(string.format(\" ID: %d, 姓名: %s, 年龄: %d, 分数: %d, 评级: %s\", id, name, age, score, rating))\nend\n--[[ 输出\n数据管道测试:\n管道处理结果:\n8 12 16 20 24 复杂管道示例:\n符合条件的用户: ID: 1, 姓名: 张三, 年龄: 25, 分数: 85, 评级: 良好 ID: 2, 姓名: 李四, 年龄: 30, 分数: 92, 评级: 优秀 ID: 5, 姓名: 钱七, 年龄: 28, 分数: 95, 评级: 优秀 ID: 8, 姓名: 吴十, 年龄: 26, 分数: 90, 评级: 优秀\n--]]\nlocal function range(from, to, step) step = step or 1 return coroutine.wrap(function() for i = from, to, step do coroutine.yield(i) end end)\nend -- 使用\nfor i in range(1, 10, 2) do print(i)\nend\n--[[ 输出\n1\n3\n5\n7\n9\n--]]\n-- 向量类实现\nVector = {}\nVector.__index = Vector -- 构造函数\nfunction Vector.new(x, y) local v = { x = x, y = y} setmetatable(v, Vector) return v\nend -- 加法\nfunction Vector.__add(a, b) if getmetatable(a) == Vector and getmetatable(b) == Vector then return Vector.new(a.x + b.x, a.y + b.y) end error(\"Cannot add non-vector values\")\nend -- 减法\nfunction Vector.__sub(a, b) if getmetatable(a) == Vector and getmetatable(b) == Vector then return Vector.new(a.x - b.x, a.y - b.y) end error(\"Cannot subtract non-vector values\")\nend -- 乘法（点积）\nfunction Vector.__mul(a, b) if getmetatable(a) == Vector and getmetatable(b) == Vector then return a.x * b.x + a.y * b.y end error(\"Cannot multiply non-vector values\")\nend -- 负号\nfunction Vector.__unm(a) if getmetatable(a) == Vector then return Vector.new(-a.x, -a.y) end error(\"Cannot negate non-vector value\")\nend -- 字符串表示\nfunction Vector.__tostring(self) return string.format(\"Vector(%d, %d)\", self.x, self.y)\nend -- 测试代码\nlocal v1 = Vector.new(3, 4)\nlocal v2 = Vector.new(1, 2) print(\"v1 = \" .. tostring(v1)) -- Vector(3, 4)\nprint(\"v2 = \" .. tostring(v2)) -- Vector(1, 2)\nprint(\"v1 + v2 = \" .. tostring(v1 + v2)) -- Vector(4, 6)\nprint(\"v1 - v2 = \" .. tostring(v1 - v2)) -- Vector(2, 2)\nprint(\"v1 * v2 = \" .. (v1 * v2)) -- 11\nprint(\"-v1 = \" .. tostring(-v1)) -- Vector(-3, -4)\n-- 带日志功能的向量类\nTrackedVector = {}\nTrackedVector.__index = TrackedVector -- 构造函数\nfunction TrackedVector.new(x, y) local v = { x = x, y = y, _log = {} -- 日志记录 } setmetatable(v, TrackedVector) -- 记录创建 table.insert(v._log, string.format(\"创建向量: Vector(%d, %d)\", x, y)) return v\nend -- 添加日志条目\nfunction TrackedVector:_add_log(operation, operand, result) local entry = string.format(\"%s: \", operation) if operand then entry = entry .. string.format(\"与 %s \", tostring(operand)) end entry = entry .. string.format(\"运算, 结果: %s\", tostring(result)) table.insert(self._log, entry)\nend -- 加法（带日志）\nfunction TrackedVector.__add(a, b) if getmetatable(a) == TrackedVector and getmetatable(b) == TrackedVector then local result = TrackedVector.new(a.x + b.x, a.y + b.y) -- 记录到两个向量的日志中 a:_add_log(\"被加\", b, result) b:_add_log(\"加数\", a, result) return result end error(\"Cannot add non-vector values\")\nend -- 减法（带日志）\nfunction TrackedVector.__sub(a, b) if getmetatable(a) == TrackedVector and getmetatable(b) == TrackedVector then local result = TrackedVector.new(a.x - b.x, a.y - b.y) a:_add_log(\"被减\", b, result) b:_add_log(\"减数\", a, result) return result end error(\"Cannot subtract non-vector values\")\nend -- 乘法（点积，带日志）\nfunction TrackedVector.__mul(a, b) if getmetatable(a) == TrackedVector and getmetatable(b) == TrackedVector then local result = a.x * b.x + a.y * b.y a:_add_log(\"点积\", b, result) b:_add_log(\"点积\", a, result) return result end error(\"Cannot multiply non-vector values\")\nend -- 负号（带日志）\nfunction TrackedVector.__unm(a) if getmetatable(a) == TrackedVector then local result = TrackedVector.new(-a.x, -a.y) a:_add_log(\"取负\", nil, result) return result end error(\"Cannot negate non-vector value\")\nend -- 获取日志\nfunction TrackedVector.get_log(self) local logs = {} -- 添加向量基本信息 table.insert(logs, string.format(\"向量: %s\", tostring(self))) -- 添加所有操作记录 for i, entry in ipairs(self._log) do table.insert(logs, string.format(\"%d. %s\", i, entry)) end return logs\nend -- 字符串表示（与普通向量兼容）\nfunction TrackedVector.__tostring(self) return string.format(\"Vector(%d, %d)\", self.x, self.y)\nend -- 测试代码\nprint(\"\\n\\n=== 练习2：带日志的向量类测试 ===\")\nlocal v1 = TrackedVector.new(3, 4)\nlocal v2 = TrackedVector.new(1, 2) print(\"v1 = \" .. tostring(v1)) -- Vector(3, 4)\nprint(\"v2 = \" .. tostring(v2)) -- Vector(1, 2) local sum = v1 + v2\nprint(\"v1 + v2 = \" .. tostring(sum)) -- Vector(4, 6) local diff = v1 - v2\nprint(\"v1 - v2 = \" .. tostring(diff)) -- Vector(2, 2) local dot = v1 * v2\nprint(\"v1 * v2 = \" .. dot) -- 11 local neg = -v1\nprint(\"-v1 = \" .. tostring(neg)) -- Vector(-3, -4) print(\"\\n=== v1的操作日志 ===\")\nlocal v1_logs = v1:get_log()\nprint(table.concat(v1_logs, \"\\n\")) print(\"\\n=== v2的操作日志 ===\")\nlocal v2_logs = v2:get_log()\nprint(table.concat(v2_logs, \"\\n\"))\n--[[ 输出\n=== 练习2：带日志的向量类测试 ===\nv1 = Vector(3, 4)\nv2 = Vector(1, 2)\nv1 + v2 = Vector(4, 6)\nv1 - v2 = Vector(2, 2)\nv1 * v2 = 11\n-v1 = Vector(-3, -4) === v1的操作日志 ===\n向量: Vector(3, 4)\n1. 创建向量: Vector(3, 4)\n2. 被加: 与 Vector(1, 2) 运算, 结果: Vector(4, 6)\n3. 被减: 与 Vector(1, 2) 运算, 结果: Vector(2, 2)\n4. 点积: 与 Vector(1, 2) 运算, 结果: 11\n5. 取负: 运算, 结果: Vector(-3, -4) === v2的操作日志 ===\n向量: Vector(1, 2)\n1. 创建向量: Vector(1, 2)\n2. 加数: 与 Vector(3, 4) 运算, 结果: Vector(4, 6)\n3. 减数: 与 Vector(3, 4) 运算, 结果: Vector(2, 2)\n4. 点积: 与 Vector(3, 4) 运算, 结果: 11\n--]]\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<strong>本篇为所有练习的参考答案，下滑查看</strong>","level":2,"id":"**本篇为所有练习的参考答案，下滑查看**_0"},{"heading":"<strong>练习 2.2</strong>：判断以下哪些是合法的标识符：","level":3,"id":"**练习_2.2**：判断以下哪些是合法的标识符：_0"},{"heading":"练习 2.3：创建一个自我介绍程序","level":3,"id":"练习_2.3：创建一个自我介绍程序_0"},{"heading":"练习 3.1：数据类型识别","level":3,"id":"练习_3.1：数据类型识别_0"},{"heading":"练习 4.1：简单计算器","level":3,"id":"练习_4.1：简单计算器_0"},{"heading":"练习 5.1：猜数字游戏","level":3,"id":"练习_5.1：猜数字游戏_0"},{"heading":"练习 5.2：打印图形","level":3,"id":"练习_5.2：打印图形_0"},{"heading":"练习 6.1：简单的计算器函数库","level":3,"id":"练习_6.1：简单的计算器函数库_0"},{"heading":"练习 6.2：提取函数，优化代码","level":3,"id":"练习_6.2：提取函数，优化代码_0"},{"heading":"练习 7.1：简单的联系人管理系统","level":3,"id":"练习_7.1：简单的联系人管理系统_0"},{"heading":"练习 7.2：购物车系统","level":3,"id":"练习_7.2：购物车系统_0"},{"heading":"练习 8.1：简单的文本分析器","level":3,"id":"练习_8.1：简单的文本分析器_0"},{"heading":"练习 9.1：创建一个日志模块","level":3,"id":"练习_9.1：创建一个日志模块_0"},{"heading":"练习 10.2：模拟数据库操作错误处理","level":3,"id":"练习_10.2：模拟数据库操作错误处理_0"},{"heading":"练习 11.1：实现一个数据管道系统","level":3,"id":"练习_11.1：实现一个数据管道系统_0"},{"heading":"练习 12.1：使用协程实现生成器","level":3,"id":"练习_12.1：使用协程实现生成器_0"},{"heading":"练习 13.1：实现向量类","level":3,"id":"练习_13.1：实现向量类_0"},{"heading":"练习 13.2：跟踪向量的修改","level":3,"id":"练习_13.2：跟踪向量的修改_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"第-1-节-语法/参考答案.html","pathToRoot":"..","attachments":[],"createdTime":1765071806510,"modifiedTime":1766727418333,"sourceSize":40329,"sourcePath":"第 1 节 - 语法/参考答案.md","exportPath":"第-1-节-语法/参考答案.html","showInTree":true,"treeOrder":17,"backlinks":["第-1-节-语法/10.-调试与错误处理.html","第-1-节-语法/11.-迭代器与泛型for.html","第-1-节-语法/12.-协程.html","第-1-节-语法/2.-基础语法规则.html","第-1-节-语法/3.-变量与数据类型.html","第-1-节-语法/4.-运算符.html","第-1-节-语法/5.-控制结构.html","第-1-节-语法/6.-函数.html","第-1-节-语法/7.-表.html","第-1-节-语法/8.-字符串.html","第-1-节-语法/9.-模块.html"],"type":"markdown"},"第-2-节-修改基础/1.-介绍.html":{"title":"1. 介绍","icon":"","description":"《王国保卫战》（Kingdom Rush）是由乌拉圭的 Ironhide Game Studio 游戏工作室于 2011 年制作的一款塔防类策略游戏。游戏使用 ECS（Entity-Component-System）实体-组件-系统架构它通过将数据（组件）和行为（系统）解耦，并用实体将它们灵活地组合起来，为游戏开发带来了一种高性能、高弹性且易于管理的代码组织方式。\ntable 库额外增加深浅拷贝、深浅合并、高阶函数等\n增加 vector 向量库\n增加 macros 宏指令库\n增加 class 模拟类库\n增加 signal 信号库\n增加 timer 定时器库\n增加 log 日志库\n注：只有触发断点时监视才可用<img alt=\"Pasted image 20250621105918.png\" src=\"site-lib/media/pasted-image-20250621105918.png\" target=\"_self\" style=\"width: 450px; max-width: 100%;\">点击左上角金币图标，即可开启有 UI 的调试（功能与快捷键相同）<br>\n<img alt=\"Pasted image 20250620190901.png\" src=\"site-lib/media/pasted-image-20250620190901.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\"><br><img alt=\"Pasted image 20251213194044.png\" src=\"site-lib/media/pasted-image-20251213194044.png\" target=\"_self\" style=\"width: 900px; max-width: 100%;\">\n调试控制台会显示详细信息，比如加载资源，所有点击事件，操作实体（插入，移除）等点击代码行左侧即可增加断点。注：断点只有 Debug 模式可用<br>\n<img alt=\"Pasted image 20251213173619.png\" src=\"site-lib/media/pasted-image-20251213173619.png\" target=\"_self\" style=\"width: 281px; max-width: 100%;\">运行过程可按 0 手动断点直接使用 Debug 模式进入游戏即可在 args 取消 screen 与 custom 的注释， custom 输入要编辑的关卡的编号运行后即可进入关卡编辑器<br>\n<img alt=\"Pasted image 20250712192159.png\" src=\"site-lib/media/pasted-image-20250712192159.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\">游戏中报错通常会直接蓝屏，上面显示错误信息。<br>\n<img alt=\"Pasted image 20250624161626.png\" src=\"site-lib/media/pasted-image-20250624161626.png\" target=\"_self\" style=\"width: 400px; max-width: 100%;\">游戏中协程错误会直接显示在调试控制台，通常某个实体卡住，无法移动与攻击就代表出现了协程错误<br>\n<img alt=\"Pasted image 20251213194044.png\" src=\"site-lib/media/pasted-image-20251213194044.png\" target=\"_self\" style=\"width: 900px; max-width: 100%;\">\nError running coro: kr1/game_scripts.lua:1430: attempt to index global 'a' (a nil value) 如图关闭输入法即可<br><img alt=\"Pasted image 20250803203730.png\" src=\"site-lib/media/pasted-image-20250803203730.png\" target=\"_self\" style=\"width: 750px; max-width: 100%;\">\n在 all/systems 搜索 main_script:on_update-- 将以下代码修改\nif coroutine.status(s.co) == \"dead\" or error ~= nil then if error ~= nil then -- 修改为\nif coroutine.status(s.co) == \"dead\" or (not success and error ~= nil) then if not success and error ~= nil then\n<br><img alt=\"Pasted image 20250717091020.png\" src=\"site-lib/media/pasted-image-20250717091020.png\" target=\"_self\" style=\"width: 975px; max-width: 100%;\"> 游戏自带的几个库： 向量库：vector 宏指令库：macros 模拟类库：class 信号库：signal\n定时器库：timer 日志库：log table 库扩展功能： 深浅拷贝\n深浅合并\n高阶函数 调试功能： 监视变量：在运行与调试监视变量\n调试控制台：类似于输出\n调试快捷键：m 增加金币、l 增加生命、z 加速、a 暂停等\n断点：在代码行左侧打断点、游戏内按 0 手动断点、报错时自动断点\n关卡编辑器：修改 args 进入关卡编辑器 两种报错形式： 蓝屏：一般报错\n控制台的报错：协程报错等 下一章预告：在第 2 章中，我们将学习游戏实体数据的存储与修改，这是了解游戏系统的关键一步！","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1.1 游戏介绍","level":2,"id":"1.1_游戏介绍_0"},{"heading":"1.2 游戏自带的完整开发环境","level":2,"id":"1.2_游戏自带的完整开发环境_0"},{"heading":"1.2.1 增加多个库，并扩展 table 库（详见 lib 目录）：","level":3,"id":"1.2.1_增加多个库，并扩展_table_库（详见_lib_目录）：_0"},{"heading":"1.3 调试功能","level":2,"id":"1.3_调试功能_0"},{"heading":"1.3.1 监视变量","level":3,"id":"1.3.1_监视变量_0"},{"heading":"1.3.2 游戏内的调试快捷键","level":3,"id":"1.3.2_游戏内的调试快捷键_0"},{"heading":"五代特有","level":4,"id":"五代特有_0"},{"heading":"1.3.3 调试控制台","level":3,"id":"1.3.3_调试控制台_0"},{"heading":"1.3.4 断点","level":3,"id":"1.3.4_断点_0"},{"heading":"报错时自动断点","level":4,"id":"报错时自动断点_0"},{"heading":"1.3.5 关卡编辑器","level":3,"id":"1.3.5_关卡编辑器_0"},{"heading":"1.4 报错","level":2,"id":"1.4_报错_0"},{"heading":"1.4.1 蓝屏","level":3,"id":"1.4.1_蓝屏_0"},{"heading":"1.4.2 协程错误","level":3,"id":"1.4.2_协程错误_0"},{"heading":"1.5 排查问题","level":2,"id":"1.5_排查问题_0"},{"heading":"1.5.1 调试快捷键失效","level":3,"id":"1.5.1_调试快捷键失效_0"},{"heading":"1.5.2 Local Lua Debugger 报错","level":3,"id":"1.5.2_Local_Lua_Debugger_报错_0"},{"heading":"1.6 本章总结","level":2,"id":"1.6_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"}],"links":[],"author":"","coverImageURL":".","fullURL":"第-2-节-修改基础/1.-介绍.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20250621105918.png","site-lib/media/pasted-image-20250620190901.png","site-lib/media/pasted-image-20251213194044.png","site-lib/media/pasted-image-20251213173619.png","site-lib/media/pasted-image-20250712192159.png","site-lib/media/pasted-image-20250624161626.png","site-lib/media/pasted-image-20250803203730.png","site-lib/media/pasted-image-20250717091020.png"],"createdTime":1765592137526,"modifiedTime":1766732416195,"sourceSize":7314,"sourcePath":"第 2 节 - 修改基础/1. 介绍.md","exportPath":"第-2-节-修改基础/1.-介绍.html","showInTree":true,"treeOrder":19,"backlinks":[],"type":"markdown"},"第-2-节-修改基础/2.-实体与模板.html":{"title":"2. 实体与模板","icon":"","description":"开始之前我们需要先了解 ECS（Entity-Component-System）实体-组件-系统是什么ECS 是一种游戏编程架构模式，核心思想是将数据与逻辑分离，强调组合优于继承。\n一个唯一的标识符（通常就是一个 ID），它不是游戏对象本身，而是一个“容器”。\n类比：就像一张空白的身份证，上面只有一个身份证号码。这张证本身没有任何信息（没有名字、年龄、职业），但它可以用来关联各种信息卡片。\n作用：它的唯一作用是将不同的 z 组件组合在一起，形成一个有意义的游戏对象。例如，一个“玩家”实体，可能是 entity #1，它关联了 位置、精灵、生命值、控制器 等组件。 纯数据的容器。它只包含属性，绝对不包含任何逻辑或方法。\n类比：一张张信息卡片。比如“位置卡”只记录 (x, y, z) 坐标；“生命值卡”只记录 当前血量 和 最大血量；“渲染卡”只记录 纹理ID 和 颜色。\n作用：定义实体的特征。一个实体拥有哪些组件，就具备了哪些能力。想给实体添加新功能？只需挂载一个新的组件即可，无需修改复杂的类继承树。 纯逻辑的执行者。它只包含行为和方法，不持有自己的状态（数据来自组件）。\n类比：一个个专业的处理部门。比如“移动部门”只关心所有带有 位置 和 速度 组件的实体，并根据速度更新它们的位置；“渲染部门”只关心所有带有 位置 和 精灵 组件的实体，并把它们画到屏幕上。\n作用：驱动游戏世界的运转。系统遍历所有拥有特定组件的实体，并对这些组件的数据进行操作。\n假设我们要创建一个可以移动和渲染的“玩家”。\n创建实体：生成一个 entity #1（只是一个 ID）。\n添加组件：为 entity #1 添加： position (x: 0, y: 0)\nvelocity (vx: 1, vy: 0)\nsprite (texture: “player.png”) 系统运作： 移动系统 每帧运行。寻找所有同时拥有 position 和 velocity 的实体。找到 entity #1，读取其速度数据，更新其位置数据。\n渲染系统 每帧运行。寻找所有同时拥有 position 和 velocity 的实体。找到 entity #1，读取其位置和纹理数据，将其绘制在屏幕正确位置。 实体发生了什么、看起来什么样，完全由它身上挂载的组件组合决定，而行为则由系统统一驱动。all/entity_db 模块简称为 E\n定义： E.entities&nbsp;表中包含的子表，称为实体模板\n作用：使用模板创建各种实体，用于存储实体的数据\n读取位置：kr/game_templates 与 all/templates、 kr/data/balance\n模板的表无实际作用，仅用于存储数据，数据传递过程： balance → 模板 → 实体 → 函数 位置：E.components\n读取位置：all/components 位置：game.store.entities\n英雄：具有 hero 组件\n士兵：具有 soldier 组件\n敌人：具有 enemy 组件\n防御塔：具有 tower 组件 位置：all/systems\n首先使用搜索功能在 kr/game_templates 任意找到一个英雄模板，所有模板名见 <a data-href=\"1. 模板名\" href=\"总结/1.-模板名.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1. 模板名</a>如图以小公主（hero_alleria）为例：<br>\n<img alt=\"Pasted image 20251212181056.png\" src=\"site-lib/media/pasted-image-20251212181056.png\" target=\"_self\" style=\"width: 346px; max-width: 100%;\">tt = RT(\"hero_alleria\", \"hero\") -- tt 指的是 hero_alleria 模板，E:register_t 函数会返回创建的模板的引用\nAC(tt, \"melee\", \"ranged\", \"timed_attacks\")\t-- 增加组件 melee、ranged、timed_attacks\ntt.hero.level_stats.armor = {...} -- hero 组件的 level_stats.armor，物理护甲\ntt.hero.level_stats.hp_max = {...} -- 最大血量\ntt.hero.level_stats.regen_health = {...}\t-- 脱战回血\ntt.hero.level_stats.melee_damage_max = {...}\t-- 近战普攻最大伤害\ntt.hero.level_stats.melee_damage_min = {...}\t-- 近战普攻最小伤害\ntt.hero.level_stats.ranged_damage_max = {...}\t-- 远程普攻最大伤害\ntt.hero.level_stats.ranged_damage_min = {...}\t-- 远程普攻最小伤害\n...\n展开的 10 个值为索引所对应等级的属性tt.hero.level_stats.hp_max = { 250,\t-- 索引 1 表示 1 级血量为 250 270,\t-- 索引 2 表示 2 级血量为 270 290,\t-- ... 310, 330, 350, 370, 390, 410, 430\n}\n将第十行血量修改为 666，然后点击运行和调试，运行游戏<br>\n<img alt=\"Pasted image 20250626192149.png\" src=\"site-lib/media/pasted-image-20250626192149.png\" target=\"_self\" style=\"width: 377px; max-width: 100%;\"><br>\n<img alt=\"Pasted image 20250626191819.png\" src=\"site-lib/media/pasted-image-20250626191819.png\" target=\"_self\" style=\"width: 541px; max-width: 100%;\">\n如图血量变为 666 成功tt.hero.level_stats.armor = b.armor\ntt.hero.level_stats.hp_max = b.hp_max\ntt.hero.level_stats.melee_damage_max = b.basic_melee.damage_max\ntt.hero.level_stats.melee_damage_min = b.basic_melee.damage_min\ntt.hero.level_stats.ranged_damage_max = b.basic_ranged.damage_max\ntt.hero.level_stats.ranged_damage_min = b.basic_ranged.damage_min\n通过查看模板的定义知道：这里是索引的 balance在 balance 搜索要改的英雄，同样可以找到基础属性，修改即可hero_muyrn = { -- 尼鲁 ... armor = {...}, -- 物理护甲 hp_max = {...}, -- 最大血量 regen_health = {...},\t-- 脱战回血 basic_melee = { -- 近战普攻 ... damage_max = {...},\t-- 近战普攻最大伤害 damage_min = {...}\t-- 近战普攻最小伤害 ... }, basic_ranged = { -- 远程普攻 ... damage_max = {...},\t-- 远程普攻最大伤害 damage_min = {...}\t-- 远程普攻最大伤害 ... }, ...\n}\nhero 组件的 skills 通常用于存储会根据等级提高的属性。以艾莉丹（hero_elves_archer）为例：tt = E:register_t(\"hero_elves_archer\", \"hero\")\nE:add_comps(tt, \"melee\", \"ranged\", \"dodge\") tt.hero.skills.double_strike = E:clone_c(\"hero_skill\")\t-- E:clone_c 函数用于返回深拷贝的组件\ntt.hero.skills.double_strike.damage_max = {...} -- 双刀跳斩最大伤害\ntt.hero.skills.double_strike.damage_min = {...} -- 双刀跳斩最小伤害\ntt.hero.skills.multishot = E:clone_c(\"hero_skill\")\ntt.hero.skills.multishot.loops = {...} -- 凌空飞箭射击次数\ntt.hero.skills.nimble_fencer = E:clone_c(\"hero_skill\")\ntt.hero.skills.nimble_fencer.chance = {...} -- 敏捷游侠闪避概率\ntt.hero.skills.porcupine = E:clone_c(\"hero_skill\")\ntt.hero.skills.porcupine.damage_inc = {...} -- 箭靶最大叠层次数\n假设要修改艾莉丹的四技能；双刀跳斩的伤害：<br>\n首先查资料（见<a data-href=\"1. 模板名\" href=\"总结/1.-模板名.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1. 模板名</a> ）知道：四技能的名称是 double_strikett.hero.skills.double_strike.damage_max = { 80, -- 3 个值意义同上，索引 1 表示 1 级的伤害 140,\t-- ... 200\n}\n还是与基础属性相同在 balancehero_muyrn = { ... sentinel_wisps = {\t-- 哨兵仙灵 cooldown = {\t-- 冷却时间 25, 25, 25 }, max_summons = {\t-- 生成数量 1, 2, 3 } ... } ...\n}\n拦截后的攻击，称为近战攻击。近战攻击通常位于 melee 组件的 attacks 列表中tt.melee.attacks[1] = E:clone_c(\"melee_attack\")\t-- 返回深拷贝的组件\ntt.melee.attacks[1].cooldown = 1 -- 冷却时间\ntt.melee.attacks[1].hit_time = fts(8) -- 攻击前摇\ntt.melee.attacks[1].sound = \"MeleeSword\" -- 攻击声音\ntt.melee.attacks[1].xp_gain_factor = 2.5 -- 获得的经验\ntt.melee.range = 45\t-- 拦截范围\n如代码所示，一般第一个攻击 attacks[1] 都是普攻，其他都是相应行为的技能注：有的攻击可能会占有多个攻击，可以通过 table.deepclone 复制的攻击来分辨\n其用于播放不同动画，与增加额外效果tt.melee.attacks[1].animation = \"attack\"\ntt.melee.attacks[1].hit_time = fts(14)\ntt.melee.attacks[1].shared_cooldown = true\ntt.melee.attacks[1].sound = \"MeleeSword\"\ntt.melee.attacks[2] = table.deepclone(tt.melee.attacks[1])\ntt.melee.attacks[2].animation = \"attack2\"\ntt.melee.attacks[2].chance = 0.5\t-- 50 % 近战普攻播放 \"attack2\" 动画\n召唤子弹作为中介的攻击，称为远程攻击（ranged）因为是召唤子弹所以远程攻击的伤害和伤害类型等数据都是写在子弹上的，可以搜索子弹（bullet）模板来找到子弹的数据-- 艾莉丹远程普攻\ntt.ranged.attacks[1] = E:clone_c(\"bullet_attack\")\ntt.ranged.attacks[1].bullet = \"arrow_hero_alleria\"\t-- 子弹\ntt.ranged.attacks[1].bullet_start_offset = { v(0, 12)\n}\ntt.ranged.attacks[1].max_range = 150\ntt.ranged.attacks[1].min_range = 45\ntt.ranged.attacks[1].shoot_time = fts(6)\ntt.ranged.attacks[1].cooldown = 0.6 -- 子弹模板\ntt = RT(\"arrow_hero_alleria\", \"arrow\")\t-- arrow_hero_alleria 续承自 arrow 模板\n-- 注：一些属性会在 hero.skills 中\ntt.bullet.xp_gain_factor = 2.875\ntt.bullet.prediction_error = false -- 由于续承关系所以搜索 arrow 模板\n-- all/templates 的 arrow 模板\nlocal arrow = E:register_t(\"arrow\", \"bullet\")\n...\narrow.bullet.damage_type = DAMAGE_PHYSICAL\t-- 默认伤害类型：物伤\n不属于以上两种攻击的攻击，称为技能（timed_attacks），例如：召唤实体、给予 buff 等-- 熊人模板\ntt.timed_attacks.list[1] = CC(\"spawn_attack\")\ntt.timed_attacks.list[1].animation = \"ancestors\"\ntt.timed_attacks.list[1].cooldown = 14 + fts(40)\ntt.timed_attacks.list[1].cast_time = fts(15)\ntt.timed_attacks.list[1].disabled = true\ntt.timed_attacks.list[1].entity = \"soldier_ingvar_ancestor\" -- 召唤这个实体 -- 维京先祖模板\ntt = RT(\"soldier_ingvar_ancestor\", \"soldier_militia\") -- E:register_t\nAC(tt, \"reinforcement\", \"melee\") -- E:add_comps\n...\ntt.health.armor = 0.25\ntt.health.hp_max = nil -- 升级技能后动态赋值\ntt.melee.attacks[1].damage_max = nil\ntt.melee.attacks[1].damage_min = nil\ntt.melee.attacks[1].cooldown = 1\ntt.melee.attacks[1].hit_time = fts(15)\ntt.melee.attacks[1].sound = \"MeleeSword\"\n在 melee.attacks 可能找不到伤害类型，可以搜索增加的 melee 组件看看有没有默认值在 components 搜索 melee 组件local melee = register_c(\"melee\")\n...\nmelee.attacks = {}\nmelee.attacks[1] = CC(\"melee_attack\") -- 继续搜索 melee_attack 组件\nlocal melee_attack = E:register_c(\"melee_attack\")\n...\nmelee_attack.damage_type = DAMAGE_PHYSICAL -- 默认伤害类型：物伤 -- 模板内修改\ntt.melee.attacks[1].damage_type = DAMAGE_TRUE\t-- 修改为真伤\n四个常用伤害类型：\nDAMAGE_TRUE 真伤\nDAMAGE_PHYSICAL 物伤\nDAMAGE_MAGICAL 法伤\nDAMAGE_EXPLOSION 炮伤\n<br>所有伤害类型见<a data-href=\"总结/3. 常量#伤害类型\" href=\"总结/3.-常量.html#伤害类型\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">总结/3. 常量 &gt; 伤害类型</a>register_t 全称 register template 简称 RT。E:register_t(模板名: str, 续承模板名?: str) -&gt; 模板表的引用: table\na = RT(\"a\")\t-- 创建一个名为 “a” 的模板\na.has_a = true\na.num = 1 template = RT(\"template\", \"a\")\t-- 创建一个名为 “template” 的模板，同时续承 “a” 模板\ntemplate.n = 123\n-- “template” 模板具有 “a” 模板所有键，修改对应键不影响模板 “a”\n-- 也就是 template = { n = 123, has_a = true, num = 1 }\nadd_comps 全称 add components 简称 AC。E:add_comps(模板: table, 组件名: str...)\ncomponent = AC(\"component\")\t-- 创建组件 “component”\ncomponent.num = 123\ncomponent.is_component = true template = RT(\"template\")\nAC(template, \"component\") -- 增加组件 “component”\ntemplate.n = 1\n-- 此时 template = { component = { num = 123, is_component = true }, n = 1}\nclone_c 全称 clone componets 简称 CCE:clone_c(组件名: str) -&gt; 深拷贝的表: table\ncomponent = RT(\"component\")\ncomponent.num = 123\ncomponent.is_component = true template = RT(\"template\")\ntemplate.cc = CC(\"component\")\t-- 深拷贝组件，此时 cc 就是组件 component\ntemplate.num = 1\n-- 此时 template = { cc = { num = 123, is_component = true }, num = 1 }\nregister_c 全称 register componentE:register_c(组件: str) -&gt; 组件索引: table\na = E:register_c(\"a\")\t-- 创建一个名为 “a” 的组件\n造成的所有正面以及负面效果统称为状态效果（modifiers，缩写 mod）\n近战攻击直接在攻击后面增加 mod 键\n远程攻击增加到子弹模板的 bullet 键上，个别子弹无效（函数无实现）\n-- 单位模板内\ntt.melee.attacks[1].mod = 效果模板名: str\n-- 子弹模板内\ntt.bullet.mod = 效果模板名: str\n-- 单位模板内\ntt.melee.attacks[1].mod = \"mod_lava\"\t-- 普通近战攻击造成燃烧效果 -- 子弹模板内\ntt.bullet.mod = \"mod_lava\"\t-- 子弹造成燃烧效果\n几个基础效果（位于 template 中）\nmod_stun 眩晕\nmod_slow 减速\nmod_freeze 冻结\nmod_lava 燃烧\nmod_poison 中毒\nmod_blood 流血\n状态效果数据也是通过模板存储的，不能直接修改基础效果模板，由于续承关系直接修改会影响其他效果，所以我们需要创建一个新模板续承基础效果。-- mod_lava（燃烧效果）模板\nlocal mod_lava = RT(\"mod_lava\", \"modifier\")\nAC(mod_lava, \"dps\", \"render\")\nmod_lava.modifier.duration = 2 -- 持续时间\nmod_lava.dps.damage_min = 1 -- 最小伤害\nmod_lava.dps.damage_max = 1 -- 最大伤害\nmod_lava.dps.damage_inc = 3 -- 伤害系数\nmod_lava.dps.damage_every = 0.2 -- 伤害频率\nmod_lava.dps.damage_type = DAMAGE_TRUE\t-- 伤害类型\n... -- 创建新模板 new_mod_lava 续承 mod_lava\ntt = RT(\"new_mod_lava\", \"mod_lava\")\ntt.modifier.duration = 10 -- 持续时间 10 秒\ntt.dps.damage_min = 5 -- 最小伤害 5\ntt.dps.damage_max = 10 -- 最大伤害 10\n-- 其他使用默认值 -- 单位模板内\ntt.melee.attacks[1].mod = \"new_mod_lava\"\t-- 使用新创建的效果 -- 子弹模板内\ntt.bullet.mod = \"new_mod_lava\"\t-- 使用新创建的效果\n注：并非所有效果都要这样改，如果效果没有其他地方在用可以直接修改。-- balance 内\nhero_spider = { basic_melee = { -- 近战普攻 mod = \"mod_lava\",\t-- 增加 mod 键值对 ... }\n} -- 模板内\ntt.melee.attacks[1].mod = b.basic_melee.mod\t-- 读取 balance 内的表\n效果互斥用于防止一些效果同时出现在同一个目标上。tt.modifier.bans = { -- 禁止的效果模板名 效果模板名: str...\n}\ntt.modifier.ban_types = {\t-- 禁止的效果类型，可选 效果类型: str...\n}\n几个效果类型：\nMOD_TYPE_BLEED 流血\nMOD_TYPE_POISON 中毒\nMOD_TYPE_FREEZE 冻结\nMOD_TYPE_STUN 眩晕\n<br>所有效果类型见<a data-href=\"总结/3. 常量#效果类型\" href=\"总结/3.-常量.html#效果类型\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">总结/3. 常量 &gt; 效果类型</a>tt.modifier.bans = { -- 禁止的效果模板名 \"mod_freeze\", -- 若目标上有燃烧效果，目标将不会被冻结 ...\n}\ntt.modifier.ban_types = {\t-- 禁止的效果类型 MOD_TYPE_FREEZE, -- 若目标上有燃烧效果，目标将不会被冻结类型的所有效果冻结 ...\n}\ntt.modifier.remove_banned = 是否移除禁止的效果: bool\n-- 燃烧效果模板内\ntt.modifier.remove_banned = true\ntt.modifier.bans = { \"mod_freeze\", -- 如果目标上有冻结效果，移除其 ...\n} tt.modifier.ban_types = { MOD_TYPE_FREEZE,\t-- 如果目标上有冻结类型的效果，移除其 ...\n}\n三种模式（三选一）：tt.modifier.allows_duplicates = 是否允许叠加: bool\ntt.modifier.replaces_lower = 是否替换低级效果: bool\ntt.modifier.resets_same = 是否仅重置持续时间: bool\n-- 燃烧效果模板内\ntt.modifier.allows_duplicates = true\t-- 可叠加多个燃烧效果\n-- 或\ntt.modifier.replaces_lower = true\t-- 替换低级燃烧效果\n-- 或\ntt.modifier.resets_same = true -- 仅重置持续时间\n给攻击初始化为范围攻击 area_attack，增加伤害范围即可。tt.melee.attacks[1] = CC(\"area_attack\")\ntt.melee.attacks[1].damage_radius = 伤害范围: num\ntt.melee.attacks[1].count = 最大目标数?: int\ntt.melee.attacks[1].min_count = 释放限制，敌人数量?: int\ntt.melee.attacks[1] = CC(\"area_attack\")\ntt.melee.attacks[1].damage_radius = 25\t-- 伤害范围 25\ntt.melee.attacks[1].count = 3 -- 最多对三名敌人造成伤害\ntt.melee.attacks[1].min_count = 2 -- 需要两名敌人才能进行这个攻击\n给攻击增加 loops 键，设定攻击次数即可。-- 近战攻击\ntt.melee.attacks[1].animations = { 开始时的动画名: str|nil, 连续攻击时的动画: str|nil, 结束时的动画名: str|nil\n}\ntt.melee.attaks[1].loops = 连续攻击次数: int\ntt.melee.attaks[1].hit_times = 一次攻击的次数（可指定间隔）: table{ 间隔: num, ... }\n-- 可以理解成乘算，loops 为 0 不攻击： 攻击次数 = loops * hit_times -- 远程攻击，同上 hit_times 变为 shoot_times\ntt.ranged.attaks[1].shoot_times = 一次攻击的次数（可指定间隔）: table{ 间隔: num, ... }\n-- 近战攻击\ntt.melee.attacks[1].animations = { nil, -- 开始动画 \"attack\",\t-- 连续攻击时的动画，复用普通近战攻击动画 nil -- 结束动画\n}\ntt.melee.attaks[1].loops = 2\t-- 连续攻击 2 次\ntt.melee.attaks[1].hit_times = { fts(10), fts(15) }\t-- 一次攻击两次，第一次间隔 10 帧，第二次间隔 15 帧 -- 远程攻击\ntt.ranged.attacks[1].animations = { nil, \"shoot\",\t-- 复用普通远程攻击动画 nil\n}\ntt.ranged.attaks[1].loops = 2\ntt.ranged.attaks[1].shoot_times = { fts(10), fts(15) }\t-- 一次攻击两次，第一次间隔 10 帧，第二次间隔 15 帧\n给子弹的 bullet.hit_payload 设定实体模板名，即可让子弹落地后生成实体。tt.bullet.hit_payload = 实体模板名: str\ntt.bullet.hit_payload = \"decal_bolin_mine\" -- 波林扔地雷\nAC(tt, \"dodge\") -- 增加闪避组件\ntt.dodge.chance = 闪避概率: num\ntt.dodge.silent = 是否有动画?: bool\nAC(tt, \"dodge\") -- 增加闪避组件\ntt.dodge.chance = 0.25\t-- 闪避概率 25 %\ntt.dodge.silent = true\t-- 无动画\n给单位的 vis.bans 让单位不会被某些标签的攻击攻击-- 单位模板\ntt.vis.bans = 单位禁止的标签: int\ntt.vis.flags = 单位的标签: int\ntt.ranged.attacks[1].vis_bans = 攻击禁止的标签: int\ntt.ranged.attacks[1].vis_flags = 攻击的标签: int\n每个单位有自己的“身份证”（标签），攻击也有自己的“许可证”（标签）。双方互相检查，匹配不上就不能攻击。只看两个条件：\n攻击的 vis_bans&nbsp;不能包含&nbsp;目标的标签\n目标的 vis_bans&nbsp;不能包含&nbsp;攻击的标签\n-- 单位模板\ntt.vis.bans = F_RANGED\t-- 不会被远程攻击\ntt.ranged.attacks[1].vis_bans = bor(F_BOSS, F_FLYING)\t-- 远程攻击不攻击拥有 boss 标签与飞行标签的敌人\ntt.ranged.attacks[1].vis_flags = F_RANGED -- 远程攻击标签\n由于标签本质上是数字（通常为二次幂），可以通过 bit.bor 来增加多个标签。bit.bor(十进制数字: int...) -&gt; 合并后的十进制数字: int\n常用标签：\nF_BLOCK 近战攻击\nF_RANGED 远程攻击\nF_HERO 英雄\nF_BOSS Boss\nF_FLYING 飞行\nF_INSTAKILL 秒杀\n<br>所有标签见<a data-href=\"总结/3. 常量#标签\" href=\"总结/3.-常量.html#标签\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">总结/3. 常量 &gt; 标签</a>-- 修改小公主（hero_alleria）模板，要求：\n-- 1. 将远程普攻的子弹改为造成燃烧效果\n-- 2. 让近战攻击造成中毒效果\n-- 3. 增加 50% 闪避率\n-- 创建一个新的中毒效果 \"剧毒\"，要求：\n-- 1. 继承 mod_poison 模板\n-- 2. 持续时间为 5 秒\n-- 3. 每 0.5 秒造成 10-15 点真伤\n-- 4. 禁止冻结效果叠加\n-- 5. 如果目标已有冻结效果，则移除冻结 核心概念： 模板：实体的数据蓝图，读取 kr/game_templates 和 all/templates\n组件：为模板添加功能模块，读取在 all/components\n实体：使用模板创建的容器\nE.entities：存放所有实体模板\nE.components：存放所有组件\n数据流程：balance → 模板 → 实体 → 函数 单位分类： 英雄：具有 hero 组件\n士兵：具有 soldier 组件的友方\n敌人：具有 enemy 组件\n防御塔：具有 tower 组件 攻击类型： 近战攻击：拦截后的攻击，使用 melee 组件\n远程攻击：召唤子弹作为中介，使用 ranged 组件\n技能：特殊攻击，使用 timed_attacks 组件 效果： 造成效果：给攻击或子弹的 mod 设定效果模板名\n修改效果：增加一个新模板并续承原效果\n效果互斥：给 bans 设定效果模板名\n移除被禁止效果：remove_banned 设为真\n效果叠加：allows_duplicates 允许叠加，replaces_lower 替换低级效果，resets_same 仅重置持续时间 特殊效果 范围攻击：使用 area_attack 组件，并设定范围\n多次攻击：增加 loops 与 hit_times（对于近战攻击） 或 shoot_times（对于远程攻击）\n子弹携带实体：给 hit_payload 设定实体模板名\n闪避：增加 dodge 组件并增加概率\n标签：使用 bans 与 flags 来过滤目标，使用 bit.bor 合并位运算增加多个标签 （点击勾选框勾选）\n完成本章后，你应该能够：\n理解 ECS 架构的理念\n理解实体、模板、组件三者的关系\n查找并修改英雄的基础属性和等级属性\n理解并修改近战、远程、技能三种攻击类型\n修改伤害类型和状态效果\n使用模板函数创建和修改模板\n配置标签系统\n实现范围攻击、多次攻击等特殊效果 为什么模板系统要采用 \"模板 → 实体 \" 的数据传递流程？这样做有什么优势？\n组件系统如何实现代码的复用性和模块化？\n目标过滤系统中的 \"标签\" 和 \"禁止标签\" 是如何工作的？这种设计有什么好处？\n下一章预告：在第 3 章中，我们将学习实体函数，为更复杂的修改打下基础！","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"2.1 概念","level":2,"id":"2.1_概念_0"},{"heading":"2.1.1 ECS 架构","level":3,"id":"2.1.1_ECS_架构_0"},{"heading":"三核心部分","level":4,"id":"三核心部分_0"},{"heading":"1. E - Entity（实体）","level":5,"id":"1._**E_-_Entity（实体）**_0"},{"heading":"2. C - Component（组件）","level":5,"id":"2._**C_-_Component（组件）**_0"},{"heading":"3. S - System（系统）","level":5,"id":"3._**S_-_System（系统）**_0"},{"heading":"ECS 如何协同工作","level":4,"id":"ECS_如何协同工作_0"},{"heading":"2.1.2 游戏中的定义","level":3,"id":"2.1.2_游戏中的定义_0"},{"heading":"1. 实体模板（templates）","level":5,"id":"1._实体模板（templates）_0"},{"heading":"2. 组件（components）","level":5,"id":"2._组件（components）_0"},{"heading":"3. 实体（entities）","level":5,"id":"3._实体（entities）_0"},{"heading":"4. 系统（systems）","level":5,"id":"4._系统（systems）_0"},{"heading":"2.2 修改属性","level":2,"id":"2.2_修改属性_0"},{"heading":"2.2.1 修改基础属性","level":3,"id":"2.2.1_修改基础属性_0"},{"heading":"修改方法","level":4,"id":"修改方法_0"},{"heading":"五代修改方法","level":4,"id":"五代修改方法_0"},{"heading":"2.2.2 修改随等级提高的属性","level":3,"id":"2.2.2_修改随等级提高的属性_0"},{"heading":"修改方法","level":4,"id":"修改方法_1"},{"heading":"五代修改方法","level":4,"id":"五代修改方法_1"},{"heading":"2.3 修改技能","level":2,"id":"2.3_修改技能_0"},{"heading":"2.3.1 近战攻击","level":3,"id":"2.3.1_近战攻击_0"},{"heading":"2.3.2 远程攻击","level":3,"id":"2.3.2_远程攻击_0"},{"heading":"2.3.3 技能","level":3,"id":"2.3.3_技能_0"},{"heading":"2.4 修改近战伤害类型","level":2,"id":"2.4_修改近战伤害类型_0"},{"heading":"2.5 模板函数","level":2,"id":"2.5_模板函数_0"},{"heading":"2.5.1 E:register_t - 创建模板","level":3,"id":"2.5.1_Eregister_t_-_创建模板_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"2.5.2 E:add_comps - 增加组件","level":3,"id":"2.5.2_Eadd_comps_-_增加组件_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"2.5.3 E:clone_c - 深拷贝组件","level":3,"id":"2.5.3_Eclone_c_-_深拷贝组件_0"},{"heading":"示例","level":4,"id":"示例_2"},{"heading":"2.5.4 E:register_c - 创建组件","level":3,"id":"2.5.4_Eregister_c_-_创建组件_0"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"更多函数见 <a data-href=\"总结/2. 模板函数.md\" href=\"总结/2. 模板函数.md\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">总结/2. 模板函数.md</a>","level":3,"id":"更多函数见_[[总结/2._模板函数.md]]_0"},{"heading":"2.6 mod - 状态效果","level":2,"id":"2.6_mod_-_状态效果_0"},{"heading":"2.6.1 攻击造成效果方法","level":3,"id":"2.6.1_攻击造成效果方法_0"},{"heading":"示例","level":4,"id":"示例_4"},{"heading":"2.6.2 修改效果","level":3,"id":"2.6.2_修改效果_0"},{"heading":"2.6.3 五代修改方法","level":3,"id":"2.6.3_五代修改方法_0"},{"heading":"2.6.4 效果互斥","level":3,"id":"2.6.4_效果互斥_0"},{"heading":"示例：","level":4,"id":"示例：_0"},{"heading":"2.6.5 移除禁止的效果","level":3,"id":"2.6.5_移除禁止的效果_0"},{"heading":"示例","level":4,"id":"示例_5"},{"heading":"2.6.6 效果叠加","level":3,"id":"2.6.6_效果叠加_0"},{"heading":"示例","level":4,"id":"示例_6"},{"heading":"2.7 特殊效果","level":2,"id":"2.7_特殊效果_0"},{"heading":"2.7.1 范围攻击","level":3,"id":"2.7.1_范围攻击_0"},{"heading":"示例","level":4,"id":"示例_7"},{"heading":"2.7.2 多次攻击","level":3,"id":"2.7.2_多次攻击_0"},{"heading":"示例","level":4,"id":"示例_8"},{"heading":"2.7.3 子弹携带实体","level":3,"id":"2.7.3_子弹携带实体_0"},{"heading":"示例","level":4,"id":"示例_9"},{"heading":"2.7.4 闪避","level":3,"id":"2.7.4_闪避_0"},{"heading":"示例","level":4,"id":"示例_10"},{"heading":"2.7.5 标签","level":3,"id":"2.7.5_标签_0"},{"heading":"示例","level":4,"id":"示例_11"},{"heading":"位运算增加多个标签","level":4,"id":"位运算增加多个标签_0"},{"heading":"2.8 练习","level":2,"id":"2.8_练习_0"},{"heading":"练习 1：修改英雄","level":3,"id":"练习_1：修改英雄_0"},{"heading":"练习 2：增加状态效果","level":3,"id":"练习_2：增加状态效果_0"},{"heading":"2.9 本章总结","level":2,"id":"2.9_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"}],"links":["总结/1.-模板名.html","总结/1.-模板名.html","总结/3.-常量.html#伤害类型","总结/2.-模板函数.html","总结/3.-常量.html#效果类型","总结/3.-常量.html#标签"],"author":"","coverImageURL":".","fullURL":"第-2-节-修改基础/2.-实体与模板.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251212181056.png","site-lib/media/pasted-image-20250626192149.png","site-lib/media/pasted-image-20250626191819.png"],"createdTime":1759492568939,"modifiedTime":1766393165723,"sourceSize":23783,"sourcePath":"第 2 节 - 修改基础/2. 实体与模板.md","exportPath":"第-2-节-修改基础/2.-实体与模板.html","showInTree":true,"treeOrder":20,"backlinks":[],"type":"markdown"},"第-2-节-修改基础/3.-实体函数.html":{"title":"3. 实体函数","icon":"","description":"tt.main_script.insert = 函数: func\ntt.main_script.update = 函数: func\ntt.hero.fn_level_up = 函数: func\n-- 这些都是实体函数 存储位置：实体函数通常存储在 kr/game_scripts 与 all/scripts 中\n作用：实体函数通常用于 main_script 系统，为实体增加逻辑\n每次创建实体都会调用一次的函数，称为插入函数（insert script）首先在模板找到函数，并在 kr/game_scripts 搜索-- 艾莉丹插入函数\nfunction scripts.hero_elves_archer.insert(this, store) -- this 表示调用插入函数的实体 ... local d = E:create_entity(\"damage\")\t-- 造成伤害 d.value = 233666 -- 伤害 d.target_id = this.id -- 目标 id 设置为当前英雄 id queue_damage(store, d) -- 插入伤害队列\nend\n使用修改的英雄进入关卡，英雄掉血，成功造成效果同上，不过要插入实体队列（queue_insert）local mod = E:create_entity(效果模板名: str)\t-- 造成效果\nmod.modifier.target_id = this.id -- 目标\nqueue_insert(store, mod) -- 插入实体队列\n-- 沙王插入函数，给沙王增加死亡骑士光环\nfunction scripts.hero_alric.insert(this, store, script) ... if this.hero.skills.toughness.level &gt; 0 then -- 若坚韧技能等级大于 0，可选 local e = E:create_entity(\"death_rider_aura\")\t-- 创建死亡骑士光环 e.aura.source_id = this.id -- 来源设置为沙王 queue_insert(store, e) -- 将 e 插入实体队列 end\nend -- 进入游戏后发现光环显示位置错误，在模板移除偏移即可（与修改效果同理）\n-- 创建新模板，续承死亡骑士光环\ntt = RT(\"death_rider_aura_alric\", \"death_rider_aura\")\ntt.aura.use_mod_offset = nil\t-- 移除偏移 -- 插入函数创建新的光环即可：E:create_entity(\"death_rider_aura_alric\")\nE:create_entity(实体模板名: str) -&gt; 实体引用: table 创建实体后需要插入实体队列才会正式创建实体\nstore 位于 game 表中，用于存储临时数据，如实体、玩家拥有的金币、生命、游戏时间、实体与伤害队列等所有创建的实体都会存储在 store.entities 表中，每个实体都有独立 ID，ID 只增不减。每次实体升级时调用的函数，称为升级函数（level up script）-- 模板内\n-- 艾莉丹的双刀跳斩\ntt.hero.skills.double_strike = CC(\"hero_skill\")\ntt.hero.skills.double_strike.cooldown = {\t-- 冷却时间随等级变化（原版 12 秒） 12,\t-- 一级 12 秒 10,\t-- 二级 10 秒 8\t-- 三级 8 秒\n} -- 艾莉丹升级函数\nfunction scripts.hero_elves_archer.level_up(this, store, initial)\n... s = this.hero.skills.double_strike if initial and s.level &gt; θ then local a = this.melee.attacks[2] -- 近战攻击 2 为双刀跳斩 a.disabled = nil a.damage_min = s.damage_min[s.level] a.damage_max = s.damage_max[s.level] a.cooldown = s.cooldown[s.level]\t-- 增加代码 end\n...\n随着游戏逻辑时间更新而调用的函数，称为更新函数（update script）找到技能造成伤害的部分，在后面加上造成效果的逻辑即可以给火男烈焰冲击增加燃烧效果为例-- 火男模板\ntt = RT(\"hero_ignus\", \"hero\")\ntt.timed_attacks.list[1].mod = \"mod_lava_ignus\"\t-- 造成这个效果 local tt = E:register_t(\"mod_lava_ignus\", \"mod_lava\")\ntt.dps.damage_inc = 2\t-- 翻倍燃烧伤害 -- 更新函数内\nfunction scripts.hero_ignus.update(this, store) ... a = this.timed_attacks.list[1] skill = this.hero.skills.flaming_frenzy if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts &gt;= a.cooldown then\t-- 计算冷却时间 ... targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags, a.vis_bans)\t-- 索敌 if targets then for _, t in pairs(targets) do -- 造成伤害 local d = E:create_entity(\"damage\") d.damage_type = a.damage_type d.source_id = this.id d.target_id = t.id d.value = math.random(a.damage_min, a.damage_max) queue_damage(store, d) -- 造成效果 local mod = E:create_entity(a.mod) mod.modifier.target_id = t.id mod.modifier.source_id = this.id queue_insert(store, mod) end ... end ... ...\nend\n计算时间常用到 store.tick_ts （游戏时间）与 ts（时间戳）a = this.timed_attacks.list[1]\t-- 某个技能 if store.tick_ts - a.ts &gt; a.cooldown then a.ts = store.tick_ts\t-- 刷新 a 的时间戳 ...\nend\n表示如果当前时间与上次释放技能 a 的时间戳之差大于冷却时间，执行条件代码块\n换句话说就是上次释放技能过去的时间大于冷却时间通常所有函数的调用源头都是 Love 2D 引擎的 love.update 回调函数。按照以下调用链通过模拟器（simulation）协调系统，通过系统（sys.main_script）来调用实体的更新函数与插入函数\n<img alt=\"Pasted image 20251215185551.png\" src=\"site-lib/media/pasted-image-20251215185551.png\" target=\"_self\" style=\"width: 1200px; max-width: 100%;\">游戏内置了一套完整的日志系统，用于开发调试和问题排查。日志系统采用分级机制，便于控制不同开发阶段的输出信息量。log:new(打印的日志前缀: str, 日志等级?: int) -&gt; 日志实例: table 推荐在 args 修改全局日志等级\nlog.debug(\"load atlas: %s,%s-%.6f\", path, name, ref_scale) --[[ 输出\n[22841.0227] image_db.DEBUG preload_atlas() - load atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000\n--]] [22841.0227] 为时间信息\nimage_db 为前缀\nDEBUG 为等级，调试五级\npreload_atlas 调用的函数\nload atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000 信息\n-- 打印最详细的调试信息\nlog.paranoid(\"实体 %d 当前状态: pos=(%.1f, %.1f), hp=%d/%d\", this.id, this.pos.x, this.pos.y, this.health.hp, this.health.hp_max) 用途：深度跟踪复杂逻辑的执行流程\n特点：信息量极大，仅在调试特定问题时开启\n示例场景： 追踪 AI 决策过程\n监控每帧的状态变化\n调试复杂的协程逻辑 -- 打印开发调试信息\nlog.debug(\"技能 %s 触发，目标=%d，伤害=%d\", skill_name, target.id, damage_value) 用途：开发阶段的主要调试工具\n特点：包含详细的过程信息，但比偏执级简洁\n示例场景： 技能释放和冷却\n伤害计算过程\n实体创建和销毁 -- 标记需要完成的功能\nlog.todo(\"TODO: 为英雄 %s 实现连击系统\", this.hero.name)\n-- 或标记已知问题\nlog.todo(\"FIXME: 当敌人被冰冻时，伤害计算有误\") 用途：标记开发中的待办事项和已知问题\n特点：便于团队协作和任务跟踪\n最佳实践： 描述清晰的问题或功能需求\n包含解决建议（如果有）\n定期清理已完成的待办事项 -- 打印正常的游戏流程信息\nlog.info(\"关卡 %d 开始，初始金币=%d，生命=%d\", store.wave, store.gold, store.lives) 用途：记录正常的游戏运行信息\n特点：适合玩家可见的进度信息\n示例场景： 关卡开始/结束\n英雄升级\n重要游戏事件 -- 打印潜在问题警告\nlog.warning(\"实体 %d 的 hp=%d，但 hp_max=%d，血量数据异常\", this.id, this.health.hp, this.health.hp_max) 用途：提示潜在问题或不规范情况\n特点：程序能继续运行，但可能存在风险\n示例场景： 数据范围异常\n资源加载失败但有备用方案\n预期外的游戏状态 -- 打印错误信息\nlog.error(\"无法找到实体 %d 的目标 %d，技能释放失败\", this.id, target_id) 用途：报告程序错误和异常情况\n特点：通常伴随功能失效\n示例场景： 空指针访问\n资源加载完全失败\n关键逻辑无法执行 -- 使用格式化字符串提高可读性\nlocal hit_count = #targets\nlocal total_damage = 0\nfor _, dmg in pairs(damages) do total_damage = total_damage + dmg.value\nend log.info(\"范围攻击命中 %d 个目标，总伤害 %d\", hit_count, total_damage)\n-- 只在特定条件下输出日志\nif DEBUG_MODE then log.debug(\"详细状态: %s\", inspect(this))\nend -- 或者在开发阶段使用\nif store.tick_ts &lt; 10 then -- 只在游戏前10秒输出 log.paranoid(\"初始状态跟踪: %s\", this.id)\nend\nfunction scripts.new_hero.insert(this, store) log.todo(\"实现新英雄的插入函数\") log.debug(\"新英雄创建，ID=%d，位置=(%.1f,%.1f)\", this.id, this.pos.x, this.pos.y) -- 开发过程中的调试 log.paranoid(\"初始组件状态: %s\", inspect(this)) -- 实现逻辑...\nend function scripts.new_hero.update(this, store) log.todo(\"实现新英雄的更新函数\") -- 跟踪特定问题 if this.some_problem then log.warning(\"检测到问题状态: %s\", this.some_problem) end -- 实现逻辑...\nend\nfunction scripts.problem_skill.update(this, store) local skill = this.hero.skills.problem_skill -- 逐步添加日志定位问题 log.debug(\"技能检查: level=%d, cooldown=%f\", skill.level, skill.cooldown) if store.tick_ts - skill.last_use &gt; skill.cooldown then log.paranoid(\"技能可用，开始索敌...\") local target = U.find_foremost_enemy(store.entities, this.pos, 0, 100) if target then log.paranoid(\"找到目标: ID=%d, hp=%d\", target.id, target.health.hp) -- 检查目标状态 if target.health.hp &lt;= 0 then log.warning(\"目标已死亡但仍被选中，ID=%d\", target.id) return end -- 执行技能... else log.debug(\"未找到有效目标\") end end\nend\nfunction scripts.heavy_function.update(this, store) local start_time = os.clock() -- 执行复杂计算... local end_time = os.clock() local duration = end_time - start_time if duration &gt; 0.016 then -- 超过一帧时间（30fps） log.warning(\"函数执行时间过长: %.3f秒，实体ID=%d\", duration, this.id) log.paranoid(\"详细状态: %s\", inspect(this)) elseif duration &gt; 0.001 then -- 超过1毫秒 log.debug(\"函数执行时间: %.3f秒\", duration) end\nend\n几乎所有索敌本质都是在一定范围索敌，然后根据条件过滤目标。U.find_enemies_in_range( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func\n) -&gt; 范围内所有敌人: list e 参数通常为 store.entities\n为过滤函数传递：实体、原点\n过滤函数用于筛选目标，返回假的目标将会被筛选\nU.find_foremost_enemy( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 预判时间: num, 标签: int, 禁止标签: int, 过滤函数?: func, 禁用最小半径的标签: int\n) -&gt; 首个敌人: table, 范围内所有敌人: list{敌人: table...}, 预判位置: vec2 禁用最小半径的标签：拥有此标签的目标不受搜索最小半径限制\n<br>所有索敌见<a data-href=\"9. 工具函数#一、索敌\" href=\"总结/9.-工具函数.html#一、索敌\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">9. 工具函数 &gt; 一、索敌</a>local target = U.find_foremost_enemy(..., function(v, origin)\t-- v 为实体，origin 为原点 ...\t-- 函数体 return v.health.hp &gt;= 1000\t-- 筛选掉血量小于 1000 的敌人\nend, ...) local targets = U.find_enemies_in_range(store.entities, hero.pos, 0, a.radius, a.vis_flags, a.vis_bans) if targets then table.sort(targets, function(e1, e2) return e1.health.hp &gt; e2.health.hp\t-- 根据血量排序，血量最高的排序在最前 end) local target = targets[1]\t-- 取血量最高目标 ...\nend\n给近战攻击的 fn_can 指定条件函数即可。tt.melee.attacks[1].fn_can = 条件函数: func 为条件函数传递： store、攻击、目标\n条件函数返回真表示可以攻击\n以给鬼侍灭魂斩增加条件为例：-- 模板\ntt.melee.attacks[2].trigger_min_hp = 150\t-- 释放条件：目标血量大于等于 150\ntt.melee.attacks[2].fn_can = scripts.hero_oni.update -- game_scripts\nfunction scripts.hero_oni.update(this, store) ...\nend -- 写在更新函数下面\nfunction scripts.hero_oni.melee_fn_can_2(this, store, a, target) return target.health.hp &gt;= a.trigger_min_hp\nend\n给远程攻击的 filter_fn 指定条件函数即可。tt.ranged.attacks[1].filter_fn = 条件函数: func 为条件函数传递：目标、原点\n条件函数返回真表示可以攻击\n以小公主为例：tt.ranged.attacks[1].trigger_min_hp = 150 tt.ranged.attacks[1].filter_fn = scripts.hero_alleria.ranged_filter_fn_1 -- game_scripts\nfunction scripts.hero_alleria.ranged_filter_fn_1(v, origin) return v.health.hp &gt; trigger_min_hp\nend\n给攻击的 fn_chance 指定条件函数即可。tt.melee.attacks[1].fn_chance = 条件函数: func 为条件函数传递：当前实体、store、攻击、目标\n以使鬼侍灭魂斩 100% 秒杀处于流血效果的目标为例：-- 鬼侍近战攻击 2 是灭魂斩的秒杀，3 则是灭魂斩不秒杀的真伤\ntt.melee.attacks[2].instakill_mod_type = MOD_TYPE_BLEED\t-- 效果类型：流血类型\ntt.melee.attacks[2].fn_chance = scripts.hero_oni.fn_chance_death_strike -- game_scripts\nfunction scripts.hero_oni.fn_chance_death_strike(this, store, a, target) return U.has_modifier_types(store, target, a.instakill_mod_type) or math.random() &lt; attack.chance\nend\nU.has_modifiers(store: table, 实体: table, 效果模板名: str) -&gt; 是否拥有: bool, 找到的效果实体: table 若不传递效果模板名称则返回所有效果\nU.has_modifier_types(store: table, 实体: table, 效果类型: int...) -&gt; 是否拥有: bool, 所有找到的效果实体: table\ntt.melee.attacks[2] = table.deepclone(tt.melee.attacks[1]) -- 深拷贝的攻击\ntt.melee.attacks[2].chance = 概率: num\ntt.melee.attacks[2].mod = 效果模板名: str\n以火男普攻概率造成燃烧效果为例：-- 模板\ntt.melee.attacks[2] = table.deepclone(tt.melee.attacks[1]) -- 深拷贝近战普攻\ntt.melee.attacks[2].chance = 0.5\ntt.melee.attacks[2].mod = \"mod_lava\" -- 升级函数，只有能升级（有升级函数）的单位才需要修改升级函数\n...\nthis.melee.attacks[1].damage_min = ls.melee_damage_min[hl]\nthis.melee.attacks[1].damage_max = ls.melee_damage_max[hl]\n-- 同时将伤害赋值到新攻击上\nthis.melee.attacks[2].damage_min = ls.melee_damage_min[hl]\nthis.melee.attacks[2].damage_max = ls.melee_damage_max[hl]\n...\n防御塔的攻击需要自己写逻辑。以地震普攻概率造成眩晕效果为例：-- 模板\nlocal tower_dwaarp = RT(\"tower_dwaarp\", \"tower\")\ntower_dwaarp.attacks.list[4] = table.deepclone(tower_dwaarp.attacks.list[1])\ntower_dwaarp.attacks.list[4].mod = \"mod_stun\"\ntower_dwaarp.attacks.list[4].chance = 0.5 -- 更新函数\nfunction scripts.tower_dwaarp.update(this, store, script) ... local aa_m = this.attacks.list[4] while true do if this.tower.blocked then coroutine.yield() else ... if store.tick_ts - aa.ts &gt; aa.cooldown then ... -- 若进行攻击 1 则计算概率，然后将攻击 1 改成攻击 4 if math.random() &lt;= aa_m.chance then aa = aa_m end end ... if not drill_ready and not lava_ready and not std_ready then coroutine.yield() else ... if std_ready and trigger_enemy then -- 更新两个时间戳 aa.ts = store.tick_ts this.attacks.list[1].ts = store.tick_ts ... -- 还原 aa = this.attacks.list[1] std_ready = false lava_ready = false ... end ... end ... end ... end ...\nend\n以爵士为例：-- 模板\ntt = RT(\"hero_gerald\", \"hero\")\nAC(tt, \"melee\", \"timed_attacks\", \"dodge\", \"ranged\")\n...\ntt.ranged.attacks[1].bullet = \"gerald_arrow\"\ntt.ranged.attacks[1].bullet_start_offset = { v(0, 12)\n}\ntt.ranged.attacks[1].cooldown = 1\ntt.ranged.attacks[1].max_range = 150\ntt.ranged.attacks[1].min_range = 25\ntt.ranged.attacks[1].shoot_time = fts(6)\ntt.ranged.attacks[1].animation = \"idle\" -- 使用待机时的动画 tt = RT(\"gerald_arrow\", \"arrow\")\ntt.bullet.damage_min = 10\ntt.bullet.damage_max = 25\ntt.bullet.prediction_error = false -- 更新函数\nfunction scripts.hero_gerald.update(this, store) ... brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)\t-- 调用近战攻击函数 -- brk 就是 break，sta 就是 status if brk or sta ~= A_NO_TARGET then\t-- 删除 sta ~= A_NO_TARGET 条件即可让近战攻击与远程攻击同时进行 -- block empty else brk, sta = SU.y_soldier_ranged_attacks(store, this)\t-- 调用远程攻击函数 if brk then -- block empty elseif SU.soldier_go_back_step(store, this) then\t-- 前往集结点 -- block empty else SU.soldier_idle(store, this) SU.soldier_regen(store, this) end end ...\nend\n以利维坦为例：tt = RT(\"eb_leviathan\", \"boss\")\nAC(tt, \"attacks\", \"ranged\")\n...\ntt.ranged.attacks[1].bullet = \"bolt_blazefang_eb_leviathan\"\ntt.ranged.attacks[1].bullet_start_offset = { v(25, 10), v(12, 22), v(6, 4)\n}\ntt.ranged.attacks[1].cooldown = 1\ntt.ranged.attacks[1].hold_advance = true\ntt.ranged.attacks[1].max_range = 150\ntt.ranged.attacks[1].min_range = 25\ntt.ranged.attacks[1].shoot_time = fts(24)\ntt.ranged.attacks[1].animation = \"idle\" -- 使用待机时的动画\ntt.ranged.attacks[1].shared_cooldown = true\n... tt = E:register_t(\"bolt_blazefang_eb_leviathan\", \"bolt_blazefang\")\t-- 续承蜥蜴人未来战士子弹\ntt.bullet.damage_max = 1000\ntt.bullet.damage_min = 600 -- 更新函数\nfunction scripts.eb_leviathan.update(this, store, script) ... local a = this.ranged.attacks[1] ::label_244_0:: while true do ... if this.unit.is_stunned then coroutine.yield() else local ranged = U.find_nearest_soldier(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans) -- 如果找到士兵目标 if ranged then -- 如果可以远程攻击，并且没有被拦截一直进行远程攻击 while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do if not SU.y_enemy_range_attacks(store, this, ranged) then goto label_244_0 end coroutine.yield() end end ... end end\nend\n以给尼鲁增加一个技能：每 275 秒增加 1 生命（升级二技能翠绿迸发解锁）为例：-- 模板\ntt.hero.skills.heal_live = CC(\"hero_skill\")\t-- 防御塔与其他单位技能组件是 power\ntt.hero.skills.heal_live.cooldown = { 275,\t-- 一级冷却时间 275 秒 245,\t-- 三级冷却时间 245 秒 210 -- 三级冷却时间 210 秒\n}\n...\ntt.timed_attacks.list[5] = CC(\"custom_attack\")\ntt.timed_attacks.list[5].animation = \"fairy_dust\"\t-- 动画套用四技能衰弱咒语\ntt.timed_attacks.list[5].sound = \"HeroNyruFairyDustCast\"\t-- 音效，也是借用衰弱咒语\ntt.timed_attacks.list[5].cooldown = nil\ntt.timed_attacks.list[5].disabled = true\ntt.timed_attacks.list[5].heal_live = 1 -- 升级函数\nfunction scripts.hero_muyrn.level_up(this, store, initial) s = this.hero.skills.verdant_blast sl = s.level ... if sl &gt; 0 and initial then ... local a = this.timed_attacks.list[5] a.cooldown = this.hero.skills.heal_live.cooldown[sl] a.disabled = nil ... end ...\nend -- 更新函数\nfunction scripts.hero_muyrn.update(this, store) ... if this.unit.is_stunned then SU.soldier_idle(store, this) else ... a = this.timed_attacks.list[5] skill = this.hero.skills.heal_live if not a.disabled and store.tick_ts - a.ts &gt; a.cooldown then a.ts = store.tick_ts U.animation_start(this, a.animation, nil, store.tick_ts) S:queue(a.sound)\t-- 播放音效 store.lives = store.lives + a.heal_live\t-- 增加生命 SU.y_hero_animation_wait(this)\t-- 等待动画完成 ... end\nend\n为闪避组件的 counter_attack 指定攻击即可。以爵士格挡为例：-- 模板\ntt.dodge.counter_attack = CC(\"melee_attack\")\ntt.dodge.counter_attack.damage_type = bor(DAMAGE_TRUE, DAMAGE_NO_DODGE)\ntt.dodge.counter_attack.reflected_damage_factor = 0.5\ntt.dodge.counter_attack.reflected_damage_factor_inc = 0.5\t-- 技能升级提升系数\ntt.dodge.counter_attack.hit_time = fts(5)\ntt.dodge.counter_attack.animation = \"counter\"\ntt.dodge.counter_attack.sound = \"HeroPaladinDeflect\" -- 更新函数\nfunction scripts.hero_gerald.update(this, store) ... local d = this.dodge while true do ... if this.unit.is_stunned then SU.soldier_idle(store, this) else ... skill = this.hero.skills.block_counter if skill.level &gt; 0 and d and d.active then d.active = false -- 闪避后 dodge.active 会被赋值为真 d.counter_attack_pending = true\t-- counter_attack_pending 为真表示将下次的普攻改成闪避反击 local la = d.last_attack local ca = d.counter_attack if la then local counter_damage = ca.reflected_damage_factor + ca.reflected_damage_factor_inc * skill.level ca.damage_max = la.damage_max * counter_damage ca.damage_min = la.damage_min * counter_damage end ... end ... end ... end ...\nend\n给闪避的 can_dodge 指定条件函数即可。tt.dodge.can_dodge = 条件函数: func 为条件函数传递 store 当前实体、远程攻击、攻击、来源\n条件函数返回真表示可以闪避\n以爵士格挡为例：-- 模板\ntt.dodge.can_dodge = scripts.hero_gerald.fn_can_dodge -- game_scripts\nfunction scripts.hero_gerald.fn_can_dodge(store, this, ranged_attack, attack, source) if (attack and attack.type == \"area\" or source and source.vis and band(source.vis.flags, F_BOSS) ~= 0) and math.random() &gt; this.dodge.low_chance_factor then -- 如果攻击为范围伤害，或为 Boss 计算闪避概率（Boss 闪避概率为三分之一） return false end return true\nend\n攻击优先级存储于攻击的 order 中，通过 U.attack_order 自动排序。攻击概率造成效果也是通过其排序方法实现的。\n释放概率不同，释放概率低者在前\n释放概率相同，冷却时间长者在前\n所有条件相同，攻击索引低者在前\n-- 雷格森插入函数\nfunction scripts.hero_regson.insert(this, store) ... this.melee.order = U.attack_order(this.melee.attacks)\t-- 删除这个 ...\nend -- 直接在模板指定攻击优先级\ntt.melee.order = { 2, -- 优先释放近战攻击 2 1, -- 之后释放近战攻击 1 ... -- 注：必须填写所有的攻击，没填写的攻击将永不释放\n} -- 远程攻击同理\nthis.ranged.order = U.attack_order(this.ranged.attacks)\t-- 删除这个 tt.ranged.order = { 2, -- 优先释放远程攻击 2 1, -- 之后释放远程攻击 1 ...\n}\n以利维坦为例：-- 模板\ntt = E:register_t(\"eb_leviathan\", \"boss\")\n...\ntt.second_phase = {}\ntt.second_phase.wait_time = 5 -- 死亡后进入二阶段等待时间\ntt.second_phase.hp_max = 10000 -- 二阶段血量\ntt.second_phase.armor = 0.5 -- 二阶段护甲 -- 更新函数\nfunction scripts.eb_leviathan.update(this, store, script)\n... ::label_244_0:: while true do if this.health.dead then if not this.is_second_phase then this.ui.can_click = false -- 进入二阶段等待时禁止玩家点击，避免显示状态栏 this.health_bar.hidden = true\t-- 进入二阶段等待时隐藏血条 U.animation_start(this, \"death\", nil, store.tick_ts, false) -- 播放死亡动画 U.y_wait(store, this.second_phase.wait_time)\t-- 等待 5 秒 this.ui.can_click = true -- 重新启用，允许玩家点击 this.health_bar.hidden = false\t-- 重新显示血条 this.is_second_phase = true this.health.dead = false this.health.hp_max = this.second_phase.hp_max -- 设置新的最大血量 this.health.hp = this.second_phase.hp_max -- 设置新的血量 this.health.armor = this.second_phase.armor -- 设置新的护甲 goto label_244_0 -- 直接跳出，避免进入死亡移除环节（正式死亡） end -- 二阶段死亡则进入死亡移除环节（正式死亡） this.phase = \"dead\" LU.kill_all_enemies(store, true) for _, t in pairs(tentacles) do t.interrupt = true end do_death() queue_remove(store, this) signal.emit(\"boss-killed\", this) return end ... end ...\nend\n<br>根据 <a data-href=\"3. 实体函数#3 5 谁在调用插入与更新函数\" href=\"第-2-节-修改基础/3.-实体函数.html#3 5 谁在调用插入与更新函数\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">3. 实体函数 &gt; 3 5 谁在调用插入与更新函数</a> 阅读代码了解驱动函数是怎么调用实体函数的要点：\n系统存储位置：系统存储于 all/systems\n协程机制：更新函数使用协程（coroutine）管理与控制执行流程\n队列：使用多个队列（实体队列、伤害队列）批量处理操作\n<br>（答案见<a data-href=\"第 2 节 - 修改基础/参考答案#练习 3 2：日志与调试实践\" href=\"第-2-节-修改基础/参考答案.html#练习 3 2：日志与调试实践\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">第 2 节 - 修改基础/参考答案 &gt; 练习 3 2：日志与调试实践</a>）-- 假设你正在为英雄 \"暗影刺客\" 实现一个新技能 \"暗影突袭\"\n-- 技能效果：对范围内血量最低的敌人造成伤害并附加流血效果 -- 已有代码框架：\nfunction scripts.hero_shadow_assassin.update(this, store) local skill = this.hero.skills.shadow_assault local attack = this.timed_attacks.list[3] -- 第3个是暗影突袭 while true do if skill.level &gt; 0 and not attack.disabled then if store.tick_ts - attack.ts &gt;= attack.cooldown then -- 技能可用，开始索敌... -- TODO: 在这里实现技能逻辑 -- 要求： -- 1. 找到范围内血量最低的敌人 -- 2. 造成伤害 (伤害值 = 基础伤害 + 技能等级 * 伤害成长) -- 3. 附加流血效果 -- 4. 刷新技能时间戳 -- 5. 播放动画和音效 -- 技能参数： -- attack.radius = 200 -- 技能范围 -- attack.damage_base = 50 -- 基础伤害 -- attack.damage_per_level = 30 -- 每级伤害成长 -- attack.mod = \"mod_bleed_v2\" -- 流血效果模板 end end coroutine.yield() end\nend -- 要求：\n-- 1. 实现上述TODO部分的技能逻辑\n-- 2. 在关键位置添加适当的日志：\n-- - 使用 log.debug 记录技能触发和目标选择\n-- - 使用 log.info 记录技能释放成功\n-- - 使用 log.warning 处理边界情况（如无目标）\n-- - 使用 log.error 处理严重错误\n-- - 使用 log.paranoid 记录详细的计算过程（可选）\n-- 3. 确保代码有良好的错误处理 -- 提示函数：\n-- U.find_enemies_in_range -- 范围内所有敌人\n-- table.sort -- 对表排序\n-- E:create_entity(\"damage\")-- 创建伤害实体\n-- E:create_entity -- 创建效果实体\n-- queue_damage -- 排队伤害\n-- queue_insert -- 排队插入实体\n-- U.animation_start -- 播放动画\n-- S:queue -- 播放音效 实体函数概述 定义：存储在 kr/game_scripts 和 all/scripts 中的逻辑函数\n作用：为 main_script 系统增加实体逻辑\n插入函数（insert）：实体创建时调用一次\n更新函数（update）：每帧调用，管理实体持续行为\n升级函数（level up）：实体升级时调用 存储位置 实体存储：所有实体存储在 store.entities 表中\n临时存储：store 用于存储游戏临时数据 核心技能实现 造成伤害：E:create_entity(\"damage\") + queue_damage\n造成效果：E:create_entity + queue_insert\n增加光环：创建光环实体并设置 source_id\n修改攻击优先级：直接在模板攻击指定 order 数组 时间与状态管理 游戏时间：store.tick_ts\n时间戳：a.ts（攻击的时间戳）\n冷却计算：store.tick_ts - a.ts &gt;= a.cooldown\n效果判断：U.has_modifiers 和 U.has_modifier_types 打印日志 详细：log.paranoid 打印最详细的跟踪信息\n调试：log.debug 打印开发过程中的详细调试信息\n代办：log.todo 打印标记需要完成的功能或修复的问题\n信息：log.info 打印正常的游戏流程信息\n警告：log.warning 打印潜在问题或不规范使用\n错误：log.error 打印程序错误和异常情况 索敌与目标选择 范围索敌：U.find_enemies_in_range\n首个敌人：U.find_foremost_enemy\n过滤函数：可自定义条件筛选目标\n特殊筛选：如按血量排序找到最高血量目标 攻击条件控制 近战条件：fn_can 函数\n远程条件：filter_fn 函数\n释放概率：fn_chance 函数 扩展攻击与技能 新增攻击：使用 table.deepclone 复制攻击\n概率效果：设置 chance 和 mod 属性\n士兵新增远程攻击：需在更新函数中调用远程攻击 y_soldier_ranged_attacks 函数\n敌人新增远程攻击：需在逻辑循环中集成远程攻击检与 y_enemy_range_attacks 函数\n新增技能：在 timed_attacks 中添加，配合升级函数解锁\n闪避机制：counter_attack 和 can_dodge 函数 特殊机制实现 二阶段机制：通过状态标志和血量重置实现 架构与调用机制 ECS 架构：实体-组件-系统的分离设计\n调用链：Love2D → 游戏层 → 模拟器 → 实体函数\n协程管理：更新函数使用协程实现复杂逻辑控制 （点击勾选框勾选）\n完成本章后，你应该能够：\n理解插入、更新、升级三种实体函数的作用和调用时机\n在插入函数中实现伤害、效果、光环等基础功能\n使用 store.tick_ts 和 a.ts 计算时间和冷却\n使用日志库打印日志\n实现各种索敌逻辑和目标筛选\n为攻击添加释放条件和概率控制\n通过深拷贝和组件配置新增攻击和技能\n实现闪避和反击机制\n创建复杂的多阶段机制\n理解实体函数的调用链和协程机制 为什么实体函数要分为插入、更新、升级三种类型？这种分离设计如何提高代码的可维护性和性能？\n如果要为一个英雄添加一个新的召唤技能，需要考虑哪些方面？\nECS 架构如何支持游戏中复杂的行为组合？\n协程在游戏逻辑管理中有哪些优势和局限性？\n当多个实体需要共享某种行为时，如何设计避免代码重复？\n如何处理实体之间的复杂交互（如连锁反应）？ 代码复用： 观察现有英雄的实现，提取通用模式\n创建可复用的辅助函数库 文档习惯： 为自定义函数添加清晰文档注释\n记录重要的设计决策和实现细节 下一章预告：在第 4 章中，我们将学习修改游戏的关卡，包括路径、网格、出怪等，为更复杂的修改做准备。","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"3.1 插入函数","level":2,"id":"3.1_插入函数_0"},{"heading":"3.1.1 造成伤害","level":3,"id":"3.1.1_造成伤害_0"},{"heading":"3.1.2 造成效果","level":3,"id":"3.1.2_造成效果_0"},{"heading":"3.1.3 实体增加光环","level":3,"id":"3.1.3_实体增加光环_0"},{"heading":"3.1.4 E:create_entity - 创建实体","level":3,"id":"3.1.4_Ecreate_entity_-_创建实体_0"},{"heading":"3.2 store - 临时存储","level":2,"id":"3.2_store_-_临时存储_0"},{"heading":"实体存储位置","level":4,"id":"实体存储位置_0"},{"heading":"3.3 升级函数","level":2,"id":"3.3_升级函数_0"},{"heading":"3.3.1 数据随等级而变化","level":3,"id":"3.3.1_数据随等级而变化_0"},{"heading":"3.4 更新函数","level":2,"id":"3.4_更新函数_0"},{"heading":"3.4.1 技能造成效果","level":3,"id":"3.4.1_技能造成效果_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"3.4.2 计算时间","level":3,"id":"3.4.2_计算时间_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"3.5 谁在调用插入与更新函数","level":2,"id":"3.5_谁在调用插入与更新函数_0"},{"heading":"3.6 打印日志","level":2,"id":"3.6_打印日志_0"},{"heading":"3.6.1 六级日志系统","level":3,"id":"3.6.1_六级日志系统_0"},{"heading":"3.6.2 函数","level":3,"id":"3.6.2_函数_0"},{"heading":"1. 创建新日志实例","level":4,"id":"1._创建新日志实例_0"},{"heading":"示例","level":5,"id":"示例_2"},{"heading":"2. 偏执级调试（6 级）","level":4,"id":"2._偏执级调试（6_级）_0"},{"heading":"3. 调试信息（5 级）","level":4,"id":"3._调试信息（5_级）_0"},{"heading":"4. 待办事项（4 级）","level":4,"id":"4._待办事项（4_级）_0"},{"heading":"5. 常规信息（3 级）","level":4,"id":"5._常规信息（3_级）_0"},{"heading":"6. 警告信息（2 级）","level":4,"id":"6._警告信息（2_级）_0"},{"heading":"7. 错误信息（1 级）","level":4,"id":"7._错误信息（1_级）_0"},{"heading":"3.6.3 实用技巧","level":3,"id":"3.6.3_实用技巧_0"},{"heading":"1. 格式化输出","level":4,"id":"1._格式化输出_0"},{"heading":"2. 条件日志","level":4,"id":"2._条件日志_0"},{"heading":"3.6.4 调试工作流示例","level":3,"id":"3.6.4_调试工作流示例_0"},{"heading":"1. 新功能开发","level":4,"id":"1._新功能开发_0"},{"heading":"2. 问题排查","level":4,"id":"2._问题排查_0"},{"heading":"3. 性能分析","level":4,"id":"3._性能分析_0"},{"heading":"3.6.5 更多日志库函数见 <a data-href=\"12. 库#日志库\" href=\"12. 库#日志库\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">12. 库 &gt; 日志库</a>","level":3,"id":"3.6.5_更多日志库函数见_[[12._库#日志库]]_0"},{"heading":"3.7 索敌","level":2,"id":"3.7_索敌_0"},{"heading":"3.7.1 基础索敌","level":3,"id":"3.7.1_基础索敌_0"},{"heading":"1. 搜索范围内所有敌人","level":4,"id":"1._搜索范围内所有敌人_0"},{"heading":"2. 搜索首个敌人","level":4,"id":"2._搜索首个敌人_0"},{"heading":"3.7.2 过滤函数","level":3,"id":"3.7.2_过滤函数_0"},{"heading":"3.7.3 寻找血量最高的敌人","level":3,"id":"3.7.3_寻找血量最高的敌人_0"},{"heading":"3.8 实体攻击增加条件","level":2,"id":"3.8_实体攻击增加条件_0"},{"heading":"3.8.1 近战攻击条件","level":3,"id":"3.8.1_近战攻击条件_0"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"3.8.2 远程攻击条件","level":3,"id":"3.8.2_远程攻击条件_0"},{"heading":"示例","level":4,"id":"示例_4"},{"heading":"3.8.3 释放概率根据条件而变化","level":3,"id":"3.8.3_释放概率根据条件而变化_0"},{"heading":"示例","level":4,"id":"示例_5"},{"heading":"3.8.4 判断是否拥有状态效果","level":3,"id":"3.8.4_判断是否拥有状态效果_0"},{"heading":"1. 判断拥有单个效果","level":4,"id":"1._判断拥有单个效果_0"},{"heading":"2. 判断拥有效果类型","level":4,"id":"2._判断拥有效果类型_0"},{"heading":"3.9 增加新攻击与技能","level":2,"id":"3.9_增加新攻击与技能_0"},{"heading":"3.9.1 攻击概率造成效果","level":3,"id":"3.9.1_攻击概率造成效果_0"},{"heading":"示例","level":4,"id":"示例_6"},{"heading":"3.9.2 防御塔攻击概率造成效果","level":3,"id":"3.9.2_防御塔攻击概率造成效果_0"},{"heading":"示例","level":4,"id":"示例_7"},{"heading":"3.9.3 增加远程攻击","level":3,"id":"3.9.3_增加远程攻击_0"},{"heading":"1. 士兵","level":4,"id":"1._士兵_0"},{"heading":"2. 敌人","level":4,"id":"2._敌人_0"},{"heading":"3.9.4 增加新技能","level":3,"id":"3.9.4_增加新技能_0"},{"heading":"示例","level":4,"id":"示例_8"},{"heading":"3.9.5 闪避反击","level":3,"id":"3.9.5_闪避反击_0"},{"heading":"示例","level":4,"id":"示例_9"},{"heading":"3.9.6 闪避条件","level":3,"id":"3.9.6_闪避条件_0"},{"heading":"示例","level":4,"id":"示例_10"},{"heading":"3.9.7 攻击优先级","level":3,"id":"3.9.7_攻击优先级_0"},{"heading":"排序方法","level":4,"id":"排序方法_0"},{"heading":"手动指定优先级","level":4,"id":"手动指定优先级_0"},{"heading":"3.10 特殊效果","level":2,"id":"3.10_特殊效果_0"},{"heading":"3.10.1 增加二阶段","level":3,"id":"3.10.1_增加二阶段_0"},{"heading":"3.11 练习","level":2,"id":"3.11_练习_0"},{"heading":"练习 1：了解驱动函数逻辑","level":3,"id":"练习_1：了解驱动函数逻辑_0"},{"heading":"练习 2：日志与调试实践","level":3,"id":"练习_2：日志与调试实践_0"},{"heading":"3.12 本章总结","level":2,"id":"3.12_本章总结_0"},{"heading":"关键知识点回顾","level":3,"id":"关键知识点回顾_0"},{"heading":"检查清单","level":3,"id":"检查清单_0"},{"heading":"思考题","level":3,"id":"思考题_0"},{"heading":"实战建议","level":3,"id":"实战建议_0"}],"links":["总结/12.-库.html#日志库","总结/9.-工具函数.html#一、索敌","第-2-节-修改基础/3.-实体函数.html#3 5 谁在调用插入与更新函数","第-2-节-修改基础/参考答案.html#练习 3 2：日志与调试实践"],"author":"","coverImageURL":".","fullURL":"第-2-节-修改基础/3.-实体函数.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251215185551.png"],"createdTime":1759492803499,"modifiedTime":1766647086920,"sourceSize":34237,"sourcePath":"第 2 节 - 修改基础/3. 实体函数.md","exportPath":"第-2-节-修改基础/3.-实体函数.html","showInTree":true,"treeOrder":21,"backlinks":["第-2-节-修改基础/3.-实体函数.html"],"type":"markdown"},"第-2-节-修改基础/4.-关卡.html":{"title":"4. 关卡","icon":"","description":"关卡中所有数据存储于 kr/data/levels 中其中：\n无后缀为关卡的函数\n_data 为关卡参数\n_paths 为路径数据\n_gird 为网格数据\nlocked_hero = 是否锁定英雄: bool,\nmax_upgrade_level = 科技最大等级: int,\nlocked_towers = { -- 锁定的防御塔 防御塔模板名 1: str, -- 防御塔模板名 2...\n},\navailable_towers = { -- 可用的防御塔（五代可用） 防御塔模板名 1: str, -- 防御塔模板名 2...\n},\nlocked_powers { -- 锁定的能力 是否锁定对应索引的能力: bool\n},\nentities_list = { -- 进入关卡创建的实体 { -- 实体 1 template = 创建的实体模板名: str, pos = 实体位置: vec2, }, -- 实体 2...\n},\nlevel_mode_overrides = {\t-- 不同模式覆盖的键（战役模式索引为 1、英雄为 2、钢铁为 3） {}, -- 战役模式 { -- 英雄模式 max_upgrade_level = 2\t-- 英雄模式下科技最大等级 2 }\n},\nrequired_sounds = { -- 加载的音效资源 资源 1 名称: str, -- 资源 2 名称...\n},\nrequired_textures = { -- 加载的美术资源 资源 1 名称: str, -- 资源 2 名称...\n}\nrequired_exoskeletons = {\t-- 加载的骨骼动画资源 资源 1 名称: str, -- 资源 2 名称...\n}\n路径用于规定怪物的行走路线，缩写为 P存储位置：all/path_db 的 paths 表中\n读取位置：读取 kr/data/levels 中的关卡路径数据（_paths）路径中：\nni 为节点索引（node index），即一条路径中的位置\npi 为路径索引（path index），即不同路径\nspi 为子路径索引（subpath index），即路径中的三个分支\n<img alt=\"Pasted image 20250812125430.png\" src=\"site-lib/media/pasted-image-20250812125430.png\" target=\"_self\">\n如图所示一条路径有三条子路径，白点为节点，关卡内按 H 即可显示路径\n在 level_data 的 entities_list 增加一个实体，在这个实体更新函数写召唤逻辑即可-- 模板\ntt = RT(\"s_spawner_entities\")\nAC(tt, \"main_script\", \"editor\")\ntt.main_script.update = scripts.s_spawner_entities.update\ntt.ts = 0\ntt.entity = \"enemy_halloween_zombie\"\t-- 召唤的实体\ntt.spawn_margin = { 30,\t-- 距离起点边距 60\t-- 距离终点边距\n}\ntt.spawn_cooldown = 3\t-- 召唤间隔\ntt.spawn_count = 1 -- 召唤数量\ntt.spawn_wave = 1 -- 开始召唤的波次\ntt.spawn_path = { -- 生成的路径 1, 2, 3\n}\ntt.enemy_gold = 0.5\t-- 召唤的敌人赏金乘数 -- 函数\nscripts.s_spawner_entities = {}\nfunction scripts.s_spawner_entities.update(this, store) local pi, spi, ni local p_pi, p_spi = this.spawn_path, { 1, 2, 3 } local start_margin, end_margin = unpack(this.spawn_margin) while true do if store.waves_finished then break end -- 计算召唤间隔 if store.wave_group_number &gt;= this.spawn_wave and this.spawn_cooldown &lt; store.tick_ts - this.ts then this.ts = store.tick_ts for i = 1, this.spawn_count do -- 取随机路径上随机节点 pi, spi = table.random(p_pi), table.random(p_spi) ni = math.random(P:get_start_node(pi) + start_margin, P:get_end_node(pi) - end_margin) -- 召唤实体 local e = E:create_entity(this.entity) e.pos = P:node_pos(pi, spi, ni) e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = pi, spi, ni e.render.sprites[1].name = \"raise\" e.enemy.gold = e.enemy.gold * this.enemy_gold queue_insert(store, e) end end coroutine.yield() end queue_remove(store, this)\nend -- 关卡数据\nentities_list = { { template = \"s_spawner_entities\", pos = { x = 0, y = 0 } } ...\n}\n波次的所有数据存储于 kr/data/waves 中其中：\n_campaign 为战役模式（1）\n_heroic 为英雄模式（2）\n_iron 为钢铁模式（3） 时间单位为游戏帧\n所有出怪组都是并发的，使用出怪组延迟控制\n出怪组一般用于多个怪物组合进攻与进攻不同路径\n交替出怪用于两个怪物轮流进攻\n每个组的怪物只有前一个出完才会出下一个\ncash = 初始金币: int,\ngroups = { -- 所有波次 { -- 第 1 波 interval = 下一波到来时间: num, waves = { -- 出怪组 { -- 第 1 组 delay = 延迟: num, path_index = 出怪路径: int, spawns = { -- 生成的怪物 { -- 怪物 1 interval = 生成间隔: num, creep = 怪物模板名: str, creep_aux = 交替怪物模板名: str,\t-- 每次出 max_same 数量的怪交替怪物 max_same = 交替数量: int, max = 出怪总数量: int, -- 包含交替的怪物 fixed_sub_path = 出怪子路径: int,\t-- 0 为随机 1-3，1 为 path 指定的子路径 path = 子路径: int, -- 用于 fixed_sub_path interval_next = 下一个怪物的延迟: num }, -- 怪物 2... } }, -- 第 2 组... } }, -- 第 2 波...\n}\n由于出怪数据的表不易于查看修改，推荐使用附件的波次生成脚本修改<br>\n<img alt=\"Pasted image 20250828164236.png\" src=\"site-lib/media/pasted-image-20250828164236.png\" target=\"_self\" style=\"width: 750px; max-width: 100%;\"><br><img alt=\"Pasted image 20250828164839.png\" src=\"site-lib/media/pasted-image-20250828164839.png\" target=\"_self\" style=\"width: 550px; max-width: 100%;\">\n数字改成你修改的关卡编号，然后直接替换波次数据即可.在关卡数据的 required_textures 键增加对应资源即可。required_textures = { \"go_enemies_bandits\",\t-- 强盗支线的所有怪物资源 ...\n}\n图像资源基本都在 _assets/kr-desktop/images/fullhd 内注：有些实体的资源在关卡资源内特殊出怪数据位于 kr/data/levels/levelxx_spawner 中groups = { -- 组 { -- 组 1 可能出怪点位 1: int, -- 可能出怪点位 2... }, -- 组 2...\n},\npoints = { -- 出怪点位 { -- 点位 1 path = int, -- 生成路径 from = vec2,\t-- 生成位置 to = vec2 -- 实际生成节点位置 }, -- 点位 2...\n},\nwaves = {\t-- 生成的波次 { -- 战役模式（战役 1，英雄 2，钢铁 3）的生成 {\t-- 第 1 波 {\t-- 出怪 1 延迟: num, 延迟随机变化值: num, 组: int, 生成子路径: int, 生成数量: int, 是否所有点位同时出怪: bool, 顺序生成/并行生成: bool, 出怪随机间隔最小值: num, 出怪随机间隔最大值: num, 生成怪物模板名: str, 自定义参数: any }, -- 出怪 2... }, -- 第二波... }, -- 英雄模式的生成...\n}\n-- 关卡数据\nentities_list = { {\t-- 加载的特殊出怪数据 template = \"mega_spawner\", load_file = \"level417_spawner\",\t-- 特殊出怪文件名 }\n} -- 特殊出怪数据\ngroups = { -- 组 { 1 -- 组 1 生成在点位 1 }\n},\npoints = { -- 点位 { -- 点位 1 path = 3,\t-- 位于路径 3 from = {\t-- 点位坐标 x = 260, y = 147 }, to = { x = 260, y = 147 } }\n},\nwaves = { -- 生成的波次 [1] = { -- 战役模式 [3] = { -- 第 3 波 { 2.6, -- 延迟 2.6 秒 0, -- 延迟不随机变化 1, -- 组 1 1, -- 生成到子路径 1 1, -- 生成 1 个 false, -- 所有点位不同时出怪 true, -- 顺序出怪 4, -- 出怪随机间隔最小值 4, -- 出怪随机间隔最大值 \"enemy_chaser\"\t-- 怪物模板名 } } }\n}\n包可以理解为模板，提前创建，后续快速使用。缺点是无法指定点位，只能生成在起点节点packs = { -- 包 包 1 名称 = { {\t-- 出怪 1 延迟: num, 延迟随机变化值: num, nil, 生成子路径: int, 生成数量: int, nil, nil, 出怪随机间隔最小值: num, 出怪随机间隔最大值: num, 生成怪物模板名: str } -- 出怪 2... }, -- 包 2...\n},\nwaves = {\t-- 生成的波次 { -- 战役模式（战役 1，英雄 2，钢铁 3）的生成 {\t-- 第 1 波 {\t-- 出怪 1 nil, nil, nil, nil, nil, nil, nil, nil, nil, \"PACK\", -- 生成怪物模板名改为 \"PACK\" { spawnPackId = 生成的包名: str, path = 生成路径: int } }, -- 出怪 2... }, -- 第二波... }, -- 英雄模式的生成...\n}\n-- 关卡数据\nentities_list = { {\t-- 加载的特殊出怪数据 template = \"mega_spawner\", load_file = \"level417_spawner\", }\n} -- 特殊出怪数据\npacks = { -- 包 frogs = { { 0, -- 延迟 0 帧 0, -- 延迟不随机变化 nil, 1, -- 生成到子路径 1 1, -- 生成 1 个 nil, nil, 4, -- 4, -- 出怪随机间隔 4 ~ 4 \"enemy_chaser\"\t-- 怪物模板名 \"enemy_chaser\" }, { 2, -- 延迟 2 帧 0, -- 延迟不随机变化 nil, 1, -- 生成到子路径 1 10, -- 生成 10 个 nil, nil, 4, -- 4, -- 出怪随机间隔 4 ~ 4 \"enemy_chaser\"\t-- 怪物模板名 \"enemy_chaser\" }, }\n}\nwaves = { -- 生成的波次 [1] = { -- 战役模式 [3] = { -- 第 3 波 { nil, nil, nil, nil, nil, nil, nil, nil, nil, \"PACK\",\t-- 出怪包模式 { spawnPackId = \"frogs\",\t-- 生成包 \"frogs\" 的怪物 path = 1 -- 生成路径 } } } }\n}\n通常用于给一些生成器实体发送出怪信号，用于检查是否正在出怪，播放动画等groups = { -- 组 组名 = { 生成器名称1: str, -- 生成器名称2... }\n},\nwaves = {\t-- 生成的波次 { -- 战役模式（战役 1，英雄 2，钢铁 3）的生成 {\t-- 第一波 {\t-- 出怪 1 延迟: num, 延迟随机变化值: num, 组: int, nil, nil, nil, nil, nil, nil, \"CUSTOM\", -- 生成怪物模板名改为 \"CUSTOM\" 为生成器的 spawner.spawn_data 键传递的数据: any }, -- 出怪 2... }, -- 第二波... }, -- 英雄模式的生成\n}\n-- 关卡数据\nentities_list = { { template = \"bullywag_spawner\", pos = { x = 260, y = 147 }, [\"spawner.name\"] = \"object1\" }, {\t-- 加载的特殊出怪数据 template = \"mega_spawner\", load_file = \"level417_spawner\", },\n}, -- 特殊出怪数据\ngroups = { -- 组 { 1 -- 组 1 生成在点位 1 }, som1 = { \"object1\",\t-- 组 \"som1\" 为 \"object1\" 也就是 \"bullywag_spawner\" 传递数据 }\n},\npoints = { -- 点位 { -- 点位 1 path = 3,\t-- 位于路径 3 from = {\t-- 点位坐标 x = 260, y = 147 }, to = { x = 260, y = 147 } }\n},\nwaves = { -- 生成的波次 [1] = { -- 战役模式 [3] = { -- 第 3 波 { -- 出怪前 1.6 秒（动画时间）给 \"som1\" 组内的所有生成器传递 true 1, -- 延迟 0, -- 延迟随机变化值 \"som1\", -- 组 \"som1\" nil, nil, nil, nil, nil, nil, \"CUSTOM\",\t-- 生成器模式 true -- 为生成器的 spawner.spawn_data 键传递的数据 }, { 2.6, -- 延迟 2.6 帧 0, -- 延迟不随机变化 1, -- 组 1 1, -- 生成子路径 1, -- 生成 1 个 false, -- 所有点位不同时出怪 true, -- 顺序出怪 4, -- 4, -- 出怪随机间隔 4 ~ 4 \"enemy_chaser\"\t-- 怪物模板名 \"enemy_chaser\" } } }\n} -- 生成器实体更新函数\nfunction scripts.basic_spawner.update(this, store, script) while true do if this.spawner.spawn_data then print(\"当前生成器生成怪物\") this.spawner.spawn_data = nil else print(\"当前生成器未生成怪物\") end coroutine.yield() end queue_remove(store, this)\nend 网格用于通过设定单元格类型来设定地形，例如水路、冰面等。实体可以通过判断地形来进行一些逻辑，例如判断脚下地形如果是冰面则开始滑冰增加移动速度。网格同时也会规范寻路。网格缩写为 GR<br><img alt=\"Pasted image 20251223100412.png\" src=\"site-lib/media/pasted-image-20251223100412.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\">\n如图所示绿色部分的单元格类型为不可移动，也就是说修改英雄集结点英雄只会在灰色部分寻路，关卡内按 g 显示网格存储位置：all/grid_db 的 grid 表中\n读取位置：读取 kr/data/levels 中的关卡网格数据（_grid）","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"4.1 关卡数据","level":2,"id":"4.1_关卡数据_0"},{"heading":"结构：","level":3,"id":"结构：_0"},{"heading":"4.2 路径（path）","level":2,"id":"4.2_路径（path）_0"},{"heading":"4.2.1 随机在路径上召唤实体","level":3,"id":"4.2.1_随机在路径上召唤实体_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"4.3 波次数据","level":2,"id":"4.3_波次数据_0"},{"heading":"4.3.1 结构","level":3,"id":"4.3.1_结构_0"},{"heading":"4.3.2 修改出怪","level":3,"id":"4.3.2_修改出怪_0"},{"heading":"4.3.3 加载资源","level":3,"id":"4.3.3_加载资源_0"},{"heading":"4.4 特殊出怪","level":2,"id":"4.4_特殊出怪_0"},{"heading":"4.4.1 正常出怪模式","level":3,"id":"4.4.1_正常出怪模式_0"},{"heading":"结构","level":4,"id":"结构_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"4.4.2 出怪包模式","level":3,"id":"4.4.2_出怪包模式_0"},{"heading":"结构","level":4,"id":"结构_1"},{"heading":"示例","level":4,"id":"示例_2"},{"heading":"4.4.3 生成器出怪模式","level":3,"id":"4.4.3_生成器出怪模式_0"},{"heading":"结构","level":4,"id":"结构_2"},{"heading":"示例","level":4,"id":"示例_3"},{"heading":"4.5 网格（grid）","level":2,"id":"4.5_网格（grid）_0"}],"links":[],"author":"","coverImageURL":".","fullURL":"第-2-节-修改基础/4.-关卡.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20250812125430.png","site-lib/media/pasted-image-20250828164236.png","site-lib/media/pasted-image-20250828164839.png","site-lib/media/pasted-image-20251223100412.png"],"createdTime":1759493275907,"modifiedTime":1766457701211,"sourceSize":12342,"sourcePath":"第 2 节 - 修改基础/4. 关卡.md","exportPath":"第-2-节-修改基础/4.-关卡.html","showInTree":true,"treeOrder":22,"backlinks":[],"type":"markdown"},"第-2-节-修改基础/5.-科技树与难度设定.html":{"title":"5. 科技树与难度设定","icon":"","description":"模块位置：kr/upgrades游戏设定用于存储关卡部分信息、游戏难度的差异、图鉴部分数据等模块位置：kr/game_settings难度设定用于设置不同难度下的实体模板数据模块位置：all/difficulty","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"5.1 科技树","level":2,"id":"5.1_科技树_0"},{"heading":"5.3 游戏设定","level":2,"id":"5.3_游戏设定_0"},{"heading":"5.4 难度设定","level":2,"id":"5.4_难度设定_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"第-2-节-修改基础/5.-科技树与难度设定.html","pathToRoot":"..","attachments":[],"createdTime":1766548471711,"modifiedTime":1766733677004,"sourceSize":308,"sourcePath":"第 2 节 - 修改基础/5. 科技树与难度设定.md","exportPath":"第-2-节-修改基础/5.-科技树与难度设定.html","showInTree":true,"treeOrder":23,"backlinks":[],"type":"markdown"},"第-2-节-修改基础/6.-精灵与声音.html":{"title":"6. 精灵与声音","icon":"","description":"可在屏幕上移动具有坐标，可变化的图像，称为精灵（sprite）精灵通过计算自身的时间戳（timestamp，缩写 ts）控制其显示的图像所有美术资源都存于 _assets 目录中，其中 images 子目录为图像资源。images 目录中的文件分为两种：图集与相应的图像数据name_1 = { -- 图像名称 a_name = \"abc-1.dds\",\t-- 图集名称 size = { -- 图像原始大小（未裁剪透明边） 200, -- 长度 100 -- 高度 }, trim = { -- 裁剪的透明边 10, -- 左侧裁剪的长度 20, -- 上方裁剪的长度 15, -- 右侧裁剪的长度 25 -- 下方裁剪的长度 }, a_size = { -- 图集大小 2048, -- 长度 2048 -- 高度 }, f_quad = { -- 从图集指定位置得到图像 1000, -- x 500, -- y 175, -- 长度 55 -- 高度 }, alias = { -- 别名 \"name_2\"\t-- 也可以通过name_2找到这个图像 }\n}\n以上完整含义为：\n定义一个名叫 name_1 或 name_2 的图像\n原始大小 200x100 像素\n从左边裁去 10 像素，再从右边裁去 15 像素，最后再从上下裁去 20 和 25 像素\n图集名称 abc-1.dds\n图集大小 2048x2048\n这个图像位于图集的 [1000, 500] 到 [1175, 555] 处\n示意图：\n<img alt=\"Pasted image 20251109133154.png\" src=\"site-lib/media/pasted-image-20251109133154.png\" target=\"_self\" style=\"width: 1000px; max-width: 100%;\">所有动画数据都存于 kr/data/animations 目录中.animation_a_name = { -- 动画名称 prefix = \"name\", -- 图像名称前缀（不带_x序号） to = 10, -- 动画结束时的图像序号（结束帧） from = 1 -- 动画开始时的图像序号（开始帧）\n}\n以上完整含义为：\n定义动画名称为 animation_a_name\n图像名称 name，用于与当前帧拼接（例如：动画结束帧的图像为 name_10）\n动画从图像序号 1 开始到序号 10 结束（即 name_1 到 name_10）\ntt.render.sprites[1].scale = v(2, 2)\t-- 缩放到此前的两倍\n<br>所有键见 <a data-href=\"7. 键#精灵\" href=\"总结/7.-键.html#精灵\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">7. 键 &gt; 精灵</a>U.animation_start( 实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 是否循环播放: bool, 精灵索引?: int, 强制重置时间戳: bool\n) 后续动画名将与精灵的 prefix 前缀拼接\n精灵索引默认为 1\n<br>所有动画函数见 <a data-href=\"9. 工具函数#动画\" href=\"总结/9.-工具函数.html#动画\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">9. 工具函数 &gt; 动画</a>-- 模板\ntt.render.sprites[1].prefix = \"hero_muyrn\"\ntt.melee.attacks[1] = CC(\"melee_attack\")\ntt.melee.attacks[1].hit_time = fts(9)\ntt.melee.attacks[1].animation = \"melee_attack\" -- 更新函数中\nlocal ma = this.melee.attacks[1]\n-- 实际播放动画 hero_muyrn .. melee_attack = hero_muyrn_melee_attack\nU.animation_start(this, ma.animation, nil, store.tick_ts)\n-- 播放后等待攻击前摇的时间（9帧）\nU.y_wait(store, ma.hit_time) -- 也可以使用 U.y_animation_wait(this) 等待动画播放完成\nU.y_wait(store, 等待时间: num, 中断函数?: func) -&gt; 是否被中断: bool 在指定时间内循环挂起协程\n中断函数用于提前终止暂停\nU.y_animation_wait(实体: table, 精灵索引?: int, 播放次数?: int) 精灵索引默认为 1\n播放次数默认为 1\n-- 更新函数中\nlocal ma = this.melee.attacks[1]\nU.animation_start(this, ma.animation, nil, store.tick_ts) -- 播放后等待动画播放完成\nU.y_animation_wait(this) U.y_animation_play(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数?: int, 精灵索引?: int) 是 animation_start 与 y_animation_wait 的结合\n精灵索引默认为 1\n播放次数默认值为 1\n-- 更新函数中\nlocal ma = this.melee.attacks[1]\nU.y_animation_play(this, ma.animation, nil, store.tick_ts)\n根据精灵起点与终点的参数补足中间过渡帧的动画，称为补间动画（Tween Animation）\n补间动画可当做关键帧，用于过渡，淡出淡入、平滑移动等首先增加 tween 补间动画组件，在 keys 指定关键帧，在 name 指定精灵键，在 sprite_id 指定目标精灵。默认值：\nname：alpha\nsprite_id：1\n-- 透明度\nAC(tt, \"tween\")\t-- 增加组件\ntt.tween.props[1].keys = { { 0, 255\t-- 默认不透明 }, { 1, 0\t-- 1 秒时完全透明 }\n}\ntt.tween.props[1].sprite_id = 2\t-- 补间的精灵，支持数字或表 -- 缩放\ntt.tween.props[1].name = \"scale\"\t-- 缩放\ntt.tween.props[1].keys = { { 0, v(1, 1) }, { 5, -- 从 0 秒到 5 秒缓慢放大精灵到此前的两倍 v(2, 2) }\n}\nAC(tt, \"tween\")\ntt.tween.props[1].keys = { { 0,\t-- 默认透明度 0 255 }, { 1,\t-- 1 秒时完全淡出 0 }, { 2,\t-- 2 秒时完全淡入 255 }\n}\ntt.tween.props[1].sprite_id = {\t-- 补间的精灵，可以直接用数字或表 1, 2, ...\n}\ntt.tween.remove = false -- 禁用播放后移除\ntt.tween.props[1].loop = true\t-- 循环播放\n声音资源位于 _assets/kr-desktop/sounds 目录中。其中：\ngroups 为声音组\nsettings 用于指定声音最大来源\nsounds 用于指定声音数据，声音资源位置，是否循环播放等\nfiles 声音资源\n声音函数位于 all/sound_db （缩写 S）中S:queue(声音名称: str, 声音参数?: table) 同样会分配唯一 ID\n1. gain: 声音大小: num|list{最小范围: num, 最大范围: num}\n2. seek: 从指定位置开始播放（秒）: num\n3. delay: 延迟（秒）: num\n4. chance: 播放概率: num\n5. every: 每N次请求播放一次: int\n6. ignore: 播放声音间隔: num\n7. ref_counted: 是否引用计数: bool\n8. mode: 播放模式: 按顺序播放: \"sequence\"|随机选择一个播放: \"random\"|同时播放所有: \"concurrent\" 引用计数用于管理多个相同声音实例\n-- 模板\ntt.melee.attacks[1] = CC(\"melee_attack\")\ntt.melee.attacks[1].sound = \"HeroNyruBasicAttackMelee\"\ntt.melee.attacks[1].sound_args = { delay = 1\t-- 延迟 1 秒播放\n} -- 更新函数中\nlocal ma = this.melee.attacks[1]\nS:queue(ma.sound, ma.sound_args)\nS:stop(声音名称: str)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"6.1 精灵","level":2,"id":"6.1_精灵_0"},{"heading":"6.1.1 美术资源","level":3,"id":"6.1.1_美术资源_0"},{"heading":"6.1.2 动画","level":3,"id":"6.1.2_动画_0"},{"heading":"6.1.3 常用精灵键","level":3,"id":"6.1.3_常用精灵键_0"},{"heading":"示例","level":4,"id":"示例_0"},{"heading":"6.1.4 animation_start - 播放动画","level":3,"id":"6.1.4_animation_start_-_播放动画_0"},{"heading":"示例","level":4,"id":"示例_1"},{"heading":"6.1.5 等待动画的三种方法","level":3,"id":"6.1.5_等待动画的三种方法_0"},{"heading":"1. y_wait - 协程等待","level":4,"id":"1._y_wait_-_协程等待_0"},{"heading":"2. y_animation_wait - 等待动画播放完成","level":4,"id":"2._y_animation_wait_-_等待动画播放完成_0"},{"heading":"示例","level":5,"id":"示例_2"},{"heading":"3. y_animation_play - 播放并等待动画完成","level":4,"id":"3._y_animation_play_-_播放并等待动画完成_0"},{"heading":"示例","level":5,"id":"示例_3"},{"heading":"6.2 补间动画","level":2,"id":"6.2_补间动画_0"},{"heading":"6.2.1 使用方法","level":3,"id":"6.2.1_使用方法_0"},{"heading":"6.2.2 淡出淡入","level":3,"id":"6.2.2_淡出淡入_0"},{"heading":"5.3 声音","level":2,"id":"5.3_声音_0"},{"heading":"6.3.1 声音函数","level":3,"id":"6.3.1_声音函数_0"},{"heading":"1. 将声音加入播放队列","level":4,"id":"1._将声音加入播放队列_0"},{"heading":"可选声音参数","level":5,"id":"可选声音参数_0"},{"heading":"示例","level":5,"id":"示例_4"},{"heading":"2. 停止播放声音","level":4,"id":"2._停止播放声音_0"}],"links":["总结/7.-键.html#精灵","总结/9.-工具函数.html#动画"],"author":"","coverImageURL":".","fullURL":"第-2-节-修改基础/6.-精灵与声音.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251109133154.png"],"createdTime":1759539205111,"modifiedTime":1766548566167,"sourceSize":7377,"sourcePath":"第 2 节 - 修改基础/6. 精灵与声音.md","exportPath":"第-2-节-修改基础/6.-精灵与声音.html","showInTree":true,"treeOrder":24,"backlinks":[],"type":"markdown"},"第-2-节-修改基础/7.-界面.html":{"title":"7. 界面","icon":"","description":"进入关卡后的所有界面，能力按钮、英雄肖像等，统称为关卡界面（game gui）地图界面的相关类都在 all-desktop/game_gui 中（五代为 sequels/game_gui）。防御塔菜单的数据位于 kr/data/tower_menus_data 中。防御塔菜单数据通常用于 TowerMenu 与 TowerMenuButton 类中{ {\t-- 二级的按钮 check = 用于安卓的二次确认图标: str action_arg = 动作参数: any action = 动作名称: str halo = 边框名称: str image = 图标名称: str place = 位置索引: int tt_title = 标题文本: str tt_desc = 描述文本: str sounds = 播放的声音名称: str }, {} -- 三级的按钮...\n} place 读取 kr1-desktop/data/game_gui_data 中的 tower_menu_button_places 的位置信息\n地图上的所有界面，英雄殿堂，科技等，统称为地图界面（screen map）地图界面的相关类都在 all-desktop/screen_map 中（五代为 sequels/screen_map）。注：本篇为五代特有修改 kr/data/kui_templates/group_towers_wheel 增加一个新防御塔选择槽位{ template_name = \"button_tower_ring_sel\",\t-- kui模板 class = \"TowerRingItemButton\",\t-- 续承的类 r = 0,\t-- 旋转 id = \"button_tower_ring_sel_06\",\t-- 序号 pos = v(150, 250.5),\t-- 位置 scale = v(0.9999, 0.9999)\t-- 缩放\n}\n修改 sequels/kviews_screen_map_sequels.TowerRoomView:initialize 函数增加槽位按钮...\n-- 通关第5关后将树灵增加选择的塔中，用于解锁额外选择槽位\nif #user_data.towers.selected &lt; 6 and #user_data.levels &gt; 5 then table.insert(user_data.towers.selected, \"arborean_emissary\")\t-- 填写模板名（无tower_前缀） storage:save_slot(user_data)\nend\n... -- 正式创建槽位\nself.roster_sel_items = { self:ci(\"button_tower_ring_sel_01\"), ... self:ci(\"button_tower_ring_sel_06\")\t-- 创建第六个防御塔选择槽位\n}\nself.roster_sel_positions = { V.vclone(self.roster_sel_items[1].pos), ... V.vclone(self.roster_sel_items[6].pos)\t-- 槽位位置\n}\n...\n修改 sequels/kviews_screen_map_sequels.game_gui:init 函数部分，增加防御塔建造按钮for i = 1, 6 do\t-- 5改为6 local tower_found = selected_holders[i] if tower_found then for _, holder in ipairs(tower_menus.holder[1]) do if holder.type == tower_found then holder.place = index index = index + 1\n...\n修改 kr-desktop/data/game_gui_data 的 tower_menu_button_places 键，修改防御塔建造按钮位置其每个子键索引对应相应按钮的位置tower_menu_button_places = { v(-92 * ring_scale, -146 * ring_scale),\t-- 第一个按钮位置 v(92 * ring_scale, -146 * ring_scale),\t-- 第二个按钮位置... v(-153 * ring_scale, 31 * ring_scale), v(153 * ring_scale, 31 * ring_scale), v(0 * ring_scale, 155 * ring_scale), v(-150 * ring_scale, 165 * ring_scale),\t-- 第六个按钮位置，修改这个\n} 指定切换的界面：切换界面时会调用 director:item_done_callback 回调函数指定切换的界面\n进入加载界面中转：然后在 director:update 更新函数内检查有没有要切换的界面如果有则调用 director:queue_load_item_named 函数进入加载界面中转\n调用初始化函数：最后调用相应界面的 init 初始化函数并加载需要的资源\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"7.1 关卡界面","level":2,"id":"7.1_关卡界面_0"},{"heading":"7.1.1 防御塔菜单数据","level":3,"id":"7.1.1_防御塔菜单数据_0"},{"heading":"结构","level":4,"id":"结构_0"},{"heading":"所有动作","level":4,"id":"所有动作_0"},{"heading":"7.2 地图界面","level":2,"id":"7.2_地图界面_0"},{"heading":"7.2.1 增加额外防御塔选择","level":3,"id":"7.2.1_增加额外防御塔选择_0"},{"heading":"7.3 程序如何切换界面","level":2,"id":"7.3_程序如何切换界面_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"第-2-节-修改基础/7.-界面.html","pathToRoot":"..","attachments":[],"createdTime":1760274872490,"modifiedTime":1766548717917,"sourceSize":3961,"sourcePath":"第 2 节 - 修改基础/7. 界面.md","exportPath":"第-2-节-修改基础/7.-界面.html","showInTree":true,"treeOrder":25,"backlinks":[],"type":"markdown"},"第-2-节-修改基础/8.-存档.html":{"title":"8. 存档","icon":"","description":"存档用于存储各种英雄等级，加点，完成的成就、星星以及升级、关卡完成情况等\n原版 C:\\Users\\用户\\AppData\\Roaming\\kingdom_rush_xxx 调试 C:\\Users\\用户\\AppData\\Roaming\\LOVE\\kingdom_rush_xxx 里面 也可以点击工作区文件夹内的存档位置快捷方式进行跳转\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"存档位置：","level":5,"id":"存档位置：_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"第-2-节-修改基础/8.-存档.html","pathToRoot":"..","attachments":[],"createdTime":1750666599819,"modifiedTime":1760418292270,"sourceSize":349,"sourcePath":"第 2 节 - 修改基础/8. 存档.md","exportPath":"第-2-节-修改基础/8.-存档.html","showInTree":true,"treeOrder":26,"backlinks":[],"type":"markdown"},"第-2-节-修改基础/9.-系统.html":{"title":"9. 系统","icon":"","description":"系统模块位于 all/systems 是游戏运行逻辑的关键部分。整个系统又分为多个子系统：\n关卡系统 level\n波次生成系统 wave_spawn\n防御塔升级系统 tower_upgrade\n科技树系统 game_upgrades\n实体函数系统 main_script\n血量系统 health\n精灵系统 render\n...\n而子系统的函数又分为：\n初始化 init\n入列 on_queue\n出列 on_dequeue\n插入 on_insert\n更新 on_update\n移除 on_remove\n-- 实体函数系统\nsys.main_script = {}\nsys.main_script.name = \"main_script\" -- 入列\nfunction sys.main_script:on_queue(entity, store, insertion) ...\nend -- 出列\nfunction sys.main_script:on_dequeue(entity, store, insertion) ...\nend -- 插入\nfunction sys.main_script:on_insert(entity, store) ...\nend -- 更新\nfunction sys.main_script:on_update(dt, ts, store) ...\nend -- 移除\nfunction sys.main_script:on_remove(entity, store) ...\nend\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"9.1.1 子系统","level":3,"id":"9.1.1_子系统_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"第-2-节-修改基础/9.-系统.html","pathToRoot":"..","attachments":[],"createdTime":1765780291474,"modifiedTime":1766548727941,"sourceSize":974,"sourcePath":"第 2 节 - 修改基础/9. 系统.md","exportPath":"第-2-节-修改基础/9.-系统.html","showInTree":true,"treeOrder":27,"backlinks":[],"type":"markdown"},"第-2-节-修改基础/11.-工具使用方法.html":{"title":"11. 工具使用方法","icon":"","description":"\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://wwuk.lanzouo.com/b007u3i2jg\" target=\"_self\">https://wwuk.lanzouo.com/b007u3i2jg</a>\n密码:fv51\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"第-2-节-修改基础/11.-工具使用方法.html","pathToRoot":"..","attachments":[],"createdTime":1766647335959,"modifiedTime":1766647353977,"sourceSize":55,"sourcePath":"第 2 节 - 修改基础/11. 工具使用方法.md","exportPath":"第-2-节-修改基础/11.-工具使用方法.html","showInTree":true,"treeOrder":28,"backlinks":[],"type":"markdown"},"第-2-节-修改基础/参考答案.html":{"title":"参考答案","icon":"","description":" -- 模板内：\ntt = RT(\"hero_alleria\", \"hero\")\nAC(tt, \"melee\", \"ranged\", \"timed_attacks\", \"dodge\")\n...\ntt.dodge.chance = 0.5\ntt.dodge.silent = false\ntt.melee.attacks[1].mod = \"mod_poison\" tt = RT(\"arrow_hero_alleria\", \"arrow\")\ntt.bullet.mod = \"mod_lava\"\ntt = RT(\"mod_deadly_poison\", \"mod_poison\")\ntt.modifier.duration = 5\ntt.dps.damage_inc = 1\ntt.dps.damage_min = 10\ntt.dps.damage_max = 15\ntt.dps.damage_every = 0.5\ntt.dps.damage_type = DAMAGE_TRUE\ntt.modifier.bans = { \"mod_freeze\"\n}\ntt.modifier.remove_banned = true\nfunction scripts.hero_shadow_assassin.update(this, store) local skill = this.hero.skills.shadow_assault local attack = this.timed_attacks.list[3] while true do if skill.level &gt; 0 and not attack.disabled then if store.tick_ts - attack.ts &gt;= attack.cooldown then -- 记录技能检查通过 log.debug(\"暗影突袭技能检查: 等级=%d, 冷却=%f, 剩余冷却=%f\", skill.level, attack.cooldown, store.tick_ts - attack.ts) -- 1. 索敌：找到范围内所有敌人 local enemies = U.find_enemies_in_range( store.entities, this.pos, 0, attack.radius, attack.vis_flags, attack.vis_bans ) if not enemies or #enemies == 0 then -- 没有找到目标，记录警告但不中断游戏流程 log.warning(\"暗影突袭未找到目标: 实体ID=%d, 位置=(%.1f,%.1f), 范围=%d\", this.id, this.pos.x, this.pos.y, attack.radius) return end log.debug(\"找到 %d 个潜在目标\", #enemies) -- 2. 找到血量最低的敌人 -- 首先过滤掉无效或已死亡的敌人 local valid_enemies = {} for _, enemy in ipairs(enemies) do if enemy and enemy.health and enemy.health.hp &gt; 0 then table.insert(valid_enemies, enemy) end end if #valid_enemies == 0 then log.warning(\"所有目标都已死亡或无效\") return end -- 按血量排序（升序） table.sort(valid_enemies, function(a, b) return a.health.hp &lt; b.health.hp end) local target = valid_enemies[1] log.info(\"选择目标: ID=%d, 血量=%d/%d, 位置=(%.1f,%.1f)\", target.id, target.health.hp, target.health.hp_max, target.pos.x, target.pos.y) -- 偏执级日志：记录详细选择过程 log.paranoid(\"目标选择详情:\") for i, enemy in ipairs(valid_enemies) do log.paranoid(\" [%d] ID=%d, 血量=%d, 距离=%.1f\", i, enemy.id, enemy.health.hp, V.dist(this.pos, enemy.pos)) end -- 3. 计算伤害 local damage = attack.damage_base + attack.damage_per_level * skill.level log.debug(\"伤害计算: 基础=%d, 等级加成=%d, 总伤害=%d\", attack.damage_base, attack.damage_per_level * skill.level, damage) -- 4. 创建并排队伤害实体 local d = E:create_entity(\"damage\") d.value = damage d.source_id = this.id d.target_id = target.id d.damage_type = attack.damage_type log.paranoid(\"伤害实体创建成功: 值=%d, 来源=%d, 目标=%d\", d.value, d.source_id, d.target_id) queue_damage(store, d) -- 5. 创建并排队流血效果 local mod = E:create_entity(attack.mod) mod.modifier.target_id = target.id mod.modifier.source_id = this.id queue_insert(store, mod) log.debug(\"流血效果已应用: 模板=%s, 目标=%d\", attack.mod, target.id) -- 6. 刷新技能时间戳 attack.ts = store.tick_ts log.debug(\"技能时间戳更新: %f -&gt; %f\", attack.ts - attack.cooldown, attack.ts) -- 7. 播放动画和音效 U.animation_start(this, attack.animation, nil, store.tick_ts) log.paranoid(\"播放动画: %s\", attack.animation) S:queue(attack.sound) log.paranoid(\"播放音效: %s\", attack.sound) -- 8. 记录技能释放成功 log.info(\"暗影突袭释放成功: 实体ID=%d -&gt; 目标ID=%d, 伤害=%d\", this.id, target.id, damage) -- 9. 等待动画完成（如果需要） U.y_animation_wait(this, store.tick_ts) log.paranoid(\"动画播放完成\") else -- 技能冷却中，偶尔记录调试信息 if math.random() &lt; 0.01 then -- 1%的概率记录，避免日志过多 local remaining = attack.cooldown - (store.tick_ts - attack.ts) log.paranoid(\"技能冷却中: 剩余 %.2f秒\", remaining) end end else -- 技能未解锁或已禁用 if not attack.disabled and math.random() &lt; 0.001 then log.todo(\"检查技能解锁条件: 当前等级=%d, 需要等级=1\", skill.level) end end coroutine.yield() end\nend\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<strong>本篇为所有练习的参考答案，下滑查看</strong>","level":2,"id":"**本篇为所有练习的参考答案，下滑查看**_0"},{"heading":"练习 2.1：修改英雄","level":3,"id":"练习_2.1：修改英雄_0"},{"heading":"练习 2.2 增加状态效果","level":3,"id":"练习_2.2_增加状态效果_0"},{"heading":"练习 3.2：日志与调试实践","level":3,"id":"练习_3.2：日志与调试实践_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"第-2-节-修改基础/参考答案.html","pathToRoot":"..","attachments":[],"createdTime":1765615931087,"modifiedTime":1766405187488,"sourceSize":5845,"sourcePath":"第 2 节 - 修改基础/参考答案.md","exportPath":"第-2-节-修改基础/参考答案.html","showInTree":true,"treeOrder":29,"backlinks":["第-2-节-修改基础/3.-实体函数.html"],"type":"markdown"},"第-3-节-进阶/4.-创建新关卡.html":{"title":"4. 创建新关卡","icon":"","description":" 绘图\n可以使用 AI 进行绘图 <a data-tooltip-position=\"top\" aria-label=\"https://tieba.baidu.com/p/9780582087?\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://tieba.baidu.com/p/9780582087?\" target=\"_self\">AI 链接</a> 将背景图像放入 _assets/kr-desktop/images/fullhd 内，并改名为 go_stagex_bg-1，x 为关卡编号，在保证不会与已有关卡冲突的条件下可以随便填一个\n图像分辨率推荐 1920x1080<br>\n<img alt=\"Pasted image 20250809164512.png\" src=\"site-lib/media/pasted-image-20250809164512.png\" target=\"_self\" style=\"width: 425px; max-width: 100%;\"> 然后创建对应的数据文件 go_stagex_bg.lua，x 同上，并复制以下模板 return { stagex = {\t-- x 同上 a_name = \"go_stagex_bg-1.png\",-- x 同上 size = { 1920, 1080 }, trim = { 0, 0, 0, 0 }, a_size = { 1920, 1080 }, f_quad = { 0, 0, 1920, 1080 }, alias = {} }\n}\n在 _assets/kr1-desktop/images/fullhd/screen_map 最后面增加一个表即可：stage_thumbs_000x = {\t-- x 同上，若 x 为 1 则是 0001，大于等于 10 则需要在前面加 “00” 如：0010 a_name = \"go_stagex_bg-1.png\", size = { 1920, 1080 }, trim = { 0, 0, 0, 0 }, a_size = { 342, 246 }, f_quad = { 0, 0, 342, 246 }, alias = {}\n}\n<br><img alt=\"Pasted image 20250809094636.png\" src=\"site-lib/media/pasted-image-20250809094636.png\" target=\"_self\" style=\"width: 425px; max-width: 100%;\">level_select_thumbs_thumb_stage_427_0001 = { a_name = \"room_levelselect_level_select_thumbs-427.dds\", defer = true, size = { 2016, 1064 }, trim = { 0, 0, 0, 0 }, a_size = { 2016, 1064 }, f_quad = { 0, 0, 2016, 1064 }, alias = {}\n},\n在 kr\\data\\levels 创建 levelx_data.lua 文件，x 同上，并复制以下模板，参数可以按照自己的想法填return { entities_list = { { template = \"decal_background\",\t-- 背景贴图，背景本质也是实体 pos = { x = 512, y = 384 }, [\"render.sprites[1].name\"] = \"stage27\", [\"render.sprites[1].z\"] = 1000 }, { template = \"decal_background\",\t-- 防守点旗帜，可选 pos = { x = -43.46875, y = 326.34375 }, [\"render.sprites[1].name\"] = \"blue_flag\", [\"render.sprites[1].z\"] = 1400 }, { template = \"decal_background\", pos = { x = -43.46875, y = 526.03125 }, [\"render.sprites[1].name\"] = \"blue_flag\", [\"render.sprites[1].z\"] = 1400 }, { template = \"decal_defend_point\",\t-- 防守点，必加，否则进入将会报错 [\"editor.exit_id\"] = 1, pos = { x = -44.875, y = 402.28125 } }, { template = \"editor_wave_flag\",\t-- 释放波次贴图，必加，否则无法释放波次 [\"editor.len\"] = 240, [\"editor.path_id\"] = 1, [\"editor.r\"] = 0, pos = { x = 1156.0625, y = 399.46875 } }, }, invalid_path_ranges = {}, level_mode_overrides = { { locked_towers = {}, max_upgrade_level = 5 }, { locked_towers = {}, max_upgrade_level = 5 }, { locked_towers = {}, max_upgrade_level = 5 } }, level_terrain_type = 1, locked_hero = false, max_upgrade_level = 5, nav_mesh = {}, required_sounds = {},\t-- 音效资源 required_textures = { \"go_enemies_grass\",\t-- 一些敌人资源 \"go_stagex_bg\",\t-- 加载对应关卡背景资源，x 同上 \"go_stages_blackburn\"\t-- 借用里面的防守点旗帜资源 }\n} 将 game_settings.last_level 数字加 1 在 game_settings.level_ranges 最后面增加一个关卡序号表，表内填增加的关卡序号 {x}，可以增加 list 键改为无序解锁\ngame_settings.level_ranges 表决定关卡解锁顺序，注：所有支线第一关在主线通关后会全部解锁 示例：game_settings.level_ranges = { { 1, 12\t-- 1-12 关为主线 }, -- 主线通关后解锁第 13、14、17 关支线 { 13 }, { 14, 16\t-- 第 14 关通关后解锁第 15 关，第 15 关通关后解锁第 16 关，以此类推 }, { 17, 22,\t-- 第 16 关通关后仅解锁第 22 关 list = true }, ...\n} 在 kr-desktop\\data\\map_data.level_data 最后面增加一个表：\n{ upgrades = { heroe = true,\t-- 规则：有英雄 level = 5\t-- 规则：防御塔等级 }, iron = {\t-- 钢铁规则：禁用的塔 \"archers\",\t-- 箭塔 \"barracks\"\t-- 兵营 \"mages\",\t-- 法师 \"artillery\",\t-- 炮塔 }\n}\nmap_data.level_data 表的键的下标索引决定对应的关卡的模式选择界面显示的规则<br>\n<img alt=\"Pasted image 20250809094524.png\" src=\"site-lib/media/pasted-image-20250809094524.png\" target=\"_self\" style=\"width: 190px; max-width: 100%;\">\n在 kr-desktop/data/map_points.flags 最后面增加一个入口位置表\n{ number = \"x\",\t-- 关卡编号 pos = { x = 1173,\t-- 位置 y = 102 }\n}\nmap_points.flags 表的键的下标索引决定对应关卡的入口的坐标位置将 args 启动参数的关卡编辑器取消注释，将 custom 键修改为刚刚创建的关卡编号\n运行游戏即可进入关卡编辑器点击小加号选中，拖动即可移动位置，注：需要点击 entities 选项<br>\n<img alt=\"Pasted image 20250807181638.png\" src=\"site-lib/media/pasted-image-20250807181638.png\" target=\"_self\" style=\"width: 900px; max-width: 100%;\">\n防守点规定了英雄出生位置搜索并选择样式，然后插入塔位即可\n修改位置的方法还是拖动，注：会同时插入名为 editor_rally_point 的默认集结点<br>\n<img alt=\"Pasted image 20250807183501.png\" src=\"site-lib/media/pasted-image-20250807183501.png\" target=\"_self\">\n注：若进入关卡发现塔位贴图消失就是忘记选择样式了点击 paths 选项然后创建路径，自行设定路径即可<br>\n<img alt=\"Pasted image 20250807182230.png\" src=\"site-lib/media/pasted-image-20250807182230.png\" target=\"_self\">\n注：较大的节点为起点，推荐将起点与终点设在关卡背景外\n最下面 subdivide 可以增加额外节点点击 grid 选项，选择网格类型然后画满背景即可<br>\n<img alt=\"Pasted image 20250807183059.png\" src=\"site-lib/media/pasted-image-20250807183059.png\" target=\"_self\" style=\"width: 725px; max-width: 100%;\">\n网格规定了可更改集结点单位的可移动区域路径上直接画 land，非路径一般都有 no walk 标签\nbrush size 为刷子大小点击 nav 选项然后点击塔位调整 top / left / right / bottom 即可<br>\n<img alt=\"Pasted image 20250808185126.png\" src=\"site-lib/media/pasted-image-20250808185126.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\">\nnav 规定了键盘方向键切换塔位的顺序一切完毕后点击 save 保存即可\n此时会自动创建对应关卡的路径与格子数据文件使用波次编辑器在 kr\\data\\waves 创建 levelx_waves_campaign 波次数据文件\n注：不同后缀表示对应模式的波次数据，英雄为 _heroic，钢铁为 _iron，请自行创建，若没有则全部使用战役的波次数据再次打开关卡编辑器插入 editor_wave_flag 的实体，修改位置即可<br>\n<img alt=\"Pasted image 20250808090849.png\" src=\"site-lib/media/pasted-image-20250808090849.png\" target=\"_self\">\n注：默认按钮是没有贴图的，需要找加号修改位置（加号默认在中心点偏下）\n如果有多条路径则需要增加多个波次释放按钮可以通过插入实体来创建一些动态贴图或可交互彩蛋<br>\n<img alt=\"Pasted image 20250811184142.png\" src=\"site-lib/media/pasted-image-20250811184142.png\" target=\"_self\" style=\"width: 349px; max-width: 100%;\">\n注：其他场景装饰实体自行在关卡编辑器查看，并且需要加载相应贴图与动画资源","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"创建新关卡","level":1,"id":"创建新关卡_0"},{"heading":"一、创建新关卡","level":2,"id":"一、创建新关卡_0"},{"heading":"1. 增加关卡背景","level":5,"id":"1._增加关卡背景_0"},{"heading":"2. 给选择模式的界面增加封面","level":5,"id":"2._给选择模式的界面增加封面_0"},{"heading":"4. 五代封面","level":5,"id":"4._五代封面_0"},{"heading":"5. 创建关卡数据","level":5,"id":"5._创建关卡数据_0"},{"heading":"4. 增加关卡","level":5,"id":"4._增加关卡_0"},{"heading":"二、设置塔位、路径等","level":2,"id":"二、设置塔位、路径等_0"},{"heading":"1. 进入关卡编辑器","level":5,"id":"1._进入关卡编辑器_0"},{"heading":"2. 修改防守点的旗帜与防守点位置","level":5,"id":"2._修改防守点的旗帜与防守点位置_0"},{"heading":"3. 增加塔位","level":5,"id":"3._增加塔位_0"},{"heading":"4. 增加路径","level":5,"id":"4._增加路径_0"},{"heading":"5. 画网格","level":5,"id":"5._画网格_0"},{"heading":"6. 方向键切换塔位","level":5,"id":"6._方向键切换塔位_0"},{"heading":"7. 保存","level":5,"id":"7._保存_0"},{"heading":"三、增加波次","level":2,"id":"三、增加波次_0"},{"heading":"1. 增加波次数据","level":5,"id":"1._增加波次数据_0"},{"heading":"2. 增加波次释放按钮","level":5,"id":"2._增加波次释放按钮_0"},{"heading":"四、装饰","level":2,"id":"四、装饰_0"}],"links":[],"author":"","coverImageURL":".","fullURL":"第-3-节-进阶/4.-创建新关卡.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20250809164512.png","site-lib/media/pasted-image-20250809094636.png","site-lib/media/pasted-image-20250809094524.png","site-lib/media/pasted-image-20250807181638.png","site-lib/media/pasted-image-20250807183501.png","site-lib/media/pasted-image-20250807182230.png","site-lib/media/pasted-image-20250807183059.png","site-lib/media/pasted-image-20250808185126.png","site-lib/media/pasted-image-20250808090849.png","site-lib/media/pasted-image-20250811184142.png"],"createdTime":1759493219229,"modifiedTime":1764126953367,"sourceSize":7872,"sourcePath":"第 3 节 - 进阶/4. 创建新关卡.md","exportPath":"第-3-节-进阶/4.-创建新关卡.html","showInTree":true,"treeOrder":31,"backlinks":[],"type":"markdown"},"第-3-节-进阶/4.-移植.html":{"title":"4. 移植","icon":"","description":"已前三代移植五代为例在五代目录搜索要移植的实体的模板将所有与此实体相关的模板从五代复制到前三代 game_templates 内注：这些模板可能在不同位置，务必将这些都复制过去，而不是搜索后仅复制一部分通常敌人与单位的锚点位于脚下\n<img alt=\"Pasted image 20251120103043.png\" src=\"site-lib/media/pasted-image-20251120103043.png\" target=\"_self\" style=\"width: 475px; max-width: 100%;\">\n如图锚点（红点）位置 [160, 183]\n图像大小 320x211\nX 轴相对位置：160 / 320 = 0.5\nY 轴相对位置：1 - 183 / 211 ≈ 0.133\n综上 anchor = v(0.5, 0.133) Q：为什么 Y 轴相对位置是 1 与原 Y 轴相对位置之差\nA：这是因为 love2d 坐标系原点在左上角，而图像坐标系原点在左下角，所以需要反转\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"移植防御塔","level":1,"id":"移植防御塔_0"},{"heading":"一、复制模板","level":2,"id":"一、复制模板_0"},{"heading":"1. 搜索模板","level":5,"id":"1._搜索模板_0"},{"heading":"2. 复制模板","level":5,"id":"2._复制模板_0"},{"heading":"二、复制函数","level":2,"id":"二、复制函数_0"},{"heading":"三、处理美术资源","level":2,"id":"三、处理美术资源_0"},{"heading":"四、增加到建造界面","level":2,"id":"四、增加到建造界面_0"},{"heading":"五、必要调整","level":2,"id":"五、必要调整_0"},{"heading":"移植英雄","level":1,"id":"移植英雄_0"},{"heading":"移植关卡","level":1,"id":"移植关卡_0"},{"heading":"锚点","level":3,"id":"锚点_0"},{"heading":"1. 测量得到锚点位置","level":5,"id":"1._测量得到锚点位置_0"},{"heading":"2. 计算锚点相当于图像的位置","level":5,"id":"2._计算锚点相当于图像的位置_0"},{"heading":"Q&amp;A","level":5,"id":"Q&A_0"}],"links":[],"author":"","coverImageURL":".","fullURL":"第-3-节-进阶/4.-移植.html","pathToRoot":"..","attachments":["site-lib/media/pasted-image-20251120103043.png"],"createdTime":1759540680267,"modifiedTime":1765528587673,"sourceSize":1056,"sourcePath":"第 3 节 - 进阶/4. 移植.md","exportPath":"第-3-节-进阶/4.-移植.html","showInTree":true,"treeOrder":32,"backlinks":[],"type":"markdown"},"其他/local-lua-debugger-说明翻译.html":{"title":"Local Lua Debugger 说明翻译","icon":"","description":"一个简单的 Lua 调试器，无需额外依赖。从 0.3.0 版本开始，对于使用 Sourcemap 来调试从其他语言（例如 TypescriptToLua）转译而来的代码的项目，必须在启动配置中指定 scriptFiles 选项，才能在原始源文件中使用断点。这允许在启动时（而非运行时）解析这些文件，从而显著提高性能。\n使用独立解释器或自定义可执行文件调试 Lua\n支持 Lua 5.1、5.2、5.3 版本以及 LuaJIT\n基本调试功能（单步执行、检查变量、断点等）\n条件断点\n将协程作为独立线程进行调试\n对 Source map 的基础支持（例如由 TypescriptToLua 生成的）\n要使用独立解释器调试 Lua 程序，请在用户或工作区设置中设置 lua-local.interpreter：\"lua-local.interpreter\": \"lua5.1\"或者，您也可以在 launch.json 中设置解释器和要运行的文件：{ \"configurations\": [ { \"type\": \"lua-local\", \"request\": \"launch\", \"name\": \"Debug\", \"program\": { \"lua\": \"lua5.1\", \"file\": \"main.lua\" } } ]\n}\n要使用自定义的 Lua 可执行文件进行调试，您必须在 launch.json 中设置可执行文件的名称/路径以及任何可能需要的额外参数。{ \"configurations\": [ { \"type\": \"lua-local\", \"request\": \"launch\", \"name\": \"Debug Custom Executable\", \"program\": { \"command\": \"executable\" }, \"args\": [ \"${workspaceFolder}\" ] } ]\n}\n然后您必须在您的 Lua 代码中手动启动调试器：require(\"lldebugger\").start()请注意，lldebugger 的路径将自动附加到 LUA_PATH 环境变量中，因此 Lua 能够找到它。\nLua 环境必须支持通过 stdio 或管道进行通信（Windows 上为命名管道，Linux 上为 fifo）。\n某些环境可能需要命令行选项来支持 stdio 通信（例如 Solar2D 需要 /no-console 标志）。\n在 stdio 模式下，使用 io.read 或其他需要用户输入的函数调用会导致问题。可将 program.communication 设置为 pipe 来解决此问题。\nLua 环境必须内置 debug 库，且没有其他代码尝试设置调试钩子。\n当程序正在运行时，您不能手动暂停调试。\n在 Lua 5.1 和 LuaJIT 中，当在协程内部暂停时，无法访问主线程。 为了方便起见，调试器的全局引用始终以 lldebugger 的形式存储。\n您可以通过检查环境变量 LOCAL_LUA_DEBUGGER_VSCODE 来检测调试器扩展是否已附加。这对于在自定义环境中条件性地启动调试器非常有用。\nif os.getenv(\"LOCAL_LUA_DEBUGGER_VSCODE\") == \"1\" then require(\"lldebugger\").start()\nend 某些自定义环境不会在未捕获的运行时错误时中断。要捕获运行时错误，您可以使用 lldebugger.call() 包装代码：\nlldebugger.call(function() -- 引发运行时错误的代码\nend) 某些环境不会从标准文件系统加载所需的文件。在这种情况下，您可以使用存储在 LOCAL_LUA_DEBUGGER_FILEPATH 中的文件路径手动加载调试器：\npackage.loaded[\"lldebugger\"] = assert(loadfile(os.getenv(\"LOCAL_LUA_DEBUGGER_FILEPATH\")))()\nrequire(\"lldebugger\").start()\n一个备用路径列表，用于查找 Lua 脚本。这对于像 LÖVE 这样的环境非常有用，它们使用自定义解析器来查找位于 package.config 指定路径之外的其他位置的脚本。一个 glob 模式列表，用于标识调试时在工作区中查找 Lua 脚本的位置。对于在 sourcemap 映射的文件（例如使用 TypescriptToLua 时的 'ts' 脚本）中放置断点是必需的，因为必须提前查找源文件以便解析断点。示例：scriptFiles: [\"**/*.lua\"]一个 Lua 模式列表，指定单步执行代码时要跳过的文件。示例：ignorePatterns: [\"^/usr\"]在单步执行 sourcemap 映射的代码且当前行没有可用映射时，单步进入 Lua 代码。当协程内部发生错误时中断进入调试器。\n用 coroutine.wrap 创建的协程将始终中断，无论此选项如何设置。\n在 Lua 5.1 中，中断将发生在协程被恢复的位置，并且消息将包含错误发生的实际位置。\n在设置调试钩子后，自动在首行中断。指定启动可执行文件时的工作目录。默认为项目目录。启动时传递给 Lua 脚本或自定义环境的参数列表。指定启动可执行文件时要设置的环境变量。指定扩展程序与调试器通信的方式。可能的值：\nstdio （默认）：消息嵌入在 stdin 和 stdout 中。\npipe：创建管道来传递消息（Windows 上为命名管道，Linux 上为 fifo）。如果您的环境在使用 stdio 通信时出现问题，请使用此方式。\n启用调试器的详细输出。仅在尝试识别调试器本身的问题时有用。{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Debug Love\", \"type\": \"lua-local\", \"request\": \"launch\", \"program\": { \"command\": \"love\" }, \"args\": [ \"game\" ], \"scriptRoots\": [ \"game\" ] } ]\n}\nif os.getenv(\"LOCAL_LUA_DEBUGGER_VSCODE\") == \"1\" then require(\"lldebugger\").start()\nend function love.load() ...\n请注意，在 conf.lua 中 console 必须设置为 false（默认值），否则调试器将无法与运行中的程序通信。game/conf.luafunction love.conf(t) t.console = false\nend\n请注意，即使通过 Lua 解释器使用 busted，也必须将其设置为自定义环境才能正常工作。{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Debug Busted CLI\", \"type\": \"lua-local\", \"request\": \"launch\", \"program\": { \"command\": \"busted\" }, \"args\": [ \"test/start-cli.lua\" ], \"ignorePatterns\": \"^/usr\" }, { \"name\": \"Debug Busted via Lua Interpreter\", \"type\": \"lua-local\", \"request\": \"launch\", \"program\": { \"command\": \"lua\" }, \"args\": [ \"test/start-interpreter.lua\" ], \"ignorePatterns\": \"^/usr\" } ]\n}\ntest/start-cli.luaif os.getenv(\"LOCAL_LUA_DEBUGGER_VSCODE\") == \"1\" then require(\"lldebugger\").start()\nend describe(\"a test\", function() ...\nend)\ntest/start-interpreter.lua-- 应在挂钩调试器之前引入 busted，以避免双重挂钩\nrequire(\"busted.runner\")() if os.getenv(\"LOCAL_LUA_DEBUGGER_VSCODE\") == \"1\" then require(\"lldebugger\").start()\nend describe(\"a test\", function() ...\nend)\n{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Debug\", \"type\": \"lua-local\", \"request\": \"launch\", \"program\": { \"command\": \"dmengine\" }, \"args\": [ \"./build/default/game.projectc\" ], \"scriptRoots\": [ \".\" ] // 调试器查找脚本所必需 } ]\n}\nif os.getenv(\"LOCAL_LUA_DEBUGGER_VSCODE\") == \"1\" then local lldebugger = loadfile(os.getenv(\"LOCAL_LUA_DEBUGGER_FILEPATH\"))() lldebugger.start()\nend function init(self) ...\nend\n有关为您的平台下载 dmengine 的信息可以在[这里](Information on downloading dmengine for your platform can be found here.)找到。{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Debug\", \"type\": \"lua-local\", \"request\": \"launch\", \"windows\": { \"program\": { \"command\": \"C:\\\\Program Files (x86)\\\\Corona Labs\\\\Corona\\\\Corona Simulator.exe\", }, \"args\": [ \"/no-console\", \"/debug\", \"${workspaceFolder}\\\\main.lua\" ] }, \"osx\": { \"program\": { \"command\": \"/Applications/Corona/CoronaSimulator.app/Contents/MacOS/CoronaSimulator\", }, \"args\": [ \"-no-console\"\"YES\"\"-debug\"\"1\"\"-project\"\"${workspaceFolder}/main.lua\" ] } } ]\n}\nif os.getenv(\"LOCAL_LUA_DEBUGGER_VSCODE\") == \"1\" then local lldebugger = loadfile(os.getenv(\"LOCAL_LUA_DEBUGGER_FILEPATH\"))() lldebugger.start()\nend ...\n{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Debug TSTL\", \"type\": \"lua-local\", \"request\": \"launch\", \"program\": { \"command\": \"my_custom_environment\" }, \"args\": [ ... ], \"scriptFiles\": [ \"**/*.lua\" ] // 使 ts 文件中的断点正常工作所必需 } ]\n}\nif os.getenv(\"LOCAL_LUA_DEBUGGER_VSCODE\") == \"1\" then require(\"lldebugger\").start()\nend ...\ntsconfig.json{ \"compilerOptions\": { \"sourceMap\": true, ... }, \"tstl\": { \"noResolvePaths\": [ \"lldebugger\" ] // 必需，以便 TSTL 忽略缺失的依赖项 }\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Visual Studio Code 的本地 Lua 调试器","level":2,"id":"Visual_Studio_Code_的本地_Lua_调试器_0"},{"heading":"重大变更通知","level":3,"id":"重大变更通知_0"},{"heading":"功能特性","level":3,"id":"功能特性_0"},{"heading":"使用方法","level":3,"id":"使用方法_0"},{"heading":"Lua 独立解释器","level":4,"id":"Lua_独立解释器_0"},{"heading":"自定义 Lua 环境","level":4,"id":"自定义_Lua_环境_0"},{"heading":"要求与限制","level":3,"id":"要求与限制_0"},{"heading":"使用技巧","level":3,"id":"使用技巧_0"},{"heading":"其他配置选项","level":3,"id":"其他配置选项_0"},{"heading":"<code>scriptRoots</code>","level":4,"id":"`scriptRoots`_0"},{"heading":"<code>scriptFiles</code>","level":4,"id":"`scriptFiles`_0"},{"heading":"<code>ignorePatterns</code>","level":4,"id":"`ignorePatterns`_0"},{"heading":"<code>stepUnmappedLines</code>","level":4,"id":"`stepUnmappedLines`_0"},{"heading":"<code>breakInCoroutines</code>","level":4,"id":"`breakInCoroutines`_0"},{"heading":"<code>stopOnEntry</code>","level":4,"id":"`stopOnEntry`_0"},{"heading":"<code>cwd</code>","level":4,"id":"`cwd`_0"},{"heading":"<code>args</code>","level":4,"id":"`args`_0"},{"heading":"<code>env</code>","level":4,"id":"`env`_0"},{"heading":"<code>program.communication</code>","level":4,"id":"`program.communication`_0"},{"heading":"<code>verbose</code>","level":4,"id":"`verbose`_0"},{"heading":"自定义环境示例","level":3,"id":"自定义环境示例_0"},{"heading":"LÖVE","level":4,"id":"LÖVE_0"},{"heading":"Busted","level":4,"id":"Busted_0"},{"heading":"Defold","level":4,"id":"Defold_0"},{"heading":"Solar2D / Corona","level":4,"id":"Solar2D_/_Corona_0"},{"heading":"TypescriptToLua（自定义环境）","level":4,"id":"TypescriptToLua（自定义环境）_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"其他/local-lua-debugger-说明翻译.html","pathToRoot":"..","attachments":[],"createdTime":1766718563185,"modifiedTime":1766719435980,"sourceSize":10276,"sourcePath":"其他/Local Lua Debugger 说明翻译.md","exportPath":"其他/local-lua-debugger-说明翻译.html","showInTree":true,"treeOrder":34,"backlinks":[],"type":"markdown"},"总结/5-关卡/逻辑/3.-生成怪物逻辑.html":{"title":"3. 生成怪物逻辑","icon":"","description":"调用 simulation:init 函数初始化 simulation调用 system.wave_spawn:init 函数创建波次线协程若下一波没有到来，挂起协程等待释放第一波若玩家主动释放下一波，给予玩家奖励创建新协程根据延迟等数据生成怪物","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"总结/5-关卡/逻辑/3.-生成怪物逻辑.html","pathToRoot":"../../..","attachments":[],"createdTime":1764143502944,"modifiedTime":1764144443672,"sourceSize":2300,"sourcePath":"总结/5 - 关卡/逻辑/3. 生成怪物逻辑.canvas","exportPath":"总结/5-关卡/逻辑/3.-生成怪物逻辑.html","showInTree":true,"treeOrder":38,"backlinks":[],"type":"canvas"},"总结/5-关卡/逻辑/12.-关卡逻辑.html":{"title":"12. 关卡逻辑","icon":"","description":" 调用 screen_map:start_level 函数 回调 director:item_done_callback 函数指定即将进入的界面：\n1. 将 director.next_item_name 键赋值为 \"game\" 调用 director:update 函数更新界面： 调用 director:queue_load_item_named 函数进入加载界面中转： 根据 next_item_name 键在 kr-desktop/data/director_data.item_props 的 src 决定进入的界面 进入 game 关卡界面\n加载模块 game 并存入 director.queued_item 队列内 调用 director.queued_item.init 函数（game:init）初始化关卡 调用 grid_db:load 函数加载网格数据 调用 path_db:load 函数加载路径数据 调用 wave_db:load 函数加载波次数据 若有 level:init 关卡初始化函数则调用其 若有关卡数据则调用 LU.insert_entities 创建关卡数据内的实体 若有 level.load 关卡加载函数则调用其 根据波次数据设定初始金币 根据模式设定初始生命 战役设定为 20\n英雄、钢铁设定为 1 若有 store.level.update 关卡更新函数则调用其 调用 LU.insert_hero 函数插入英雄 若当前生命小于 1 （失败）则： 将结果、关卡索引、模式、难度存入 store.game_outcome 游戏结果 将存档 last_victory 键赋值为 nil，表示未胜利 调用 store_hero_xp 函数保存英雄经验 无尽模式则将最高分数写入存档 若关卡完成、所有波次已释放、敌人全部死亡（胜利）则： 根据血量计算星星 将结果、模式、关卡索引、星星数量等存入游戏结果以及存档的 last_victory 最近胜利中 保存英雄经验 调用 game_gui:go_to_map 函数前往地图： 保存英雄经验到存档 调用 sound_db:stop_all 停止所有音效 回调 director:item_done_callback 函数指定即将进入的界面： 将 director.next_item_name 键赋值为 \"map\" 调用 director:update 函数更新界面： 调用 director:queue_load_item_named 函数进入加载界面中转： 根据 next_item_name 键在 kr-desktop/data/director_data.item_props 的 src 决定进入的界面 进入 screen_map 地图界面\n加载模块 screen_map 并存入 director.queued_item 队列内 调用 director.queued_item.init 函数（screen_map:init）重新初始化 若存档中有 last_victory 键且存档没有对应关卡模式的通关数据（存档的 levels 键），则根据关卡模式进行： 战役模式：调用 U.find_next_level_in_ranges 函数在 game_settings.level_ranges 寻找下一关 将 screen.unlock_data 解锁数据表的 show_stars_level 赋值为通关的关卡索引，表示通关的关卡旗帜上播放星星增加动画 将解锁数据表的 new_level 赋值为下一个关卡的索引： 遍历 game_settings.level_ranges 关卡范围\n若一个范围内的 list 键为 true （表示这个范围为列表）且通关的关卡索引包含在内，则： 返回范围中的下一个关卡的索引 ↑ 若通关的关卡索引等于最大范围，则： 返回下一个范围的第一个键 ↑ 若通关的关卡索引在一个范围区间内，则： 返回范围中的下一个关卡的索引 ↑ 将下一个关卡的索引存入解锁数据表的 new_level 与 unlocked_levels 中 若通关获得的星星大于此前获得的星星，则： 将解锁数据表的 star_count_before 此前星星总数赋值为通关获得的星星\n将通关获得的星星重新赋值给存档的对应关卡数据 英雄模式：将解锁数据表的 heroic_level 赋值为通关的关卡的索引 钢铁模式：将解锁数据表的 iron_level 赋值为通关的关卡的索引 调用 U.unlock_next_levels_in_ranges 函数将将要解锁的关卡存起： 若存档有主线最后一关的关卡数据则： 将所有存档内没有的支线关卡第一关存入将要解锁的关卡表 将所有存档内没有的关卡，根据关卡范围将下一关索引存入将要解锁的关卡表 同时将下一关索引存入 screen.unlock_data.new_level 加载 kr-desktop/data/map_points 模块并将对应表分别存入 screen_map.map_points.points / flags / endless_flags 调用 self:show_flags 函数（续承自父类 MapView）显示关卡旗帜： 调用 self:load_level_decos 函数加载并创建地图装饰 kr-desktop/data.map_data.map_decos 将有 trigger_level 键的装饰返回到 self.level_decos 中 根据 game_settings.last_level 设定最大关卡数 遍历存档中通关的关卡 根据 screen_map.map_points.points 表创建旗帜之间的连接点（续承自 KImageView） 创建已通关的关卡的旗帜（续承自 LevelFlagView） 根据存档内战役、英雄、钢铁通关状态为旗帜设定不同样式 创建无尽模式旗帜（续承自 EndlessLevelFlagView） 若是首次创建的旗帜则根据不同情况播放动画： 若关卡索引等于 screen.unlock_data.show_stars_level 则播放显示星星动画\n若通过钢铁模式 screen.unlock_data.iron_level 则播放通过钢铁模式的动画\n若通过英雄模式 screen.unlock_data.heroic_level 则播放通过英雄模式的动画\n显示对应关卡的地图装饰（trigger_level）\n播放连接新解锁（screen.unlock_data.new_level）的关卡的连接动画（旗帜之间的连接点）\n播放所有将要解锁的关卡表的关卡（screen.unlock_data.unlocked_levels）的插入旗帜动画 根据不同数据格式调用： tsv 则调用 wave_db:load_tsv\nlua 则调用 wave_db:load_lua 将波次数据存入 wave_db.db 调用 system.wave_spawn:init 函数： 根据模式设定关卡最大波次 无尽最大波次 store.wave_group_total 设定为 0\n非无尽根据波次数据的波次数量决定 创建波次线协程 store.wave_spawn_thread 调用 W:get_group 获得对应波次的数据 第一波则调用 game_gui.wave_notification_handler 函数显示消息 若没有主动释放第一波则循环挂起协程 若下一波没有到来（interval），没有跳过这一波则循环挂起协程 若主动释放下一波则调用 game_gui.early_wave_called_handler 函数处理释放非第一波波次 无尽模式额外增加分数\n调用对应能力的 early_wave_bonus 函数给予玩家奖励（减冷却） 调用 game_gui.next_wave_sent_handler 函数处理释放波次 隐藏释放波次按钮\n调用 game_gui.unlock_user_power_handler 函数解锁对应技能 显示消息 创建协程，延迟 delay 一定时间，返回并 spawner 调用生成敌人 协程返回到 store.waves_active 这一波敌人生成完毕后 i += 1 标志进入下一波 加载关卡路径数据并存入 path_db:paths 调用 path_db:set_start_node 与 path_db:set_end_node 函数设定起点与终点节点并存入 path_db:path_start_node 与 path_db:path_end_node 内 在驱动函数调用 system.goal_line:on_update 函数 若具有 nav_path 键的敌人到达终点（nav_path.ni &gt;= P:path_end_node）则： 将生命减去敌人的 enemy.lives_cost，并移除这个敌人 加载关卡网格数据，并存入 grid_db.grid grid_db.ox 网格中心点 x 轴\ngrid_db.oy 网格中心点 y 轴\ngrid_db.grid_w 所有网格总长度\ngrid_db.grid_h 所有网格总宽度 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"一、关卡加载逻辑","level":2,"id":"一、关卡加载逻辑_0"},{"heading":"[一] 进入关卡","level":3,"id":"[一]_进入关卡_0"},{"heading":"[二] 调用 <code>system.level:init</code> 函数进行初始化","level":3,"id":"[二]_调用_`system.levelinit`_函数进行初始化_0"},{"heading":"[三] 在驱动函数调用关卡更新函数 <code>system.level:on_update</code>","level":3,"id":"[三]_在驱动函数调用关卡更新函数_`system.levelon_update`_0"},{"heading":"二、关卡退出逻辑","level":2,"id":"二、关卡退出逻辑_0"},{"heading":"[一] 退出：","level":3,"id":"[一]_退出：_0"},{"heading":"[二] 调用 <code>screen_map:init</code> 函数初始化","level":3,"id":"[二]_调用_`screen_mapinit`_函数初始化_0"},{"heading":"[三] 向地图增加关卡入口","level":3,"id":"[三]_向地图增加关卡入口_0"},{"heading":"三、生成怪物逻辑","level":2,"id":"三、生成怪物逻辑_0"},{"heading":"[一] 调用 <code>wave_db:load</code> 函数加载波次数据","level":3,"id":"[一]_调用_`wave_dbload`_函数加载波次数据_0"},{"heading":"[二] 波次生成初始化","level":3,"id":"[二]_波次生成初始化_0"},{"heading":"四、路径加载逻辑","level":2,"id":"四、路径加载逻辑_0"},{"heading":"[一] 加载路径","level":3,"id":"[一]_加载路径_0"},{"heading":"[二] 终点更新","level":3,"id":"[二]_终点更新_0"},{"heading":"五、网格加载逻辑","level":2,"id":"五、网格加载逻辑_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/5-关卡/逻辑/12.-关卡逻辑.html","pathToRoot":"../../..","attachments":[],"createdTime":1760418682514,"modifiedTime":1760422063971,"sourceSize":8506,"sourcePath":"总结/5 - 关卡/逻辑/12. 关卡逻辑.md","exportPath":"总结/5-关卡/逻辑/12.-关卡逻辑.html","showInTree":true,"treeOrder":39,"backlinks":[],"type":"markdown"},"总结/5-关卡/逻辑/特殊出怪逻辑.html":{"title":"特殊出怪逻辑","icon":"","description":"falsetrue在关卡实体表增加 mega_spawner 实体，并指定加载的特殊出怪文件调用 scripts.mega_spawner.insert 函数加载特殊出怪文件调用 scripts.mega_spawner.update 函数将当前波次的怪物增加到生成队列取出队列根据数据实时生成敌人判断是否到达指定波次，并且没有被中断正常出怪模式遍历所有组，得到其中指定的生成器实体判断通过，加载当前波次出怪数据判断未通过重新判断解包得到数据出怪包模式生成器出怪模式筛选出具有 spawner 组件的实体根据不同模式插入队列根据延迟升序排序队列计算时间，生成敌人","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"总结/5-关卡/逻辑/特殊出怪逻辑.html","pathToRoot":"../../..","attachments":[],"createdTime":1763867332967,"modifiedTime":1764128465107,"sourceSize":6681,"sourcePath":"总结/5 - 关卡/逻辑/特殊出怪逻辑.canvas","exportPath":"总结/5-关卡/逻辑/特殊出怪逻辑.html","showInTree":true,"treeOrder":40,"backlinks":[],"type":"canvas"},"总结/6-动画/逻辑/1.-精灵插入逻辑.html":{"title":"1. 精灵插入逻辑","icon":"","description":"插入具有精灵组件的实体时调用 system.render:on_insert 函数初始化精灵帧遍历实体的所有精灵初始化相应精灵的帧，增加各种参数，位置、透明度、旋转等增加到 store.render_frames同上初始化血条帧 health_bar.frames","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"每帧调用驱动函数 <code>simulation:do_tick</code>","level":2,"id":"每帧调用驱动函数_`simulationdo_tick`_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/6-动画/逻辑/1.-精灵插入逻辑.html","pathToRoot":"../../..","attachments":[],"createdTime":1764056035591,"modifiedTime":1764127597814,"sourceSize":2541,"sourcePath":"总结/6 - 动画/逻辑/1. 精灵插入逻辑.canvas","exportPath":"总结/6-动画/逻辑/1.-精灵插入逻辑.html","showInTree":true,"treeOrder":43,"backlinks":[],"type":"canvas"},"总结/6-动画/逻辑/2.-精灵移除逻辑.html":{"title":"2. 精灵移除逻辑","icon":"","description":"将精灵帧从 store.render_frames 移除","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"每帧调用驱动函数 <code>simulation:do_tick</code>","level":2,"id":"每帧调用驱动函数_`simulationdo_tick`_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/6-动画/逻辑/2.-精灵移除逻辑.html","pathToRoot":"../../..","attachments":[],"createdTime":1764056073443,"modifiedTime":1764138876753,"sourceSize":778,"sourcePath":"总结/6 - 动画/逻辑/2. 精灵移除逻辑.canvas","exportPath":"总结/6-动画/逻辑/2.-精灵移除逻辑.html","showInTree":true,"treeOrder":44,"backlinks":[],"type":"canvas"},"总结/6-动画/逻辑/3.-精灵更新逻辑.html":{"title":"3. 精灵更新逻辑","icon":"","description":"若该精灵是动画，则跳过 animation_db:fn 通过搜索动画调用 animation_db:fni 函数得到图像名称通过时间戳与精灵的 fps 得到图像名称、计算播放次数、将要播放的帧若该精灵启用动画，则调用 animation_db:fn 通过前缀与精灵名称搜索动画默认情况，则图像名称为精灵指定的名称遍历所有具有精灵组件的实体的所有精灵，得到图像名称根据实体血量更新血条缩放、使血条帧同步血条等根据图层升序排序 store.render_frames更新并使精灵帧同步精灵调用 image_db:s 函数根据名称加载对应图像，并存入精灵帧的 ss在 game.draw_game 函数调用 render_utils.draw_frames_range 函数绘制图像","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"每帧调用驱动函数 <code>simulation:do_tick</code>","level":2,"id":"每帧调用驱动函数_`simulationdo_tick`_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/6-动画/逻辑/3.-精灵更新逻辑.html","pathToRoot":"../../..","attachments":[],"createdTime":1764056090581,"modifiedTime":1764139269163,"sourceSize":5273,"sourcePath":"总结/6 - 动画/逻辑/3. 精灵更新逻辑.canvas","exportPath":"总结/6-动画/逻辑/3.-精灵更新逻辑.html","showInTree":true,"treeOrder":45,"backlinks":[],"type":"canvas"},"总结/6-动画/逻辑/4.-补间动画更新逻辑.html":{"title":"4. 补间动画更新逻辑","icon":"","description":"调用 system.tween:on_update 函数根据关键帧进行插值计算遍历所有实体补间组件的 props获取目标精灵根据补间的 keys 对指定的精灵的键进行插值计算","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"总结/6-动画/逻辑/4.-补间动画更新逻辑.html","pathToRoot":"../../..","attachments":[],"createdTime":1764128573181,"modifiedTime":1764138433759,"sourceSize":1477,"sourcePath":"总结/6 - 动画/逻辑/4. 补间动画更新逻辑.canvas","exportPath":"总结/6-动画/逻辑/4.-补间动画更新逻辑.html","showInTree":true,"treeOrder":46,"backlinks":[],"type":"canvas"},"总结/逻辑/1.-更新逻辑.html":{"title":"1. 更新逻辑","icon":"","description":"处理实体移除更新逻辑时间 store.tick_ts + 1调用\ngame:update调用 director:update调用所有系统更新函数处理实体插入调用 simulation:update simulation:do_tick调用所有系统移除函数调用所有系统插入函数每帧调用的游戏引擎回调函数\nlove.update","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"总结/逻辑/1.-更新逻辑.html","pathToRoot":"../..","attachments":[],"createdTime":1764029623605,"modifiedTime":1765796138430,"sourceSize":4302,"sourcePath":"总结/逻辑/1. 更新逻辑.canvas","exportPath":"总结/逻辑/1.-更新逻辑.html","showInTree":true,"treeOrder":48,"backlinks":[],"type":"canvas"},"总结/逻辑/2.-实体创建逻辑.html":{"title":"2. 实体创建逻辑","icon":"","description":"调用 entity_db:create_entity 函数创建实体表返回该实体表深拷贝模板，生成独立实体表实体表具有只增不减的 ID取出队列的实体表调用插入系统传递参数：this 当前实体表、store若其中任意一个返回假则调用出列系统传递参数：this、store、true调用 simulation:insert_entity&nbsp;函数插入实体以键值对&nbsp;[ID] = 实体表&nbsp;形式插入&nbsp;store.entities 正式创建实体调用 simulation.queue_insert_entity 函数将实体表增加到待插入队列增加到 store.pending_inserts","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"每帧调用驱动函数 <code>simulation:do_tick</code>","level":2,"id":"每帧调用驱动函数_`simulationdo_tick`_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/逻辑/2.-实体创建逻辑.html","pathToRoot":"../..","attachments":[],"createdTime":1764029533316,"modifiedTime":1764056700629,"sourceSize":5338,"sourcePath":"总结/逻辑/2. 实体创建逻辑.canvas","exportPath":"总结/逻辑/2.-实体创建逻辑.html","showInTree":true,"treeOrder":49,"backlinks":[],"type":"canvas"},"总结/逻辑/3.-实体移除逻辑.html":{"title":"3. 实体移除逻辑","icon":"","description":"取出队列的实体调用&nbsp;simulation:remove_entity&nbsp;函数移除实体调用移除系统传递参数：this、store调用 simulation.queue_remove_entity 函数将实体增加到待移除队列增加到 store.pending_removals将 store.entities 对应 ID 实体表赋值为 nil 移除实体若其中任意一个移除函数返回假则调用出列系统传递参数：this、store、false","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"每帧调用驱动函数 <code>simulation:do_tick</code>","level":2,"id":"每帧调用驱动函数_`simulationdo_tick`_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/逻辑/3.-实体移除逻辑.html","pathToRoot":"../..","attachments":[],"createdTime":1764029710440,"modifiedTime":1764029754613,"sourceSize":3672,"sourcePath":"总结/逻辑/3. 实体移除逻辑.canvas","exportPath":"总结/逻辑/3.-实体移除逻辑.html","showInTree":true,"treeOrder":50,"backlinks":[],"type":"canvas"},"总结/逻辑/4.-实体更新逻辑.html":{"title":"4. 实体更新逻辑","icon":"","description":"调用 systems.main_script:on_update 函数调度协程遍历所有具有 main_script.update 更新函数的实体若实体更新函数没有协程且没有运行过，则创建更新函数的协程重启协程传递参数：当前实体、store、实体函数表的引用","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"每帧调用驱动函数 <code>simulation:do_tick</code>","level":2,"id":"每帧调用驱动函数_`simulationdo_tick`_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/逻辑/4.-实体更新逻辑.html","pathToRoot":"../..","attachments":[],"createdTime":1764029922283,"modifiedTime":1764030622642,"sourceSize":2220,"sourcePath":"总结/逻辑/4. 实体更新逻辑.canvas","exportPath":"总结/逻辑/4.-实体更新逻辑.html","showInTree":true,"treeOrder":51,"backlinks":[],"type":"canvas"},"总结/逻辑/5.-造成伤害逻辑.html":{"title":"5. 造成伤害逻辑","icon":"","description":"调用 entity_db:create_entity 创建伤害实体表调用 table.insert 函数将伤害增加到伤害队列遍历伤害队列通过 target_id 在 store.entities 得到目标实体调用 U.predict_damage 函数计算伤害大小降低实体血量，造成伤害将造成过伤害的伤害移出队列计算护甲与伤害类型的影响，不进行赘叙处理血量小于 0 死亡的敌人将此敌人标记为已死亡通过赏金给予玩家金币health.dead = true","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"每帧调用驱动函数 <code>simulation:do_tick</code>","level":2,"id":"每帧调用驱动函数_`simulationdo_tick`_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/逻辑/5.-造成伤害逻辑.html","pathToRoot":"../..","attachments":[],"createdTime":1764029786332,"modifiedTime":1764054445274,"sourceSize":4746,"sourcePath":"总结/逻辑/5. 造成伤害逻辑.canvas","exportPath":"总结/逻辑/5.-造成伤害逻辑.html","showInTree":true,"treeOrder":52,"backlinks":[],"type":"canvas"},"总结/逻辑/6.-造成效果逻辑.html":{"title":"6. 造成效果逻辑","icon":"","description":"效果实体插入时调用 systems.mod_lifecycle:on_insert 函数遍历所有具有相同目标的其他效果实体若被其中任意一个效果禁止返回真replaces_lower 为真则移除其中与当前效果名称相同的效果allows_duplicates 为真，则移除并替换其中与当前效果模板名相同的低级效果返回真resets_same 为真则更新其中效果的时间戳，返回假若当前效果 remove_banned 为真，则移除被当前效果禁止的所有效果","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"每帧调用驱动函数 <code>simulation:do_tick</code>","level":2,"id":"每帧调用驱动函数_`simulationdo_tick`_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/逻辑/6.-造成效果逻辑.html","pathToRoot":"../..","attachments":[],"createdTime":1764032325133,"modifiedTime":1765596536495,"sourceSize":3329,"sourcePath":"总结/逻辑/6. 造成效果逻辑.canvas","exportPath":"总结/逻辑/6.-造成效果逻辑.html","showInTree":true,"treeOrder":53,"backlinks":[],"type":"canvas"},"总结/逻辑/7.-近战攻击逻辑.html":{"title":"7. 近战攻击逻辑","icon":"","description":"在实体插入函数调用 U.attack_order 函数排序攻击遍历攻击表，根据以下条件排序其概率不同，释放概率低者在前概率相同，冷却时间长者在前所有条件相同，攻击表索引低者在前排序后返回到实体攻击的 order在实体更新函数调用 SU.y_soldier_melee_block_and_attacks 函数进行近战攻击调用 SU.soldier_pick_melee_target 函数寻找拦截范围内的目标调用 SU.soldier_pick_melee_attack 函数得到可用攻击根据攻击类型：单体攻击、多次攻击、范围攻击，调用对应攻击类型的函数按顺序遍历攻击的 order 表闪避反击可用优先返回其基础造成伤害，不进行赘叙可用攻击：攻击没有禁用、攻击冷却完毕、标签没有被禁用...","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"总结/逻辑/7.-近战攻击逻辑.html","pathToRoot":"../..","attachments":[],"createdTime":1764053014866,"modifiedTime":1766404192227,"sourceSize":5399,"sourcePath":"总结/逻辑/7. 近战攻击逻辑.canvas","exportPath":"总结/逻辑/7.-近战攻击逻辑.html","showInTree":true,"treeOrder":54,"backlinks":[],"type":"canvas"},"总结/逻辑/8.-远程攻击逻辑.html":{"title":"8. 远程攻击逻辑","icon":"","description":"在实体插入函数调用 U.attack_order 函数排序攻击见近战攻击逻辑，不进行赘叙在实体更新函数调用 SU.y_soldier_ranged_attacks 远程攻击函数调用 SU.soldier_pick_ranged_target_and_attack 函数寻找攻击范围内目标与得到可用攻击按顺序遍历攻击的 order 表寻找攻击范围内的目标根据攻击类型：单体攻击、多次攻击，调用对应攻击类型的函数创建子弹计算子弹飞行轨迹，抛物线（箭矢），直线追踪（魔法弹）等造成伤害与造成效果","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"总结/逻辑/8.-远程攻击逻辑.html","pathToRoot":"../..","attachments":[],"createdTime":1764053014866,"modifiedTime":1764055057171,"sourceSize":3767,"sourcePath":"总结/逻辑/8. 远程攻击逻辑.canvas","exportPath":"总结/逻辑/8.-远程攻击逻辑.html","showInTree":true,"treeOrder":55,"backlinks":[],"type":"canvas"},"总结/逻辑/9.-闪避逻辑.html":{"title":"9. 闪避逻辑","icon":"","description":"攻击者攻击时调用 SU.unit_dodges 闪避函数若目标闪避此次攻击，则将目标的 dodge.active 设为真闪避：没有被眩晕、闪避冷却完毕...进行闪避反击","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"总结/逻辑/9.-闪避逻辑.html","pathToRoot":"../..","attachments":[],"createdTime":1764055081621,"modifiedTime":1766404203443,"sourceSize":1351,"sourcePath":"总结/逻辑/9. 闪避逻辑.canvas","exportPath":"总结/逻辑/9.-闪避逻辑.html","showInTree":true,"treeOrder":56,"backlinks":[],"type":"canvas"},"总结/1.-模板名.html":{"title":"1. 模板名","icon":"","description":"\n详细请查阅 @杨叔伟大无需多言的文档：\n<a data-tooltip-position=\"top\" aria-label=\"https://www.bilibili.com/read/readlist/rl141527\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.bilibili.com/read/readlist/rl141527\" target=\"_self\">《王国保卫战》Kingdom Rush 中文百科全集</a>\n所有附属模板请自行搜索，例如 tower_barrack 兵营召唤的士兵模板所有基础塔模板名都是相同的，n 后缀为等级\ntower_archer + _n 箭塔\ntower_barrack + _n 兵营\ntower_mage + _n 法师\ntower_engineer + _n 炮塔\n所有英雄大招模板名都是：英雄模板名 + _ultimate所有关卡自带塔的塔位模板名都是：自带塔模板名 + _holder部分防御塔四级名字略有不同好的，这是根据您提供的场景单位信息整理的表格：","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"一代","level":2,"id":"一代_0"},{"heading":"[一] 防御塔","level":3,"id":"[一]_防御塔_0"},{"heading":"[二] 英雄","level":3,"id":"[二]_英雄_0"},{"heading":"[三] 科技树","level":3,"id":"[三]_科技树_0"},{"heading":"[四] 敌人","level":3,"id":"[四]_敌人_0"},{"heading":"[五] 杂项","level":3,"id":"[五]_杂项_0"},{"heading":"二代","level":2,"id":"二代_0"},{"heading":"[一] 防御塔","level":3,"id":"[一]_防御塔_1"},{"heading":"[二] 英雄","level":3,"id":"[二]_英雄_1"},{"heading":"[三] 科技树","level":3,"id":"[三]_科技树_1"},{"heading":"[四] 敌人","level":3,"id":"[四]_敌人_1"},{"heading":"[五] 杂项","level":3,"id":"[五]_杂项_1"},{"heading":"三代","level":2,"id":"三代_0"},{"heading":"[一] 防御塔","level":3,"id":"[一]_防御塔_2"},{"heading":"[二] 英雄","level":3,"id":"[二]_英雄_2"},{"heading":"[三] 科技树","level":3,"id":"[三]_科技树_2"},{"heading":"[四] 敌人","level":3,"id":"[四]_敌人_2"},{"heading":"[五] 杂项","level":3,"id":"[五]_杂项_2"},{"heading":"四代","level":2,"id":"四代_0"},{"heading":"[一] 防御塔","level":3,"id":"[一]_防御塔_3"},{"heading":"[二] 英雄","level":3,"id":"[二]_英雄_3"},{"heading":"[三] 科技树","level":3,"id":"[三]_科技树_3"},{"heading":"[四] 敌人","level":3,"id":"[四]_敌人_3"},{"heading":"[五] 杂项","level":3,"id":"[五]_杂项_3"},{"heading":"五代","level":2,"id":"五代_0"},{"heading":"[一] 防御塔","level":3,"id":"[一]_防御塔_4"},{"heading":"[二] 英雄","level":3,"id":"[二]_英雄_4"},{"heading":"[三] 科技树","level":3,"id":"[三]_科技树_4"},{"heading":"[四] 敌人","level":3,"id":"[四]_敌人_4"},{"heading":"[五] 杂项","level":3,"id":"[五]_杂项_4"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/1.-模板名.html","pathToRoot":"..","attachments":[],"createdTime":1760418154392,"modifiedTime":1766056121362,"sourceSize":111156,"sourcePath":"总结/1. 模板名.md","exportPath":"总结/1.-模板名.html","showInTree":true,"treeOrder":57,"backlinks":["第-2-节-修改基础/2.-实体与模板.html"],"type":"markdown"},"总结/2.-模板函数.html":{"title":"2. 模板函数","icon":"","description":"E:register_t(模板名: str, 续承模板名?: str) -&gt; 模板的引用: table 示例：\na = E:register_t(\"a\")\t-- 创建一个名为 “a” 的模板\na.has_a = true\na.num = 1 template = E:register_t(\"template\", \"a\")\t-- 创建一个名为 “template” 的模板，同时续承 “a” 模板\ntemplate.n = 123\n-- “template” 模板具有 “a” 模板所有键，修改对应键不影响模板 “a”\n-- 也就是 template = { n = 123, has_a = true, num = 1 }\nE:get_template(模板名: str) -&gt; 模板的引用: table 作用：返回给定的模板，该函数等价于 E.entities[模板名]\n示例：\ntemplate = E:register_t(\"template\")\ntemplate.num = 1 t = E:get_template(\"template\")\t-- 索引模板，等价于 `E.entities.template`\nt.num = 123 -- 等价于 `E.entities.template.num = 123`\n-- 此时模板 “template” 的 num 键等于 123\nE:set_template(模板名: str, 新模板: table) 作用：将对应模板赋值为新模板，该函数等价于 self.entities[模板名] = 新模板\n示例：\ntemplate = E:register_t(\"template\")\ntemplate.num = 1 new_template = { n = 123 } E:set_template(\"template\", new_template)\t-- 将 “template” 模板设为 “new_template” 表\n-- 此时 template = { n = 123 }\nE:register_c(组件: str) -&gt; 组件的引用: table 作用：创建新组件\n示例：\na = E:register_c(\"a\")\t-- 创建一个名为 “a” 的组件\nE:add_comps(模板: table, 组件名: str...) 作用：向模板增加 components 中的组件\n示例：\ncomponent = E:register_c(\"component\")\t-- 创建组件 “component”\ncomponent.num = 123\ncomponent.is_component = true template = E:register_t(\"template\")\nE:add_comps(template, \"component\") -- 增加组件 “component”\ntemplate.n = 1\n-- 此时 template = { component = { num = 123, is_component = true }, n = 1}\nE:clone_c(组件名: str) -&gt; 表: table 作用：返回深拷贝的组件\n示例：\ncomponent = E:register_c(\"component\")\t-- 创建组件 “component”\ncomponent.num = 123\ncomponent.is_component = true template = E:register_t(\"template\")\ntemplate.cc = E:clone_c(\"component\")\t-- 拷贝组件，此时 cc 就是组件 component\ntemplate.num = 1\n-- 此时 template = { cc = { num = 123, is_component = true }, num = 1 }\nE:get_component(组件名: str) -&gt; 组件的引用: table 作用：返回给定的组件，该函数等价于 E.components[组件名]\n示例：\ncomponent = E:register_c(\"component\")\t-- 创建组件 “component”\ncomponent.num = 123 c = E:get_component(\"component\")\t-- 索引组件，等价于 `E.components.component`\nc.num = 1 -- 等价于 `E.components.component.num = 1`\n-- 此时 component = { num = 1 }\nE:filter(表: table, 键: str...) -&gt; 筛选出的表: table 作用：返回一个表，表内包含在给定表内具有指定键的表\n示例：\nt = { a = { k = true }, b = { k = true }, c = { n = 2 }\n} ft = E:filter(t, \"k\")\t-- 得到 t 里面的所有具有 k 键的表\n-- 此时 ft = { a = { k = true }, b = { k = true } }，不包含 c 子表\nE:filter_templates(键: str...) -&gt; 筛选出的模板: table 作用：返回一个表，表内包含具有给定键的模板，该函数等价于 E:filter(E.entities, 键: str...)\n示例：\nenemy_templates = E:filter_templates(\"enemy\")\t-- 得到所有敌人模板 for _, e in pairs(enemy_templates) do e.enemy.gold = e.enemy.gold + 100\t-- 所有敌人赏金加 100\nend\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"[一] 创建模板","level":3,"id":"[一]_创建模板_0"},{"heading":"[二] 索引模板","level":3,"id":"[二]_索引模板_0"},{"heading":"[三] 重设模板","level":3,"id":"[三]_重设模板_0"},{"heading":"[四] 创建组件","level":3,"id":"[四]_创建组件_0"},{"heading":"[五] 添加组件","level":3,"id":"[五]_添加组件_0"},{"heading":"[六] 拷贝组件","level":3,"id":"[六]_拷贝组件_0"},{"heading":"[七] 索引组件","level":3,"id":"[七]_索引组件_0"},{"heading":"[八] 筛选具有指定键的表","level":3,"id":"[八]_筛选具有指定键的表_0"},{"heading":"[九] 筛选具有指定键的模板","level":3,"id":"[九]_筛选具有指定键的模板_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/2.-模板函数.html","pathToRoot":"..","attachments":[],"createdTime":1760418189594,"modifiedTime":1765702882136,"sourceSize":3879,"sourcePath":"总结/2. 模板函数.md","exportPath":"总结/2.-模板函数.html","showInTree":true,"treeOrder":58,"backlinks":["第-2-节-修改基础/2.-实体与模板.html"],"type":"markdown"},"总结/3.-常量.html":{"title":"3. 常量","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"位运算","level":1,"id":"位运算_0"},{"heading":"伤害类型","level":1,"id":"伤害类型_0"},{"heading":"伤害标签","level":1,"id":"伤害标签_0"},{"heading":"标签","level":1,"id":"标签_0"},{"heading":"效果类型","level":1,"id":"效果类型_0"},{"heading":"关卡模式","level":1,"id":"关卡模式_0"},{"heading":"地形","level":1,"id":"地形_0"},{"heading":"图层","level":1,"id":"图层_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/3.-常量.html","pathToRoot":"..","attachments":[],"createdTime":1760418254609,"modifiedTime":1766457651503,"sourceSize":13792,"sourcePath":"总结/3. 常量.md","exportPath":"总结/3.-常量.html","showInTree":true,"treeOrder":59,"backlinks":["第-2-节-修改基础/2.-实体与模板.html"],"type":"markdown"},"总结/4.-关卡.html":{"title":"4. 关卡","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"关卡编号","level":1,"id":"关卡编号_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/4.-关卡.html","pathToRoot":"..","attachments":[],"createdTime":1760418586205,"modifiedTime":1766455916807,"sourceSize":1393,"sourcePath":"总结/4. 关卡.md","exportPath":"总结/4.-关卡.html","showInTree":true,"treeOrder":60,"backlinks":[],"type":"markdown"},"总结/5.-路径.html":{"title":"5. 路径","icon":"","description":"P:path_width(路径: int, 子路径: int, 节点: int) -&gt; 宽度: int\nP:node_pos(路径: int, 子路径: int, 节点: int, 是否返回引用?: bool) -&gt; 节点坐标: vec2\nP:node_offset_pos(偏移量: int, 路径: int, 子路径: int, 节点: int) -&gt; 节点坐标: vec2\nP:get_start_node(路径: int) -&gt; 节点: int\nP:get_end_node(路径: int) -&gt; 节点: int\nP:get_defend_point_node(路径: int) -&gt; 节点: int\nP:nodes_from_start(路径: int, 子路径: int, 节点: int) -&gt; 节点距离: int\nP:nodes_to_goal(路径: int, 子路径: int, 节点: int) -&gt; 节点距离: int\nP:nodes_to_defend_point(路径: int, 子路径: int, 节点: int) -&gt; 节点距离: int\nP:get_visible_end_node(路径: int) -&gt; 节点: int\nP:get_visible_start_node(路径: int) -&gt; 节点: int\nP:point_within_distance(x, y, 距离: num) -&gt; 是否存在: bool\nP:nearest_nodes( x, y, 路径?: list{ 路径: int... }, 子路径?: list{ 子路径: int... }, 是否仅有效节点: bool, 节点标签: int, 过滤函数?: func, 步长: int\n) -&gt; 节点列表: list{list{ 路径: int, 子路径: int, 节点: int, 距离: num }...} 返回一个根据距离排序的节点列表\n不指定路径将会在所有路径查找节点\n子路径默认值 { 1 }\nP:path_terrain_types(路径: int) -&gt; 地形: int\nP:path_terrain_props(路径: int) -&gt; 地形属性: int\nP:is_path_active(路径: int) -&gt; 是否启用: bool\nP:activate_path(路径: int)\nP:deactivate_path(路径: int)\nP:add_invalid_range(路径: int, 最小范围: int, 最大范围: int, 标签: int)\nP:remove_invalid_range(路径: int, 最小范围: int, 最大范围: int)\nP:is_node_valid(路径: int, 节点: int, 节点标签: int) -&gt; 是否有效: bool\nP:get_valid_nodes(路径: int, 节点标签: int) -&gt; 有效节点列表: list{ 节点: int... }\nP:valid_node_nearby(x, y, 路径宽度乘数: num, 节点标签: int) -&gt; 是否存在: bool\nP:get_random_position( 边距: int | list{ 前边距: int, 后边距: int }, 地形: int, 节点标签: int, 边距是否从防守点开始计算: bool\n) -&gt; 节点坐标: vec2, 路径: int, 子路径: int, 节点: int\nP:get_next_pi(路径: int) -&gt; 连接的下一路径: int\nP:get_connected_paths(路径: int) -&gt; 连接路径列表: list{ 路径: int... }\nP:get_all_valid_pos( x, y, 最小距离: num, 最大距离: num, 地形: int, 过滤函数: func, 标签: int, 子路径: list{ 子路径: int }\n) -&gt; 有效节点列表: list{ 节点: int... }\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"路径函数","level":1,"id":"路径函数_0"},{"heading":"[一] 获取路径宽度","level":3,"id":"[一]_获取路径宽度_0"},{"heading":"[二] 获取节点坐标","level":3,"id":"[二]_获取节点坐标_0"},{"heading":"[三] 获取偏移后节点坐标","level":3,"id":"[三]_获取偏移后节点坐标_0"},{"heading":"[四] 获取起点节点","level":3,"id":"[四]_获取起点节点_0"},{"heading":"[五] 获取终点节点","level":3,"id":"[五]_获取终点节点_0"},{"heading":"[六] 获取防守点节点","level":3,"id":"[六]_获取防守点节点_0"},{"heading":"[七] 获取节点到起点距离","level":3,"id":"[七]_获取节点到起点距离_0"},{"heading":"[八] 获取节点到终点距离","level":3,"id":"[八]_获取节点到终点距离_0"},{"heading":"[九] 获取节点到防守点距离","level":3,"id":"[九]_获取节点到防守点距离_0"},{"heading":"[十] 获取可见终点节点","level":3,"id":"[十]_获取可见终点节点_0"},{"heading":"[十一] 返回可见起点节点","level":3,"id":"[十一]_返回可见起点节点_0"},{"heading":"[十二] 判断一定距离是否存在节点","level":3,"id":"[十二]_判断一定距离是否存在节点_0"},{"heading":"[十三] 返回附近所有节点","level":3,"id":"[十三]_返回附近所有节点_0"},{"heading":"[十四] 返回地形","level":3,"id":"[十四]_返回地形_0"},{"heading":"[十五] 返回地形属性","level":3,"id":"[十五]_返回地形属性_0"},{"heading":"[十六] 判断路径是否启用","level":3,"id":"[十六]_判断路径是否启用_0"},{"heading":"[十七] 启用路径","level":3,"id":"[十七]_启用路径_0"},{"heading":"[十八] 禁用路径","level":3,"id":"[十八]_禁用路径_0"},{"heading":"[十九] 增加无效节点范围","level":3,"id":"[十九]_增加无效节点范围_0"},{"heading":"[二十] 移除无效节点范围","level":3,"id":"[二十]_移除无效节点范围_0"},{"heading":"[二十一] 判断节点是否有效","level":3,"id":"[二十一]_判断节点是否有效_0"},{"heading":"[二十二] 返回所有有效节点","level":3,"id":"[二十二]_返回所有有效节点_0"},{"heading":"[二十三] 判断附近是否存在有效节点","level":3,"id":"[二十三]_判断附近是否存在有效节点_0"},{"heading":"[二十四] 返回随机节点信息","level":3,"id":"[二十四]_返回随机节点信息_0"},{"heading":"[二十五] 返回连接的下一路径","level":3,"id":"[二十五]_返回连接的下一路径_0"},{"heading":"[二十六] 返回所有连接的路径","level":3,"id":"[二十六]_返回所有连接的路径_0"},{"heading":"[二十七] 返回所有有效节点","level":3,"id":"[二十七]_返回所有有效节点_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/5.-路径.html","pathToRoot":"..","attachments":[],"createdTime":1766455895468,"modifiedTime":1766459112430,"sourceSize":3783,"sourcePath":"总结/5. 路径.md","exportPath":"总结/5.-路径.html","showInTree":true,"treeOrder":61,"backlinks":[],"type":"markdown"},"总结/6.-网格.html":{"title":"6. 网格","icon":"","description":"GR:get_coords(x, y) -&gt; 网格x坐标: int, 网格y坐标: int\nGR:cell_type(x, y) -&gt; 地形: int, 网格x坐标: int, 网格y坐标: int\nGR:cell_is(x, y, 地形: int) -&gt; 是否包含: bool\nGR:cell_is_only(x, y, 地形: int) -&gt; 是否仅包含: bool\nGR:set_cell_type(x, y, 地形: int) -&gt; 地形: int\nGR:set_cell(网格x坐标: int, 网格y坐标: int, 地形: int)\nGR:get_cell(网格x坐标: int, 网格y坐标: int) -&gt; 地形: int\nGR:cell_pos(网格x坐标: int, 网格y坐标: int) -&gt; x, y 返回单元格中心位置\nGR:set_grid_size(新长度: int, 新高度: int) 保持原有数据居中，新增单元格填充默认值 0\nGR:set_grid_offset(x, y)\nGR:print_cell(地形: int) -&gt; 字符串: str\nGR:find_waypoints(起点: vec2, 备用起点?: vec2, 终点: vec2, 有效地形: int, 是否不读取缓存: bool) -&gt; 点位: list{vec2...}\nGR:find_line_waypoints(起点: vec2, 终点: vec2, 有效地形: int)\n-&gt; 点位: list{vec2...}, 网格坐标: list{vec2...}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"网格函数","level":1,"id":"网格函数_0"},{"heading":"[一] 世界坐标转换网格坐标","level":3,"id":"[一]_世界坐标转换网格坐标_0"},{"heading":"[二] 获取世界坐标的地形类型与网格坐标","level":3,"id":"[二]_获取世界坐标的地形类型与网格坐标_0"},{"heading":"[三] 判断单元格是否包含指定类型","level":3,"id":"[三]_判断单元格是否包含指定类型_0"},{"heading":"[四] 判断单元格是否仅包含给定类型","level":3,"id":"[四]_判断单元格是否仅包含给定类型_0"},{"heading":"[五] 设定世界坐标的地形类型","level":3,"id":"[五]_设定世界坐标的地形类型_0"},{"heading":"[六] 设定网格坐标的地形类型","level":3,"id":"[六]_设定网格坐标的地形类型_0"},{"heading":"[七] 获取网格坐标的地形类型","level":3,"id":"[七]_获取网格坐标的地形类型_0"},{"heading":"[八] 将网格坐标转换为世界坐标","level":3,"id":"[八]_将网格坐标转换为世界坐标_0"},{"heading":"[九] 设定网格尺寸","level":3,"id":"[九]_设定网格尺寸_0"},{"heading":"[十] 设定网格原点偏移量","level":3,"id":"[十]_设定网格原点偏移量_0"},{"heading":"[十一] 地形类型转换为可读字符串","level":3,"id":"[十一]_地形类型转换为可读字符串_0"},{"heading":"[十二] A* 算法寻路","level":3,"id":"[十二]_A\\*_算法寻路_0"},{"heading":"[十三] Bresenham 算法寻路","level":3,"id":"[十三]_Bresenham_算法寻路_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/6.-网格.html","pathToRoot":"..","attachments":[],"createdTime":1766455874868,"modifiedTime":1766457736577,"sourceSize":1701,"sourcePath":"总结/6. 网格.md","exportPath":"总结/6.-网格.html","showInTree":true,"treeOrder":62,"backlinks":[],"type":"markdown"},"总结/6.-字符串.html":{"title":"6. 字符串","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"转义符","level":3,"id":"转义符_0"},{"heading":"模式匹配修饰符","level":2,"id":"模式匹配修饰符_0"},{"heading":"大写形式（补集）","level":3,"id":"大写形式（补集）_0"},{"heading":"特殊字符","level":3,"id":"特殊字符_0"},{"heading":"重复修饰符","level":3,"id":"重复修饰符_0"},{"heading":"字符集语法","level":3,"id":"字符集语法_0"},{"heading":"特殊模式项","level":3,"id":"特殊模式项_0"},{"heading":"格式化修饰符","level":2,"id":"格式化修饰符_0"},{"heading":"操作函数","level":2,"id":"操作函数_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/6.-字符串.html","pathToRoot":"..","attachments":[],"createdTime":1765074028824,"modifiedTime":1765285313876,"sourceSize":10784,"sourcePath":"总结/6. 字符串.md","exportPath":"总结/6.-字符串.html","showInTree":true,"treeOrder":63,"backlinks":["第-1-节-语法/8.-字符串.html"],"type":"markdown"},"总结/7.-键.html":{"title":"7. 键","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"精灵","level":1,"id":"精灵_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/7.-键.html","pathToRoot":"..","attachments":[],"createdTime":1764029307672,"modifiedTime":1765972795478,"sourceSize":2421,"sourcePath":"总结/7. 键.md","exportPath":"总结/7.-键.html","showInTree":true,"treeOrder":64,"backlinks":["第-2-节-修改基础/6.-精灵与声音.html"],"type":"markdown"},"总结/8.-表.html":{"title":"8. 表","icon":"","description":"table.keys(表: table) -&gt; 包含表中所有键的列表: list\ntable.keyforobject(表: table, 键值: any) -&gt; 键: any\ntable.contains(表: table, 键值: any) -&gt; 是否包含键值: bool\ntable.clone(表: table) -&gt; 浅拷贝的表: table\ntable.deepclone(表: table) -&gt; 深拷贝的表: table\ntable.merge(表1: table, 表2: table, 是否创建新表合并: bool) -&gt; 浅合并后的表: table 如果不创建新表合并将会修改表 1\ntable.deepmerge(表1: table, 表2: table, 是否合并到新表?: bool) -&gt; 深合并后的表: table 如果不创建新表合并将会修改表 1\ntable.append(表1: table, 表2: table, 是否合并到新表?: bool) -&gt; 合并后的列表: list\ntable.reverse(表: table, 是否深度反转?: bool) -&gt; 反转后的列表: list\ntable.count(表: table, 过滤函数?: func) -&gt; 统计到的数量: int 为过滤函数传递迭代到的：键: any, 键值: any\ntable.find(表: table, 元素键值: any|过滤函数: func) -&gt; 键: any 为过滤函数传递迭代到的：键: any, 键值: any\ntable.filter(表: table, 过滤函数: func) -&gt; 过滤后的列表: list 为过滤函数传递迭代到的：键: any, 键值: any\ntable.map(表: table, 映射函数: func) -&gt; 转换后表: table 为映射函数传递迭代到的：键: any, 键值: any\n映射函数返回值：键: any, 键值: any\n映射函数返回单个值将会被序列化\n映射函数返回两个值将会保留键值映射\ntable.reduce(表: table, 归约函数: func) -&gt; 结果: any 为归约函数传递迭代到的：键值: any\n示例：\n-- 求和\nlocal numbers = { 10, 20, 30, 40 } local sum = table.reduce(numbers, function(element, accumulator) return element + accumulator\nend) print(\"求和结果:\", sum) -- 100\ntable.maxv(表: table) -&gt; 键: any, 键值: any\ntable.minv(表: table) -&gt; 键: any, 键值: any\ntable.slice(表: table, 起始索引: int, 结束索引: int) -&gt; 结果: list\ntable.removeobject(表: table, 键值: any)\ntable.random(表: table) -&gt; 元素的值: any, 元素索引: int\ntable.random_order(表: table) -&gt; 获取到的元素列表: list\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"[一] 获取所有键","level":3,"id":"[一]_获取所有键_0"},{"heading":"[二] 根据键值获取键","level":3,"id":"[二]_根据键值获取键_0"},{"heading":"[三] 检查是否包含指定元素","level":3,"id":"[三]_检查是否包含指定元素_0"},{"heading":"[四] 浅拷贝表","level":3,"id":"[四]_浅拷贝表_0"},{"heading":"[五] 深拷贝表","level":3,"id":"[五]_深拷贝表_0"},{"heading":"[六] 浅合并表","level":3,"id":"[六]_浅合并表_0"},{"heading":"[七] 深合并表","level":3,"id":"[七]_深合并表_0"},{"heading":"[八] 列表合并","level":3,"id":"[八]_列表合并_0"},{"heading":"[九] 反转列表","level":3,"id":"[九]_反转列表_0"},{"heading":"[十] 统计元素数量","level":3,"id":"[十]_统计元素数量_0"},{"heading":"[十一] 查找指定元素","level":3,"id":"[十一]_查找指定元素_0"},{"heading":"[十二] 过滤元素","level":3,"id":"[十二]_过滤元素_0"},{"heading":"[十三] 映射转换","level":3,"id":"[十三]_映射转换_0"},{"heading":"[十四] 归约元素","level":3,"id":"[十四]_归约元素_0"},{"heading":"[十五] 获取最大元素","level":3,"id":"[十五]_获取最大元素_0"},{"heading":"[十六] 获取最小元素","level":3,"id":"[十六]_获取最小元素_0"},{"heading":"[十七] 列表切片","level":3,"id":"[十七]_列表切片_0"},{"heading":"[十八] 根据键值移除元素","level":3,"id":"[十八]_根据键值移除元素_0"},{"heading":"[十九] 随机获取列表单个元素","level":3,"id":"[十九]_随机获取列表单个元素_0"},{"heading":"[二十] 随机获取列表元素","level":3,"id":"[二十]_随机获取列表元素_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/8.-表.html","pathToRoot":"..","attachments":[],"createdTime":1765680702732,"modifiedTime":1765763849879,"sourceSize":2940,"sourcePath":"总结/8. 表.md","exportPath":"总结/8.-表.html","showInTree":true,"treeOrder":65,"backlinks":[],"type":"markdown"},"总结/9.-工具函数.html":{"title":"9. 工具函数","icon":"","description":"U.find_enemies_in_range( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func\n) -&gt; 范围内所有敌人: list 实体列表通常为 store.entities\n为过滤函数传递：实体、原点\n过滤函数用于筛选目标，返回假的目标将会被筛选\nU.find_foremost_enemy( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 预判时间: num, 标签: int, 禁止标签: int, 过滤函数?: func, 禁用最小半径的标签: int\n) -&gt; 首个敌人: table, 范围内所有敌人: list{敌人: table...}, 预判位置: vec2 禁用最小半径的标签：拥有此标签的目标不受搜索最小半径限制\nU.find_nearest_enemy( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func\n) -&gt; 最近敌人: table, 范围内所有敌人: list{敌人: table...}\nU.find_random_enemy( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func\n) -&gt; 随机敌人: table\nU.find_soldiers_in_range( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func\n) -&gt; 范围内所有士兵: list{士兵: table...}\nU.find_nearest_soldier( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func\n) -&gt; 最近士兵: table\nU.find_targets_in_range( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func\n) -&gt; 范围内所有目标: list{目标: table...} 目标包含敌人与士兵\nU.find_first_target( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func\n) -&gt; 首个目标: table\nU.find_random_target( 实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func\n) -&gt; 随机目标: table\nU.find_towers_in_range( 实体列表: list, 原点: vec2, 攻击: table, 过滤函数?: func\n) -&gt; 范围内所有防御塔: list\nU.find_enemies_in_paths( 实体列表: list, 原点: vec2, 最小节点距离: int, 最大节点距离: int, 最大距离: num, 标签: int, 禁止标签: int, 是否仅上游: bool, 过滤函数?: func\n) -&gt; 排序后的敌人列表: list{{敌人: table, 节点: int}...} 返回根据到终点距离排序的列表\n是否仅上游: 指定是否只筛选位于当前节点上游或下游的敌人\nU.find_paths_with_enemies(实体列表: list, 标签: int, 禁止标签: int, 过滤函数?: func) -&gt; 所有路径列表: list\nU.find_entity_at_pos(实体列表: list, x: num, y: num, 过滤函数?: func) -&gt; 实体: table\nU.get_modifiers(store, 实体: table, 效果表: table) -&gt; 拥有的效果实体: table 若不传递效果表则返回所有拥有的效果实体\nU.has_modifiers(store, 实体: table, 效果模板名: str) -&gt; 是否拥有: bool, 找到的效果实体: table 若不传递效果模板名称则返回所有效果\nU.has_modifier_in_list(store, 实体: table, 效果表: table) -&gt; 是否拥有: bool\nU.has_modifier_types(store, 实体: table, 效果类型: int...) -&gt; 是否拥有: bool, 所有找到的效果实体: table\nU.get_blocker(store, 被拦截者: table) -&gt; 拦截者: table\nU.get_blocked(store, 拦截者: table) -&gt; 被拦截者: table\nU.blocker_rank(store, 拦截者: table) -&gt; 索引: int\nU.is_blocked_valid(store, 拦截者: table) -&gt; 是否可被拦截: bool\nU.unblock_all(store, 被拦截者: table)\nU.unblock_target(store, 拦截者: table)\nU.block_enemy(store, 拦截者: table, 被拦截者: table)\nU.replace_blocker(store, 原拦截者: table, 新拦截者: table)\nU.cleanup_blockers(store, 被拦截者: table)\nU.y_wait(store, 等待时间: num, 中断函数?: func) -&gt; 是否被中断: bool 在指定时间内循环挂起协程\n中断函数用于提前终止暂停\nU.animation_start( 实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 是否循环播放: bool, 精灵索引?: int, 强制重置时间戳: bool\n) 不指定精灵索引将会使所有精灵播放动画\nU.animation_finished(实体: table, 精灵索引?: int, 播放次数?: int) -&gt; 是否完成: bool 精灵索引默认为 1\n播放次数默认为 1\n循环动画将根据播放完成次数判断\nU.y_animation_wait(实体: table, 精灵索引?: int, 播放次数?: int) 精灵索引默认为 1\n播放次数默认为 1\n若动画没有完成则循环挂起函数，直到动画播放完成\n循环动画将根据播放完成次数判断\nU.y_animation_play(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数?: int, 精灵索引?: int) 是 animation_start 与 y_animation_wait 的结合\n精灵索引默认为 1\n播放次数默认值为 1\nU.animation_start_group(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 是否循环: bool, 组名: str)\nU.animation_finished_group(实体: table, 组名: str, 播放次数?: int) -&gt; 是否完成: bool 播放次数默认值为 1\nU.y_animation_wait_group(实体: table, 组名: str, 播放次数?: int) 播放次数默认值为 1\nU.y_animation_play_group(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数?: int, 组: int) 是 animation_start_group 与 y_animation_wait_group 的结合\n播放次数默认值为 1\nU.animation_name_for_angle( 实体: table, 组名: str, 角度: num, 精灵索引?: int\n) -&gt; 动画名: str, 是否水平翻转: bool, 象限索引: int 精灵索引默认值为 1\n在精灵的 angles 键中选择动画\nU.animation_name_facing_point( 实体: table, 组名: str, 目标点: vec2, 精灵索引?: int, 偏移: vec2, 是否使用路径: bool\n) -&gt; 动画名: str, 是否水平翻转: bool, 象限索引: int 精灵索引默认为 1\n在精灵的 angles 键中选择动画\nU.get_animation_ts(实体: table, 组: int) -&gt; 时间戳: num\nU.sprites_hide(实体: table, 起始索引: int, 结束索引: int, 是否计数: bool) 计数存入精灵 hidden_count 键\nU.sprites_show(实体: table, 起始索引: int, 结束索引: int, 是否计数: bool)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"索敌","level":1,"id":"索敌_0"},{"heading":"[一] 搜索范围内所有敌人","level":3,"id":"[一]_搜索范围内所有敌人_0"},{"heading":"[二] 搜索首个敌人","level":3,"id":"[二]_搜索首个敌人_0"},{"heading":"[三] 搜索最近敌人","level":3,"id":"[三]_搜索最近敌人_0"},{"heading":"[四] 搜索随机敌人","level":3,"id":"[四]_搜索随机敌人_0"},{"heading":"[五] 搜索范围内所有士兵","level":3,"id":"[五]_搜索范围内所有士兵_0"},{"heading":"[六] 搜索最近士兵","level":3,"id":"[六]_搜索最近士兵_0"},{"heading":"[七] 搜索范围内所有目标","level":3,"id":"[七]_搜索范围内所有目标_0"},{"heading":"[八] 搜索首个目标","level":3,"id":"[八]_搜索首个目标_0"},{"heading":"[九] 搜索随机目标","level":3,"id":"[九]_搜索随机目标_0"},{"heading":"[十] 搜索范围内所有防御塔","level":3,"id":"[十]_搜索范围内所有防御塔_0"},{"heading":"[十一] 搜索路径上的敌人","level":3,"id":"[十一]_搜索路径上的敌人_0"},{"heading":"[十二] 搜索有敌人的路径","level":3,"id":"[十二]_搜索有敌人的路径_0"},{"heading":"[十三] 搜索坐标处的实体","level":3,"id":"[十三]_搜索坐标处的实体_0"},{"heading":"状态效果","level":1,"id":"状态效果_0"},{"heading":"[一] 获取实体指定效果","level":3,"id":"[一]_获取实体指定效果_0"},{"heading":"[二] 判断是否拥有单个效果","level":3,"id":"[二]_判断是否拥有单个效果_0"},{"heading":"[三] 判断是否拥有表中效果","level":3,"id":"[三]_判断是否拥有表中效果_0"},{"heading":"[四] 判断是否拥有给定效果类型的效果","level":3,"id":"[四]_判断是否拥有给定效果类型的效果_0"},{"heading":"拦截","level":1,"id":"拦截_0"},{"heading":"[一] 获取拦截者","level":3,"id":"[一]_获取拦截者_0"},{"heading":"[二] 获取被拦截者","level":3,"id":"[二]_获取被拦截者_0"},{"heading":"[三] 获取被拦截者中拦截者的索引","level":3,"id":"[三]_获取被拦截者中拦截者的索引_0"},{"heading":"[四] 判断是否可被拦截","level":3,"id":"[四]_判断是否可被拦截_0"},{"heading":"[五] 解除所有被拦截者的拦截者","level":3,"id":"[五]_解除所有被拦截者的拦截者_0"},{"heading":"[六] 解除拦截者的拦截","level":3,"id":"[六]_解除拦截者的拦截_0"},{"heading":"[七] 拦截","level":3,"id":"[七]_拦截_0"},{"heading":"[八] 替换拦截者","level":3,"id":"[八]_替换拦截者_0"},{"heading":"[九] 清除无效拦截","level":3,"id":"[九]_清除无效拦截_0"},{"heading":"动画","level":1,"id":"动画_0"},{"heading":"[一] 协程等待","level":3,"id":"[一]_协程等待_0"},{"heading":"[二] 播放动画","level":3,"id":"[二]_播放动画_0"},{"heading":"[三] 判断动画播放完成","level":3,"id":"[三]_判断动画播放完成_0"},{"heading":"[四] 等待动画播放完成","level":3,"id":"[四]_等待动画播放完成_0"},{"heading":"[五] 播放并等待动画","level":3,"id":"[五]_播放并等待动画_0"},{"heading":"[六] 播放动画组","level":3,"id":"[六]_播放动画组_0"},{"heading":"[七] 判断动画组播放完成","level":3,"id":"[七]_判断动画组播放完成_0"},{"heading":"[八] 等待动画组播放完成","level":3,"id":"[八]_等待动画组播放完成_0"},{"heading":"[九] 播放并等待动画组播放完成","level":3,"id":"[九]_播放并等待动画组播放完成_0"},{"heading":"[十] 根据角度确定动画名称与翻转状态","level":3,"id":"[十]_根据角度确定动画名称与翻转状态_0"},{"heading":"[十一] 根据朝向目标点的角度确定动画","level":3,"id":"[十一]_根据朝向目标点的角度确定动画_0"},{"heading":"[十二] 获取动画时间戳","level":3,"id":"[十二]_获取动画时间戳_0"},{"heading":"[十三] 隐藏指定范围的精灵","level":3,"id":"[十三]_隐藏指定范围的精灵_0"},{"heading":"[十四] 显示指定范围的精灵","level":3,"id":"[十四]_显示指定范围的精灵_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/9.-工具函数.html","pathToRoot":"..","attachments":[],"createdTime":1760418452838,"modifiedTime":1766459040569,"sourceSize":8381,"sourcePath":"总结/9. 工具函数.md","exportPath":"总结/9.-工具函数.html","showInTree":true,"treeOrder":66,"backlinks":["第-2-节-修改基础/3.-实体函数.html","第-2-节-修改基础/6.-精灵与声音.html"],"type":"markdown"},"总结/10.-脚本函数.html":{"title":"10. 脚本函数","icon":"","description":"SU.can_range_soldier(store, 当前实体: table, 被攻击士兵: table) -&gt; 是否可以攻击: bool 作用：判断是否可以远程攻击士兵\n判断条件： 是否站桩远程攻击或远程攻击冷却完毕\n当前实体没有死亡\n当前实体没有被眩晕\n被攻击士兵没有死亡\n标签没有被禁止\n在最小攻击范围外\n在最大攻击范围内\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"士兵","level":1,"id":"士兵_0"},{"heading":"敌人","level":1,"id":"敌人_0"},{"heading":"[一] 判断是否可以远程攻击士兵","level":3,"id":"[一]_判断是否可以远程攻击士兵_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/10.-脚本函数.html","pathToRoot":"..","attachments":[],"createdTime":1763193306912,"modifiedTime":1765855598038,"sourceSize":474,"sourcePath":"总结/10. 脚本函数.md","exportPath":"总结/10.-脚本函数.html","showInTree":true,"treeOrder":67,"backlinks":[],"type":"markdown"},"总结/11.-其他函数.html":{"title":"11. 其他函数","icon":"","description":"storage:load_slot(存档索引?: int, 是否强制重新加载文件?: bool)\nstorage:save_slot(保存的表: table, 存档索引?: int)\n保存前必须要先读取存档\n因为这个函数会将存档直接完全替换为保存的表，所以刚开始必须先读取存档，否则存档会丢失此前保存的内容，仅有保存的内容示例：slot = storage:load_slot()\t-- slot 接收存档的表，如果你要修改存档必须首先加载存档 slot.heroes.status.hero_gerald.xp = 2333\t-- 将爵士的经验设置为 2333 点 storage:save_slot(slot) -- 保存到存档里\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"存档函数","level":1,"id":"存档函数_0"},{"heading":"[一] 读取存档","level":3,"id":"[一]_读取存档_0"},{"heading":"[二] 保存存档","level":3,"id":"[二]_保存存档_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/11.-其他函数.html","pathToRoot":"..","attachments":[],"createdTime":1760418275686,"modifiedTime":1765855835127,"sourceSize":685,"sourcePath":"总结/11. 其他函数.md","exportPath":"总结/11.-其他函数.html","showInTree":true,"treeOrder":68,"backlinks":[],"type":"markdown"},"总结/12.-库.html":{"title":"12. 库","icon":"","description":"log:new(打印的日志前缀: str, 日志等级?: int) -&gt; 日志实例: table 推荐在 args 修改全局日志等级\n[22841.0227] image_db.DEBUG preload_atlas() - load atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000 [22841.0227] 为时间信息\nimage_db 为前缀\nDEBUG 为等级，调试五级\npreload_atlas 调用的函数\nload atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000 信息\nlog.paranoid(信息: str, 用于格式化的参数: any...)\nlog.debug(信息: str, 用于格式化的参数: any...)\nlog.todo(信息: str, 用于格式化的参数: any...)\nlog.info(信息: str, 用于格式化的参数: any...)\nlog.warning(信息: str, 用于格式化的参数: any...)\nlog.error(信息: str, 用于格式化的参数: any...)\nlog.assert(条件: bool, 信息: str, 用于格式化的参数: any...)\nlog.traceall(信息?: str)\nlog.traceall(显示的调用栈深度: int)\nmacros.pi = 3.1415926535898 -- 圆周率 π\nmacros.twopi = 6.2831853071796 -- 2π\nmacros.pi_2 = 1.5707963267949 -- π/2\nmacros.pi_4 = 0.78539816339745 -- π/4\nmacros.unroll(角度: num) -&gt; 归一化后的角度: num 将任意弧度角归一化到 [0, 2π] 范围内\nmacros.unroll_deg(角度: num) -&gt; 归一化后的角度: num 将任意角度制角度归一化到 [0, 360] 范围内\nmacros.signed_unroll(角度: num) -&gt; 归一化后的角度: num 使用 macros.fmod 进行归一化，保持符号信息\nmacros.signed_unroll_deg(角度: num) -&gt; 归一化后的角度: num 使用 math.fmod 进行角度制归一化，保持符号信息\nmacros.short_angle(起始角: num, 目标角: num) -&gt; 最短角度差: num 计算从 起始角 到 目标角 的最短弧度差，结果在 [-π, π] 范围内\nmacros.short_angle_deg(起始角: num, 目标角: num) -&gt; 最短角度差: num 计算从 起始角 到 目标角 的最短角度差，结果在 [-180, 180] 范围内\nmacros.clamp_signed(最小值: num, 最大值: num, 数值: num) -&gt; 限制后的值: num 将数值限制在指定范围内（要求最小值 ≤ 最大值）\nmacros.clamp(边界1: num, 边界2: num, 数值: num) -&gt; 限制后的值: num 使用 macros.clamp_signed 将数值限制在指定范围内，自动处理边界顺序\nmacros.zmod(值: num, 模数: num) -&gt; 取模结果: num 返回 ((值 - 1) % 模数) + 1，常用于数组索引循环\nmacros.round(数值: num) -&gt; 取整结果: num 返回 math.floor(数值 + 0.5) 的四舍五入结果\nmacros.sign(数值: num) -&gt; 符号: num 返回数值的符号：负数为 -1，非负数为 1\nmacros.rand_sign(正号概率?: num) -&gt; 符号: num 返回随机符号：-1 或 1。正号概率 默认为 0.5，表示返回 1 的概率\nmacros.deg2rad(角度: num) -&gt; 弧度: num\nmacros.rad2deg(弧度: num) -&gt; 角度: num\nV.v(x, y) -&gt; 向量: vec2\nV.vv(值: num) -&gt; 向量: vec2\nV.vclone(向量: vec2) -&gt; 深拷贝的向量: vec2\nV.veq(向量1: vec2, 向量2: vec2) -&gt; 是否相等: bool\nV.v2c(向量: vec2) -&gt; x: int, y: int\nV.vsnap(向量: vec2) -&gt; 取整后的向量: vec2\nV.csnap(x, y) -&gt; x: int, y: int\nV.r(x, y, 长: num, 高: h) -&gt; 矩形: rect\nV.rclone(矩形: rect) -&gt; 深拷贝的矩形: rect\nV.is_inside(点位: vec2, 矩形: rect) -&gt; 是否在矩形内: bool 包含边界\nV.overlap(矩形: rect, 矩形: rect) -&gt; 是否重叠: bool 包括边缘接触\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"日志库","level":1,"id":"日志库_0"},{"heading":"[一] 创建新日志实例","level":3,"id":"[一]_创建新日志实例_0"},{"heading":"[二] 打印 6 级完整信息","level":3,"id":"[二]_打印_6_级完整信息_0"},{"heading":"[三] 打印 5 级调试信息","level":3,"id":"[三]_打印_5_级调试信息_0"},{"heading":"[四] 打印 4 级待办信息","level":3,"id":"[四]_打印_4_级待办信息_0"},{"heading":"[五] 打印 3 级常规信息","level":3,"id":"[五]_打印_3_级常规信息_0"},{"heading":"[六] 打印 2 级警告信息","level":3,"id":"[六]_打印_2_级警告信息_0"},{"heading":"[七] 打印 1 级错误信息","level":3,"id":"[七]_打印_1_级错误信息_0"},{"heading":"[八] 断言检查","level":3,"id":"[八]_断言检查_0"},{"heading":"[九] 调用栈跟踪","level":4,"id":"[九]_调用栈跟踪_0"},{"heading":"[十] 完整的堆栈跟踪","level":4,"id":"[十]_完整的堆栈跟踪_0"},{"heading":"macros 宏指令库","level":1,"id":"macros_宏指令库_0"},{"heading":"[一] 常量","level":3,"id":"[一]_常量_0"},{"heading":"[二] 弧度角归一化","level":3,"id":"[二]_弧度角归一化_0"},{"heading":"[三] 角度制归一化","level":3,"id":"[三]_角度制归一化_0"},{"heading":"[四] 带符号弧度角归一化","level":3,"id":"[四]_带符号弧度角归一化_0"},{"heading":"[五] 带符号角度制归一化","level":4,"id":"[五]_带符号角度制归一化_0"},{"heading":"[六] 计算最短弧度差","level":3,"id":"[六]_计算最短弧度差_0"},{"heading":"[七] 计算最短角度制差","level":3,"id":"[七]_计算最短角度制差_0"},{"heading":"[八] 有符号范围限制","level":3,"id":"[八]_有符号范围限制_0"},{"heading":"[九] 通用范围限制","level":3,"id":"[九]_通用范围限制_0"},{"heading":"[十] 循环取模","level":3,"id":"[十]_循环取模_0"},{"heading":"[十一] 四舍五入","level":3,"id":"[十一]_四舍五入_0"},{"heading":"[十二] 符号函数","level":3,"id":"[十二]_符号函数_0"},{"heading":"[十三] 随机符号","level":3,"id":"[十三]_随机符号_0"},{"heading":"[十四] 角度转弧度","level":3,"id":"[十四]_角度转弧度_0"},{"heading":"[十五] 弧度转角度","level":3,"id":"[十五]_弧度转角度_0"},{"heading":"vector 向量库","level":1,"id":"vector_向量库_0"},{"heading":"[一] 创建向量","level":3,"id":"[一]_创建向量_0"},{"heading":"[二] 创建对角线向量","level":3,"id":"[二]_创建对角线向量_0"},{"heading":"[三] 深拷贝向量","level":3,"id":"[三]_深拷贝向量_0"},{"heading":"[四] 判断向量相等","level":3,"id":"[四]_判断向量相等_0"},{"heading":"[五] 向量分量取整（向上舍入）","level":3,"id":"[五]_向量分量取整（向上舍入）_0"},{"heading":"[六] 向量取整（创建新向量）","level":3,"id":"[六]_向量取整（创建新向量）_0"},{"heading":"[七] 坐标分量取整（向上舍入）","level":3,"id":"[七]_坐标分量取整（向上舍入）_0"},{"heading":"[八] 创建矩形","level":3,"id":"[八]_创建矩形_0"},{"heading":"[九] 深拷贝矩形","level":3,"id":"[九]_深拷贝矩形_0"},{"heading":"[十] 点是否在矩形内","level":3,"id":"[十]_点是否在矩形内_0"},{"heading":"[十一] 判断矩形是否重叠","level":3,"id":"[十一]_判断矩形是否重叠_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/12.-库.html","pathToRoot":"..","attachments":[],"createdTime":1765963915655,"modifiedTime":1766395244003,"sourceSize":4981,"sourcePath":"总结/12. 库.md","exportPath":"总结/12.-库.html","showInTree":true,"treeOrder":69,"backlinks":["第-2-节-修改基础/3.-实体函数.html"],"type":"markdown"},"总结/13.-类.html":{"title":"13. 类","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"关卡界面","level":1,"id":"关卡界面_0"},{"heading":"地图界面","level":1,"id":"地图界面_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"总结/13.-类.html","pathToRoot":"..","attachments":[],"createdTime":1764029384732,"modifiedTime":1766285531210,"sourceSize":1300,"sourcePath":"总结/13. 类.md","exportPath":"总结/13.-类.html","showInTree":true,"treeOrder":70,"backlinks":[],"type":"markdown"},"index.html":{"title":"index","icon":"","description":"最近更新：2025 年 12 月 26 日\n相关链接：\n<a data-tooltip-position=\"top\" aria-label=\"https://github.com/MC123ACD/KR_modCourse\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/MC123ACD/KR_modCourse\" target=\"_self\">本文档 Github 仓库</a><br>\n<a data-tooltip-position=\"top\" aria-label=\"https://kingdomrush.huijiwiki.com/p/1\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://kingdomrush.huijiwiki.com/p/1\" target=\"_self\">中文维基</a><br>\n<a data-tooltip-position=\"top\" aria-label=\"https://www.bilibili.com/read/readlist/rl141527\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.bilibili.com/read/readlist/rl141527\" target=\"_self\">中文百科全集</a><br>\n<a data-tooltip-position=\"top\" aria-label=\"https://www.bilibili.com/video/BV1yTBeBFEsi/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.bilibili.com/video/BV1yTBeBFEsi/\" target=\"_self\">王国保卫战1235代修改教程</a>\n本文档适用于电脑版的一、二、三、五代，请注意版本（安卓版部分可用）\n由于本人正处于学习阶段，所以错误在所难免，欢迎提出意见、提 request。由于五代过于臃肿，初学者推荐使用一代修改本文档具有少量练习，如有疑问建议先问 AI 再看答案，答案问题也可以问 AI。\n国内免费 AI 链接：<br>\n<a data-tooltip-position=\"top\" aria-label=\"https://chat.deepseek.com/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://chat.deepseek.com/\" target=\"_self\">DeepSeek</a><br>\n<a data-tooltip-position=\"top\" aria-label=\"https://www.doubao.com/chat/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.doubao.com/chat/\" target=\"_self\">豆包</a>\n问问题需要向 AI 提供信息：编程语言，目标，问题，具体代码 问题：Lua 我想检查表里面有没有元素应该怎么写 AI： 使用 next 函数 if not next(表) then\nif #表 == 0 then（只对数组部分有效） 问题：我试了第一种，现在想检查表格是否有某个键，怎么写 AI： 使用 if 表.键 then\n或者使用 if 表[\"键\"] then 本文档使用伪代码类型注解：\n该文档仅限学习交流，禁止用于商业用途，除商业用途之外可随意分发\n请购买正版游戏后再进行修改。若修改盗版出现任何问题，均与作者以及文档无关\n本文档可能具有编写错误导致的误导性内容请仔细甄别\n本文档部分内容由其他文章二次修改而成，且均与作者取得授权\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"导言","level":1,"id":"导言_0"},{"heading":"如何问 AI","level":1,"id":"如何问_AI_0"},{"heading":"示例","level":3,"id":"示例_0"},{"heading":"类型注解","level":1,"id":"类型注解_0"},{"heading":"免责声明","level":1,"id":"免责声明_0"}],"links":[],"author":"","coverImageURL":".","fullURL":"index.html","pathToRoot":".","attachments":["site-lib/media/pasted-image-20250803100142.png","site-lib/media/pasted-image-20250803100333.png"],"createdTime":1749969216293,"modifiedTime":1766750815863,"sourceSize":3209,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":71,"backlinks":[],"type":"markdown"},"readme.html":{"title":"README","icon":"","description":"文档地址：\nmc123acd.github.io/KR_modCourseHTML文件在另一个分支，主分支用来放 Markdown 源文件第三个分支为整合包 使用 Git 克隆本仓库的 MD 源文件的分支 使用 Obsidian 打开克隆的仓库 <a data-tooltip-position=\"top\" aria-label=\"https://thoughts.teambition.com/share/62a131711a6baa00416a79d3#title=Obsidian_%E5%AE%89%E8%A3%85%E5%8C%85\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://thoughts.teambition.com/share/62a131711a6baa00416a79d3#title=Obsidian_%E5%AE%89%E8%A3%85%E5%8C%85\" target=\"_self\">下载链接</a> 虽然仓库自带 MD 转化 HTML 插件，但是还是推荐编辑完毕后仅提交 MD 源文件\n<br>\n图像必须为 png，并且需要压缩，请将图像放到 site-lib/media 内 <a data-tooltip-position=\"top\" aria-label=\"https://www.iloveimg.com/zh-cn/compress-image\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.iloveimg.com/zh-cn/compress-image\" target=\"_self\">在线压缩图像</a> 格式统一 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"如何编辑 ：","level":1,"id":"如何编辑_：_0"},{"heading":"编辑规范","level":2,"id":"编辑规范_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"readme.html","pathToRoot":".","attachments":[],"createdTime":1756780171078,"modifiedTime":1764126953366,"sourceSize":676,"sourcePath":"README.md","exportPath":"readme.html","showInTree":true,"treeOrder":72,"backlinks":[],"type":"markdown"}},"fileInfo":{"第-1-节-语法/0.-配置环境.html":{"createdTime":1765023457061,"modifiedTime":1766647323566,"sourceSize":2038,"sourcePath":"第 1 节 - 语法/0. 配置环境.md","exportPath":"第-1-节-语法/0.-配置环境.html","showInTree":true,"treeOrder":1,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/1.-lua-介绍.html":{"createdTime":1765019901432,"modifiedTime":1765936010616,"sourceSize":5265,"sourcePath":"第 1 节 - 语法/1. Lua 介绍.md","exportPath":"第-1-节-语法/1.-lua-介绍.html","showInTree":true,"treeOrder":2,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/2.-基础语法规则.html":{"createdTime":1765021472737,"modifiedTime":1766727564386,"sourceSize":8653,"sourcePath":"第 1 节 - 语法/2. 基础语法规则.md","exportPath":"第-1-节-语法/2.-基础语法规则.html","showInTree":true,"treeOrder":3,"backlinks":["第-1-节-语法/14.-luajit.html","第-1-节-语法/5.-控制结构.html"],"type":"markdown","data":null},"第-1-节-语法/3.-变量与数据类型.html":{"createdTime":1765072758647,"modifiedTime":1765936029553,"sourceSize":9526,"sourcePath":"第 1 节 - 语法/3. 变量与数据类型.md","exportPath":"第-1-节-语法/3.-变量与数据类型.html","showInTree":true,"treeOrder":4,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/4.-运算符.html":{"createdTime":1765076428774,"modifiedTime":1766712895124,"sourceSize":7917,"sourcePath":"第 1 节 - 语法/4. 运算符.md","exportPath":"第-1-节-语法/4.-运算符.html","showInTree":true,"treeOrder":5,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/5.-控制结构.html":{"createdTime":1765088947239,"modifiedTime":1766713040993,"sourceSize":24087,"sourcePath":"第 1 节 - 语法/5. 控制结构.md","exportPath":"第-1-节-语法/5.-控制结构.html","showInTree":true,"treeOrder":6,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/6.-函数.html":{"createdTime":1765108025706,"modifiedTime":1765936070640,"sourceSize":27532,"sourcePath":"第 1 节 - 语法/6. 函数.md","exportPath":"第-1-节-语法/6.-函数.html","showInTree":true,"treeOrder":7,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/7.-表.html":{"createdTime":1765173921839,"modifiedTime":1765936076523,"sourceSize":34415,"sourcePath":"第 1 节 - 语法/7. 表.md","exportPath":"第-1-节-语法/7.-表.html","showInTree":true,"treeOrder":8,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/8.-字符串.html":{"createdTime":1765186221153,"modifiedTime":1766659248275,"sourceSize":36335,"sourcePath":"第 1 节 - 语法/8. 字符串.md","exportPath":"第-1-节-语法/8.-字符串.html","showInTree":true,"treeOrder":9,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/9.-模块.html":{"createdTime":1765270771743,"modifiedTime":1766650016822,"sourceSize":31761,"sourcePath":"第 1 节 - 语法/9. 模块.md","exportPath":"第-1-节-语法/9.-模块.html","showInTree":true,"treeOrder":10,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/10.-调试与错误处理.html":{"createdTime":1765335739434,"modifiedTime":1766744878665,"sourceSize":63901,"sourcePath":"第 1 节 - 语法/10. 调试与错误处理.md","exportPath":"第-1-节-语法/10.-调试与错误处理.html","showInTree":true,"treeOrder":11,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/11.-迭代器与泛型for.html":{"createdTime":1765335828615,"modifiedTime":1765936106060,"sourceSize":44075,"sourcePath":"第 1 节 - 语法/11. 迭代器与泛型for.md","exportPath":"第-1-节-语法/11.-迭代器与泛型for.html","showInTree":true,"treeOrder":12,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/12.-协程.html":{"createdTime":1765609117143,"modifiedTime":1766546428697,"sourceSize":17270,"sourcePath":"第 1 节 - 语法/12. 协程.md","exportPath":"第-1-节-语法/12.-协程.html","showInTree":true,"treeOrder":13,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/13.-元表.html":{"createdTime":1766488904769,"modifiedTime":1766548775792,"sourceSize":21641,"sourcePath":"第 1 节 - 语法/13. 元表.md","exportPath":"第-1-节-语法/13.-元表.html","showInTree":true,"treeOrder":14,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/14.-luajit.html":{"createdTime":1765335834818,"modifiedTime":1766749999612,"sourceSize":23357,"sourcePath":"第 1 节 - 语法/14. LuaJIT.md","exportPath":"第-1-节-语法/14.-luajit.html","showInTree":true,"treeOrder":15,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/15.-love-2d.html":{"createdTime":1765502579627,"modifiedTime":1766484568767,"sourceSize":1202,"sourcePath":"第 1 节 - 语法/15. Love 2D.md","exportPath":"第-1-节-语法/15.-love-2d.html","showInTree":true,"treeOrder":16,"backlinks":[],"type":"markdown","data":null},"第-1-节-语法/参考答案.html":{"createdTime":1765071806510,"modifiedTime":1766727418333,"sourceSize":40329,"sourcePath":"第 1 节 - 语法/参考答案.md","exportPath":"第-1-节-语法/参考答案.html","showInTree":true,"treeOrder":17,"backlinks":["第-1-节-语法/10.-调试与错误处理.html","第-1-节-语法/11.-迭代器与泛型for.html","第-1-节-语法/12.-协程.html","第-1-节-语法/2.-基础语法规则.html","第-1-节-语法/3.-变量与数据类型.html","第-1-节-语法/4.-运算符.html","第-1-节-语法/5.-控制结构.html","第-1-节-语法/6.-函数.html","第-1-节-语法/7.-表.html","第-1-节-语法/8.-字符串.html","第-1-节-语法/9.-模块.html"],"type":"markdown","data":null},"第-2-节-修改基础/1.-介绍.html":{"createdTime":1765592137526,"modifiedTime":1766732416195,"sourceSize":7314,"sourcePath":"第 2 节 - 修改基础/1. 介绍.md","exportPath":"第-2-节-修改基础/1.-介绍.html","showInTree":true,"treeOrder":19,"backlinks":[],"type":"markdown","data":null},"第-2-节-修改基础/2.-实体与模板.html":{"createdTime":1759492568939,"modifiedTime":1766393165723,"sourceSize":23783,"sourcePath":"第 2 节 - 修改基础/2. 实体与模板.md","exportPath":"第-2-节-修改基础/2.-实体与模板.html","showInTree":true,"treeOrder":20,"backlinks":[],"type":"markdown","data":null},"第-2-节-修改基础/3.-实体函数.html":{"createdTime":1759492803499,"modifiedTime":1766647086920,"sourceSize":34237,"sourcePath":"第 2 节 - 修改基础/3. 实体函数.md","exportPath":"第-2-节-修改基础/3.-实体函数.html","showInTree":true,"treeOrder":21,"backlinks":["第-2-节-修改基础/3.-实体函数.html"],"type":"markdown","data":null},"第-2-节-修改基础/4.-关卡.html":{"createdTime":1759493275907,"modifiedTime":1766457701211,"sourceSize":12342,"sourcePath":"第 2 节 - 修改基础/4. 关卡.md","exportPath":"第-2-节-修改基础/4.-关卡.html","showInTree":true,"treeOrder":22,"backlinks":[],"type":"markdown","data":null},"第-2-节-修改基础/5.-科技树与难度设定.html":{"createdTime":1766548471711,"modifiedTime":1766733677004,"sourceSize":308,"sourcePath":"第 2 节 - 修改基础/5. 科技树与难度设定.md","exportPath":"第-2-节-修改基础/5.-科技树与难度设定.html","showInTree":true,"treeOrder":23,"backlinks":[],"type":"markdown","data":null},"第-2-节-修改基础/6.-精灵与声音.html":{"createdTime":1759539205111,"modifiedTime":1766548566167,"sourceSize":7377,"sourcePath":"第 2 节 - 修改基础/6. 精灵与声音.md","exportPath":"第-2-节-修改基础/6.-精灵与声音.html","showInTree":true,"treeOrder":24,"backlinks":[],"type":"markdown","data":null},"第-2-节-修改基础/7.-界面.html":{"createdTime":1760274872490,"modifiedTime":1766548717917,"sourceSize":3961,"sourcePath":"第 2 节 - 修改基础/7. 界面.md","exportPath":"第-2-节-修改基础/7.-界面.html","showInTree":true,"treeOrder":25,"backlinks":[],"type":"markdown","data":null},"第-2-节-修改基础/8.-存档.html":{"createdTime":1750666599819,"modifiedTime":1760418292270,"sourceSize":349,"sourcePath":"第 2 节 - 修改基础/8. 存档.md","exportPath":"第-2-节-修改基础/8.-存档.html","showInTree":true,"treeOrder":26,"backlinks":[],"type":"markdown","data":null},"第-2-节-修改基础/9.-系统.html":{"createdTime":1765780291474,"modifiedTime":1766548727941,"sourceSize":974,"sourcePath":"第 2 节 - 修改基础/9. 系统.md","exportPath":"第-2-节-修改基础/9.-系统.html","showInTree":true,"treeOrder":27,"backlinks":[],"type":"markdown","data":null},"第-2-节-修改基础/11.-工具使用方法.html":{"createdTime":1766647335959,"modifiedTime":1766647353977,"sourceSize":55,"sourcePath":"第 2 节 - 修改基础/11. 工具使用方法.md","exportPath":"第-2-节-修改基础/11.-工具使用方法.html","showInTree":true,"treeOrder":28,"backlinks":[],"type":"markdown","data":null},"第-2-节-修改基础/参考答案.html":{"createdTime":1765615931087,"modifiedTime":1766405187488,"sourceSize":5845,"sourcePath":"第 2 节 - 修改基础/参考答案.md","exportPath":"第-2-节-修改基础/参考答案.html","showInTree":true,"treeOrder":29,"backlinks":["第-2-节-修改基础/3.-实体函数.html"],"type":"markdown","data":null},"第-3-节-进阶/4.-创建新关卡.html":{"createdTime":1759493219229,"modifiedTime":1764126953367,"sourceSize":7872,"sourcePath":"第 3 节 - 进阶/4. 创建新关卡.md","exportPath":"第-3-节-进阶/4.-创建新关卡.html","showInTree":true,"treeOrder":31,"backlinks":[],"type":"markdown","data":null},"第-3-节-进阶/4.-移植.html":{"createdTime":1759540680267,"modifiedTime":1765528587673,"sourceSize":1056,"sourcePath":"第 3 节 - 进阶/4. 移植.md","exportPath":"第-3-节-进阶/4.-移植.html","showInTree":true,"treeOrder":32,"backlinks":[],"type":"markdown","data":null},"其他/local-lua-debugger-说明翻译.html":{"createdTime":1766718563185,"modifiedTime":1766719435980,"sourceSize":10276,"sourcePath":"其他/Local Lua Debugger 说明翻译.md","exportPath":"其他/local-lua-debugger-说明翻译.html","showInTree":true,"treeOrder":34,"backlinks":[],"type":"markdown","data":null},"总结/5-关卡/逻辑/3.-生成怪物逻辑.html":{"createdTime":1764143502944,"modifiedTime":1764144443672,"sourceSize":2300,"sourcePath":"总结/5 - 关卡/逻辑/3. 生成怪物逻辑.canvas","exportPath":"总结/5-关卡/逻辑/3.-生成怪物逻辑.html","showInTree":true,"treeOrder":38,"backlinks":[],"type":"canvas","data":null},"总结/5-关卡/逻辑/12.-关卡逻辑.html":{"createdTime":1760418682514,"modifiedTime":1760422063971,"sourceSize":8506,"sourcePath":"总结/5 - 关卡/逻辑/12. 关卡逻辑.md","exportPath":"总结/5-关卡/逻辑/12.-关卡逻辑.html","showInTree":true,"treeOrder":39,"backlinks":[],"type":"markdown","data":null},"总结/5-关卡/逻辑/特殊出怪逻辑.html":{"createdTime":1763867332967,"modifiedTime":1764128465107,"sourceSize":6681,"sourcePath":"总结/5 - 关卡/逻辑/特殊出怪逻辑.canvas","exportPath":"总结/5-关卡/逻辑/特殊出怪逻辑.html","showInTree":true,"treeOrder":40,"backlinks":[],"type":"canvas","data":null},"总结/6-动画/逻辑/1.-精灵插入逻辑.html":{"createdTime":1764056035591,"modifiedTime":1764127597814,"sourceSize":2541,"sourcePath":"总结/6 - 动画/逻辑/1. 精灵插入逻辑.canvas","exportPath":"总结/6-动画/逻辑/1.-精灵插入逻辑.html","showInTree":true,"treeOrder":43,"backlinks":[],"type":"canvas","data":null},"总结/6-动画/逻辑/2.-精灵移除逻辑.html":{"createdTime":1764056073443,"modifiedTime":1764138876753,"sourceSize":778,"sourcePath":"总结/6 - 动画/逻辑/2. 精灵移除逻辑.canvas","exportPath":"总结/6-动画/逻辑/2.-精灵移除逻辑.html","showInTree":true,"treeOrder":44,"backlinks":[],"type":"canvas","data":null},"总结/6-动画/逻辑/3.-精灵更新逻辑.html":{"createdTime":1764056090581,"modifiedTime":1764139269163,"sourceSize":5273,"sourcePath":"总结/6 - 动画/逻辑/3. 精灵更新逻辑.canvas","exportPath":"总结/6-动画/逻辑/3.-精灵更新逻辑.html","showInTree":true,"treeOrder":45,"backlinks":[],"type":"canvas","data":null},"总结/6-动画/逻辑/4.-补间动画更新逻辑.html":{"createdTime":1764128573181,"modifiedTime":1764138433759,"sourceSize":1477,"sourcePath":"总结/6 - 动画/逻辑/4. 补间动画更新逻辑.canvas","exportPath":"总结/6-动画/逻辑/4.-补间动画更新逻辑.html","showInTree":true,"treeOrder":46,"backlinks":[],"type":"canvas","data":null},"总结/逻辑/1.-更新逻辑.html":{"createdTime":1764029623605,"modifiedTime":1765796138430,"sourceSize":4302,"sourcePath":"总结/逻辑/1. 更新逻辑.canvas","exportPath":"总结/逻辑/1.-更新逻辑.html","showInTree":true,"treeOrder":48,"backlinks":[],"type":"canvas","data":null},"总结/逻辑/2.-实体创建逻辑.html":{"createdTime":1764029533316,"modifiedTime":1764056700629,"sourceSize":5338,"sourcePath":"总结/逻辑/2. 实体创建逻辑.canvas","exportPath":"总结/逻辑/2.-实体创建逻辑.html","showInTree":true,"treeOrder":49,"backlinks":[],"type":"canvas","data":null},"总结/逻辑/3.-实体移除逻辑.html":{"createdTime":1764029710440,"modifiedTime":1764029754613,"sourceSize":3672,"sourcePath":"总结/逻辑/3. 实体移除逻辑.canvas","exportPath":"总结/逻辑/3.-实体移除逻辑.html","showInTree":true,"treeOrder":50,"backlinks":[],"type":"canvas","data":null},"总结/逻辑/4.-实体更新逻辑.html":{"createdTime":1764029922283,"modifiedTime":1764030622642,"sourceSize":2220,"sourcePath":"总结/逻辑/4. 实体更新逻辑.canvas","exportPath":"总结/逻辑/4.-实体更新逻辑.html","showInTree":true,"treeOrder":51,"backlinks":[],"type":"canvas","data":null},"总结/逻辑/5.-造成伤害逻辑.html":{"createdTime":1764029786332,"modifiedTime":1764054445274,"sourceSize":4746,"sourcePath":"总结/逻辑/5. 造成伤害逻辑.canvas","exportPath":"总结/逻辑/5.-造成伤害逻辑.html","showInTree":true,"treeOrder":52,"backlinks":[],"type":"canvas","data":null},"总结/逻辑/6.-造成效果逻辑.html":{"createdTime":1764032325133,"modifiedTime":1765596536495,"sourceSize":3329,"sourcePath":"总结/逻辑/6. 造成效果逻辑.canvas","exportPath":"总结/逻辑/6.-造成效果逻辑.html","showInTree":true,"treeOrder":53,"backlinks":[],"type":"canvas","data":null},"总结/逻辑/7.-近战攻击逻辑.html":{"createdTime":1764053014866,"modifiedTime":1766404192227,"sourceSize":5399,"sourcePath":"总结/逻辑/7. 近战攻击逻辑.canvas","exportPath":"总结/逻辑/7.-近战攻击逻辑.html","showInTree":true,"treeOrder":54,"backlinks":[],"type":"canvas","data":null},"总结/逻辑/8.-远程攻击逻辑.html":{"createdTime":1764053014866,"modifiedTime":1764055057171,"sourceSize":3767,"sourcePath":"总结/逻辑/8. 远程攻击逻辑.canvas","exportPath":"总结/逻辑/8.-远程攻击逻辑.html","showInTree":true,"treeOrder":55,"backlinks":[],"type":"canvas","data":null},"总结/逻辑/9.-闪避逻辑.html":{"createdTime":1764055081621,"modifiedTime":1766404203443,"sourceSize":1351,"sourcePath":"总结/逻辑/9. 闪避逻辑.canvas","exportPath":"总结/逻辑/9.-闪避逻辑.html","showInTree":true,"treeOrder":56,"backlinks":[],"type":"canvas","data":null},"总结/1.-模板名.html":{"createdTime":1760418154392,"modifiedTime":1766056121362,"sourceSize":111156,"sourcePath":"总结/1. 模板名.md","exportPath":"总结/1.-模板名.html","showInTree":true,"treeOrder":57,"backlinks":["第-2-节-修改基础/2.-实体与模板.html"],"type":"markdown","data":null},"总结/2.-模板函数.html":{"createdTime":1760418189594,"modifiedTime":1765702882136,"sourceSize":3879,"sourcePath":"总结/2. 模板函数.md","exportPath":"总结/2.-模板函数.html","showInTree":true,"treeOrder":58,"backlinks":["第-2-节-修改基础/2.-实体与模板.html"],"type":"markdown","data":null},"总结/3.-常量.html":{"createdTime":1760418254609,"modifiedTime":1766457651503,"sourceSize":13792,"sourcePath":"总结/3. 常量.md","exportPath":"总结/3.-常量.html","showInTree":true,"treeOrder":59,"backlinks":["第-2-节-修改基础/2.-实体与模板.html"],"type":"markdown","data":null},"总结/4.-关卡.html":{"createdTime":1760418586205,"modifiedTime":1766455916807,"sourceSize":1393,"sourcePath":"总结/4. 关卡.md","exportPath":"总结/4.-关卡.html","showInTree":true,"treeOrder":60,"backlinks":[],"type":"markdown","data":null},"总结/5.-路径.html":{"createdTime":1766455895468,"modifiedTime":1766459112430,"sourceSize":3783,"sourcePath":"总结/5. 路径.md","exportPath":"总结/5.-路径.html","showInTree":true,"treeOrder":61,"backlinks":[],"type":"markdown","data":null},"总结/6.-网格.html":{"createdTime":1766455874868,"modifiedTime":1766457736577,"sourceSize":1701,"sourcePath":"总结/6. 网格.md","exportPath":"总结/6.-网格.html","showInTree":true,"treeOrder":62,"backlinks":[],"type":"markdown","data":null},"总结/6.-字符串.html":{"createdTime":1765074028824,"modifiedTime":1765285313876,"sourceSize":10784,"sourcePath":"总结/6. 字符串.md","exportPath":"总结/6.-字符串.html","showInTree":true,"treeOrder":63,"backlinks":["第-1-节-语法/8.-字符串.html"],"type":"markdown","data":null},"总结/7.-键.html":{"createdTime":1764029307672,"modifiedTime":1765972795478,"sourceSize":2421,"sourcePath":"总结/7. 键.md","exportPath":"总结/7.-键.html","showInTree":true,"treeOrder":64,"backlinks":["第-2-节-修改基础/6.-精灵与声音.html"],"type":"markdown","data":null},"总结/8.-表.html":{"createdTime":1765680702732,"modifiedTime":1765763849879,"sourceSize":2940,"sourcePath":"总结/8. 表.md","exportPath":"总结/8.-表.html","showInTree":true,"treeOrder":65,"backlinks":[],"type":"markdown","data":null},"总结/9.-工具函数.html":{"createdTime":1760418452838,"modifiedTime":1766459040569,"sourceSize":8381,"sourcePath":"总结/9. 工具函数.md","exportPath":"总结/9.-工具函数.html","showInTree":true,"treeOrder":66,"backlinks":["第-2-节-修改基础/3.-实体函数.html","第-2-节-修改基础/6.-精灵与声音.html"],"type":"markdown","data":null},"总结/10.-脚本函数.html":{"createdTime":1763193306912,"modifiedTime":1765855598038,"sourceSize":474,"sourcePath":"总结/10. 脚本函数.md","exportPath":"总结/10.-脚本函数.html","showInTree":true,"treeOrder":67,"backlinks":[],"type":"markdown","data":null},"总结/11.-其他函数.html":{"createdTime":1760418275686,"modifiedTime":1765855835127,"sourceSize":685,"sourcePath":"总结/11. 其他函数.md","exportPath":"总结/11.-其他函数.html","showInTree":true,"treeOrder":68,"backlinks":[],"type":"markdown","data":null},"总结/12.-库.html":{"createdTime":1765963915655,"modifiedTime":1766395244003,"sourceSize":4981,"sourcePath":"总结/12. 库.md","exportPath":"总结/12.-库.html","showInTree":true,"treeOrder":69,"backlinks":["第-2-节-修改基础/3.-实体函数.html"],"type":"markdown","data":null},"总结/13.-类.html":{"createdTime":1764029384732,"modifiedTime":1766285531210,"sourceSize":1300,"sourcePath":"总结/13. 类.md","exportPath":"总结/13.-类.html","showInTree":true,"treeOrder":70,"backlinks":[],"type":"markdown","data":null},"index.html":{"createdTime":1749969216293,"modifiedTime":1766750815863,"sourceSize":3209,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":71,"backlinks":[],"type":"markdown","data":null},"readme.html":{"createdTime":1756780171078,"modifiedTime":1764126953366,"sourceSize":676,"sourcePath":"README.md","exportPath":"readme.html","showInTree":true,"treeOrder":72,"backlinks":[],"type":"markdown","data":null},"site-lib/html/custom-head-content-content.html":{"createdTime":1750676176646,"modifiedTime":1753954093046,"sourceSize":827,"sourcePath":"site-lib/html/custom-head-content.html","exportPath":"site-lib/html/custom-head-content-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/fonts/94f2f163d4b698242fef.otf":{"createdTime":1766752091392,"modifiedTime":1766752091392,"sourceSize":66800,"sourcePath":"","exportPath":"site-lib/fonts/94f2f163d4b698242fef.otf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/72505e6a122c6acd5471.woff2":{"createdTime":1766752091411,"modifiedTime":1766752091411,"sourceSize":104232,"sourcePath":"","exportPath":"site-lib/fonts/72505e6a122c6acd5471.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/2d5198822ab091ce4305.woff2":{"createdTime":1766752091412,"modifiedTime":1766752091412,"sourceSize":104332,"sourcePath":"","exportPath":"site-lib/fonts/2d5198822ab091ce4305.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c8ba52b05a9ef10f4758.woff2":{"createdTime":1766752091413,"modifiedTime":1766752091413,"sourceSize":98868,"sourcePath":"","exportPath":"site-lib/fonts/c8ba52b05a9ef10f4758.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cb10ffd7684cd9836a05.woff2":{"createdTime":1766752091415,"modifiedTime":1766752091415,"sourceSize":106876,"sourcePath":"","exportPath":"site-lib/fonts/cb10ffd7684cd9836a05.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/293fd13dbca5a3e450ef.woff2":{"createdTime":1766752091416,"modifiedTime":1766752091416,"sourceSize":105924,"sourcePath":"","exportPath":"site-lib/fonts/293fd13dbca5a3e450ef.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/085cb93e613ba3d40d2b.woff2":{"createdTime":1766752091417,"modifiedTime":1766752091417,"sourceSize":112184,"sourcePath":"","exportPath":"site-lib/fonts/085cb93e613ba3d40d2b.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/b5f0f109bc88052d4000.woff2":{"createdTime":1766752091419,"modifiedTime":1766752091419,"sourceSize":105804,"sourcePath":"","exportPath":"site-lib/fonts/b5f0f109bc88052d4000.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cbe0ae49c52c920fd563.woff2":{"createdTime":1766752091422,"modifiedTime":1766752091422,"sourceSize":106108,"sourcePath":"","exportPath":"site-lib/fonts/cbe0ae49c52c920fd563.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/535a6cf662596b3bd6a6.woff2":{"createdTime":1766752091423,"modifiedTime":1766752091423,"sourceSize":111708,"sourcePath":"","exportPath":"site-lib/fonts/535a6cf662596b3bd6a6.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1766752091424,"modifiedTime":1766752091424,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1766752091429,"modifiedTime":1766752091429,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1766752091430,"modifiedTime":1766752091430,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1766752091426,"modifiedTime":1766752091426,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1766752091387,"modifiedTime":1766752091387,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1766752091389,"modifiedTime":1766752091389,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/2308ab1944a6bfa5c5b8.svg":{"createdTime":1766752091391,"modifiedTime":1766752091391,"sourceSize":278,"sourcePath":"","exportPath":"site-lib/media/2308ab1944a6bfa5c5b8.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1766752092078,"modifiedTime":1766752092078,"sourceSize":27041,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1766750905038,"modifiedTime":1766750905038,"sourceSize":110729,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1751268810040,"modifiedTime":1751268796000,"sourceSize":10073,"sourcePath":"site-lib/media/icon256.png","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/snippets.css":{"createdTime":1766752091403,"modifiedTime":1766752091403,"sourceSize":2468,"sourcePath":"","exportPath":"site-lib/styles/snippets.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/obsidian.css":{"createdTime":1766752091554,"modifiedTime":1766752091554,"sourceSize":205827,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/other-plugins.css":{"createdTime":1766750905318,"modifiedTime":1766750905318,"sourceSize":13394,"sourcePath":"","exportPath":"site-lib/styles/other-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/theme.css":{"createdTime":1766750905956,"modifiedTime":1766750905956,"sourceSize":791278,"sourcePath":"","exportPath":"site-lib/styles/theme.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1766752091304,"modifiedTime":1766752091304,"sourceSize":481,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/supported-plugins.css":{"createdTime":1766752091304,"modifiedTime":1766752091304,"sourceSize":1252,"sourcePath":"","exportPath":"site-lib/styles/supported-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1766750905084,"modifiedTime":1766750905084,"sourceSize":19521,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/media/pasted-image-20250803100142.png":{"createdTime":1754708600152,"modifiedTime":1754708576000,"sourceSize":184919,"sourcePath":"site-lib/media/Pasted image 20250803100142.png","exportPath":"site-lib/media/pasted-image-20250803100142.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250803100333.png":{"createdTime":1754708600143,"modifiedTime":1754708576000,"sourceSize":257141,"sourcePath":"site-lib/media/Pasted image 20250803100333.png","exportPath":"site-lib/media/pasted-image-20250803100333.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225185539.png":{"createdTime":1766733796992,"modifiedTime":1766733769000,"sourceSize":3236,"sourcePath":"site-lib/media/Pasted image 20251225185539.png","exportPath":"site-lib/media/pasted-image-20251225185539.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225185723.png":{"createdTime":1766733796999,"modifiedTime":1766733766000,"sourceSize":5999,"sourcePath":"site-lib/media/Pasted image 20251225185723.png","exportPath":"site-lib/media/pasted-image-20251225185723.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225185853.png":{"createdTime":1766733797006,"modifiedTime":1766733767000,"sourceSize":5220,"sourcePath":"site-lib/media/Pasted image 20251225185853.png","exportPath":"site-lib/media/pasted-image-20251225185853.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225190026.png":{"createdTime":1766733797013,"modifiedTime":1766733767000,"sourceSize":2094,"sourcePath":"site-lib/media/Pasted image 20251225190026.png","exportPath":"site-lib/media/pasted-image-20251225190026.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225190451.png":{"createdTime":1766733797019,"modifiedTime":1766733767000,"sourceSize":14370,"sourcePath":"site-lib/media/Pasted image 20251225190451.png","exportPath":"site-lib/media/pasted-image-20251225190451.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225191640.png":{"createdTime":1766733797026,"modifiedTime":1766733767000,"sourceSize":10716,"sourcePath":"site-lib/media/Pasted image 20251225191640.png","exportPath":"site-lib/media/pasted-image-20251225191640.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225195034.png":{"createdTime":1766733797053,"modifiedTime":1766733768000,"sourceSize":2248,"sourcePath":"site-lib/media/Pasted image 20251225195034.png","exportPath":"site-lib/media/pasted-image-20251225195034.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225203906.png":{"createdTime":1766733797076,"modifiedTime":1766733768000,"sourceSize":8382,"sourcePath":"site-lib/media/Pasted image 20251225203906.png","exportPath":"site-lib/media/pasted-image-20251225203906.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225201739.png":{"createdTime":1766733797060,"modifiedTime":1766733768000,"sourceSize":1894,"sourcePath":"site-lib/media/Pasted image 20251225201739.png","exportPath":"site-lib/media/pasted-image-20251225201739.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225202221.png":{"createdTime":1766733797068,"modifiedTime":1766733768000,"sourceSize":8374,"sourcePath":"site-lib/media/Pasted image 20251225202221.png","exportPath":"site-lib/media/pasted-image-20251225202221.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250621105918.png":{"createdTime":1752497479593,"modifiedTime":1750757975000,"sourceSize":4487,"sourcePath":"site-lib/media/Pasted image 20250621105918.png","exportPath":"site-lib/media/pasted-image-20250621105918.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250620190901.png":{"createdTime":1754708600148,"modifiedTime":1754708575000,"sourceSize":86134,"sourcePath":"site-lib/media/Pasted image 20250620190901.png","exportPath":"site-lib/media/pasted-image-20250620190901.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251213194044.png":{"createdTime":1765850025562,"modifiedTime":1765766719000,"sourceSize":12230,"sourcePath":"site-lib/media/Pasted image 20251213194044.png","exportPath":"site-lib/media/pasted-image-20251213194044.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251213173619.png":{"createdTime":1765850025554,"modifiedTime":1765766719000,"sourceSize":8221,"sourcePath":"site-lib/media/Pasted image 20251213173619.png","exportPath":"site-lib/media/pasted-image-20251213173619.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250712192159.png":{"createdTime":1753702633256,"modifiedTime":1753702625000,"sourceSize":23317,"sourcePath":"site-lib/media/Pasted image 20250712192159.png","exportPath":"site-lib/media/pasted-image-20250712192159.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250624161626.png":{"createdTime":1752497616401,"modifiedTime":1750940380000,"sourceSize":5198,"sourcePath":"site-lib/media/Pasted image 20250624161626.png","exportPath":"site-lib/media/pasted-image-20250624161626.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250803203730.png":{"createdTime":1754708093033,"modifiedTime":1754707949000,"sourceSize":5874,"sourcePath":"site-lib/media/Pasted image 20250803203730.png","exportPath":"site-lib/media/pasted-image-20250803203730.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250717091020.png":{"createdTime":1754708600150,"modifiedTime":1754708575000,"sourceSize":52114,"sourcePath":"site-lib/media/Pasted image 20250717091020.png","exportPath":"site-lib/media/pasted-image-20250717091020.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251206205112.png":{"createdTime":1765181185320,"modifiedTime":1765181143000,"sourceSize":7421,"sourcePath":"site-lib/media/Pasted image 20251206205112.png","exportPath":"site-lib/media/pasted-image-20251206205112.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251206205740.png":{"createdTime":1765181185336,"modifiedTime":1765181143000,"sourceSize":12807,"sourcePath":"site-lib/media/Pasted image 20251206205740.png","exportPath":"site-lib/media/pasted-image-20251206205740.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225155912.png":{"createdTime":1766733796985,"modifiedTime":1766733769000,"sourceSize":10624,"sourcePath":"site-lib/media/Pasted image 20251225155912.png","exportPath":"site-lib/media/pasted-image-20251225155912.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225194347.png":{"createdTime":1766733797040,"modifiedTime":1766733767000,"sourceSize":40189,"sourcePath":"site-lib/media/Pasted image 20251225194347.png","exportPath":"site-lib/media/pasted-image-20251225194347.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225194118.png":{"createdTime":1766733797032,"modifiedTime":1766733767000,"sourceSize":5788,"sourcePath":"site-lib/media/Pasted image 20251225194118.png","exportPath":"site-lib/media/pasted-image-20251225194118.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251226133851.png":{"createdTime":1766733797083,"modifiedTime":1766733768000,"sourceSize":4398,"sourcePath":"site-lib/media/Pasted image 20251226133851.png","exportPath":"site-lib/media/pasted-image-20251226133851.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251225194600.png":{"createdTime":1766733797046,"modifiedTime":1766733767000,"sourceSize":1976,"sourcePath":"site-lib/media/Pasted image 20251225194600.png","exportPath":"site-lib/media/pasted-image-20251225194600.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251210202636.png":{"createdTime":1765370590717,"modifiedTime":1765370549000,"sourceSize":11073,"sourcePath":"site-lib/media/Pasted image 20251210202636.png","exportPath":"site-lib/media/pasted-image-20251210202636.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250706200745.png":{"createdTime":1752497479743,"modifiedTime":1752113989000,"sourceSize":10372,"sourcePath":"site-lib/media/Pasted image 20250706200745.png","exportPath":"site-lib/media/pasted-image-20250706200745.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250710092722.png":{"createdTime":1752497479826,"modifiedTime":1752113990000,"sourceSize":3038,"sourcePath":"site-lib/media/Pasted image 20250710092722.png","exportPath":"site-lib/media/pasted-image-20250710092722.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251206202705.png":{"createdTime":1765181185307,"modifiedTime":1765181143000,"sourceSize":15268,"sourcePath":"site-lib/media/Pasted image 20251206202705.png","exportPath":"site-lib/media/pasted-image-20251206202705.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250618131806.png":{"createdTime":1754708600141,"modifiedTime":1754708574000,"sourceSize":130294,"sourcePath":"site-lib/media/Pasted image 20250618131806.png","exportPath":"site-lib/media/pasted-image-20250618131806.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250716183243.png":{"createdTime":1753702633261,"modifiedTime":1753702625000,"sourceSize":16596,"sourcePath":"site-lib/media/Pasted image 20250716183243.png","exportPath":"site-lib/media/pasted-image-20250716183243.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250707085646.png":{"createdTime":1752497479781,"modifiedTime":1752113989000,"sourceSize":12140,"sourcePath":"site-lib/media/Pasted image 20250707085646.png","exportPath":"site-lib/media/pasted-image-20250707085646.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250707085857.png":{"createdTime":1752497479790,"modifiedTime":1752113989000,"sourceSize":15183,"sourcePath":"site-lib/media/Pasted image 20250707085857.png","exportPath":"site-lib/media/pasted-image-20250707085857.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250716131909.png":{"createdTime":1753702633262,"modifiedTime":1753702625000,"sourceSize":14699,"sourcePath":"site-lib/media/Pasted image 20250716131909.png","exportPath":"site-lib/media/pasted-image-20250716131909.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251115141653.png":{"createdTime":1764053449609,"modifiedTime":1764053444000,"sourceSize":13061,"sourcePath":"site-lib/media/Pasted image 20251115141653.png","exportPath":"site-lib/media/pasted-image-20251115141653.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251215185551.png":{"createdTime":1766733796971,"modifiedTime":1766733768000,"sourceSize":17216,"sourcePath":"site-lib/media/Pasted image 20251215185551.png","exportPath":"site-lib/media/pasted-image-20251215185551.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251109133154.png":{"createdTime":1762666314452,"modifiedTime":1762761734000,"sourceSize":33808,"sourcePath":"site-lib/media/Pasted image 20251109133154.png","exportPath":"site-lib/media/pasted-image-20251109133154.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251215100819.png":{"createdTime":1765850025568,"modifiedTime":1765766719000,"sourceSize":7307,"sourcePath":"site-lib/media/Pasted image 20251215100819.png","exportPath":"site-lib/media/pasted-image-20251215100819.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250812125430.png":{"createdTime":1756796257453,"modifiedTime":1756796212000,"sourceSize":5629,"sourcePath":"site-lib/media/Pasted image 20250812125430.png","exportPath":"site-lib/media/pasted-image-20250812125430.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250828164236.png":{"createdTime":1756796257461,"modifiedTime":1756796212000,"sourceSize":9328,"sourcePath":"site-lib/media/Pasted image 20250828164236.png","exportPath":"site-lib/media/pasted-image-20250828164236.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250828164839.png":{"createdTime":1756796257471,"modifiedTime":1756796212000,"sourceSize":2800,"sourcePath":"site-lib/media/Pasted image 20250828164839.png","exportPath":"site-lib/media/pasted-image-20250828164839.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251223100412.png":{"createdTime":1766733796978,"modifiedTime":1766733769000,"sourceSize":161535,"sourcePath":"site-lib/media/Pasted image 20251223100412.png","exportPath":"site-lib/media/pasted-image-20251223100412.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251212181056.png":{"createdTime":1765850025547,"modifiedTime":1765766719000,"sourceSize":14032,"sourcePath":"site-lib/media/Pasted image 20251212181056.png","exportPath":"site-lib/media/pasted-image-20251212181056.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250626192149.png":{"createdTime":1752497616467,"modifiedTime":1750940380000,"sourceSize":4471,"sourcePath":"site-lib/media/Pasted image 20250626192149.png","exportPath":"site-lib/media/pasted-image-20250626192149.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250626191819.png":{"createdTime":1752497616459,"modifiedTime":1750940380000,"sourceSize":8639,"sourcePath":"site-lib/media/Pasted image 20250626191819.png","exportPath":"site-lib/media/pasted-image-20250626191819.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251211142754.png":{"createdTime":1765508234581,"modifiedTime":1765508207000,"sourceSize":12798,"sourcePath":"site-lib/media/Pasted image 20251211142754.png","exportPath":"site-lib/media/pasted-image-20251211142754.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251208134125.png":{"createdTime":1765181185390,"modifiedTime":1765181143000,"sourceSize":10708,"sourcePath":"site-lib/media/Pasted image 20251208134125.png","exportPath":"site-lib/media/pasted-image-20251208134125.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251211205307.png":{"createdTime":1765508234586,"modifiedTime":1765508206000,"sourceSize":8913,"sourcePath":"site-lib/media/Pasted image 20251211205307.png","exportPath":"site-lib/media/pasted-image-20251211205307.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251209094358.png":{"createdTime":1765370590645,"modifiedTime":1765370550000,"sourceSize":10976,"sourcePath":"site-lib/media/Pasted image 20251209094358.png","exportPath":"site-lib/media/pasted-image-20251209094358.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20251120103043.png":{"createdTime":1764053449607,"modifiedTime":1764053444000,"sourceSize":6230,"sourcePath":"site-lib/media/Pasted image 20251120103043.png","exportPath":"site-lib/media/pasted-image-20251120103043.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250809164512.png":{"createdTime":1756796257438,"modifiedTime":1756796212000,"sourceSize":26815,"sourcePath":"site-lib/media/Pasted image 20250809164512.png","exportPath":"site-lib/media/pasted-image-20250809164512.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250809094636.png":{"createdTime":1754708093030,"modifiedTime":1754707948000,"sourceSize":55393,"sourcePath":"site-lib/media/Pasted image 20250809094636.png","exportPath":"site-lib/media/pasted-image-20250809094636.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250809094524.png":{"createdTime":1754708093023,"modifiedTime":1754707947000,"sourceSize":9467,"sourcePath":"site-lib/media/Pasted image 20250809094524.png","exportPath":"site-lib/media/pasted-image-20250809094524.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250807181638.png":{"createdTime":1754708093035,"modifiedTime":1754707949000,"sourceSize":13356,"sourcePath":"site-lib/media/Pasted image 20250807181638.png","exportPath":"site-lib/media/pasted-image-20250807181638.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250807183501.png":{"createdTime":1754708093032,"modifiedTime":1754707950000,"sourceSize":3200,"sourcePath":"site-lib/media/Pasted image 20250807183501.png","exportPath":"site-lib/media/pasted-image-20250807183501.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250807182230.png":{"createdTime":1754708093017,"modifiedTime":1754707950000,"sourceSize":14233,"sourcePath":"site-lib/media/Pasted image 20250807182230.png","exportPath":"site-lib/media/pasted-image-20250807182230.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250807183059.png":{"createdTime":1754708093022,"modifiedTime":1754707950000,"sourceSize":13046,"sourcePath":"site-lib/media/Pasted image 20250807183059.png","exportPath":"site-lib/media/pasted-image-20250807183059.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250808185126.png":{"createdTime":1754708093040,"modifiedTime":1754707947000,"sourceSize":63053,"sourcePath":"site-lib/media/Pasted image 20250808185126.png","exportPath":"site-lib/media/pasted-image-20250808185126.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250808090849.png":{"createdTime":1754708093020,"modifiedTime":1754707950000,"sourceSize":5436,"sourcePath":"site-lib/media/Pasted image 20250808090849.png","exportPath":"site-lib/media/pasted-image-20250808090849.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/pasted-image-20250811184142.png":{"createdTime":1756796257446,"modifiedTime":1756796212000,"sourceSize":12817,"sourcePath":"site-lib/media/Pasted image 20250811184142.png","exportPath":"site-lib/media/pasted-image-20250811184142.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/rss.xml":{"createdTime":1766752207473,"modifiedTime":1766752207473,"sourceSize":368878,"sourcePath":"","exportPath":"site-lib/rss.xml","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null}},"sourceToTarget":{"第 1 节 - 语法/0. 配置环境.md":"第-1-节-语法/0.-配置环境.html","第 1 节 - 语法/1. Lua 介绍.md":"第-1-节-语法/1.-lua-介绍.html","第 1 节 - 语法/2. 基础语法规则.md":"第-1-节-语法/2.-基础语法规则.html","第 1 节 - 语法/3. 变量与数据类型.md":"第-1-节-语法/3.-变量与数据类型.html","第 1 节 - 语法/4. 运算符.md":"第-1-节-语法/4.-运算符.html","第 1 节 - 语法/5. 控制结构.md":"第-1-节-语法/5.-控制结构.html","第 1 节 - 语法/6. 函数.md":"第-1-节-语法/6.-函数.html","第 1 节 - 语法/7. 表.md":"第-1-节-语法/7.-表.html","第 1 节 - 语法/8. 字符串.md":"第-1-节-语法/8.-字符串.html","第 1 节 - 语法/9. 模块.md":"第-1-节-语法/9.-模块.html","第 1 节 - 语法/10. 调试与错误处理.md":"第-1-节-语法/10.-调试与错误处理.html","第 1 节 - 语法/11. 迭代器与泛型for.md":"第-1-节-语法/11.-迭代器与泛型for.html","第 1 节 - 语法/12. 协程.md":"第-1-节-语法/12.-协程.html","第 1 节 - 语法/13. 元表.md":"第-1-节-语法/13.-元表.html","第 1 节 - 语法/14. LuaJIT.md":"第-1-节-语法/14.-luajit.html","第 1 节 - 语法/15. Love 2D.md":"第-1-节-语法/15.-love-2d.html","第 1 节 - 语法/参考答案.md":"第-1-节-语法/参考答案.html","第 2 节 - 修改基础/1. 介绍.md":"第-2-节-修改基础/1.-介绍.html","第 2 节 - 修改基础/2. 实体与模板.md":"第-2-节-修改基础/2.-实体与模板.html","第 2 节 - 修改基础/3. 实体函数.md":"第-2-节-修改基础/3.-实体函数.html","第 2 节 - 修改基础/4. 关卡.md":"第-2-节-修改基础/4.-关卡.html","第 2 节 - 修改基础/5. 科技树与难度设定.md":"第-2-节-修改基础/5.-科技树与难度设定.html","第 2 节 - 修改基础/6. 精灵与声音.md":"第-2-节-修改基础/6.-精灵与声音.html","第 2 节 - 修改基础/7. 界面.md":"第-2-节-修改基础/7.-界面.html","第 2 节 - 修改基础/8. 存档.md":"第-2-节-修改基础/8.-存档.html","第 2 节 - 修改基础/9. 系统.md":"第-2-节-修改基础/9.-系统.html","第 2 节 - 修改基础/11. 工具使用方法.md":"第-2-节-修改基础/11.-工具使用方法.html","第 2 节 - 修改基础/参考答案.md":"第-2-节-修改基础/参考答案.html","第 3 节 - 进阶/4. 创建新关卡.md":"第-3-节-进阶/4.-创建新关卡.html","第 3 节 - 进阶/4. 移植.md":"第-3-节-进阶/4.-移植.html","其他/Local Lua Debugger 说明翻译.md":"其他/local-lua-debugger-说明翻译.html","总结/5 - 关卡/逻辑/3. 生成怪物逻辑.canvas":"总结/5-关卡/逻辑/3.-生成怪物逻辑.html","总结/5 - 关卡/逻辑/12. 关卡逻辑.md":"总结/5-关卡/逻辑/12.-关卡逻辑.html","总结/5 - 关卡/逻辑/特殊出怪逻辑.canvas":"总结/5-关卡/逻辑/特殊出怪逻辑.html","总结/6 - 动画/逻辑/1. 精灵插入逻辑.canvas":"总结/6-动画/逻辑/1.-精灵插入逻辑.html","总结/6 - 动画/逻辑/2. 精灵移除逻辑.canvas":"总结/6-动画/逻辑/2.-精灵移除逻辑.html","总结/6 - 动画/逻辑/3. 精灵更新逻辑.canvas":"总结/6-动画/逻辑/3.-精灵更新逻辑.html","总结/6 - 动画/逻辑/4. 补间动画更新逻辑.canvas":"总结/6-动画/逻辑/4.-补间动画更新逻辑.html","总结/逻辑/1. 更新逻辑.canvas":"总结/逻辑/1.-更新逻辑.html","总结/逻辑/2. 实体创建逻辑.canvas":"总结/逻辑/2.-实体创建逻辑.html","总结/逻辑/3. 实体移除逻辑.canvas":"总结/逻辑/3.-实体移除逻辑.html","总结/逻辑/4. 实体更新逻辑.canvas":"总结/逻辑/4.-实体更新逻辑.html","总结/逻辑/5. 造成伤害逻辑.canvas":"总结/逻辑/5.-造成伤害逻辑.html","总结/逻辑/6. 造成效果逻辑.canvas":"总结/逻辑/6.-造成效果逻辑.html","总结/逻辑/7. 近战攻击逻辑.canvas":"总结/逻辑/7.-近战攻击逻辑.html","总结/逻辑/8. 远程攻击逻辑.canvas":"总结/逻辑/8.-远程攻击逻辑.html","总结/逻辑/9. 闪避逻辑.canvas":"总结/逻辑/9.-闪避逻辑.html","总结/1. 模板名.md":"总结/1.-模板名.html","总结/2. 模板函数.md":"总结/2.-模板函数.html","总结/3. 常量.md":"总结/3.-常量.html","总结/4. 关卡.md":"总结/4.-关卡.html","总结/5. 路径.md":"总结/5.-路径.html","总结/6. 网格.md":"总结/6.-网格.html","总结/6. 字符串.md":"总结/6.-字符串.html","总结/7. 键.md":"总结/7.-键.html","总结/8. 表.md":"总结/8.-表.html","总结/9. 工具函数.md":"总结/9.-工具函数.html","总结/10. 脚本函数.md":"总结/10.-脚本函数.html","总结/11. 其他函数.md":"总结/11.-其他函数.html","总结/12. 库.md":"总结/12.-库.html","总结/13. 类.md":"总结/13.-类.html","index.md":"index.html","README.md":"readme.html","site-lib/html/custom-head-content.html":"site-lib/html/custom-head-content-content.html","":"site-lib/rss.xml","site-lib/media/icon256.png":"site-lib/media/favicon.png","site-lib/media/Pasted image 20250803100142.png":"site-lib/media/pasted-image-20250803100142.png","site-lib/media/Pasted image 20250803100333.png":"site-lib/media/pasted-image-20250803100333.png","site-lib/media/Pasted image 20251225185539.png":"site-lib/media/pasted-image-20251225185539.png","site-lib/media/Pasted image 20251225185723.png":"site-lib/media/pasted-image-20251225185723.png","site-lib/media/Pasted image 20251225185853.png":"site-lib/media/pasted-image-20251225185853.png","site-lib/media/Pasted image 20251225190026.png":"site-lib/media/pasted-image-20251225190026.png","site-lib/media/Pasted image 20251225190451.png":"site-lib/media/pasted-image-20251225190451.png","site-lib/media/Pasted image 20251225191640.png":"site-lib/media/pasted-image-20251225191640.png","site-lib/media/Pasted image 20251225195034.png":"site-lib/media/pasted-image-20251225195034.png","site-lib/media/Pasted image 20251225203906.png":"site-lib/media/pasted-image-20251225203906.png","site-lib/media/Pasted image 20251225201739.png":"site-lib/media/pasted-image-20251225201739.png","site-lib/media/Pasted image 20251225202221.png":"site-lib/media/pasted-image-20251225202221.png","site-lib/media/Pasted image 20250621105918.png":"site-lib/media/pasted-image-20250621105918.png","site-lib/media/Pasted image 20250620190901.png":"site-lib/media/pasted-image-20250620190901.png","site-lib/media/Pasted image 20251213194044.png":"site-lib/media/pasted-image-20251213194044.png","site-lib/media/Pasted image 20251213173619.png":"site-lib/media/pasted-image-20251213173619.png","site-lib/media/Pasted image 20250712192159.png":"site-lib/media/pasted-image-20250712192159.png","site-lib/media/Pasted image 20250624161626.png":"site-lib/media/pasted-image-20250624161626.png","site-lib/media/Pasted image 20250803203730.png":"site-lib/media/pasted-image-20250803203730.png","site-lib/media/Pasted image 20250717091020.png":"site-lib/media/pasted-image-20250717091020.png","site-lib/media/Pasted image 20251206205112.png":"site-lib/media/pasted-image-20251206205112.png","site-lib/media/Pasted image 20251206205740.png":"site-lib/media/pasted-image-20251206205740.png","site-lib/media/Pasted image 20251225155912.png":"site-lib/media/pasted-image-20251225155912.png","site-lib/media/Pasted image 20251225194347.png":"site-lib/media/pasted-image-20251225194347.png","site-lib/media/Pasted image 20251225194118.png":"site-lib/media/pasted-image-20251225194118.png","site-lib/media/Pasted image 20251226133851.png":"site-lib/media/pasted-image-20251226133851.png","site-lib/media/Pasted image 20251225194600.png":"site-lib/media/pasted-image-20251225194600.png","site-lib/media/Pasted image 20251210202636.png":"site-lib/media/pasted-image-20251210202636.png","site-lib/media/Pasted image 20250706200745.png":"site-lib/media/pasted-image-20250706200745.png","site-lib/media/Pasted image 20250710092722.png":"site-lib/media/pasted-image-20250710092722.png","site-lib/media/Pasted image 20251206202705.png":"site-lib/media/pasted-image-20251206202705.png","site-lib/media/Pasted image 20250618131806.png":"site-lib/media/pasted-image-20250618131806.png","site-lib/media/Pasted image 20250716183243.png":"site-lib/media/pasted-image-20250716183243.png","site-lib/media/Pasted image 20250707085646.png":"site-lib/media/pasted-image-20250707085646.png","site-lib/media/Pasted image 20250707085857.png":"site-lib/media/pasted-image-20250707085857.png","site-lib/media/Pasted image 20250716131909.png":"site-lib/media/pasted-image-20250716131909.png","site-lib/media/Pasted image 20251115141653.png":"site-lib/media/pasted-image-20251115141653.png","site-lib/media/Pasted image 20251215185551.png":"site-lib/media/pasted-image-20251215185551.png","site-lib/media/Pasted image 20251109133154.png":"site-lib/media/pasted-image-20251109133154.png","site-lib/media/Pasted image 20251215100819.png":"site-lib/media/pasted-image-20251215100819.png","site-lib/media/Pasted image 20250812125430.png":"site-lib/media/pasted-image-20250812125430.png","site-lib/media/Pasted image 20250828164236.png":"site-lib/media/pasted-image-20250828164236.png","site-lib/media/Pasted image 20250828164839.png":"site-lib/media/pasted-image-20250828164839.png","site-lib/media/Pasted image 20251223100412.png":"site-lib/media/pasted-image-20251223100412.png","site-lib/media/Pasted image 20251212181056.png":"site-lib/media/pasted-image-20251212181056.png","site-lib/media/Pasted image 20250626192149.png":"site-lib/media/pasted-image-20250626192149.png","site-lib/media/Pasted image 20250626191819.png":"site-lib/media/pasted-image-20250626191819.png","site-lib/media/Pasted image 20251211142754.png":"site-lib/media/pasted-image-20251211142754.png","site-lib/media/Pasted image 20251208134125.png":"site-lib/media/pasted-image-20251208134125.png","site-lib/media/Pasted image 20251211205307.png":"site-lib/media/pasted-image-20251211205307.png","site-lib/media/Pasted image 20251209094358.png":"site-lib/media/pasted-image-20251209094358.png","site-lib/media/Pasted image 20251120103043.png":"site-lib/media/pasted-image-20251120103043.png","site-lib/media/Pasted image 20250809164512.png":"site-lib/media/pasted-image-20250809164512.png","site-lib/media/Pasted image 20250809094636.png":"site-lib/media/pasted-image-20250809094636.png","site-lib/media/Pasted image 20250809094524.png":"site-lib/media/pasted-image-20250809094524.png","site-lib/media/Pasted image 20250807181638.png":"site-lib/media/pasted-image-20250807181638.png","site-lib/media/Pasted image 20250807183501.png":"site-lib/media/pasted-image-20250807183501.png","site-lib/media/Pasted image 20250807182230.png":"site-lib/media/pasted-image-20250807182230.png","site-lib/media/Pasted image 20250807183059.png":"site-lib/media/pasted-image-20250807183059.png","site-lib/media/Pasted image 20250808185126.png":"site-lib/media/pasted-image-20250808185126.png","site-lib/media/Pasted image 20250808090849.png":"site-lib/media/pasted-image-20250808090849.png","site-lib/media/Pasted image 20250811184142.png":"site-lib/media/pasted-image-20250811184142.png"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"用于定位元素的CSS选择器。功能将相对于该元素放置。","placeholder":""},"info_type":{"show":true,"name":"","description":"该功能将放置在该元素之前、之后，还是内部（开头或结尾）。","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"将此功能放置在页面上的位置（相对于选择器）。","placeholder":""},"displayTitle":"反向链接","info_displayTitle":{"show":true,"name":"","description":"功能上方显示的描述性标题","placeholder":""}},"tags":{"featureId":"tags","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"用于定位元素的CSS选择器。功能将相对于该元素放置。","placeholder":""},"info_type":{"show":true,"name":"","description":"该功能将放置在该元素之前、之后，还是内部（开头或结尾）。","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"将此功能放置在页面上的位置（相对于选择器）。","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"功能上方显示的描述性标题","placeholder":""},"showInlineTags":true,"showFrontmatterTags":true,"info_showInlineTags":{"show":true,"name":"","description":"在页面顶部显示文档内定义的标签。","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"在页面顶部显示文档前置区域定义的标签。","placeholder":""}},"alias":{"featureId":"aliases","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"用于定位元素的CSS选择器。功能将相对于该元素放置。","placeholder":""},"info_type":{"show":true,"name":"","description":"该功能将放置在该元素之前、之后，还是内部（开头或结尾）。","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"将此功能放置在页面上的位置（相对于选择器）。","placeholder":""},"displayTitle":"Aliases","info_displayTitle":{"show":true,"name":"","description":"功能上方显示的描述性标题","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"用于定位元素的CSS选择器。功能将相对于该元素放置。","placeholder":""},"info_type":{"show":true,"name":"","description":"该功能将放置在该元素之前、之后，还是内部（开头或结尾）。","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"将此功能放置在页面上的位置（相对于选择器）。","placeholder":""},"displayTitle":"属性","info_displayTitle":{"show":true,"name":"","description":"功能上方显示的描述性标题","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"要从属性视图中隐藏的属性列表","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"用于定位元素的CSS选择器。功能将相对于该元素放置。","placeholder":""},"info_type":{"show":true,"name":"","description":"该功能将放置在该元素之前、之后，还是内部（开头或结尾）。","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"将此功能放置在页面上的位置（相对于选择器）。","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"为树中的每个文件显示一个自定义图标","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"为树中的每个文件夹显示一个默认图标","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"为树中的每个文件显示一个默认图标","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"用于文件夹的图标。使用'lucide//'前缀使用Lucide图标","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"用于文件的图标。使用'lucide//'前缀使用Lucide图标","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"用于媒体文件的图标。使用'lucide//'前缀使用Lucide图标","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"在页面首次加载时是否显示文件树中的当前文件","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"用于定位元素的CSS选择器。功能将相对于该元素放置。","placeholder":""},"info_type":{"show":true,"name":"","description":"该功能将放置在该元素之前、之后，还是内部（开头或结尾）。","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"将此功能放置在页面上的位置（相对于选择器）。","placeholder":""},"displayTitle":"搜索...","info_displayTitle":{"show":true,"name":"","description":"功能上方显示的描述性标题","placeholder":""}},"outline":{"featureId":"outline","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"用于定位元素的CSS选择器。功能将相对于该元素放置。","placeholder":""},"info_type":{"show":true,"name":"","description":"该功能将放置在该元素之前、之后，还是内部（开头或结尾）。","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"将此功能放置在页面上的位置（相对于选择器）。","placeholder":""},"displayTitle":"大纲","info_displayTitle":{"show":true,"name":"","description":"功能上方显示的描述性标题","placeholder":""},"startCollapsed":false,"minCollapseDepth":"1","info_startCollapsed":{"show":true,"name":"","description":"大纲是否开始折叠？","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"应折叠标题的最小深度","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"用于定位元素的CSS选择器。功能将相对于该元素放置。","placeholder":""},"info_type":{"show":true,"name":"","description":"该功能将放置在该元素之前、之后，还是内部（开头或结尾）。","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"将此功能放置在页面上的位置（相对于选择器）。","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"功能上方显示的描述性标题","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"用于定位元素的CSS选择器。功能将相对于该元素放置。","placeholder":""},"info_type":{"show":true,"name":"","description":"该功能将放置在该元素之前、之后，还是内部（开头或结尾）。","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"将此功能放置在页面上的位置（相对于选择器）。","placeholder":""},"displayTitle":"图形视图","info_displayTitle":{"show":true,"name":"","description":"功能上方显示的描述性标题","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"name":"","description":"显示未连接到任何其他节点的节点。","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"将附件（如图像和PDF）显示为图中的节点。","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"允许用户查看所有节点的全局图。","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"允许用户将图形视图弹出至全屏显示。","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"链接节点之间的吸引力有多大？吸引力越大，图形将显得越集中。","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"节点之间的链接应有多长？链接越短，节点将聚集得更紧密。","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"节点之间的排斥力有多大？排斥力越大，分离的节点将分散得越远。","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"节点被吸引到中心的程度有多大？吸引力越大，图形看起来越密集和呈圆形。","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"超过此阈值长度的边将不会显示，但仍然参与图形计算。这有助于大型复杂图形显得更加有序。悬停在节点上时，仍会显示这些链接。","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"最小节点的大小是多少？节点越小，吸引其他节点的力量越小。","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"最大节点的大小是多少？节点大小取决于它们的链接数量。节点越大，吸引其他节点的力量越大。这有助于围绕最重要的节点形成良好的分组。","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"name":"","description":"是否允许用户调整侧边栏的大小","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"是否允许用户折叠侧边栏","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"右侧边栏的默认宽度","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"左侧边栏的默认宽度","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"head","type":"end","info_selector":{"show":true,"name":"","description":"用于定位元素的CSS选择器。功能将相对于该元素放置。","placeholder":""},"info_type":{"show":true,"name":"","description":"该功能将放置在该元素之前、之后，还是内部（开头或结尾）。","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"将此功能放置在页面上的位置（相对于选择器）。","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"site-lib\\html\\custom-head-content.html","info_sourcePath":{"show":true,"name":"","description":"包含的本地HTML文件路径。","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"hideSettingsButton":false,"allowFoldingLists":false,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"name":"","description":"是否允许列表折叠","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"是否允许标题折叠","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"文档的宽度","placeholder":""}},"rss":{"featureId":"rss","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"siteUrl":"","authorName":"","info_siteUrl":{"show":true,"name":"","description":"此站点将托管的URL","placeholder":"https://example.com/mysite"},"info_authorName":{"show":true,"name":"","description":"站点作者的名称","placeholder":""}},"linkPreview":{"featureId":"link-preview","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":true}},"modifiedTime":1766752091556,"siteName":"王国保卫战修改教程","vaultName":"王国保卫战修改教程","exportRoot":"","baseURL":"","pluginVersion":"1.9.2","themeName":"","bodyClasses":"publish css-settings-manager mod-windows is-frameless is-hidden-frameless styled-scrollbars show-inline-title show-ribbon background-settings-workplace-theme-dark-in-the-sky background-image-settings-markdown-page-custom notebook-liked-markdown-page-grid-notebook-1 panel-page-bg-theme-light-custom panel-page-bg-theme-dark-plant hide-left-ribbon-retention-drawer toggle-divider-lines toggle-header-bottom-line bt-bubble-layout bt-bubble-layout-hide-borders remove-heading-indicator h1-toggle-underline toggle-left-aligned-content fancy-hr-no-icon custom-unordered-list custom-ordered-list list-no-border folder-icons bt-toggle-colorful-folder folder-style-change-options-colorful-default folder-colorful-one table-width-auto table-style-two link-underline-internal enable-alternative-checkboxes default-loading-page loading-text-typing-style rainbow-tag translucent-setting-panel underline-tab-style canvas-card-text-middle admonition-bg-color-same toggle-calendar-shadow style-options-for-buttons-plugin dataview-list-style-pacman memos-banner-gradient thino-frosted-style thino-background-default quiet-outline-optimize code-theme-sublime is-focused","hasFavicon":true}