# (一) 修改实体插入函数
每次创建实体都会调用一次对应实体的插入函数

**有些技能就是通过插入函数来实现的；**
**典型代表就是二代女巫的 1 伤害的光环，原理：调用插入函数 → 判断技能等级 → 创建光环**

## 一、尝试造成伤害
##### 1. 搜索插入函数
**搜索对应英雄的模板，在 `kr/game_scripts` 就可以找到函数了（如图为艾莉丹）**
![[Pasted image 20250701213229.png|825]]
当然也可以直接跳转到对应函数的定义，不需要搜索，直接**在对应英雄模板右键插入函数转到定义即可**
![[Pasted image 20250705190320.png|725]]
```lua
function scripts.hero_elves_archer.insert(this, store)
-- this 表示调用插入函数的完全独立的实体，store 就是存储实体的表
	...	-- 其他可以先不用管
	
	local d = E:create_entity("damage")	-- 造成伤害
	d.value = 233666	-- 伤害
	d.target_id = this.id	-- 目标 id 设置为当前英雄 id
	queue_damage(store, d)	-- 插入伤害队列
end
```

##### 2. 运行游戏
**使用修改的英雄进入关卡，英雄掉血，成功**
![[Pasted image 20250716185606.png|194]]
造成效果同理，只不过要插入实体队列，而不是伤害队列
```lua
local mod = E:create_entity(效果模板名)	-- 造成效果
mod.modifier.target_id = this.id	-- 目标
queue_insert(store, mod)	-- 插入实体队列
```

## 二、给实体增加光环
##### 示例：
以给沙王增加死亡骑士光环为例
```lua
function scripts.hero_alric.insert(this, store, script)
-- hero_alric 为沙王模板名，this 就是通过模板创建的沙王实体
	... -- 其他先不用管
	if this.hero.skills.toughness.level > 0 then	-- 若坚韧技能等级大于 0，可选
		local e = E:create_entity("death_rider_aura")	-- 创建死亡骑士光环
		e.aura.source_id = this.id	-- 来源设置为沙王

		queue_insert(store, e)	-- 创建光环 e，也就是死亡骑士光环
	end
end
```
`E:create_entity` 与 `queue_insert` 作用见 [[1.4 - 函数#二、实体创建逻辑]]

注意：`this` 指的不是模板，**而是通过模板创建出来的完全独立的实体**

##### 修改光环
**然后发现光环显示在了脸上，显示位置不符合预期，这是因为默认光环显示位置有偏移，移除偏移即可，修改光环的方法与修改效果相同**

##### 示例：
```lua
-- 模块内
-- 创建新模板，底表为原死亡骑士光环，变量为缩写用于区分模板
araa = E:register_t("death_rider_aura_alric", "death_rider_aura")

araa.aura.use_mod_offset = nil	-- 移除偏移
...	-- 其他属性同理，比如作用范围，护甲或伤害加成等

-- 插入函数内
local e = E:create_entity("death_rider_aura_alric")	-- 修改创建的实体表为新模板即可
```

**注意：修改函数还是与修改效果相同：如果一个函数有多个效果在用，修改函数就需要复制这个函数，重新命名，然后让对应效果使用这个函数，最后再修改复制出来的函数**
```lua
-- 某个效果模板
--原 tt.main_script.insert = scripts.mod_dps.insert
tt.main_script.insert = scripts.mod_dps_2.insert

-- 修改函数
scripts.mod_dps_2 = {}	-- 需要注意，避免索引问题
function scripts.mod_dps_2.insert()
	... -- mod_dps 插入函数的代码，修改即可
end
```

## 三、修改攻击优先级
**删除实体插入函数的排序函数，直接在模板手动写优先级即可（写攻击的序号，例如攻击 1 就是 1）**

攻击逻辑见 [[1.4 - 函数#七、攻击逻辑]]

##### 1. 删除插入函数的排序函数
![[Pasted image 20250701134555.png|500]]

##### 2. 手动指定优先级
```lua
-- 模板内
tt.melee.order = {
	2,	-- 优先释放攻击 2
	1,	-- 之后释放攻击 1
	...	-- 注意：必须填写所有的攻击，没填写的将不会被释放
}
```
注：仅能修改攻击，技能需要在更新函数修改代码顺序

# (二) 修改升级函数
## 一、技能或攻击的属性随等级而变化

##### 1. 在模板增加属性键
还是以艾莉丹的四技能，双刀跳斩为例
```lua
tt.hero.skills.double_strike = E:clone_c("hero_skill")
tt.hero.skills.double_strike.cooldown = {	-- 假设要让双刀跳斩的冷却时间随等级变化（原版 12 秒）
	12,	-- 一级 12 秒
	10,	-- 二级 10 秒
	8	-- 三级 8 秒
}
```

##### 2. 修改升级函数
搜索方法同插入函数
![[Pasted image 20250705182915.png|600]]
**这里就是每次升级时都会调用的函数，所有属性表都会在这里根据等级赋值到对应属性键上**

插入函数总是会调用一次这个函数 （`this.hero.fn_level_up(this, store, true)`）**这是因为升级函数只有升级时才会调用，所以需要在插入时调用一次进行初始化来保证属性表正确被赋值**

找到双刀跳斩对应的转化代码块，后面加上 `a.cooldown = s.cooldown[s.level]`：
![[Pasted image 20250705184937.png|450]]

# (三) 修改实体更新函数
调用逻辑见 [[1.4 - 函数#三、调用实体更新函数逻辑]]

更新函数与插入函数寻找方法相同

## 一、重要要点
##### 1. 计算时间
计算时间常用到 `store.tick_ts` 与 `ts`（时间戳）

示例：
```lua
a = this.timed_attacks.list[1]	-- 某个技能

if store.tick_ts - a.ts > a.cooldown then
	a.ts = store.tick_ts	-- 表示已释放技能，刷新 a 的时间戳
	-- 造成伤害等逻辑
...
```
表示如果**当前时间**与**上次释放技能 `a` 的时间戳** 之差**大于冷却时间**，则执行条件代码块
换句话说就是**上次释放技能过去的时间**大于冷却时间

持续时间等同理

注意：通常时间运算都在 `while true` 死循环内

##### 2. 索敌
`targets = U.find_enemies_in_range`，`U.find_xxx` 这种都是索敌

使用方法详细见 [[3 - 函数#一、索敌]]

##### 3. 攻击
`SU.y_soldier_melee_block_and_attacks(store, this)` 近战攻击函数

`y_soldier_ranged_attacks` 远程攻击函数

无目标返回 `A_NO_TARGET`
无可用攻击返回 `A_IN_COOLDOWN
攻击完毕 `A_DONE`

**可以通过返回值判断攻击的状态，来执行某些代码块**

`SU.y_soldier_ranged_attacks(store, this)` 远程攻击函数

详细见 [[1.4 - 函数#七、攻击逻辑]]

##### 4. 挂起协程
`coroutine.yield()` `while` 循环末尾必须挂起协程，否则会卡死程序

##### 5. 造成伤害与造成效果以及召唤实体
逻辑见 [[1.4 - 函数#五、造成伤害逻辑]]，[[1.4 - 函数#六、造成效果逻辑]]，[[1.4 - 函数#二、实体创建逻辑]]

通过查看逻辑知道：**造成伤害、效果，以及召唤实体用的都是 `E:create_entity` 函数**

**然后再加上具体目标，以及所有者的 id，具体属性等**

**最后插入队列即可**

## 二、技能造成效果
**主要目的**：让技能造成效果

找到技能造成伤害的代码块，在后面加上造成效果即可

##### 示例：
以给火男烈焰冲击增加燃烧效果为例（需要注意一下变量不要用错）
```lua
-- 更新函数内
a = this.timed_attacks.list[1]	-- 看到这个就说明下面是对应技能的代码块了
skill = this.hero.skills.flaming_frenzy

if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts >= a.cooldown then	-- 计算冷却时间
...
	targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags,
	a.vis_bans)	-- 索敌

	if targets then	-- 如果找到敌人
		for _, t in pairs(targets) do	-- 范围伤害要遍历找到的所有敌人，单体没有遍历这一步
			local d = E:create_entity("damage")	-- 造成伤害
			d.damage_type = a.damage_type	-- 伤害类型
			d.source_id = this.id	-- 所有者 id
			d.target_id = t.id	-- 目标 id
			d.value = math.random(a.damage_min, a.damage_max)	-- 具体伤害

			queue_damage(store, d)	-- 插入伤害队列

			-- 后面写上造成效果
			if a.mod then	-- 避免没有 mod 导致的一些问题
				local mod = E:create_entity(a.mod)	-- 也就是 this.timed_attacks.list[1].mod
				mod.modifier.target_id = t.id	-- 目标 id，再次注意：变量不要用错，是一个目标，而不是多个目标
				-- 因为索敌是找范围内的所有敌人所以是遍历出来的单体 t，如果索敌找的是单体敌人，则直接用索敌找到的敌人 					target 这些
				mod.modifier.source_id = this.id	-- 可选，有些效果需要来源，推荐加上
				...	-- 后面一些可以按需求加

				queue_insert(store, mod)	-- 插入实体队列
			end
		end
	end
...

-- 模板内
tt.timed_attacks.list[1].mod = "mod_lava_ignus"	-- 造成这个效果

local mod_lava = E:register_t("mod_lava_ignus", "mod_lava")
mod_lava.dps.damage_inc = 2	-- 修改伤害
```
通过上面的教程，个别子弹的效果无效也可以加上造成效果的代码块来解决，方法就不赘叙了，还是顺着 `E:register_t` 和 `E:add_comps` 找更新函数就行

### [一] 技能造成多个效果
只需要在模板增加一个效果表（mods），然后在更新函数遍历这个表然后造成效果即可

##### 示例：
还是以给火男烈焰冲击增加燃烧效果为例
```lua
-- 火男更新函数内
a = this.timed_attacks.list[1]
skill = this.hero.skills.flaming_frenzy

if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts >= a.cooldown then
...
	targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags,
	a.vis_bans)

	if targets then
		for _, t in pairs(targets) do
			local d = E:create_entity("damage")
			d.damage_type = a.damage_type
			d.source_id = this.id
			d.target_id = t.id
			d.value = math.random(a.damage_min, a.damage_max)
			
			queue_damage(store, d)
		
			-- 修改造成效果的代码块
			if a.mod or a.mods then	-- 避免没有 mod 导致的一些问题
				local mods = a.mods or {	-- 没有 mods 则创建一个包含 mod 的表，然后赋值
					a.mod
				}
				for _, mod_name in pairs(mods) do	-- 遍历效果表
					local new_mod = E:create_entity(mod_name)	
					new_mod.modifier.target_id = t.id
					new_mod.modifier.source_id = this.id

					queue_insert(store, new_mod)
				end
			end
		end
	end
...

-- 模板内
tt.timed_attacks.list[1].mods = {
	效果 1,	-- 因为 mod 会被覆盖，所以需要注意一下如果原本就有效果，需要加上之前的效果，否则技能将不会造成之前的效果
	效果 2
	...
}

```

## 三、修改索敌
所有索敌函数见 [[3 - 函数#一、索敌]]

### [一] 过滤函数
##### 示例：
```lua
target = find_foremost_enemy(..., function(v, origin)	-- 其他传递的参数省略，v 会传递实体表，origin 会传递圆心
	...	-- 函数体
	return v.health.hp >= 1000	-- 寻找血量大于等于 1000 的敌人
end, ...)	
```

##### 2. 结合判断拥有效果的工具函数使用
函数见 [[3 - 函数#二、判断拥有效果]]

##### 示例：
```lua
target = find_foremost_enemy(..., function(v, origin)
	...
	return v.health.hp >= 1000 and U.has_modifiers(store, v, "mod_lava")
	-- 寻找血量大于等于 1000，并且处于燃烧效果的敌人
end, ...)	
```

### [二] 寻找血量最高的敌人
因为基本所有索敌都是从范围索敌改来的，由此先通过范围索敌找到目标，然后排序血量最高的敌人

##### 示例：
```lua
local targets = U.find_enemies_in_range(store.entities, hero.pos, 0, a.radius, a.vis_flags, a.vis_bans)
--索敌

if targets then
	table.sort(targets, function(e1, e2)	-- 排序函数
		return e1.health.hp > e2.health.hp	-- 根据血量排序，最终血量最高的会排序在最前
	end)
	
	local target = targets[1]	-- 取第一个目标
	...	-- 后面造成伤害，造成效果，目标都传第一个目标即可
```
返回 `true` 表示 `e1` 在前 `e2` 在后，`false` 则是 `e1` 在后 `e2` 在前

当然你也可以根据伤害、速度、护甲大小排序，表示选择伤害最高或最低、速度最快或最慢、护甲最高或最低的目标

## 四、给实体攻击增加条件
### [一] 近战攻击
**主要目的**：给实体释放某个近战攻击增加条件，满足条件才释放这个攻击

**注意：仅支持实体的近战攻击，技能与远程不支持，防御塔的攻击也不支持**

只需要给实体的模板的近战攻击增加 `fn_can` 键，键值为函数即可

##### 示例：
以给一代鬼侍二技能灭魂斩增加血量释放条件为例
```lua
-- 鬼侍模板内
tt.melee.attacks[3].trigger_min_hp = 150	-- 释放条件：目标血量大于等于 150，键自己编一个就行，仅用于后续方便修改，你直接写到函数也是没问题的
tt.melee.attacks[3].fn_can = scripts.hero_oni.fn_can_death_strike	-- 函数名自己编一个

-- game_scripts 模块内，最好和更新函数与插入函数写在同一个位置
function scripts.hero_oni.update(this, store)
... end

function scripts.hero_oni.fn_can_death_strike(this, store, a, target)
	return target.health.hp >= a.trigger_min_hp	-- 目标血量大于等于设定的血量时返回 true，表示可以释放
end
```

- `fn_can` 函数会传递调用这个函数的实体，以及 `store`、攻击、目标

### [二] 远程攻击
只需要给实体模板的远程攻击增加 `filter_fn` 键，键值为函数即可

和索敌的过滤函数写法相同

##### 示例：
```lua
-- 模板内
tt.ranged.attacks[2].trigger_min_hp = 150	
tt.ranged.attacks[2].filter_fn = scripts.xxx.filter_fn_xxx

-- game_scripts 模块内，还是最好和更新函数与插入函数写在一个位置
function scripts.xxx.filter_fn_xxx(v, origin)
	return v.health.hp > trigger_min_hp	-- 寻找低于阈值的敌人
end
```

**本质还是索敌的过滤函数，过滤某些条件的目标**

### [三] 让近战攻击概率根据条件而动态变化
**主要目的**：让实体释放近战攻击概率，根据不同条件动态变化，例如对处于流血效果的目标造成百分百概率秒杀

**注意：还是仅支持实体的近战攻击，技能与远程不支持，防御塔的攻击也不支持**

只需要给实体的模板的攻击增加 `fn_chance` 键，键值为函数即可

##### 示例：
以给一代鬼侍二技能灭魂斩百分百秒杀处于流血状态为例
```lua
-- 鬼侍模板内
-- 鬼侍近战攻击 2 是灭魂斩的秒杀，3 则是不秒杀的真伤
tt.melee.attacks[2].instakill_mod_type = MOD_TYPE_BLEED	-- 效果：流血类型的效果，键自己编一个就行
tt.melee.attacks[2].fn_chance = scripts.hero_oni.fn_chance_death_strike	-- 函数名自己编一个

-- game_scripts 模块内，最好和鬼侍更新函数与插入函数写在一个位置
function scripts.hero_oni.update(this, store)
... end

function scripts.hero_oni.fn_chance_death_strike(this, store, a, target)
	return U.has_modifier_types(store, target, a.instakill_mod) or math.random() < attack.chance
	-- 目标拥有流血类型效果时返回 true，表示百分百概率，or 后面是原始计算概率逻辑
end
```

##### Q&A：
- Q：为什么 `fn_chance` 函数后面要加原始计算概率逻辑
- A：这是因为计算概率时会判断攻击有没有 `fn_chance` 函数，有则用 `fn_chance` 函数，没有则用这个原始计算概率逻辑，两个不能同时存在，所以需要单独增加

## 五、将远程攻击改为特殊远程攻击
特殊远程攻击就是近战时进行的远程攻击

```lua
-- 某个可以远程攻击单位的更新函数内
...
if this.unit.is_stunned then	-- 处于眩晕状态原地待机
	SU.soldier_idle(store, this)
else
	brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)	-- 调用近战攻击函数
	-- brk 就是跳出 break 缩写，sta 就是状态 status
	
	if brk or sta ~= A_NO_TARGET then	-- 近战攻击跳出，或近战攻击有目标，跳过远程攻击
		-- block empty
	else	-- 近战攻击未跳出，无目标
		brk, sta = SU.y_soldier_ranged_attacks(store, this)	-- 调用远程攻击函数
		if brk then	-- 远程攻击跳出，跳过
			-- block empty
		elseif SU.soldier_go_back_step(store, this) then	-- 正在返回集结点，跳过
			-- block empty
		else	-- 远程攻击成功，脱战
			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end
	end
end

::label_43_0::	-- 标志，用于代码之间的跳转
coroutine.yield()
```
通过观察函数发现：**远程攻击和近战攻击一次只能触发一个**，并且远程攻击优先级低于近战攻击，由此可以通过修改代码让远程和近战攻击**同时都可以触发**，来将远程攻击改为特殊远程攻击

将以上代码修改为以下即可：
```lua
...
if this.unit.is_stunned then
	SU.soldier_idle(store, this)
else
	if this.melee then
		brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

		if brk then	-- 近战攻击跳出
			goto 挂起协程	-- 直接跳到挂起协程部分
		end
	end

	if this.ranged then
		brk, sta = SU.y_soldier_ranged_attacks(store, this)

		if brk or sta == A_DONE then	-- 远程攻击跳出，或攻击完毕
			goto 挂起协程
		elseif sta == A_IN_COOLDOWN then	-- 远程攻击未跳出，并且在冷却
			goto 脱战
		end
	end

	if SU.soldier_go_back_step(store, this) then
		goto 挂起协程
	end

	::脱战::	--可以自己改个标志
	SU.soldier_idle(store, this)
	SU.soldier_regen(store, this)
end

::挂起协程::
coroutine.yield()
```

## 六、增加新攻击与技能
### [一] 使攻击概率造成效果
**主要目的**：概率造成效果、概率暴击等

**在模板增加一个新攻击，复制要概率造成效果的攻击，增加效果和概率即可**

##### 示例：
```lua
-- 模板内
tt.melee.attacks[3] = table.deepclone(tt.melee.attacks[1])
tt.melee.attacks[3].chance = 0.33	-- 概率
tt.melee.attacks[3].mod = xxx	-- 效果

-- 由于属性表最后会根据等级赋值到对应属性键上，所以直接复制攻击是得不到属性表的属性的，此时就需要修改升级函数，让属性表最后也会赋值到新攻击上
-- 升级函数内
local hl = this.hero.level
local ls = this.hero.level_stats
...
this.melee.attacks[3].damage_min = ls.melee_damage_min[hl]
this.melee.attacks[3].damage_max = ls.melee_damage_max[hl]
...
```
**注**：
1. 原版一个攻击的多个不同动画也是这样实现的，所以有些攻击可能有两三个，看着是不同的攻击，实际就是相同的只不过动画不同，可以通过这个攻击是复制谁的与修改的键来判断
2. **需要重点关注攻击顺序对实际释放概率的影响**
3. 只有能升级（有升级函数）的单位才需要修改升级函数

##### Q&A：
- Q：为什么可以通过增加另一个攻击来让一个攻击概率造成效果
- A：这是因为攻击顺序是概率低的优先，详见 [[1.4 - 函数#七、攻击逻辑]]
**本质还是增加了一个新攻击，看似原攻击概率造成效果，实则不然，只是使新攻击复制（深拷贝）原攻击，给这个攻击增加了效果而已，也就是说复制后两个攻击之间其实已经没有什么关联了**

#### {一} 防御塔攻击修改方法
由于防御塔的攻击大多数在更新函数使用的都是独立代码块并且没有概率相关的逻辑，所以需要自己写逻辑

##### 示例：
假设增加的是攻击 4，想让普攻概率造成效果
```lua
while true do
...
	if this.tower.blocked then
		coroutine.yield()
	else
		for i, aa in pairs(attacks) do
			-- 若进行普攻则计算概率，然后将普攻改成攻击 4
			if aa == this.attacks.list[1] and math.random() <= this.attacks.list[4].chance then
				aa = this.attacks.list[4]
			end
		end
...
```
注：由于防御塔攻击的逻辑的多变性，所以这里只有思路，具体写法需要自行调整

### [二] 增加新技能
**主要目的**：增加一个较为独立的技能

##### 示例：
以给尼鲁增加一个技能：每 275 秒增加 1 生命（升级二技能翠绿迸发解锁）为例

```lua
-- 尼鲁模板内
tt.hero.skills.heal_live = E:clone_c("hero_skill")	-- 复制英雄技能组件，防御塔与其他单位技能组件是 power
tt.hero.skills.heal_live.cooldown = {	-- 增加属性表：冷却时间
	275,	-- 一级冷却时间 275 秒
	245,	-- 三级冷却时间 245 秒
	210		-- 三级冷却时间 210 秒
}

tt.timed_attacks.list[5] = E:clone_c("custom_attack")	-- 复制自定义技能组件，尼鲁只有四个技能所以序号是 5
tt.timed_attacks.list[5].animation = "fairy_dust"	-- 动画套用四技能衰弱咒语，当然也可以套用其他技能，注意：只能用当前实体有的动画，否则将会报错
tt.timed_attacks.list[5].sound = "HeroNyruFairyDustCast"	-- 音效，也是借用衰弱咒语
tt.timed_attacks.list[5].cooldown = nil		-- 默认冷却时间，因为属性表已经有了所以不需要，其他键处理方法相同
tt.timed_attacks.list[5].disabled = true	-- 默认禁用	
tt.timed_attacks.list[5].heal_live = 1		-- 增加生命数量

-- 尼鲁升级函数
s = this.hero.skills.verdant_blast	-- 目前不能做到增加 UI，但是可以先借用其他技能，当然你也可以直接根据等级来实现
sl = s.level

if sl > 0 and initial then
	...
	local a = this.timed_attacks.list[5]
	a.cooldown = this.hero.skills.heal_live.cooldown[sl]	-- 根据翠绿迸发技能等级决定冷却时间，对应属性表
	a.disabled = nil	-- 解除禁用
end

-- 尼鲁更新函数内
while true do
	...
	if h.dead then
		SU.y_hero_death_and_respawn(store, this)
	end
	if this.unit.is_stunned then
		SU.soldier_idle(store, this)
	else
		a = this.timed_attacks.list[5]
		skill = this.hero.skills.heal_live

		if not a.disabled and store.tick_ts - a.ts > a.cooldown then	-- 计算冷却时间
			a.ts = store.tick_ts	-- 刷新时间戳
			U.animation_start(this, a.animation, nil, store.tick_ts)	-- 播放动画
			S:queue(a.sound)	-- 播放音效
			
			store.lives = store.lives + a.heal_live	-- 增加生命，注：生命，金币都存在 store

			SU.y_hero_animation_wait(this)	-- 等待动画完成
		end
		...
	end
	...
end
```

### [三] 闪避攻击
**主要目的**：使闪避或格挡时进行反击

逻辑见：[[1.4 - 函数#八、闪避逻辑]]

**通过查看逻辑知道：主要是通过 `dodge.active` 键来判断是否闪避，以及 `dodge.counter_attack_pending` 键来判断是否进行闪避攻击的**

由此可以在单位的更新函数判断闪避，然后将 `dodge.counter_attack_pending` 键的键值改为 `true`，在模板 `dodge.counter_attack` 键写上攻击即可

##### 示例：
```lua
-- 某个单位的更新函数内
while true do
	if h.dead then
		SU.y_hero_death_and_respawn(store, this)
	end

	if this.unit.is_stunned then
		SU.soldier_idle(store, this)
	else	-- 通常不会在死亡或眩晕时闪避
		if this.dodge and this.dodge.active then	-- 判断闪避
			this.dodge.active = false	-- 重置状态
			this.dodge.counter_attack_pending = true
			...	-- 注：后面可以增加其他逻辑
		end
	end
	...
end

-- 模板内
tt.dodge.counter_attack = E:clone_c("melee_attack")
tt.dodge.counter_attack.animation = "attack"
tt.dodge.counter_attack.sound = "MeleeSword"	-- 动画和音效可以套用普通攻击的
...	-- 增加伤害类型，伤害这些，与攻击同理
```

#### {一} 增加闪避条件
与攻击相同，就不赘叙了，增加 `tt.dodge.can_dodge = scripts.xxx.can_dodge` 键，然后写函数即可

函数与攻击写法相同但是**会传递 `store`、调用这个函数的实体、远程攻击、攻击、攻击来源给 `can_dodge`**

# (四)、修改实体行为函数
## 一、近战攻击造成多个效果
**通过上面的教程知道：造成多个效果需要有效果表，最后遍历效果表**
所以近战攻击不能造成多个效果的原因如下：**造成效果时只造成单一的 `mod` 效果**

造成多个效果只需要将近战攻击函数的造成效果的代码块修改一下即可：

##### 1. 搜索
首先找到近战攻击函数
参考 [[1.4 - 函数#七、攻击逻辑]] 直接在 `script_utils` 搜索 `y_soldier_melee_block_and_attacks` 函数，即可找到近战攻击函数

然后修改近战攻击函数 `y_soldier_do_loopable_melee_attack`，`y_soldier_do_single_area_attack`，`y_soldier_do_single_melee_attack`，多次攻击、范围攻击、单次攻击这三个函数

可以直接搜索也可以直接转到定义
**右键函数点击转到定义跳转到这个函数的定义**
![[Pasted image 20250705131059.png|600]]
##### 2. 修改
**往下找造成伤害的代码块**
![[Pasted image 20250705131332.png|525]]
**同上修改造成效果的代码块即可**
```lua
if attack.mod or attack.mods then
	local mods = attack.mods or {
		attack.mod
	}
	for _, mod_name in pairs(mods) do	-- 遍历效果表
		local new_mod = E:create_entity(mod_name)
		new_mod.modifier.target_id = e.id
		new_mod.modifier.source_id = this.id
		new_mod.modifier.ts = store.tick_ts	-- 加上原有的避免兼容性问题
		new_mod.modifier.level = attack.level
		
		queue_insert(store, new_mod)
	end
end

-- 模板内直接把效果写在 mods 键上即可
tt.melee.attacks[1].mods = {
	效果 1,
	效果 2
	...
}
```

三个函数都改一遍即可

