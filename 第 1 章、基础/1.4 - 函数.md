## 函数存储位置
所有基础函数都存储在 `all/scripts` 模块
- 后续会通过 `kr/game_scripts` 模块动态向 `scripts` 模块增加实体的各种函数
- `all/script_utils`（简称 SU）用于存储实体各种行为的函数（如攻击等，技能则是直接写到实体的更新函数上）
- `all/utils`（简称 U）用于存储通用工具函数（索敌等）

# 各种逻辑
注：调用顺序 `love` → `director` → `game` → `simulation` → `systems`（简称 sys）

## 一、驱动函数的逻辑：
### [一] 每帧调用驱动函数 `simulation:do_tick`
1. 更新逻辑时间（`store.tick_ts += 1`）
2. 处理实体插入与移除
3. 调用各种 `sys` 的更新函数

## 二、实体创建逻辑
所有实体最终都会创建到 `all/game.store.entities` 表中（`game.store` 简称 store）

### [一] 创建实体表
1. 调用 `E:create_entity(模板)` 函数：
	1. **深拷贝**模板，生成独立实体表（存储实体的各种数据）
	2. 分配唯一 ID（只增不减）
	3. 返回该实体表引用
2. 调用 `simulation.queue_insert_entity` 函数：
	1. 将实体表增加到 `store.pending_inserts`（待插入队列）

### [二] 处理待插入实体
1. 取出队列的实体表
2. 调用 `simulation:insert_entity` 函数
	1. 遍历并调用各种 `sys` 的插入函数
		1. 传递参数：创建的实体 `this`、`store`
		2. 若插入函数返回 `false` 则：
			1. 调用各种 `sys` 的 `dequeue` 函数
				1. 传递参数：`this`、`store`、`true`
				2. 直接返回，中断遍历
3. **以键值对 `[ID] = 实体表` 形式插入 `store.entities` 正式创建实体**

## 三、调用实体更新函数逻辑
### [一] 在驱动函数调用实体更新函数
1. 调用 `sys.main_script:on_update` 函数调度协程：
	1. **遍历所有有更新函数的实体**
	2. 若实体更新函数没有协程且没有运行过则创建更新函数的协程
	3. 重启协程
		1. **传递参数：更新函数对应协程、对应实体（this）、`store`、实体的函数表的引用**
		- 一般从更新函数的 `while` 重启

## 四、移除实体逻辑
### [一] 排队等待移除
1. 调用 `simulation.queue_remove_entity` 函数：
	1. 将实体表增加到 `store.pending_removals`（待移除队列）中

### [二] 处理待移除实体
1. 取出队列的实体表
2. 调用 `simulation:remove_entity` 函数移除实体
	1. 调用各种 `sys` 的移除函数
		1. 传递参数：`this`、`store`
	2. 若移除函数返回 `false` 调用实体 `dequeue` 函数，逻辑与插入相同，不进行赘叙
		1. 传递参数：`this`、`store`、`false`
	3. 将对应 ID 实体表赋值为 `nil` 移除实体

## 五、造成伤害逻辑
### [一] 创建伤害实体
1. 调用 `E:create_entity("damage")` 创建伤害实体表：
	1. 返回伤害实体表引用
		- 此后可以通过这个引用直接修改创建的实体表（使用 ID 不好索引），比如增加目标等

### [二] 将伤害插入伤害队列
1. 调用 `table.insert(store.damage_queue, 伤害)` 函数：
	1. 将伤害插入 `store.damage_queue` 伤害队列

#### 示例：
```lua
d = E:create_entity("damage")	-- 创建伤害实体
d.damage_type = DAMAGE_TRUE	-- 伤害类型设置为真伤，注意：修改的是创建的完全独立的伤害实体表

queue_damage(store, d)	-- 正式插入伤害，等价于 table.insert(store.damage_queue, d)
```

### [三] 调用驱动函数
1. 调用血量更新函数 `sys.health:on_update`：
	1. 若伤害队列非空，遍历伤害队列，使其中没有造成伤害的伤害，进行下一步
	2. 在 `store` 索引目标的 ID（`target_id`）
	3. 调用 `U.predict_damage` 函数计算伤害大小（计算护甲与伤害类型的影响）
	4. 造成伤害

## 六、造成效果逻辑
与插入实体相同

### [一] 创建效果时调用 `sys.mod_lifecycle:on_insert` 函数
1. 若没有 `modifier` 键则直接返回 `true`
	- `true` 将跳过插入实体
	- `false` 正常插入
2. 筛选出所有具有**相同目标的效果**
3. 若**当前效果被其他相同目标的效果 ban** 则直接返回 `false`
4. 遍历所有具有相同目标的效果
	1. 若当前效果的 `modifier.remove_banned` 键值为 `true` 则：
		1. 移除被 ban 其他相同目标的效果
		2. 将 `modifier.removed_by_ban` 键的键赋值为 `true`
5. 再次遍历所有具有相同目标的效果
	1. 若 `modifier.allows_duplicates` 键值为 `true` 则返回 `true`（中断遍历）
	2. 若 `modifier.replaces_lower` 键值为 `true` 则：
		1. 将其他相同目标的效果移除（继续遍历）
	3. 若 `modifier.resets_same` 键值为 `true` 则：
		1. 将其他相同目标的另一个效果的 `modifier.ts` 键赋值为当前时间戳
		2. 返回 `false` 
	4. 以上条件都不满足则直接返回 `false`
6. 最后以上代码都执行完毕返回 `true`

## 七、攻击逻辑
### [一] 调用实体的插入函数
1. 调用 `U.attack_order` 函数排序攻击：
	1. 遍历实体的攻击表（`melee / ranged.attacks`）
		1. **根据以下条件排序攻击表：**
			1. 概率不同，释放概率低者在前
			2. 释放概率相同，冷却时间长者在前
			3. 所有条件相同，攻击序号在前者在前
	2. 返回到实体  `melee / ranged.order` 表
		- `melee / ranged.order` 默认值只有攻击 1，也就是说没有排序则只能使用普通攻击

### [二] 调用实体的更新函数
1. 调用 `SU.y_soldier_melee_block_and_attacks` 近战攻击函数：
	1. 调用 `SU.soldier_pick_melee_target` 函数寻找**拦截范围内的目标**：
		1. **返回目标**
	2. **无目标返回 `A_NO_TARGET`**
	3. 调用 `SU.soldier_pick_melee_attack` 函数遍历实体的 `melee.order` 表：
		1. 优先进行闪避攻击
		2. **按排序顺序返回可用攻击
			- 可用攻击：攻击没有禁用、攻击冷却完毕、标签没有被过滤、`fn_can` 函数返回 `true`、计算概率或调用 `fn_chance` 函数计算概率，返回可用攻击
			- `fn_can` 函数会传递：**调用这个函数的实体、`store`、攻击、目标**
			- `fn_chance` 函数传递内容同上
	4. **无可用攻击返回 `A_IN_COOLDOWN`**
	5. **根据攻击类型：单体攻击、多次攻击、近战范围攻击，调用对应攻击类型的函数**
		- 攻击函数就是最基础的造成伤害与造成效果、播放动画、处理共享冷却等，不进行赘叙
		- 单体攻击会调用 `SU.unit_dodges` 函数判断目标是否闪避此次攻击，若闪避将不会造成伤害
	6. **攻击完毕返回 `A_DONE`**

注意步骤内的缩进，返回值是上一层级的函数返回

### [三] 调用 `SU.y_soldier_ranged_attacks` 远程攻击函数（如果有）
1. 调用 `SU.soldier_pick_ranged_target_and_attack` 函数：
	1. 寻找攻击范围内的目标
	2. 遍历实体的 `ranged.order` 表（排序在前的优先）
	3. **同时返回目标与可用攻击**
		- 可用攻击：攻击没有禁用、攻击冷却完毕、标签没有被过滤、没有被筛选函数 `filter_fn` 过滤
		- 传递的参数同索敌的筛选函数（`v，origin`，实体表与圆心坐标）
	4. **无目标返回 `A_NO_TARGET`**
	5. **无可用攻击返回 `A_IN_COOLDOWN`**
2. 根据攻击类型：单体攻击、多次攻击，**调用对应攻击类型的函数**
3. 创建子弹实体
4. **攻击完毕返回 `A_DONE`**

### [四] 子弹造成伤害
1. 调用子弹的更新函数：
	1. 计算子弹飞行轨迹，抛物线（箭矢），直线追踪（魔法弹）等
	2. 造成伤害与造成效果

## 八、闪避逻辑
### [一] 攻击时调用 `SU.unit_dodges` 闪避函数
1. **若目标闪避此次攻击**
	- 闪避：没有被眩晕、闪避冷却完毕、攻击的伤害类型没有 `DAMAGE_NO_DODGE`、计算概率、`can_dodge` 函数返回 `true`
	- `can_dodge` 函数会传递：**`store`、调用这个函数的实体、远程攻击、攻击、攻击来源**
	- 目标的 `dodge.active` 键的键值设为 `true`
2. 闪避返回 `true`，否则返回 `false`

### [二] 进行闪避攻击
1. 若 `dodge.counter_attack_pending` 为 `true` 则：
	1.  `soldier_pick_melee_attack` 函数返回 `dodge.counter_attack` 的攻击
2. `dodge.counter_attack_pending` 键的键值改为 `false`

注：**是否闪避是攻击者在判断，而不是目标**
攻击者 → 目标，目标闪避攻击 → 攻击者

## 九、士兵/敌人行为优先级：

`死亡（1） → 被控制（2） → 闪避（3） → 更换集结点（4） → 特殊待机（5） → 技能（6） → 特殊远程攻击（7）
→    近战攻击（8） →  远程攻击 (9) → 返回集结点 (10) → 待机 (11) → 脱战回血 (12)`

**注：**
1. 闪避优先级较高，如果有闪避动画，则会打断低优先级行为
2. 实现逻辑就是简单的判断，详见 `all/scripts.soldier_barrack.update` 函数

> 参考资料：
> [关于士兵是如何攻击的讨论 by天玑布可 -百度贴吧](https://tieba.baidu.com/p/9764441850)
