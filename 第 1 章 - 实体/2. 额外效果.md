# 修改伤害类型
在攻击组件可能找不到伤害类型，不妨先搜索 `E:add_comps` 的 `melee` 组件看看有没有默认值

在 `components` 搜索 `melee` 组件
![[Pasted image 20250630155536.png|675]]
如图发现没有伤害类型，继续往下在 `E:clone_c` 发现攻击 1 来自 `melee_attack`，继续搜索 `melee_attack`
![[Pasted image 20250630160301.png|675]]
**如图发现近战攻击是有伤害类型的，默认是物伤，也就是说英雄的近战攻击如果不填伤害类型，那么伤害类型就是物伤**

##### 2. 修改
由此可以这样修改：
```lua
-- 模板内
tt.melee.attacks[1].damage_type = DAMAGE_TRUE	-- 手动加上伤害类型键，然后键值写伤害类型就行
```
伤害类型见 [[第 2 章 - 进阶/1. 常量#一、伤害类型]]

- **其他诸如魔抗等同理，可以通过以上方法改**（看看有没有默认值）
- 重点搜索 `E:register_t` / `E:add_comps` / `E:clone_c` 的组件或模板

# 状态效果
造成的所有正面以及负面效果统称为状态效果（**modifiers**，缩写 mod）

##### 1. 增加效果
1. 近战攻击直接在攻击后面增加 `mod` 键
2. 远程攻击增加到子弹模板的 `bullet` 键上，个别子弹无效（函数无实现）
3. 技能能不能增加，增加到哪里取决于函数，后面修改函数再解释
```lua
-- 单位模板内
tt.melee.attacks[1].mod = 效果模板名: str

-- 子弹模板内
tt.bullet.mod = 效果模板名: str
```

###### 示例：
```lua
-- 单位模板内
tt.melee.attacks[1].mod = "mod_lava"	-- 普通近战攻击造成燃烧效果

-- 子弹模板内
tt.bullet.mod = "mod_lava"	-- 子弹造成燃烧效果
```

##### 2. 五代的问题
- **注意：由于五代所有新加的键不会被读取所以必须写在 `game_templates` 内，写在 `balance` 是不会生效的**
**不嫌麻烦可以让新键的键值也读取 `balance`**

```lua
-- balance 模块内
hero_spider = {
	basic_melee = {			-- 普通近战攻击
		mod = "mod_lava",	-- mod
		...					-- 其他键值对，攻击速度等
	}
}

-- game_templates 模块内
b = balance.heroes.hero_spider
tt.melee.attacks[1].mod = b.basic_melee.mod	-- 读取 balance 内的表
```

##### Q&A：
- Q：为什么攻击可以直接增加效果，而技能不行
- A：因为近战攻击与远程攻击用的对应函数都有造成效果的实现，而技能是单独的逻辑不一定有
- Q：如何造成多个效果
- A：只有光环和远程攻击有造成多个效果的实现，方法：
```lua
-- 子弹
tt.bullet.mod = {	-- 注：是 mod，而不是 mods
	效果模板名 1: str,
	-- 效果模板名 2...
}

-- 光环
tt.aura.mods = {	-- 注：是 mods，而不是 mod
	效果模板名 1: str,
	-- 效果模板名 1...
}
```

### [一] 与指定效果不可叠加
即 **A 禁止 B，有 A 不能有 B，有 B 可以有 A。AB 互相禁止，有 A 不能有 B，有 B 不能有 A**
```lua
tt.modifier.bans = {		-- 禁止的效果模板名
	效果模板名 1: str,
	-- 效果模板名 2...
}
tt.modifier.ban_types = {	-- 禁止的效果类型，可选
	效果类型 1: int,
	-- 效果类型 2...
}
```

##### 示例：
```lua
tt.modifier.bans = {		-- 禁止的效果模板名
	"mod_freeze",			-- 若目标上有燃烧效果，目标将不会被冻结
	...
}
tt.modifier.ban_types = {	-- 禁止的效果类型
	MOD_TYPE_FREEZE,		--  若目标上有燃烧效果，目标将不会被冻结类型的所有 mod 冻结
	...
}
```

### [二] 移除禁止的效果
```lua
tt.modifier.remove_banned = 是否移除禁止的效果: bool
```
- 注：不可叠加优先级高于此，如果 A 禁止 B，且 B 移除 A，B 将会被禁止

##### 示例：
```lua
-- 燃烧效果模板内
tt.modifier.remove_banned = true
tt.modifier.bans = {
	"mod_freeze",	-- 如果目标上有冻结效果，移除其，且无法与冻结叠加
	...
} 
tt.modifier.ban_types = {
	MOD_TYPE_FREEZE,	-- 如果目标上有冻结类型的效果，移除其，且无法与冻结叠加
	...
}
```

### [三] 多个相同效果叠加
三种模式（三选一）：
```lua
tt.modifier.allows_duplicates = 叠加: bool
tt.modifier.replaces_lower = 替换: bool
tt.modifier.resets_same = 重置: bool
```

##### 示例：
```lua
-- 燃烧效果模板内
tt.modifier.allows_duplicates = true	-- 可叠加多个燃烧
```

# 范围攻击
```lua
tt.melee.attacks[1] = E:clone_c ("area_attack")
tt.melee.attacks[1].damage_radius = 伤害范围: num
tt.melee.attacks[1].count = 最大目标数?: int
tt.melee.attacks[1].min_count = 释放限制;敌人数量?: int
```

示例：
```lua
tt.melee.attacks[1] = E:clone_c ("area_attack")
tt.melee.attacks[1].damage_radius = 25	-- 伤害范围 25 码，必要
tt.melee.attacks[1].count = 3			-- 最多对三名敌人造成伤害
tt.melee.attacks[1].min_count = 2		-- 需要两名敌人才能进行这个攻击
```

# 多次攻击
```lua
-- 近战攻击
tt.melee.attacks[1].animations = {
	开始时的动画名: str|nil,
	连续攻击时的动画: str|nil,
	结束时的动画名: str|nil
}
tt.melee.attaks[1].loops = 连续攻击次数: int
tt.melee.attaks[1].hit_times = 一次攻击的次数（可指定间隔）: table{ 间隔: num, ... }

tt.ranged.attacks[1].animations = {
	开始时的动画名: str|nil,
	连续攻击时的动画: str|nil,
	结束时的动画名: str|nil
}
tt.ranged.attaks[1].loops = 连续攻击次数: int
tt.ranged.attaks[1].shoot_times = 一次攻击的次数（可指定间隔）: table{ 间隔: num, ... }
```
注：`loops` 键的键值必须要有值， `hit_times` 和 `shoot_times` 才会生效
- 可以理解成乘算，`loops` 为 0 不攻击： `攻击次数 = loops × hit_times/shoot_times`

示例：
```lua
tt.melee.attacks[1].animations = {
	nil,	-- 开始动画
	"attack",	-- 连续攻击时的动画，复用普通近战攻击动画
	nil	-- 结束动画
}
tt.melee.attaks[1].loops = 2	-- 连续攻击 2 次
tt.melee.attaks[1].hit_times = { fts(10), fts(15) }	-- 一次攻击两次，第一次间隔 10 帧，第二次间隔 15 帧

tt.ranged.attacks[1].animations = {
	nil,
	"shoot",	-- 复用普通远程攻击动画
	nil
}
tt.ranged.attaks[1].loops = 2
tt.ranged.attaks[1].shoot_times = { fts(10), fts(15) }	-- 一次攻击两次，第一次间隔 10 帧，第二次间隔 15 帧
```

# 子弹携带实体
**主要目的**：让远程攻击的子弹落地后原地生成实体

```lua
-- 子弹模板
tt.bullet.hit_payload = 实体模板名: str
```

示例：
```lua
tt.bullet.hit_payload = "decal_bolin_mine"		-- 波林扔地雷
```

# 闪避
```lua
E:add_comps(tt, "dodge", ...)	-- 增加闪避组件
tt.dodge.chance = 闪避概率: num
tt.dodge.silent = 是否有动画?: bool
```

示例：
```lua
E:add_comps(tt, "dodge", ...)	-- 增加闪避组件
tt.dodge.chance = 0.25			-- 闪避概率 25 %
tt.dodge.silent = true			-- 无动画
```

# 目标过滤
**主要目的**：让单位不会被某些类型的攻击攻击

```lua
-- 某个单位模板
tt.vis.bans = 这个实体禁止的标签: int
tt.vis.flags = 这个实体拥有的标签: int
tt.ranged.attacks[1].vis_bans = 这个攻击禁止的标签: int
tt.ranged.attacks[1].vis_flags = 这个攻击拥有的标签: int
```

满足以下两个条件目标将会被过滤：
1. 标签被攻击过滤
2. 攻击标签被目标过滤

**可以通过位运算来增加多个标签，位运算见** [[第 2 章 - 进阶/1. 常量#二 位运算]]

##### 示例：
```lua
-- 某个单位模板
tt.vis.bans = F_RANGED	-- 不会被远程攻击
tt.ranged.attacks[1].vis_bans = bor(F_BOSS, F_FLYING)	-- 远程攻击不攻击 boss 与飞行敌人
tt.ranged.attacks[1].vis_flags = F_RANGED				-- 远程攻击标签
```
