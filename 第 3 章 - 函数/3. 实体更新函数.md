# (一) 重要要点
##### 1. 计算时间
计算时间常用到 `store.tick_ts` 与 `ts`（时间戳）

示例：
```lua
a = this.timed_attacks.list[1]	-- 某个技能

if store.tick_ts - a.ts > a.cooldown then
	a.ts = store.tick_ts	-- 表示已释放技能，刷新 a 的时间戳
	-- 造成伤害等逻辑
...
```
表示如果**当前时间**与**上次释放技能 `a` 的时间戳** 之差**大于冷却时间**，则执行条件代码块
换句话说就是**上次释放技能过去的时间**大于冷却时间

持续时间等同理

##### 2. 索敌


##### 3. 攻击
`SU.y_soldier_melee_block_and_attacks(store, this)` 近战攻击函数

`y_soldier_ranged_attacks` 远程攻击函数

无目标返回 `A_NO_TARGET`
无可用攻击返回 `A_IN_COOLDOWN
攻击完毕 `A_DONE`

**可以通过返回值判断攻击的状态，来执行某些代码块**

`SU.y_soldier_ranged_attacks(store, this)` 远程攻击函数

##### 4. 挂起协程
`coroutine.yield()` `while` 循环末尾必须挂起协程，否则会卡死程序

##### 5. 造成伤害与 mod 以及召唤实体
造成伤害、mod，以及创建实体使用的都是 `E:create_entity` 函数

最后需要插入队列

# (二) 技能造成 mod
找到技能造成伤害的代码块，在后面加上造成 mod 即可

以给火男烈焰冲击增加燃烧 mod 为例
```lua
-- 更新函数内
a = this.timed_attacks.list[1]
skill = this.hero.skills.flaming_frenzy

if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts >= a.cooldown then	-- 计算冷却时间
...
	targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags,
	a.vis_bans)	-- 索敌

	if targets then	-- 如果找到敌人
		for _, t in pairs(targets) do	-- 范围伤害要遍历找到的所有敌人，单体没有遍历这一步
			local d = E:create_entity("damage")	-- 造成伤害
			d.damage_type = a.damage_type	-- 伤害类型
			d.source_id = this.id	-- 所有者 id
			d.target_id = t.id	-- 目标 id
			d.value = math.random(a.damage_min, a.damage_max)	-- 具体伤害

			queue_damage(store, d)	-- 插入伤害队列

			-- 造成 mod
			local mod = E:create_entity(a.mod)	-- 也就是 this.timed_attacks.list[1].mod
			mod.modifier.target_id = t.id	-- 目标 id，注：变量不要用错
			mod.modifier.source_id = this.id	-- 来源 id

			queue_insert(store, mod)	-- 插入实体队列

		end
	end
...

-- 模板内
tt.timed_attacks.list[1].mod = "mod_lava_ignus"	-- 造成这个 mod

local mod_lava = E:register_t("mod_lava_ignus", "mod_lava")
mod_lava.dps.damage_inc = 2	-- 修改伤害
```

# (三) 索敌
## 一、过滤函数
```lua
target = U.find_foremost_enemy(..., function(v, origin)	-- v 会传递实体表，origin 会传递原点
	...	-- 函数体
	return v.health.hp >= 1000	-- 寻找血量大于等于 1000 的敌人
end, ...)	
```

## 二、寻找血量最高的敌人
```lua
local targets = U.find_enemies_in_range(store.entities, hero.pos, 0, a.radius, a.vis_flags, a.vis_bans)

if targets then
	table.sort(targets, function(e1, e2)
		return e1.health.hp > e2.health.hp	-- 根据血量排序，最终血量最高的会排序在最前
	end)
	
	local target = targets[1]	-- 取第一个目标
	...
```
当然也可以根据伤害、速度、护甲大小排序

## 四、实体攻击增加条件
### [一] 近战攻击
只需要给实体的模板的近战攻击增加 `fn_can` 键，键值为函数即可

以给鬼侍二技能灭魂斩增加血量释放条件为例：
```lua
-- 鬼侍模板内
tt.melee.attacks[3].trigger_min_hp = 150	-- 释放条件：目标血量大于等于 150
tt.melee.attacks[3].fn_can = scripts.hero_oni.fn_can_death_strike

-- game_scripts 模块内，最好和更新函数与插入函数写在同一个位置
function scripts.hero_oni.update(this, store)
... end

function scripts.hero_oni.fn_can_death_strike(this, store, a, target)
	return target.health.hp >= a.trigger_min_hp	-- 目标血量大于等于设定的血量时返回 true，表示可以释放
end
```

### [二] 远程攻击
给远程攻击增加 `filter_fn` 键，键值为函数即可

```lua
-- 模板内
tt.ranged.attacks[2].trigger_min_hp = 150	
tt.ranged.attacks[2].filter_fn = scripts.xxx.filter_fn_xxx

-- game_scripts 模块内，还是最好和更新函数与插入函数写在一个位置
function scripts.xxx.filter_fn_xxx(v, origin)
	return v.health.hp > trigger_min_hp	-- 寻找低于阈值的敌人
end
```

### [三] 让攻击概率根据条件而变化
给实体的模板的攻击增加 `fn_chance` 键，键值为函数即可

以给一代鬼侍二技能灭魂斩百分百秒杀处于流血状态为例：
```lua
-- 鬼侍模板内
-- 鬼侍近战攻击 2 是灭魂斩的秒杀，3 则是不秒杀的真伤
tt.melee.attacks[2].instakill_mod_type = MOD_TYPE_BLEED	-- mod：流血类型的 mod
tt.melee.attacks[2].fn_chance = scripts.hero_oni.fn_chance_death_strike

-- game_scripts 模块内，最好和鬼侍更新函数与插入函数写在一个位置
function scripts.hero_oni.update(this, store)
... end

function scripts.hero_oni.fn_chance_death_strike(this, store, a, target)
	return U.has_modifier_types(store, target, a.instakill_mod) or math.random() < attack.chance
	-- 目标拥有流血类型 mod 时返回 true，表示百分百概率，or 后面是原始计算概率逻辑
end
```

##### Q&A：
- Q：为什么 `fn_chance` 函数后面要加原始计算概率逻辑
- A：这是因为计算概率时会判断攻击有没有 `fn_chance` 函数，有则用 `fn_chance` 函数，没有则用这个原始计算概率逻辑，两个不能同时存在，所以需要单独增加

## 五、近战与远程攻击同时进行
```lua
-- 某个可以远程攻击单位的更新函数内
...
if this.unit.is_stunned then	-- 处于眩晕状态原地待机
	SU.soldier_idle(store, this)
else
	brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)	-- 调用近战攻击函数
	-- brk 就是跳出 break 缩写，sta 就是状态 status
	
	if brk or sta ~= A_NO_TARGET then	-- 近战攻击跳出，或近战攻击有目标，跳过远程攻击
		-- block empty
	else	-- 近战攻击未跳出，且无目标
		brk, sta = SU.y_soldier_ranged_attacks(store, this)	-- 调用远程攻击函数
		if brk then	-- 远程攻击跳出，跳过
			-- block empty
		elseif SU.soldier_go_back_step(store, this) then	-- 正在返回集结点，跳过
			-- block empty
		else	-- 远程攻击成功，脱战
			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end
	end
end

::label_43_0::	-- 标志，用于代码之间的跳转
coroutine.yield()
```
通过观察函数发现：**远程攻击和近战攻击一次只能触发一个**，并且远程攻击优先级低于近战攻击，由此可以通过修改代码让远程和近战攻击**同时都可以触发**，使近战与远程攻击同时进行

将以上代码修改为以下即可：
```lua
...
if this.unit.is_stunned then
	SU.soldier_idle(store, this)
else
	brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)

	if brk then	-- 近战攻击跳出
		goto 挂起协程	-- 直接跳到挂起协程部分
	end

	brk, sta = SU.y_soldier_ranged_attacks(store, this)

	if brk or sta == A_DONE then	-- 远程攻击跳出，或攻击完毕
		goto 挂起协程
	elseif sta == A_IN_COOLDOWN then	-- 远程攻击未跳出，并且在冷却
		goto 脱战
	end

	if SU.soldier_go_back_step(store, this) then
		goto 挂起协程
	end

	::脱战::	--可以自己改个标志
	SU.soldier_idle(store, this)
	SU.soldier_regen(store, this)
end

::挂起协程::
coroutine.yield()
```

## 六、增加新攻击与技能
### [一] 使攻击概率造成 mod
##### 1. 在模板增加一个新攻击
同时复制要概率造成 mod 的攻击，增加 mod 与概率键

```lua
-- 模板内
tt.melee.attacks[3] = table.deepclone(tt.melee.attacks[1])
tt.melee.attacks[3].chance = 0.33	-- 概率
tt.melee.attacks[3].mod = ...	-- mod
```
**注**：
1. 一个攻击的多个不同动画也是这样实现的，所以有些攻击可能有两三个，看着是不同的攻击，实际只是动画不同
2. **需要重点关注攻击顺序对实际释放概率的影响**
3. 只有能升级（有升级函数）的单位才需要修改升级函数

由于技能加点属性表最后会根据等级赋值到对应属性键上，所以直接复制攻击是得不到属性表的属性的，此时就需要修改升级函数，让属性表最后也会赋值到新攻击上
```lua
-- 升级函数内
local hl = this.hero.level
local ls = this.hero.level_stats
...
this.melee.attacks[3].damage_min = ls.melee_damage_min[hl]
this.melee.attacks[3].damage_max = ls.melee_damage_max[hl]
...
```

##### Q&A：
- Q：为什么可以通过增加另一个攻击来让一个攻击概率造成 mod
- A：这是因为攻击优先级是概率低的优先

#### {一} 防御塔攻击修改方法
由于防御塔的攻击大多数在更新函数使用的都是独立代码块并且没有概率相关的逻辑，所以需要自己写逻辑

假设增加的是攻击 4，想让普攻概率造成 mod
```lua
while true do
...
	if this.tower.blocked then
		coroutine.yield ()
	else
		for i, aa in pairs(attacks) do
			-- 若进行普攻则计算概率，然后将普攻改成攻击 4
			if aa == this.attacks.list[1] and math.random () <= this.attacks.list[4].chance then
				aa = this.attacks.list[4]
			end
		end
...
```

### [二] 增加新技能
以给尼鲁增加一个技能：每 275 秒增加 1 生命（升级二技能翠绿迸发解锁）为例

```lua
-- 尼鲁模板内
tt.hero.skills.heal_live = E:clone_c("hero_skill")	-- 复制英雄技能组件，防御塔与其他单位技能组件是 power
tt.hero.skills.heal_live.cooldown = {	-- 增加属性表：冷却时间
	275,	-- 一级冷却时间 275 秒
	245,	-- 三级冷却时间 245 秒
	210		-- 三级冷却时间 210 秒
}

tt.timed_attacks.list[5] = E:clone_c("custom_attack")	-- 复制自定义技能组件，尼鲁只有四个技能所以序号是 5
tt.timed_attacks.list[5].animation = "fairy_dust"	-- 动画套用四技能衰弱咒语，当然也可以套用其他技能，注意：只能用当前实体有的动画，否则将会报错
tt.timed_attacks.list[5].sound = "HeroNyruFairyDustCast"	-- 音效，也是借用衰弱咒语
tt.timed_attacks.list[5].cooldown = nil		-- 默认冷却时间，因为属性表已经有了所以不需要，其他键处理方法相同
tt.timed_attacks.list[5].disabled = true	-- 默认禁用	
tt.timed_attacks.list[5].heal_live = 1		-- 增加生命数量

-- 尼鲁升级函数
s = this.hero.skills.verdant_blast	-- 目前不能做到增加 UI，但是可以先借用其他技能，当然你也可以直接根据等级来实现
sl = s.level

if sl > 0 and initial then
	...
	local a = this.timed_attacks.list[5]
	a.cooldown = this.hero.skills.heal_live.cooldown[sl]	-- 根据翠绿迸发技能等级决定冷却时间，对应属性表
	a.disabled = nil	-- 解除禁用
end

-- 尼鲁更新函数内
while true do
	...
	if h.dead then
		SU.y_hero_death_and_respawn(store, this)
	end
	if this.unit.is_stunned then
		SU.soldier_idle(store, this)
	else
		a = this.timed_attacks.list[5]
		skill = this.hero.skills.heal_live

		if not a.disabled and store.tick_ts - a.ts > a.cooldown then	-- 计算冷却时间
			a.ts = store.tick_ts	-- 刷新时间戳
			U.animation_start(this, a.animation, nil, store.tick_ts)	-- 播放动画
			S:queue(a.sound)	-- 播放音效
			
			store.lives = store.lives + a.heal_live	-- 增加生命，注：生命，金币都存在 store

			SU.y_hero_animation_wait(this)	-- 等待动画完成
		end
		...
	end
	...
end
```

### [三] 闪避攻击
**通过查看逻辑知道：主要是通过 `dodge.active` 键来判断是否闪避，以及 `dodge.counter_attack_pending` 键来判断是否进行闪避攻击的**

由此可以在单位的更新函数判断闪避，然后将 `dodge.counter_attack_pending` 键的键值改为 `true`，在模板 `dodge.counter_attack` 键写上攻击即可

```lua
-- 某个单位的更新函数内
while true do
	if h.dead then
		SU.y_hero_death_and_respawn(store, this)
	end

	if this.unit.is_stunned then
		SU.soldier_idle(store, this)
	else
		if this.dodge and this.dodge.active then	-- 判断闪避
			this.dodge.active = false	-- 重置状态
			this.dodge.counter_attack_pending = true
			...	-- 注：后面可以增加其他逻辑
		end
	end
	...
end

-- 模板内
tt.dodge.counter_attack = E:clone_c("melee_attack")
tt.dodge.counter_attack.animation = "attack"
tt.dodge.counter_attack.sound = "MeleeSword"	-- 动画和音效可以套用普通攻击的
...	-- 增加伤害类型，伤害这些，与攻击同理
```

#### {一} 增加闪避条件
与攻击相同，不进行赘叙，增加 `can_dodge` 键，然后写函数即可

函数与攻击写法相同但是**会传递 `store, this`、远程攻击、攻击、攻击来源给 `can_dodge`**

