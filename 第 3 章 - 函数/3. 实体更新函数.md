# 定义
随着游戏逻辑时间更新而调用（重启协程）的函数，称为更新函数（**update script**）

# 重要要点
##### 1. 计算时间
计算时间常用到 `store.tick_ts` （游戏时间）与 `ts`（时间戳）

示例：
```lua
a = this.timed_attacks.list[1]	-- 某个技能

if store.tick_ts - a.ts > a.cooldown then
	a.ts = store.tick_ts	-- 表示已释放技能，刷新 a 的时间戳
	-- 造成伤害等逻辑
...
```
表示如果**当前时间**与**上次释放技能 `a` 的时间戳**之差**大于冷却时间**，则执行条件代码块
换句话说就是**上次释放技能过去的时间**大于冷却时间

##### 2. 攻击
`y_soldier_melee_block_and_attacks` 为近战攻击函数

`y_soldier_ranged_attacks` 为远程攻击函数

无目标返回 `A_NO_TARGET`
无可用攻击返回 `A_IN_COOLDOWN
攻击完毕 `A_DONE`

**可以通过返回值判断攻击的状态，来执行代码块**

##### 3. 挂起协程
作用：挂起协程 `coroutine.yield()`  主要用于更新函数循环内，用于暂停循环（协程）运行其他代码
示例：
```lua
function scripts.a.update(this, store)
	while true do
		print("a 死循环中...")
		coroutine.yield()		-- 如果不挂起协程程序将会一直打印 “a 死循环中...” 无法运行其他任何代码，将会卡死程序
	end
end
```

##### 4. 造成伤害与效果以及召唤实体
造成伤害、mod，以及创建实体使用的都是 `E:create_entity` 函数

并且最后会插入队列

# 技能造成效果
找到技能造成伤害的部分，在后面加上造成效果的逻辑即可

以给火男烈焰冲击增加燃烧效果为例

- 模板内：
```lua
tt.timed_attacks.list[1].mod = "mod_lava_ignus"	-- 造成这个效果

local mod_lava = E:register_t("mod_lava_ignus", "mod_lava")
mod_lava.dps.damage_inc = 2	-- 修改燃烧伤害
```

- 更新函数内：
```lua
a = this.timed_attacks.list[1]
skill = this.hero.skills.flaming_frenzy

if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts >= a.cooldown then	-- 计算冷却时间
...
	targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags,
	a.vis_bans)	-- 索敌

	if targets then	-- 如果找到敌人
		for _, t in pairs(targets) do		-- 范围伤害要遍历找到的所有敌人，单体没有遍历这一步
			local d = E:create_entity("damage")		-- 造成伤害
			d.damage_type = a.damage_type	-- 伤害类型
			d.source_id = this.id			-- 所有者 id
			d.target_id = t.id				-- 目标 id
			d.value = math.random(a.damage_min, a.damage_max)	-- 具体伤害

			queue_damage(store, d)			-- 插入伤害队列

			-- 造成效果
			local mod = E:create_entity(a.mod)	-- 也就是 this.timed_attacks.list[1].mod
			mod.modifier.target_id = t.id		-- 目标 id，注：变量不要用错
			mod.modifier.source_id = this.id	-- 来源 id

			queue_insert(store, mod)			-- 插入实体队列

		end
	end
...
```

# 索敌
## 一、过滤函数
```lua
target = U.find_foremost_enemy(..., function(v, origin)	-- v 会传递实体表，origin 会传递原点
	...	-- 函数体
	return v.health.hp >= 1000	-- 寻找血量大于等于 1000 的敌人
end, ...)	
```

## 二、寻找血量最高的敌人
```lua
local targets = U.find_enemies_in_range(store.entities, hero.pos, 0, a.radius, a.vis_flags, a.vis_bans)

if targets then
	table.sort(targets, function(e1, e2)
		return e1.health.hp > e2.health.hp	-- 根据血量排序，血量最高的排序在最前
	end)
	
	local target = targets[1]	-- 取第一个目标
	...
```
当然也可以根据伤害、速度、护甲大小排序
