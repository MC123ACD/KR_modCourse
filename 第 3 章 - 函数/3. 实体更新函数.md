# 定义
随着游戏逻辑时间更新而调用的函数，称为更新函数（**update script**）

# 重要要点
##### 1. 计算时间
计算时间常用到 `store.tick_ts` 与 `ts`（时间戳）

示例：
```lua
a = this.timed_attacks.list[1]	-- 某个技能

if store.tick_ts - a.ts > a.cooldown then
	a.ts = store.tick_ts	-- 表示已释放技能，刷新 a 的时间戳
	-- 造成伤害等逻辑
...
```
表示如果**当前时间**与**上次释放技能 `a` 的时间戳** 之差**大于冷却时间**，则执行条件代码块
换句话说就是**上次释放技能过去的时间**大于冷却时间

持续时间等同理

##### 2. 攻击
`y_soldier_melee_block_and_attacks` 为近战攻击函数

`y_soldier_ranged_attacks` 为远程攻击函数

无目标返回 `A_NO_TARGET`
无可用攻击返回 `A_IN_COOLDOWN
攻击完毕 `A_DONE`

**可以通过返回值判断攻击的状态，来执行代码块**

##### 3. 挂起协程
`coroutine.yield()` `while` 循环末尾必须挂起协程，否则会卡死程序

##### 4. 造成伤害与 mod 以及召唤实体
造成伤害、mod，以及创建实体使用的都是 `E:create_entity` 函数

并且最后会插入队列

# 技能造成 mod
找到技能造成伤害的部分，在后面加上造成 mod 逻辑即可

以给火男烈焰冲击增加燃烧 mod 为例

- 模板内：
```lua
tt.timed_attacks.list[1].mod = "mod_lava_ignus"	-- 造成这个 mod

local mod_lava = E:register_t("mod_lava_ignus", "mod_lava")
mod_lava.dps.damage_inc = 2	-- 修改伤害
```

- 更新函数内：
```lua
a = this.timed_attacks.list[1]
skill = this.hero.skills.flaming_frenzy

if sta ~= A_NO_TARGET and not a.disabled and store.tick_ts - a.ts >= a.cooldown then	-- 计算冷却时间
...
	targets = U.find_enemies_in_range(store.entities, this.pos, 0, a.max_range, a.vis_flags,
	a.vis_bans)	-- 索敌

	if targets then	-- 如果找到敌人
		for _, t in pairs(targets) do		-- 范围伤害要遍历找到的所有敌人，单体没有遍历这一步
			local d = E:create_entity("damage")		-- 造成伤害
			d.damage_type = a.damage_type	-- 伤害类型
			d.source_id = this.id			-- 所有者 id
			d.target_id = t.id				-- 目标 id
			d.value = math.random(a.damage_min, a.damage_max)	-- 具体伤害

			queue_damage(store, d)			-- 插入伤害队列

			-- 造成 mod
			local mod = E:create_entity(a.mod)	-- 也就是 this.timed_attacks.list[1].mod
			mod.modifier.target_id = t.id		-- 目标 id，注：变量不要用错
			mod.modifier.source_id = this.id	-- 来源 id

			queue_insert(store, mod)			-- 插入实体队列

		end
	end
...
```

# 索敌
## 一、过滤函数
```lua
target = U.find_foremost_enemy(..., function(v, origin)	-- v 会传递实体表，origin 会传递原点
	...	-- 函数体
	return v.health.hp >= 1000	-- 寻找血量大于等于 1000 的敌人
end, ...)	
```

## 二、寻找血量最高的敌人
```lua
local targets = U.find_enemies_in_range(store.entities, hero.pos, 0, a.radius, a.vis_flags, a.vis_bans)

if targets then
	table.sort(targets, function(e1, e2)
		return e1.health.hp > e2.health.hp	-- 根据血量排序，血量最高的排序在最前
	end)
	
	local target = targets[1]	-- 取第一个目标
	...
```
当然也可以根据伤害、速度、护甲大小排序

## 四、实体攻击增加条件
### [一] 近战攻击条件
使用 `fn_can: func` 键

- 模板内：
```lua
tt.melee.attacks[2].trigger_min_hp = 150	-- 释放条件：目标血量大于等于 150
tt.melee.attacks[2].fn_can = scripts.xxx.melee_fn_can_2
```

- `game_scripts` 内：
```lua
function scripts.xxx.update(this, store)
... end

-- 最好和更新函数与插入函数写在同一个位置
function scripts.xxx.melee_fn_can_2(this, store, a, target)
	return target.health.hp >= a.trigger_min_hp	-- 目标血量大于等于设定的血量时返回真，表示可以释放
end
```

### [二] 远程攻击条件
使用 `filter_fn: func` 键

- 模板内：
```lua
tt.ranged.attacks[2].trigger_min_hp = 150	
tt.ranged.attacks[2].filter_fn = scripts.xxx.melee_filter_fn_2
```

- `game_scripts` 内：
```lua
function scripts.xxx.melee_filter_fn_2(v, origin)
	return v.health.hp > trigger_min_hp	-- 寻找低于阈值的敌人
end
```

### [三] 概率根据条件而变化
使用 `fn_chance` 键

以使鬼侍灭魂斩 100% 秒杀处于流血 mod 的目标为例：

- 模板内：
```lua
-- 鬼侍近战攻击 2 是灭魂斩的秒杀，3 则是灭魂斩不秒杀的真伤
tt.melee.attacks[2].instakill_mod_type = MOD_TYPE_BLEED	-- mod：流血类型的 mod
tt.melee.attacks[2].fn_chance = scripts.hero_oni.fn_chance_death_strike

-- game_scripts 模块内，最好和鬼侍更新函数与插入函数写在一个位置

```

- `game_scripts` 内：
```lua
function scripts.hero_oni.update(this, store)
... end

function scripts.hero_oni.fn_chance_death_strike(this, store, a, target)
	-- 目标拥有流血类型 mod 时返回真，表示百分百概率，or 后面是原始计算概率逻辑
	return U.has_modifier_types(store, target, a.instakill_mod) or math.random() < attack.chance
end
```

##### Q&A：
- Q：为什么 `fn_chance` 函数后面要加原始计算概率逻辑
- A：这是因为计算概率时会判断攻击有没有 `fn_chance` 函数，有则用 `fn_chance` 函数，没有则用这个原始计算概率逻辑，两个不能同时存在，所以需要单独增加

## 五、近战与远程攻击同时进行
```lua
...
if this.unit.is_stunned then	-- 处于眩晕状态原地待机
	SU.soldier_idle(store, this)
else
	brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)	-- 调用近战攻击函数
	-- brk 就是跳出 break 缩写，sta 就是状态 status
	
	-- 关键点
	if brk or sta ~= A_NO_TARGET then	-- 近战攻击跳出或近战攻击有目标，跳过远程攻击
		-- block empty，无用代码仅占位
	else
		brk, sta = SU.y_soldier_ranged_attacks(store, this)	-- 调用远程攻击函数
		
		if brk then	-- 远程攻击跳出，跳过脱战
			-- block empty
		elseif SU.soldier_go_back_step(store, this) then	-- 正在前往集结点，跳过脱战
			-- block empty
		else	-- 没有以上情况，脱战
			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end
	end
end

::label_43_0::	-- 标志，用于代码之间的跳转
coroutine.yield()
```
**思路**：由于近战攻击有目标，会跳过远程攻击

**由此得出思路：让近战攻击有目标时不跳过远程攻击，即删除 `or sta ~= A_NO_TARGET`**

## 六、增加新攻击与技能
### [一] 使攻击概率造成 mod
##### 1. 在模板增加一个新攻击
同时复制要概率造成 mod 的攻击，增加 mod 与概率键

```lua
-- 模板内
tt.melee.attacks[3] = table.deepclone(tt.melee.attacks[1])
tt.melee.attacks[3].chance = 0.33	-- 概率
tt.melee.attacks[3].mod = ...	-- mod
```
**注**：
1. 一个攻击的多个不同动画也是这样实现的，所以有些攻击可能有两三个，看着是不同的攻击，实际只是动画不同
2. **需要重点关注攻击顺序对实际释放概率的影响**
3. 只有能升级（有升级函数）的单位才需要修改升级函数

##### 2. 修改升级函数
由于这个属性表最后会根据等级赋值到对应属性键上，所以直接复制攻击是得不到的属性的，此时就需要修改升级函数，让属性也会赋值到新攻击上
```lua
...
this.melee.attacks[2].damage_min = ls.melee_damage_min[hl]
this.melee.attacks[2].damage_max = ls.melee_damage_max[hl]

-- 赋值到新攻击上
this.melee.attacks[3].damage_min = ls.melee_damage_min[hl]
this.melee.attacks[3].damage_max = ls.melee_damage_max[hl]
...
```

### [二] 防御塔攻击概率造成 mod
由于防御塔的攻击大多数在更新函数使用的都是独立代码块并且没有概率相关的逻辑，所以需要自己写逻辑

假设增加的是攻击 4，想让普攻概率造成 mod
```lua
...
	if this.tower.blocked then
		coroutine.yield ()
	else
		for i, aa in pairs(attacks) do
			-- 若进行攻击 1 则计算概率，然后将进行攻击 1 改成进行攻击 4
			if aa == this.attacks.list[1] and math.random () <= this.attacks.list[4].chance then
				aa = this.attacks.list[4]
			end
		end
...
```

### [三] 增加新技能
以给尼鲁增加一个技能：每 275 秒增加 1 生命（升级二技能翠绿迸发解锁）为例：

- 模板内：
```lua
tt.hero.skills.heal_live = E:clone_c("hero_skill")	-- 复制英雄技能组件，防御塔与其他单位技能组件是 power
tt.hero.skills.heal_live.cooldown = {	-- 增加属性表：冷却时间
	275,	-- 一级冷却时间 275 秒
	245,	-- 三级冷却时间 245 秒
	210		-- 三级冷却时间 210 秒
}
...
tt.timed_attacks.list[5] = E:clone_c("custom_attack")	-- 复制自定义技能组件，尼鲁只有四个技能所以序号是 5
tt.timed_attacks.list[5].animation = "fairy_dust"	-- 动画套用四技能衰弱咒语，当然也可以套用其他技能，注意：只能用当前实体有的动画，否则将会报错
tt.timed_attacks.list[5].sound = "HeroNyruFairyDustCast"	-- 音效，也是借用衰弱咒语
tt.timed_attacks.list[5].cooldown = nil		-- 默认冷却时间，因为属性表已经有了所以不需要，其他键处理方法相同
tt.timed_attacks.list[5].disabled = true	-- 默认禁用	
tt.timed_attacks.list[5].heal_live = 1		-- 增加生命数量
```

- 升级函数内：
```lua
s = this.hero.skills.verdant_blast	-- 根据翠绿迸发等级决定是否解锁新技能
sl = s.level

if sl > 0 and initial then
	...
	local a = this.timed_attacks.list[5]
	a.cooldown = this.hero.skills.heal_live.cooldown[sl]	-- 根据翠绿迸发技能等级决定冷却时间，对应属性表
	a.disabled = nil	-- 解除禁用
...
```

- 更新函数内：
```lua
...
if h.dead then
	SU.y_hero_death_and_respawn(store, this)
end

if this.unit.is_stunned then
	SU.soldier_idle(store, this)
else
	...
	a = this.timed_attacks.list[5]
	skill = this.hero.skills.heal_live

	if not a.disabled and store.tick_ts - a.ts > a.cooldown then	-- 计算冷却时间
		a.ts = store.tick_ts	-- 更新时间戳
		U.animation_start(this, a.animation, nil, store.tick_ts)	-- 播放动画
		S:queue(a.sound)	-- 播放音效
		
		store.lives = store.lives + a.heal_live	-- 增加生命

		SU.y_hero_animation_wait(this)	-- 等待动画完成
...
```

### [三] 闪避攻击
**思路**：通过查看逻辑知道：闪避后会将 `dodge.active` 键赋值为真，以及 `dodge.counter_attack_pending` 键来判断是否进行闪避攻击的

由此可以在单位的更新函数判断闪避，然后将 `dodge.counter_attack_pending` 键的键值改为 `true`，在模板 `dodge.counter_attack` 键写上攻击即可

- 模板内：
```lua
tt.dodge.counter_attack = E:clone_c("melee_attack")
tt.dodge.counter_attack.animation = "attack"
tt.dodge.counter_attack.sound = "MeleeSword"	-- 动画和音效可以套用普通攻击的
...	-- 增加伤害类型，伤害这些，与攻击同理
```

- 更新函数内：
```lua
...
if h.dead then
	SU.y_hero_death_and_respawn(store, this)
end

if this.unit.is_stunned then
	SU.soldier_idle(store, this)
else
	...
	if this.dodge and this.dodge.active then	-- 判断闪避
		this.dodge.active = false	-- 重置状态
		this.dodge.counter_attack_pending = true
		...	-- 注：后面可以增加其他逻辑
	end
end
...
```

#### {一} 增加闪避条件
使用 `can_dodge: func` 键

与攻击写法相同但是**会传递 `store, this`、远程攻击、攻击、攻击来源给 `can_dodge`**

