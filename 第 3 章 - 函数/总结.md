# (一) 函数存储位置
所有基础函数都存储在 `all/scripts` 模块
- 后续会通过 `kr/game_scripts` 模块动态向 `scripts` 模块增加实体的各种函数
- `all/script_utils`（简称 SU）用于存储用于实体的各种函数
- `all/utils`（简称 U）用于存储通用工具函数（索敌等）

# (二) 逻辑
注：调用流水线 `love` → `director` → `game` → `simulation` → `systems`（简称 sys）
前三代 `simulation` 位于 `all` 中，五代则是位于 `lib/klove` 中

## 一、驱动函数的逻辑：
### [一] 每帧调用驱动函数 `simulation:do_tick`
1. 更新逻辑时间（`store.tick_ts += 1`）
2. 处理实体插入与移除
3. 调用各种 `sys` 的更新函数

## 二、实体创建逻辑
所有实体最终都会创建到 `all/game.store.entities` 表中（`game.store` 简称 store）

### [一] 创建实体表
1. 调用 `E:create_entity(模板)` 函数：
	1. **深拷贝**模板，生成独立实体表（存储实体的各种数据）
	2. 分配唯一 ID（只增不减）
	3. 返回该实体表引用
2. 调用 `simulation.queue_insert_entity` 函数：
	1. 将实体表增加到 `store.pending_inserts`（待插入队列）

### [二] 处理待插入实体
1. 取出队列的实体表
2. 调用 `simulation:insert_entity` 函数
	1. 遍历并调用各种 `sys` 的插入函数
		1. 传递参数：创建的实体 `this`、`store`
		2. 若插入函数返回 `false` 则：
			1. 调用各种 `sys` 的 `dequeue` 函数
				1. 传递参数：`this`、`store`、`true`
				2. 直接返回，中断遍历
3. **以键值对 `[ID] = 实体表` 形式插入 `store.entities` 正式创建实体**

## 三、实体更新函数逻辑
### [一] 在驱动函数调用实体更新函数
1. 调用 `sys.main_script:on_update` 函数调度协程：
	1. **遍历所有有更新函数的实体**
	2. 若实体更新函数没有协程且没有运行过则创建更新函数的协程
	3. 重启协程
		1. **传递参数：更新函数对应协程、对应实体（this）、`store`、实体的函数表的引用**
		- 一般从更新函数的 `while` 重启

## 四、移除实体逻辑
### [一] 排队等待移除
1. 调用 `simulation.queue_remove_entity` 函数：
	1. 将实体表增加到 `store.pending_removals`（待移除队列）中

### [二] 处理待移除实体
1. 取出队列的实体表
2. 调用 `simulation:remove_entity` 函数移除实体
	1. 调用各种 `sys` 的移除函数
		1. 传递参数：`this`、`store`
	2. 若移除函数返回 `false` 调用实体 `dequeue` 函数，逻辑与插入相同，不进行赘叙
		1. 传递参数：`this`、`store`、`false`
	3. 将对应 ID 实体表赋值为 `nil` 移除实体

## 五、造成伤害逻辑
### [一] 创建伤害实体
1. 调用 `E:create_entity("damage")` 创建伤害实体表：
	1. 返回伤害实体表引用
		- 此后可以通过这个引用直接修改创建的实体表（使用 ID 不好索引），比如增加目标等

### [二] 将伤害插入伤害队列
1. 调用 `table.insert(store.damage_queue, 伤害)` 函数：
	1. 将伤害插入 `store.damage_queue` 伤害队列

#### 示例：
```lua
d = E:create_entity("damage")	-- 创建伤害实体
d.damage_type = DAMAGE_TRUE	-- 伤害类型设置为真伤，注意：修改的是创建的完全独立的伤害实体表

queue_damage(store, d)	-- 正式插入伤害，等价于 table.insert(store.damage_queue, d)
```

### [三] 调用驱动函数
1. 调用血量更新函数 `sys.health:on_update`：
	1. 若伤害队列非空，遍历伤害队列，使其中没有造成伤害的伤害，进行下一步
	2. 在 `store` 索引目标的 ID（`target_id`）
	3. 调用 `U.predict_damage` 函数计算伤害大小（计算护甲与伤害类型的影响）
	4. 造成伤害

## 六、造成 mod 逻辑
与插入实体相同

### [一] 创建 mod 时调用 `sys.mod_lifecycle:on_insert` 函数
1. 若没有 `modifier` 键则直接返回 `true`
	- `true` 将跳过插入实体
	- `false` 正常插入
2. 筛选出所有具有**相同目标的 mod**
3. 若**当前 mod 被其他相同目标的 mod 禁止** 则直接返回 `false`
4. 遍历所有具有相同目标的 mod
	1. 若当前 mod 的 `modifier.remove_banned` 键值为 `true` 则：
		1. 移除被禁止其他相同目标的 mod
		2. 将 `modifier.removed_by_ban` 键的键赋值为 `true`，表明被 ban 移除
5. 再次遍历所有具有相同目标的 mod
	1. 若 `modifier.allows_duplicates` 键值为 `true` 则返回 `true`（中断遍历）
	2. 若 `modifier.replaces_lower` 键值为 `true` 则：
		1. 将其他相同目标的 mod 移除
	3. 若 `modifier.resets_same` 键值为 `true` 则：
		1. 更新其他相同目标的另一个 mod 的时间戳
		2. 返回 `false` 
	4. 以上条件都不满足则直接返回 `false`
6. 最后以上代码都执行完毕返回 `true`

## 七、攻击逻辑
### [一] 调用实体的插入函数
1. 调用 `U.attack_order` 函数排序攻击：
	1. 遍历实体的攻击表（`melee / ranged.attacks`）
		1. **根据以下条件排序攻击表：**
			1. 概率不同，释放概率低者在前
			2. 释放概率相同，冷却时间长者在前
			3. 所有条件相同，攻击序号在前者在前
	2. 返回到实体  `melee / ranged.order` 表
		- `melee / ranged.order` 默认值只有攻击 1，也就是说没有排序则只能使用普通攻击

### [二] 调用实体的更新函数
1. 调用 `SU.y_soldier_melee_block_and_attacks` 近战攻击函数：
	1. 调用 `SU.soldier_pick_melee_target` 函数寻找**拦截范围内的目标**：
		1. **返回目标**
	2. **无目标返回 `A_NO_TARGET`**
	3. 调用 `SU.soldier_pick_melee_attack` 函数遍历实体的 `melee.order` 表：
		1. 优先进行闪避攻击
		2. **按排序顺序返回可用攻击
			- 可用攻击：攻击没有禁用、攻击冷却完毕、标签没有被过滤、`fn_can` 函数返回 `true`、计算概率或调用 `fn_chance` 函数计算概率，返回可用攻击
			- `fn_can` 函数会传递：**调用这个函数的实体、`store`、攻击、目标**
			- `fn_chance` 函数传递内容同上
	4. **无可用攻击返回 `A_IN_COOLDOWN`**
	5. **根据攻击类型：单体攻击、多次攻击、近战范围攻击，调用对应攻击类型的函数**
		- 攻击函数就是最基础的造成伤害与造成 mod、播放动画、处理共享冷却等，不进行赘叙
		- 单体攻击会调用 `SU.unit_dodges` 函数判断目标是否闪避此次攻击，若闪避将不会造成伤害
	6. **攻击完毕返回 `A_DONE`**

注意步骤内的缩进，返回值是上一层级的函数返回

### [三] 调用 `SU.y_soldier_ranged_attacks` 远程攻击函数（如果有）
1. 调用 `SU.soldier_pick_ranged_target_and_attack` 函数：
	1. 寻找攻击范围内的目标
	2. 遍历实体的 `ranged.order` 表（排序在前的优先）
	3. **同时返回目标与可用攻击**
		- 可用攻击：攻击没有禁用、攻击冷却完毕、标签没有被过滤、没有被筛选函数 `filter_fn` 过滤
		- 传递的参数同索敌的筛选函数（`v，origin`，实体表与圆心坐标）
	4. **无目标返回 `A_NO_TARGET`**
	5. **无可用攻击返回 `A_IN_COOLDOWN`**
2. 根据攻击类型：单体攻击、多次攻击，**调用对应攻击类型的函数**
3. 创建子弹实体
4. **攻击完毕返回 `A_DONE`**

### [四] 子弹造成伤害
1. 调用子弹的更新函数：
	1. 计算子弹飞行轨迹，抛物线（箭矢），直线追踪（魔法弹）等
	2. 造成伤害与造成 mod

## 八、闪避逻辑
### [一] 攻击时调用 `SU.unit_dodges` 闪避函数
1. **若目标闪避此次攻击**
	- 闪避：没有被眩晕、闪避冷却完毕、攻击的伤害类型没有 `DAMAGE_NO_DODGE`、计算概率、`can_dodge` 函数返回 `true`
	- `can_dodge` 函数会传递：**`store`、调用这个函数的实体、远程攻击、攻击、攻击来源**
	- 目标的 `dodge.active` 键的键值设为 `true`
2. 闪避返回 `true`，否则返回 `false`

### [二] 进行闪避攻击
1. 若 `dodge.counter_attack_pending` 为 `true` 则：
	1.  `soldier_pick_melee_attack` 函数返回 `dodge.counter_attack` 的攻击
2. `dodge.counter_attack_pending` 键的键值改为 `false`

注：**是否闪避是攻击者在判断，而不是目标**
攻击者 → 目标，目标闪避攻击 → 攻击者

## 九、士兵/敌人行为优先级：

`死亡（1） → 被控制（2） → 闪避（3） → 更换集结点（4） → 特殊待机（5） → 技能（6） → 特殊远程攻击（7）
→    近战攻击（8） →  远程攻击 (9) → 返回集结点 (10) → 待机 (11) → 脱战回血 (12) `

**注：**
1. 闪避优先级较高，如有闪避动画，则会打断低优先级行为
2. 实现逻辑就是简单的判断，详见 `all/scripts.soldier_barrack.update` 函数

> 参考资料：
> [关于士兵是如何攻击的讨论 by天玑布可 -百度贴吧](https://tieba.baidu.com/p/9764441850)

# (三) 脚本函数


# (四) 工具函数
## 一、索敌
几乎所有索敌本质都是在一定范围索敌
也就是说基本所有索敌都是在范围索敌的基础上增加一些代码而来的（图片是游戏自带调试模式的功能，快捷键 b）
![[Pasted image 20250705124548.png|361]]
### [一] 搜索敌人
#### {一} 搜索范围内所有敌人
```lua
find_enemies_in_range(e: table, 原点: table, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数: func) -> 范围内所有敌人: table
```
- `e` 参数通常为 `store.entities`
- 过滤函数用于筛选目标，返回 `true` 保留实体，`false` 忽略实体

#### {二} 搜索第一个敌人
```lua
find_foremost_enemy(e: table, 原点: table, 最小半径: num, 最大半径: num, 预判时间: num, 标签: int, 禁止标签: int, 过滤函数: func, 禁用最小半径的标签: int) -> 第一个敌人: table, 范围内所有敌人: table, 预判位置: table
```
- 禁用最小半径的标签：拥有此标签的目标不受搜索最小半径限制

#### {三} 搜索最近敌人
```lua
find_nearest_enemy(e: table, 原点: table, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数: func) -> 最近敌人: table, 所有敌人: table
```

#### {四} 搜索随机敌人
```lua
find_random_enemy(e: table, 原点: table, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数: func) -> 随机敌人: table
```

### [二] 搜索士兵
#### {一} 搜索范围内所有士兵
```lua
find_soldiers_in_range(e: table, 原点: table, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数: func) -> 范围内所有士兵: table
```

#### {二} 搜索最近士兵
```lua
find_nearest_soldier(e: table, 原点: table, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数: func) -> 最近士兵: table
```

### [三] 搜索任意目标
#### {一} 搜索范围内所有目标
```lua
find_targets_in_range(e: table, 原点: table, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数: func) -> 范围内所有目标: table
```
- 目标包含敌人与士兵

#### {二} 搜索第一个目标
```lua
find_first_target(e: table, 原点: table, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数: func) -> 第一个目标: table
```

#### {三} 搜索随机目标
```lua
find_random_target(e: table, 原点: table, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数: func) -> 随机目标: table
```

### [四] 搜索防御塔
#### {一} 搜索范围内所有防御塔
```lua
find_towers_in_range(e: table, 原点: table, 攻击参数: table, 过滤函数: func) -> 范围内所有防御塔: table
```

### [五] 特殊搜索
#### {一} 搜索路径上的敌人
```lua
find_enemies_in_paths(e: table, 原点: table, 最小节点距离: num, 最大节点距离: num, 最大距离: num, 标签: int, 禁止标签: int, 是否仅上游: bool, 过滤函数: func) -> 排序敌人表: table
```
- 返回根据到终点距离排序的表，表内的子表包含每个敌人与原点附近的节点
- 是否仅上游: 指定是否只筛选位于当前节点上游或下游的敌人

#### {二} 搜索有敌人的路径
```lua
find_paths_with_enemies(e: table, 标签: int, 禁止标签: int, 过滤函数: func) -> 所有路径表: table
```

#### {三} 搜索坐标处的实体
```lua
find_entity_at_pos(e: table, x: num, y: num, 过滤函数: func) -> 实体: table
```

## 二、mod 相关
### [一] 获取实体指定 mod
```lua
get_modifiers(store: table, 实体: table, mod表: table) -> 拥有的mod: table
```
- 若不传递 mod 表则返回所有拥有的 mod

### [二] 判断拥有单个 mod
```lua
has_modifiers(store: table, 实体: table, mod模板名称: str) -> 是否拥有: bool, 找到的mod: table
```
- 若不传递 mod 模板名称则返回所有 mod

### [三] 判断拥有表中 mod
```lua
has_modifier_in_list(store: table, 实体: table, mod表: table) -> 是否拥有: bool
```

### [四] 判断拥有 mod 类型 
```lua
has_modifier_types(store: table, 实体: table, mod类型: str, ...) -> 是否拥有: bool, 所有找到的mod: table
```

## 三、动画
### [一] 协程等待
```lua
y_wait(store: table, 等待时间: num, 中断函数: func) -> 是否被中断: bool
```
- 在指定时间内循环挂起协程
- 中断函数用于提前终止

### [二] 播放动画
```lua
animation_start(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 是否循环: bool, 精灵索引?: int, 强制重置时间戳: bool) -> nil
```
- 不指定精灵索引将会使所有精灵播放动画

### [三] 判断动画播放完成
```lua
animation_finished(实体: table, 精灵索引?: int, 播放次数?: int) -> 是否完成: bool
```
- 精灵索引默认为 1
- 播放次数默认为 1
- 循环动画将根据播放完成次数判断

### [四] 等待动画播放完成
```lua
y_animation_wait(实体: table, 精灵索引?: int, 播放次数?: int) -> nil
```
- 精灵索引默认为 1
- 播放次数默认为 1
- 若动画没有完成则循环挂起函数，直到动画播放完成
- 循环动画将根据播放完成次数判断

### [五] 播放并等待动画
```lua
y_animation_play(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数: int, 精灵索引: int) -> nil
```
- 是 `animation_start` 与 `y_animation_wait` 的结合

### [六] 播放动画组
```lua
animation_start_group(实体: table, 动画名: str, 是否水平翻转: bool, ts: num, 是否循环: bool, 组名: str) -> nil
```

### [七] 判断动画组播放完成
```lua
animation_finished_group(实体: table, 组名: str, 播放次数: int) -> 是否完成: bool
```

### [八] 等待动画组播放完成
```lua
y_animation_wait_group(实体: table, 组名: str, 播放次数: int) -> nil
```

### [九] 播放并等待动画组播放完成
```lua
y_animation_play_group(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数: int, 组: int) -> nil
```
- 是 `animation_start_group` 与 `y_animation_wait_group` 的结合

### [十] 根据角度确定动画名称与翻转状态
```lua
animation_name_for_angle(实体: table, 组: int, 角度: num, 精灵索引?: int) -> 动画名: str, 是否水平翻转: bool, 象限索引: int
```
- 精灵索引默认为 1

### [十一] 根据朝向目标点的角度确定动画
```lua
animation_name_facing_point(实体: table, 组名: str, 目标点: table, 精灵索引?: int, 偏移: table, 是否使用路径: bool) -> 动画名: str, 是否翻转: bool, 象限索引: int
```
- 精灵索引默认为 1

### [十二] 获取动画时间戳
```lua
get_animation_ts(实体: table, 组: int) -> 时间戳: num
```

### [十三] 隐藏指定范围的精灵
```lua
sprites_hide(实体: table, 起始索引: int, 结束索引: int, 是否计数: bool) -> nil
```
- 计数存入精灵 `hidden_count` 键

### [十四] 显示指定范围的精灵
```lua
sprites_show(实体: table, 起始索引: int, 结束索引: int, 是否计数: bool) -> nil
```