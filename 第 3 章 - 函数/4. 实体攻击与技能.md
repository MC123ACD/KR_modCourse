
## 一、实体攻击增加条件
### [一] 近战攻击条件
使用 `fn_can: func` 键

- 模板内：
```lua
tt.melee.attacks[2].trigger_min_hp = 150	-- 释放条件：目标血量大于等于 150
tt.melee.attacks[2].fn_can = scripts.xxx.melee_fn_can_2
```

- `game_scripts` 内：
```lua
function scripts.xxx.update(this, store)
... end

-- 最好和更新函数与插入函数写在同一个位置
function scripts.xxx.melee_fn_can_2(this, store, a, target)
	return target.health.hp >= a.trigger_min_hp	-- 目标血量大于等于设定的血量时返回真，表示可以释放
end
```

### [二] 远程攻击条件
使用 `filter_fn: func` 键

- 模板内：
```lua
tt.ranged.attacks[2].trigger_min_hp = 150	
tt.ranged.attacks[2].filter_fn = scripts.xxx.melee_filter_fn_2
```

- `game_scripts` 内：
```lua
function scripts.xxx.melee_filter_fn_2(v, origin)
	return v.health.hp > trigger_min_hp	-- 寻找低于阈值的敌人
end
```

### [三] 概率根据条件而变化
使用 `fn_chance` 键

以使鬼侍灭魂斩 100% 秒杀处于流血效果的目标为例：

- 模板内：
```lua
-- 鬼侍近战攻击 2 是灭魂斩的秒杀，3 则是灭魂斩不秒杀的真伤
tt.melee.attacks[2].instakill_mod_type = MOD_TYPE_BLEED	-- 效果类型：流血类型
tt.melee.attacks[2].fn_chance = scripts.hero_oni.fn_chance_death_strike

-- game_scripts 模块内，最好和鬼侍更新函数与插入函数写在一个位置

```

- `game_scripts` 内：
```lua
function scripts.hero_oni.update(this, store)
... end

function scripts.hero_oni.fn_chance_death_strike(this, store, a, target)
	-- 目标拥有流血类型效果时返回真，表示百分百概率，or 后面是原始计算概率逻辑
	return U.has_modifier_types(store, target, a.instakill_mod) or math.random() < attack.chance
end
```

##### Q&A：
- Q：为什么 `fn_chance` 函数后面要加原始计算概率逻辑
- A：这是因为计算概率时会判断攻击有没有 `fn_chance` 函数，有则用 `fn_chance` 函数，没有则用这个原始计算概率逻辑，两个不能同时存在，所以需要单独增加

## 二、近战与远程攻击同时进行
```lua
...
if this.unit.is_stunned then	-- 处于眩晕状态原地待机
	SU.soldier_idle(store, this)
else
	brk, sta = SU.y_soldier_melee_block_and_attacks(store, this)	-- 调用近战攻击函数
	-- brk 就是跳出 break 缩写，sta 就是状态 status
	
	-- 关键点
	if brk or sta ~= A_NO_TARGET then	-- 近战攻击跳出或近战攻击有目标，跳过远程攻击
		-- block empty，无用代码仅占位
	else
		brk, sta = SU.y_soldier_ranged_attacks(store, this)	-- 调用远程攻击函数
		
		if brk then	-- 远程攻击跳出，跳过脱战
			-- block empty
		elseif SU.soldier_go_back_step(store, this) then	-- 正在前往集结点，跳过脱战
			-- block empty
		else	-- 没有以上情况，脱战
			SU.soldier_idle(store, this)
			SU.soldier_regen(store, this)
		end
	end
end

::label_43_0::	-- 标志，用于代码之间的跳转
coroutine.yield()
```
**思路**：由于近战攻击有目标，会跳过远程攻击

**由此得出思路：让近战攻击有目标时不跳过远程攻击，即删除 `or sta ~= A_NO_TARGET`**

## 三、增加新攻击与技能
### [一] 使攻击概率造成效果
##### 1. 在模板增加一个新攻击
```lua
-- 模板内
tt.melee.attacks[3] = table.deepclone(tt.melee.attacks[1])		-- 复制的攻击
tt.melee.attacks[3].chance = 概率: num
tt.melee.attacks[3].mod = 效果模板名: str
```
**注**：
1. 一个攻击的多个不同动画也是这样实现的，所以有些攻击可能有两三个，看着是不同的攻击，实际只是动画不同
2. **需要重点关注攻击顺序对实际释放概率的影响**
3. 只有能升级（有升级函数）的单位才需要修改升级函数

##### 2. 修改升级函数
由于这个属性表最后会根据等级赋值到对应属性键上，所以直接复制攻击是得不到的属性的，此时就需要修改升级函数，让属性也会赋值到新攻击上
```lua
...
this.melee.attacks[2].damage_min = ls.melee_damage_min[hl]
this.melee.attacks[2].damage_max = ls.melee_damage_max[hl]

-- 赋值到新攻击上
this.melee.attacks[3].damage_min = ls.melee_damage_min[hl]
this.melee.attacks[3].damage_max = ls.melee_damage_max[hl]
...
```

### [二] 防御塔攻击概率造成效果
由于防御塔的攻击大多数在更新函数使用的都是独立代码块并且没有概率相关的逻辑，所以需要自己写逻辑

假设增加的是攻击 4，想让普攻概率造成效果
```lua
...
	if this.tower.blocked then
		coroutine.yield ()
	else
		for i, aa in pairs(attacks) do
			-- 若进行攻击 1 则计算概率，然后将进行攻击 1 改成进行攻击 4
			if aa == this.attacks.list[1] and math.random () <= this.attacks.list[4].chance then
				aa = this.attacks.list[4]
			end
		end
...
```

### [三] 增加远程攻击
以二代利维坦为例：
##### 1. 增加远程攻击组件
```lua
tt = E:register_t("eb_leviathan", "boss")
E:add_comps(tt, "attacks", "ranged")	-- 增加远程攻击 “ranged” 组件
...
tt.ranged.attacks[1].bullet = "bolt_blazefang_eb_leviathan"		-- 子弹
tt.ranged.attacks[1].bullet_start_offset = {
	v(25, 10),
	v(12, 22),
	v(6, 4)
}
tt.ranged.attacks[1].cooldown = 1
tt.ranged.attacks[1].hold_advance = true
tt.ranged.attacks[1].max_range = 150
tt.ranged.attacks[1].min_range = 25
tt.ranged.attacks[1].shoot_time = fts(24)
tt.ranged.attacks[1].animation = "idle"		-- 使用利维坦待机时的动画
tt.ranged.attacks[1].shared_cooldown = true
...

tt = E:register_t("bolt_blazefang_eb_leviathan", "bolt_blazefang")	-- 续承蜥蜴人未来战士子弹
tt.bullet.damage_max = 1000
tt.bullet.damage_min = 600
```

##### 2. 增加远程攻击逻辑
```lua
function scripts.eb_leviathan.update(this, store, script)
...
	local a = this.ranged.attacks[1]	-- 变量，避免写重复代码
	
	::label_244_0::

	while true do
		...
		if this.unit.is_stunned then
			coroutine.yield()
		else
			local ranged = U.find_nearest_soldier(store.entities, this.pos, a.min_range, a.max_range, a.vis_flags, a.vis_bans)	-- 索敌

			-- 如果找到士兵目标
			if ranged then
				-- 如果可以远程攻击，并且没有被拦截一直进行远程攻击
				while SU.can_range_soldier(store, this, ranged) and #this.enemy.blockers == 0 do
					if not SU.y_enemy_range_attacks(store, this, ranged) then		-- 远程攻击逻辑，如果无法进行远程攻击跳出循环
						goto label_244_0
					end
	
					coroutine.yield()
				end
			end
			...
		end
	end
end
```

### [四] 增加新技能
以给尼鲁增加一个技能：每 275 秒增加 1 生命（升级二技能翠绿迸发解锁）为例：

##### 1. 模板内增加技能
```lua
tt.hero.skills.heal_live = E:clone_c("hero_skill")	-- 复制英雄技能组件，防御塔与其他单位技能组件是 power
tt.hero.skills.heal_live.cooldown = {	-- 增加属性表：冷却时间
	275,	-- 一级冷却时间 275 秒
	245,	-- 三级冷却时间 245 秒
	210		-- 三级冷却时间 210 秒
}
...
tt.timed_attacks.list[5] = E:clone_c("custom_attack")	-- 复制自定义技能组件，尼鲁只有四个技能所以序号是 5
tt.timed_attacks.list[5].animation = "fairy_dust"	-- 动画套用四技能衰弱咒语，当然也可以套用其他技能，注意：只能用当前实体有的动画，否则将会报错
tt.timed_attacks.list[5].sound = "HeroNyruFairyDustCast"	-- 音效，也是借用衰弱咒语
tt.timed_attacks.list[5].cooldown = nil		-- 默认冷却时间，因为属性表已经有了所以不需要，其他键处理方法相同
tt.timed_attacks.list[5].disabled = true	-- 默认禁用	
tt.timed_attacks.list[5].heal_live = 1		-- 增加生命数量
```

##### 2. 升级函数内根据等级解锁与赋值
```lua
s = this.hero.skills.verdant_blast	-- 根据翠绿迸发等级决定是否解锁新技能
sl = s.level

if sl > 0 and initial then
	...
	local a = this.timed_attacks.list[5]
	a.cooldown = this.hero.skills.heal_live.cooldown[sl]	-- 根据翠绿迸发技能等级决定冷却时间
	a.disabled = nil	-- 解除禁用
...
```

##### 3. 更新函数内增加逻辑
```lua
...
if this.unit.is_stunned then
	SU.soldier_idle(store, this)
else
	...
	a = this.timed_attacks.list[5]
	skill = this.hero.skills.heal_live

	if not a.disabled and store.tick_ts - a.ts > a.cooldown then	-- 计算冷却时间
		a.ts = store.tick_ts	-- 更新时间戳
		U.animation_start(this, a.animation, nil, store.tick_ts)	-- 播放动画
		S:queue(a.sound)	-- 播放音效
		
		store.lives = store.lives + a.heal_live	-- 增加生命

		SU.y_hero_animation_wait(this)	-- 等待动画完成
...
```




### [五] 闪避攻击
**思路**：通过查看逻辑知道：闪避后会将 `dodge.active` 键赋值为真，以及 `dodge.counter_attack_pending` 键来判断是否进行闪避攻击的

由此可以在单位的更新函数判断闪避，然后将 `dodge.counter_attack_pending` 键的键值改为 `true`，在模板 `dodge.counter_attack` 键写上攻击即可

- 模板内：
```lua
tt.dodge.counter_attack = E:clone_c("melee_attack")
tt.dodge.counter_attack.animation = "attack"
tt.dodge.counter_attack.sound = "MeleeSword"	-- 动画和音效可以套用普通攻击的
...	-- 增加伤害类型，伤害这些，与攻击同理
```

- 更新函数内：
```lua
...
if h.dead then
	SU.y_hero_death_and_respawn(store, this)
end

if this.unit.is_stunned then
	SU.soldier_idle(store, this)
else
	...
	if this.dodge and this.dodge.active then	-- 判断闪避
		this.dodge.active = false	-- 重置状态
		this.dodge.counter_attack_pending = true
		...	-- 注：后面可以增加其他逻辑
	end
end
...
```

### [六] 增加闪避条件
使用 `can_dodge: func` 键

与攻击写法相同但是**会传递 `store, this`、远程攻击、攻击、攻击来源给 `can_dodge`**

