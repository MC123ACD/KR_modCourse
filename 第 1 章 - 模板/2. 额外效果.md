# 修改伤害类型
在攻击组件可能找不到伤害类型，不妨先搜索 `E:add_comps` 的 `melee` 组件看看有没有默认值

在 `components` 搜索 `melee` 组件
![[Pasted image 20250630155536.png|675]]
如图发现没有伤害类型，继续往下在 `E:clone_c` 发现攻击 1 来自 `melee_attack`，继续搜索 `melee_attack`
![[Pasted image 20250630160301.png|675]]
**如图发现近战攻击是有伤害类型的，默认是物伤，也就是说英雄的近战攻击如果不填伤害类型，那么伤害类型就是物伤**

##### 2. 修改
由此可以这样修改：
```lua
-- 模板内
tt.melee.attacks[1].damage_type = DAMAGE_TRUE	-- 手动加上伤害类型键，然后键值写伤害类型就行
```
伤害类型见 [[1. 常量#一、伤害类型]]

- **其他诸如魔抗等同理，可以通过以上方法改**（看看有没有默认值）
- 重点搜索 `E:register_t` / `E:add_comps` / `E:clone_c` 的组件或模板

# 效果（mod）
##### 1. 增加 mod
1. 近战攻击直接在组件后面增加 `mod` 键，键值为 mod 模板名
2. 远程攻击增加到子弹模板的 `bullet` 键上，个别子弹无效（函数无实现）
3. 技能能不能增加，增加到哪里取决于函数，后面修改函数再解释

```lua
-- 单位模板内
tt.melee.attacks[1].mod = "mod_lava"	-- 普通近战攻击造成燃烧 mod，此燃烧来自模板可自行搜索

-- 子弹模板内
tt.bullet.mod = "mod_lava"	-- 子弹造成燃烧 mod
```

##### 2. 五代的问题
- **注意：由于五代所有新加的键不会被读取所以必须写在 `game_templates` 内，写在 `balance` 是不会生效的**
**不嫌麻烦可以让新键的键值也读取 `balance`**

```lua
-- balance 模块内
hero_spider = {
	basic_melee = {	-- 普通近战攻击
		mod = "mod_lava",	-- mod
		...	-- 其他键值对，攻击速度等
	}
}

-- game_templates 模块内
b = balance.heroes.hero_spider
tt.melee.attacks[1].mod = b.basic_melee.mod	-- 读取 balance 内的表
```

##### Q&A：
- Q：为什么攻击可以直接增加 mod，而技能不行
- A：因为近战攻击与远程攻击用的对应函数都有造成 mod 的实现，而技能是单独的逻辑不一定有
- Q：如何造成多个 mod
- A：只有光环和远程攻击有造成多个 mod 的实现
```lua
-- 子弹
tt.bullet.mod = {	-- 注：是 mod，不是 mods
	mod 1,
	mod 2
	...
}

-- 光环
tt.aura.mods = {	-- 注：是 mods，不是 mod
	mod 1,
	mod 2
	...
}
```

### [一] 与指定 mod 不可叠加
增加 `bans` 键，键值为表即可
即 **A 禁止 B，有 A 不能有 B，有 B 可以有 A。AB 互相禁止，有 A 不能有 B，有 B 不能有 A**

##### 示例：
```lua
-- 燃烧 mod 模板内
tt.modifier.bans = {
	"mod_freeze",	-- 指定 mod 模板名，若目标上有燃烧 mod，目标将不会被冻结
	...	-- 可指定多个
}
tt.modifier.ban_types = {	-- 禁止的 mod 类型，可选
	MOD_TYPE_FREEZE,	-- 指定一个 mod 类型，若目标上有燃烧 mod，目标将不会被冻结类型的所有 mod 冻结
	...
}
```

### [二] 移除禁止的 mod
增加 `remove_banned` 键，键值为布尔值即可

注：不可叠加优先级高于此，如果 A 禁止 B，且 B 移除 A，B 将会被禁止

##### 示例：
```lua
-- 燃烧 mod 模板内
tt.modifier.remove_banned = true
tt.modifier.bans = {
	"mod_freeze",	-- 指定具体 mod，如果目标上有冻结 mod，移除其，且无法与冻结叠加
	...
} 
tt.modifier.ban_types = {	-- 可选
	MOD_TYPE_FREEZE,	-- 指定 mod 类型，如果目标上有冻结类型的 mod，移除其，且无法与冻结叠加
	...
}
```

### [三] 多个相同 mod 叠加
具有三种模式：
1. 直接叠加： `allows_duplicates` 键，键值为布尔值
2. 仅替换： `replaces_lower` 键，键值为布尔值
3. 仅重置持续时间： `resets_same` 键，键值为布尔值

```lua
-- 燃烧 mod 模板内
tt.modifier.allows_duplicates = true	-- 可叠加多个燃烧
```

# 范围攻击
使攻击 `E:clone_c("aura_attack")`，然后加上伤害范围等即可

示例：
```lua
tt.melee.attacks[1] = E:clone_c ("area_attack")
tt.melee.attacks[1].damage_radius = 25	-- 伤害范围 25 码，必要
tt.melee.attacks[1].count = 3	-- 最多对三名敌人造成伤害，可选
tt.melee.attacks[1].min_count = 2	-- 需要两名敌人才能进行这个攻击，可选
```

# 多次攻击
给攻击加上 `loops` 键并在键值设置次数，设置播放的动画，即可实现每次攻击时攻击多次
`hit_times` 或 `shoot_times` 则是一次攻击的次数

注：`loops` 键的键值必须要有值， `hit_times` 和 `shoot_times` 才会生效
- 可以理解成乘算：`攻击次数 = loops × hit_times/shoot_times`

示例：
```lua
tt.melee.attacks[1].animations = {
	nil,	-- 开始动画
	"attack",	-- 连续攻击时的动画，复用普通近战攻击动画
	nil	-- 结束动画
}
tt.melee.attaks[1].loops = 2	-- 连续攻击 2 次
tt.melee.attaks[1].hit_times = { fts(10), fts(15) }	-- 一次攻击两次，第一次间隔 10 帧，第二次间隔 15 帧

tt.ranged.attacks[1].animations = {
	nil,
	"shoot",	-- 复用普通远程攻击动画
	nil
}
tt.ranged.attaks[1].loops = 2
tt.ranged.attaks[1].shoot_times = { fts(10), fts(15) }	-- 一次攻击两次，第一次间隔 10 帧，第二次间隔 15 帧
```

# 子弹携带实体
**主要目的**：让远程攻击的子弹落地后原地生成实体

给子弹加上 `hit_payload` 键，键值为模板名称即可

示例：
```lua
tt.bullet.hit_payload = "decal_bolin_mine"
```

# 闪避
给实体增加闪避组件即可

示例：
```lua
E:add_comps(tt, "dodge", ...)	-- 增加闪避组件
tt.dodge.chance = 0.25	-- 闪避概率 25 %
tt.dodge.silent = true	-- true 表示无动画
```

# 目标过滤
攻击标签写在攻击 `vis_flags` 的键上，过滤的目标标签则是攻击的 `vis_bans` 键上

目标标签写在 `vis.flags` 的键上，过滤的攻击标签则是 `vis.bans` 键上

满足以下两个条件目标将会被过滤：
1. 标签被攻击过滤
2. 攻击标签被目标过滤

**可以通过位运算来增加多个标签，位运算见** [[1. 常量#二 位运算]]

##### 示例：
```lua
-- 某个单位模板
tt.vis.bans = F_RANGED	-- 不会被远程攻击

tt.ranged.attacks[1].vis_bans = bor(F_BOSS, F_FLYING)	-- 远程攻击不攻击 boss 与飞行敌人
tt.ranged.attacks[1].vis_flags = F_RANGED	-- 远程攻击标签
```

> 参考资料：
> [标签与技能的释放机制 by发的gtr让他发 -百度贴吧](https://tieba.baidu.com/p/9839262014)

