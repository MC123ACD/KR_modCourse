## 一、驱动函数的逻辑：
1. **每帧调用驱动函数 `simulation:do_tick`**
	1. 更新逻辑时间 `store.tick_ts`
	2. 处理实体插入与移除
	3. 调用 `systems` 所有更新函数

## 二、实体创建逻辑
### [一] 创建实体表
1. **调用 `entity_db:create_entity` 函数创建实体表：**
	1. 深拷贝模板，生成独立实体表（存储实体的各种数据）
	2. 分配唯一 ID（只增不减）
	3. <font color="#ff0000">返回该实体表引用 ↑</font>

2. **调用 `simulation.queue_insert_entity` 函数将实体表增加到待插入队列：**
	- 增加到 `store.pending_inserts`

### [二] 处理待插入实体
1. **取出队列的实体表**

2. **调用 `simulation:insert_entity` 函数插入实体：**
	1. 遍历并调用 `systems` 所有的插入函数
		1. 传递参数：`this`（创建的实体）、`store`
		2. 若其中任意一个插入函数返回假，则：
			1. 调用 `systems` 的所有 `dequeue` 函数
				1. 传递参数：`this`、`store`、`true`
				2. <font color="#ff0000">直接返回，中断遍历 ↑</font>

3. **以键值对 `[ID] = 实体表` 形式插入 `store.entities` 正式创建实体**

## 三、移除实体逻辑
### [一] 排队等待移除
1. **调用 `simulation.queue_remove_entity` 函数将实体增加到待移除队列：**
	- 增加到 `store.pending_removals`

### [二] 处理待移除实体
1. 取出队列的实体

2. **调用 `simulation:remove_entity` 函数移除实体：**
	1. 调用各种 `systems` 的移除函数
		- 传递参数：`this`、`store`

	2. 若其中任意一个移除函数返回假，则：
		1. 调用 `systems` 所有 `dequeue` 函数：
			- 传递参数：`this`、`store`、`false`
			- <font color="#ff0000">直接返回，中断遍历 ↑</font>

	3. 将对应 ID 实体表赋值为 `nil` 移除实体

## 四、实体更新函数逻辑
### [一] 在驱动函数调用实体更新函数
1. **调用 `systems.main_script:on_update` 函数调度协程：**
	1. 遍历所有具有 `main_script.update` 更新函数的实体

	2. 若实体更新函数没有协程且没有运行过，则创建更新函数的协程

	3. 重启协程
		- 传递参数：更新函数的协程、`this`、`store`、实体函数表的引用

## 五、造成伤害逻辑
### [一] 创建伤害实体
1. **调用 `entity_db:create_entity` 创建伤害实体表**

### [二] 将伤害插入伤害队列
1. **调用 `table.insert` 函数将伤害增加到伤害队列：**
	- 增加到 `store.damage_queue`

### [三] 造成伤害
1. **在驱动函数调用血量更新函数 `systems.health:on_update`：**
	1. 若伤害队列非空，遍历伤害队列，使其中没有造成伤害的伤害：
		1. 在 `store` 索引目标 ID（`target_id`）
		2. 调用 `U.predict_damage` 函数计算伤害大小（计算护甲与伤害类型的影响）
		3. 造成伤害

## 六、造成 mod 逻辑
与插入实体完全相同，只不过会额外调用一个插入函数

### [一] 创建 mod 时调用 `sys.mod_lifecycle:on_insert` 函数
1. **<font color="#ff0000">若没有 `modifier` 键则直接返回真 ↑</font>**

2. **遍历所有具有相同目标的 mod**
	1. <font color="#ff0000">若当前 mod 被其他相同目标的 mod 禁止，则直接返回假 ↑</font>

	2. 若当前 mod 的 `modifier.remove_banned` 键值为真，则：
		1. 移除被禁止其他相同目标的 mod
		2. 将 `modifier.removed_by_ban` 键的键赋值为真，表示由于禁止而被移除

	3. <font color="#ff0000">若 `modifier.allows_duplicates` 键值为真（表示允许叠加）则返回真，中断遍历 ↑</font>

	4. 若 `modifier.replaces_lower` 键值为真，则：
		1. 将其他相同目标的 mod 移除

	5. 若 `modifier.resets_same` 键值为真，则：
		1. 更新其他相同目标的另一个 mod 的时间戳
		2. <font color="#ff0000">返回假 ↑</font>

	6. <font color="#ff0000">以上条件都不满足则直接返回假 ↑</font>

3. **<font color="#ff0000">以上代码都执行完毕返回真 ↑</font>**

## 七、近战攻击逻辑
### [一] 排序攻击
1. **在实体插入函数调用 `U.attack_order` 函数排序攻击：**
	1. 遍历实体的攻击表
		1. 根据以下条件排序攻击表：
			1. 概率不同，释放概率低者在前
			2. 释放概率相同，冷却时间长者在前
			3. 所有条件相同，攻击序号在前者在前

	2. <font color="#ff0000">返回到实体攻击的 `order` 表 ↑</font>

### [二] 进行近战攻击
1. **在实体更新函数调用 `SU.y_soldier_melee_block_and_attacks` 近战攻击函数：**
	1. 调用 `SU.soldier_pick_melee_target` 函数寻找拦截范围内的目标：
		1. <font color="#ff0000">返回目标 ↑</font>

	2. <font color="#ff0000">无目标返回 `A_NO_TARGET` ↑</font>

	3. 调用 `SU.soldier_pick_melee_attack` 函数得到可用攻击：
		1. 按顺序遍历实体的 `melee.order` 表
		2. 优先进行闪避攻击
		3. <font color="#ff0000">返回可用攻击 ↑</font>
			- 可用攻击：攻击没有禁用、攻击冷却完毕、标签没有被过滤、`fn_can` 函数返回真、计算概率或调用 `fn_chance` 函数计算概率，返回可用攻击
			- `fn_can` 函数会传递：**`this`、`store`、攻击、目标**
			- `fn_chance` 函数传递内容同上

	4. <font color="#ff0000">无可用攻击返回 `A_IN_COOLDOWN` ↑</font>

	5. 根据攻击类型：单体攻击、多次攻击、近战范围攻击，调用对应攻击类型的函数
		- 攻击函数就是最基础的造成伤害与造成 mod、播放动画、处理共享冷却等，不进行赘叙
		- 单体攻击会调用 `SU.unit_dodges` 函数判断目标是否闪避此次攻击，若闪避将不会造成伤害

	6. <font color="#ff0000">攻击完毕返回 `A_DONE` ↑</font>

## 八、远程攻击逻辑
### [一] 排序攻击
与近战攻击相同

### [二] 进行远程攻击
1. **在实体更新函数调用 `SU.y_soldier_ranged_attacks` 远程攻击函数：**
	1. 调用 `SU.soldier_pick_ranged_target_and_attack` 函数寻找攻击范围内目标与得到可用攻击：
		1. 按顺序遍历实体的 `ranged.order` 表
		2. 寻找攻击范围内的目标
		3. 同时返回目标与可用攻击
			- 可用攻击：攻击没有禁用、攻击冷却完毕、标签没有被过滤、没有被筛选函数 `filter_fn` 过滤
			- 为筛选函数传递参数：找到的实体、原点

	2. <font color="#ff0000">无目标返回 `A_NO_TARGET` ↑</font>

	3. <font color="#ff0000">无可用攻击返回 `A_IN_COOLDOWN` ↑</font>

	4. 根据攻击类型：单体攻击、多次攻击，调用对应攻击类型的函数

	5. 创建子弹实体

	6. <font color="#ff0000">攻击完毕返回 `A_DONE` ↑</font>

### [三] 子弹造成伤害
1. **调用子弹的更新函数：**
	1. 计算子弹飞行轨迹，抛物线（箭矢），直线追踪（魔法弹）等

	2. 造成伤害与造成 mod

## 九、闪避逻辑
### [一] 攻击时调用 `SU.unit_dodges` 闪避函数
1. **若目标闪避此次攻击**
	- 闪避：没有被眩晕、闪避冷却完毕、攻击的伤害类型没有 `DAMAGE_NO_DODGE`、计算概率、`can_dodge` 函数返回真
	- `can_dodge` 函数会传递：**`store`、`this`、远程攻击、攻击、攻击来源**
	- 将目标的 `dodge.active` 键值设为真

2. **<font color="#ff0000">闪避则返回真，否则返回假 ↑</font>**

### [二] 进行闪避攻击
1. **处于待定反击状态（`dodge.counter_attack_pending` 为真），则：**
	1.  <font color="#ff0000">近战攻击 `soldier_pick_melee_attack` 函数返回 `dodge.counter_attack` 的闪避攻击 ↑</font>

2. **退出待定反击状态**
