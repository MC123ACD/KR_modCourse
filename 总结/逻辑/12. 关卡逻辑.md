## 一、关卡加载逻辑
### [一] 进入关卡
1. **调用 `screen_map:start_level` 函数**
	1. 回调 `director:item_done_callback` 函数指定即将进入的界面：
			1. 将 `director.next_item_name` 键赋值为 `"game"`

	2. 调用 `director:update` 函数更新界面：
		1. 调用 `director:queue_load_item_named` 函数进入加载界面中转：
			1. 根据 `next_item_name` 键在 `kr-desktop/data/director_data.item_props` 的 `src` 决定进入的界面
				1. 进入 `game` 游戏界面
				2. 加载模块 `game` 并存入 `director.queued_item` 队列内
		2. 调用 `director.queued_item.init` 函数（`game:init`）初始化关卡

### [二] 调用 `system.level:init` 函数进行初始化
1. **调用 `grid_db:load` 函数加载网格数据**

2. **调用 `path_db:load` 函数加载路径数据**

3. **调用 `wave_db:load` 函数加载波次数据**

4. **若有 `level:init` 关卡初始化函数则调用其**

5. **若有关卡数据则调用 `LU.insert_entities` 创建关卡数据内的实体**

6. **若有 `level.load` 关卡加载函数则调用其**

7. **根据波次数据设定初始金币**

8. **根据模式设定初始生命**
	- 战役设定为 20
	- 英雄、钢铁设定为 1

### [三] 在驱动函数调用关卡更新函数 `system.level:on_update`
1. **若有 `store.level.update` 关卡更新函数则调用其**

2. **调用 `LU.insert_hero` 函数插入英雄**

3. **若当前生命小于 1 （失败）则：**
	1. 将结果、关卡索引、模式、难度存入 `store.game_outcome` 游戏结果

	2. 将存档 `last_victory` 键赋值为 `nil`，表示未胜利

	3. 调用 `store_hero_xp` 函数保存英雄经验

	4. 无尽模式则将最高分数写入存档

4. **若关卡完成、所有波次已释放、敌人全部死亡（胜利）则：**
	1. 根据血量计算星星

	2. 将结果、模式、关卡索引、星星数量等存入游戏结果以及存档的 `last_victory` 最近胜利中

	3. 保存英雄经验

## 二、关卡退出逻辑
### [一] 退出：
1. **调用 `game_gui:go_to_map` 函数前往地图：**
	1. 保存英雄经验到存档

	2. 调用 `sound_db:stop_all` 停止所有音效

	3. 回调 `director:item_done_callback` 函数指定即将进入的界面：
		1. 将 `director.next_item_name` 键赋值为 `"map"`

2. **调用 `director:update` 函数更新界面：**
	1. 调用 `director:queue_load_item_named` 函数进入加载界面中转：
		1. 根据 `next_item_name` 键在 `kr-desktop/data/director_data.item_props` 的 `src` 决定进入的界面
			1. 进入 `screen_map` 地图界面
			2. 加载模块 `screen_map` 并存入 `director.queued_item` 队列内

	2. 调用 `director.queued_item.init` 函数（`screen_map:init`）重新初始化

### [二] 调用 `screen_map:init` 函数初始化
1. **若存档中有 `last_victory` 键且存档没有对应关卡模式的通关数据（存档的 `levels` 键），则根据关卡模式进行：**
	1. 战役模式：调用 `U.find_next_level_in_ranges` 函数在 `game_settings.level_ranges` 寻找下一关
		1. 将 `screen.unlock_data` 解锁数据表的 `show_stars_level` 赋值为通关的关卡索引，表示通关的关卡旗帜上播放星星增加动画
		2. 将解锁数据表的 `new_level` 赋值为下一个关卡的索引：
			1. 遍历 `game_settings.level_ranges` 关卡范围
			2. 若一个范围内的 `list` 键为 `true` （表示这个范围为列表）且通关的关卡索引包含在内，则：
				1. <font color="#ff0000">返回范围中的下一个关卡的索引 ↑</font>
			3. 若通关的关卡索引等于最大范围，则：
				1. <font color="#ff0000">返回下一个范围的第一个键 ↑</font>
			4. 若通关的关卡索引在一个范围区间内，则：
				1. <font color="#ff0000">返回范围中的下一个关卡的索引 ↑</font>
	
		3. 将下一个关卡的索引存入解锁数据表的 `new_level` 与 `unlocked_levels` 中
	
		4. 若通关获得的星星大于此前获得的星星，则：
			1. 将解锁数据表的 `star_count_before` 此前星星总数赋值为通关获得的星星
			2. 将通关获得的星星重新赋值给存档的对应关卡数据
	
	2. 英雄模式：将解锁数据表的 `heroic_level` 赋值为通关的关卡的索引

	3. 钢铁模式：将解锁数据表的 `iron_level` 赋值为通关的关卡的索引

2. **调用 `U.unlock_next_levels_in_ranges` 函数将将要解锁的关卡存起：**
	1. 若存档有主线最后一关的关卡数据则：
		1. 将所有存档内没有的支线关卡第一关存入将要解锁的关卡表

	2. 将所有存档内没有的关卡，根据关卡范围将下一关索引存入将要解锁的关卡表
		1. 同时将下一关索引存入 `screen.unlock_data.new_level`

### [三] 向地图增加关卡入口
1. **加载 `kr-desktop/data/map_points` 模块并将对应表分别存入 `screen_map.map_points.points / flags / endless_flags`**

2. **调用 `self:show_flags` 函数（续承自父类 `MapView`）显示关卡旗帜：**
	1. 调用 `self:load_level_decos` 函数加载并创建地图装饰 `kr-desktop/data.map_data.map_decos`

	2. 将有 `trigger_level` 键的装饰返回到 `self.level_decos` 中

	3. 根据 `game_settings.last_level` 设定最大关卡数

	4. 遍历存档中通关的关卡
	5. 根据 `screen_map.map_points.points` 表创建旗帜之间的连接点（续承自 `KImageView`）
	6. 创建已通关的关卡的旗帜（续承自 `LevelFlagView`）
	7. 根据存档内战役、英雄、钢铁通关状态为旗帜设定不同样式
	8. 创建无尽模式旗帜（续承自 `EndlessLevelFlagView`）
	9. 若是首次创建的旗帜则根据不同情况播放动画：
		1. 若关卡索引等于 `screen.unlock_data.show_stars_level` 则播放显示星星动画
		2. 若通过钢铁模式 `screen.unlock_data.iron_level` 则播放通过钢铁模式的动画
		3. 若通过英雄模式 `screen.unlock_data.heroic_level` 则播放通过英雄模式的动画
		4. 显示对应关卡的地图装饰（`trigger_level`）
		5. 播放连接新解锁（`screen.unlock_data.new_level`）的关卡的连接动画（旗帜之间的连接点）
		6. 播放所有将要解锁的关卡表的关卡（`screen.unlock_data.unlocked_levels`）的插入旗帜动画

## 三、生成怪物逻辑
### [一] 调用 `wave_db:load` 函数加载波次数据
1. **根据不同数据格式调用：**
	- tsv 则调用 `wave_db:load_tsv`
	- lua 则调用 `wave_db:load_lua`

3. **将波次数据存入 `wave_db.db`**

### [二] 波次生成初始化
1. **调用 `system.wave_spawn:init` 函数：**
	1. 根据模式设定关卡最大波次
		1. 无尽最大波次 `store.wave_group_total` 设定为 0
		2. 非无尽根据波次数据的波次数量决定

	2. 创建波次线协程 `store.wave_spawn_thread`

	3. 调用 `W:get_group` 获得对应波次的数据

	4. 第一波则调用 `game_gui.wave_notification_handler` 函数显示消息

	5. 若没有主动释放第一波则循环挂起协程

	6. 若下一波没有到来（`interval`），没有跳过这一波则循环挂起协程

	7. 若主动释放下一波则调用 `game_gui.early_wave_called_handler` 函数处理释放非第一波波次
		 1. 无尽模式额外增加分数
		 2. 调用对应能力的 `early_wave_bonus` 函数给予玩家奖励（减冷却）

	8. 调用 `game_gui.next_wave_sent_handler` 函数处理释放波次
		1. 隐藏释放波次按钮
		2. 调用 `game_gui.unlock_user_power_handler` 函数解锁对应技能

	9. 显示消息

	10. 创建协程，延迟 `delay` 一定时间，返回并 `spawner` 调用生成敌人
		1. 协程返回到 `store.waves_active`

	11. 这一波敌人生成完毕后 `i += 1` 标志进入下一波

## 四、路径加载逻辑
### [一] 加载路径
1. **加载关卡路径数据并存入 `path_db:paths`**

2. **调用 `path_db:set_start_node` 与 `path_db:set_end_node` 函数设定起点与终点节点并存入 `path_db:path_start_node` 与 `path_db:path_end_node` 内**

### [二] 终点更新
1. **在驱动函数调用 `system.goal_line:on_update` 函数**
	1. 若具有 `nav_path` 键的敌人到达终点（`nav_path.ni >= P:path_end_node`）则：
		1. 将生命减去敌人的 `enemy.lives_cost`，并移除这个敌人

## 五、网格加载逻辑
1. **加载关卡网格数据，并存入 `grid_db.grid`**
	1. `grid_db.ox` 网格中心点 x 轴
	2. `grid_db.oy` 网格中心点 y 轴
	3. `grid_db.grid_w` 所有网格总长度
	4. `grid_db.grid_h` 所有网格总宽度
