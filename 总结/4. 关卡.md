## 关卡编号

|           | 一代    |           | 二代    |           | 三代    |           | 四代    |           | 五代   |
| --------- | ----- | --------- | ----- | --------- | ----- | --------- | ----- | --------- | ---- |
| **1-12**  | 主线    | **1-15**  | 主线    | **1-15**  | 主线    | **0**     | 教程关   | **1-16**  | 主线   |
| **13**    | 蜘蛛支线  | **16-18** | 海战支线  | **16-18** | 食人魔支线 | **1-16**  | 主线    | **17-19** | 灵魂支线 |
| **14**    | 兽人支线  | **19-21** | 万圣节支线 | **19-20** | 暮光支线  | **17-19** | 青蛙支线  | **20-22** | 鳄鱼支线 |
| **15**    | 沼泽支线  | **22**    | 蜥蜴人支线 | **21-22** | 矮人支线  | **20-22** | 冰川支线  | **23-27** | 矮人支线 |
| **16-17** | 强盗支线  |           |       |           |       | **23-25** | 天朝支线  | **28-30** | 蜘蛛支线 |
| **18-19** | 巨魔支线  |           |       |           |       | **26-28** | 万圣节支线 | **31-35** | 悟空支线 |
| **20-21** | 恶魔支线  |           |       |           |       | **29-31** | 原始支线  |           |      |
| **22**    | 蘑菇人支线 |           |       |           |       | **32-36** | 沙漠支线  |           |      |
| **23-26** | 万圣节支线 |           |       |           |       | **37-41** | 海盗支线  |           |      |

## 路径函数
###  获取节点
#### 1. 获取节点坐标
```lua
P:node_pos(路径: int, 子路径: int, 节点: int, 是否返回引用?: bool) -> 节点坐标: vec2
```

#### 2. 获取偏移后节点坐标
```lua
P:node_offset_pos(偏移量: int, 路径: int, 子路径: int, 节点: int) -> 节点坐标: vec2
```

#### 3. 获取起点节点
```lua
P:get_start_node(路径: int) -> 节点: int
```

#### 4. 获取终点节点
```lua
P:get_end_node(路径: int) -> 节点: int
```

#### 5. 获取防守点节点
```lua
P:get_defend_point_node(路径: int) -> 节点: int
```

#### 6. 获取节点到起点距离
```lua
P:nodes_from_start(路径: int, 子路径: int, 节点: int) -> 节点距离: int
```

####  7. 获取节点到终点距离
```lua
P:nodes_to_goal(路径: int, 子路径: int, 节点: int) -> 节点距离: int
```

#### 8. 获取节点到防守点距离
```lua
P:nodes_to_defend_point(路径: int, 子路径: int, 节点: int) -> 节点距离: int
```

#### 9. 获取可见终点节点
```lua
P:get_visible_end_node(路径: int) -> 节点: int
```

#### 10. 获取可见起点节点
```lua
P:get_visible_start_node(路径: int) -> 节点: int
```

### 节点操作

#### 1. 判断一定距离是否存在节点
```lua
P:point_within_distance(x, y, 距离: num) -> 是否存在: bool
```

#### 2. 返回附近所有节点
```lua
P:nearest_nodes(
	x, 
	y, 
	路径?: list{ 路径: int... }, 
	子路径?: list{ 子路径: int... }, 
	是否仅有效节点: bool, 
	节点标签: int, 
	过滤函数?: func, 
	步长: int
) -> 节点列表: list{list{ 路径: int, 子路径: int, 节点: int, 距离: num }...}
```
- 返回一个根据距离排序的节点列表
- 不指定路径将会在所有路径查找节点
- 子路径默认值 `{ 1 }`

#### 3. 增加无效节点范围
```lua
P:add_invalid_range(路径: int, 最小范围: int, 最大范围: int, 标签: int)
```

#### 4. 移除无效节点范围
```lua
P:remove_invalid_range(路径: int, 最小范围: int, 最大范围: int)
```

#### 5. 判断节点是否有效
```lua
P:is_node_valid(路径: int, 节点: int, 节点标签: int) -> 是否有效: bool
```

#### 6. 判断附近是否存在有效节点
```lua
P:valid_node_nearby(x, y, 路径宽度乘数: num, 节点标签: int) -> 是否存在: bool
```

#### 7. 返回随机节点
```lua
P:get_random_position(
	边距: int | list{ 前边距: int, 后边距: int }, 
	地形: int, 
	节点标签: int, 
	边距是否从防守点开始计算: bool
) -> 节点坐标: vec2, 路径: int, 子路径: int, 节点: int
```

#### 8. 返回范围内所有有效节点
```lua
P:get_all_valid_pos(
	x,
	y,
	最小范围: num, 
	最大范围: num, 
	地形: int, 
	过滤函数: func, 
	标签: int, 
	子路径: list{ 子路径: int }
) -> 有效节点列表: list{ 节点: int... }
```

### 路径操作

#### 1. 获取路径宽度
```lua
P:path_width(路径: int, 子路径: int, 节点: int) -> 宽度: int
```

#### 2. 启用路径
```lua
P:activate_path(路径: int)
```

#### 3. 禁用路径
```lua
P:deactivate_path(路径: int)
```

#### 4. 返回连接的下一路径
```lua
P:get_next_pi(路径: int) -> 连接的下一路径: int
```

#### 5. 返回所有连接的路径
```lua
P:get_connected_paths(路径: int) -> 连接路径列表: list{ 路径: int... }
```

#### 6. 判断路径是否启用
```lua
P:is_path_active(路径: int) -> 是否启用: bool
```

#### 7. 获取路径地形
```lua
P:path_terrain_types(路径: int) -> 地形: int
```

#### 8. 获取路径副地形
```lua
P:path_terrain_props(路径: int) -> 地形: int
```

#### 9. 返回路径上所有有效节点
```lua
P:get_valid_nodes(路径: int, 节点标签: int) -> 有效节点列表: list{ 节点: int... }
```

## 网格函数

### 游戏坐标
#### 1. 游戏坐标转网格坐标
```lua
GR:get_coords(x, y) -> 网格x坐标: int, 网格y坐标: int
```

#### 2. 获取游戏坐标的地形
```lua
GR:cell_type(x, y) -> 地形: int, 网格x坐标: int, 网格y坐标: int
```

#### 3. 设定游戏坐标的地形
```lua
GR:set_cell_type(x, y, 地形: int) -> 地形: int
```

### 网格坐标
#### 1. 网格坐标转游戏坐标
```lua
GR:cell_pos(网格x坐标: int, 网格y坐标: int) -> x, y
```
- 返回单元格中心位置

#### 2. 获取网格坐标的地形
```lua
GR:get_cell(网格x坐标: int, 网格y坐标: int) -> 地形: int
```

#### 3. 设定网格坐标的地形
```lua
GR:set_cell(网格x坐标: int, 网格y坐标: int, 地形: int)
```

### 网格
#### 1. 判断单元格是否包含指定地形
```lua
GR:cell_is(x, y, 地形: int) -> 是否包含: bool
```

#### 2. 判断单元格是否仅包含指定类型
```lua
GR:cell_is_only(x, y, 地形: int) -> 是否仅包含: bool
```

#### 3. 设定网格尺寸
```lua
GR:set_grid_size(新长度: int, 新高度: int)
```
- 保持原有数据居中，新增单元格填充默认值 0

#### 4. 设定网格原点偏移量
```lua
GR:set_grid_offset(x, y)
```

### 杂项
#### 1. 地形转换可读字符串
```lua
GR:print_cell(地形: int) -> 字符串: str
```

#### 2. A\* 算法寻路
```lua
GR:find_waypoints(起点: vec2, 备用起点?: vec2, 终点: vec2, 有效地形: int, 是否不读取缓存: bool) 
-> 点位: list{vec2...}
```

#### 3. Bresenham 算法寻路
```lua
GR:find_line_waypoints(起点: vec2, 终点: vec2, 有效地形: int)
-> 点位: list{vec2...}, 网格坐标: list{vec2...}
```