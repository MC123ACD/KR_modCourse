# 索敌
### [一] 搜索范围内所有敌人
```lua
U.find_enemies_in_range(实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 范围内所有敌人: list
```
- 实体列表通常为 `store.entities`
- 为过滤函数传递：实体、原点
- 过滤函数用于筛选目标，返回假的目标将会被筛选

### [二] 搜索第一个敌人
```lua
U.find_foremost_enemy(实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 预判时间: num, 标签: int, 禁止标签: int, 过滤函数?: func, 禁用最小半径的标签: int) -> 第一个敌人: table, 范围内所有敌人: list, 预判位置: vec2
```
- 禁用最小半径的标签：拥有此标签的目标不受搜索最小半径限制

### [三] 搜索最近敌人
```lua
U.find_nearest_enemy(实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 最近敌人: table, 范围内所有敌人: list
```

### [四] 搜索随机敌人
```lua
U.find_random_enemy(实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 随机敌人: table
```

### [五] 搜索范围内所有士兵
```lua
U.find_soldiers_in_range(实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 范围内所有士兵: list
```

### [六] 搜索最近士兵
```lua
U.find_nearest_soldier(实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 最近士兵: table
```

### [七] 搜索范围内所有目标
```lua
U.find_targets_in_range(实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 范围内所有目标: list
```
- 目标包含敌人与士兵

### [八] 搜索第一个目标
```lua
U.find_first_target(实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 第一个目标: table
```

### [九] 搜索随机目标
```lua
U.find_random_target(实体列表: list, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 随机目标: table
```

### [十] 搜索范围内所有防御塔
```lua
U.find_towers_in_range(实体列表: list, 原点: vec2, 攻击参数: table, 过滤函数?: func) -> 范围内所有防御塔: list
```

### [十一] 搜索路径上的敌人
```lua
U.find_enemies_in_paths(实体列表: list, 原点: vec2, 最小节点距离: int, 最大节点距离: int, 最大距离: num, 标签: int, 禁止标签: int, 是否仅上游: bool, 过滤函数?: func) -> 排序后的敌人列表: list{{敌人: table, 节点: int}}
```
- 返回根据到终点距离排序的列表
- 是否仅上游: 指定是否只筛选位于当前节点上游或下游的敌人

### [十二] 搜索有敌人的路径
```lua
U.find_paths_with_enemies(实体列表: list, 标签: int, 禁止标签: int, 过滤函数?: func) -> 所有路径列表: list
```

### [十三] 搜索坐标处的实体
```lua
U.find_entity_at_pos(实体列表: list, x: num, y: num, 过滤函数?: func) -> 实体: table
```

# 状态效果
### [一] 获取实体指定效果
```lua
U.get_modifiers(store, 实体: table, 效果表: table) -> 拥有的效果实体: table
```
- 若不传递效果表则返回所有拥有的效果实体

### [二] 判断是否拥有单个效果
```lua
U.has_modifiers(store, 实体: table, 效果模板名: str) -> 是否拥有: bool, 找到的效果实体: table
```
- 若不传递效果模板名称则返回所有效果

### [三] 判断是否拥有表中效果
```lua
U.has_modifier_in_list(store, 实体: table, 效果表: table) -> 是否拥有: bool
```

### [四] 判断是否拥有给定效果类型的效果
```lua
U.has_modifier_types(store, 实体: table, 效果类型: int...) -> 是否拥有: bool, 所有找到的效果实体: table
```

# 拦截
### [一] 获取拦截者
```lua
U.get_blocker(store, 被拦截者: table) -> 拦截者: table
```

### [二] 获取被拦截者
```lua
U.get_blocked(store, 拦截者: table) -> 被拦截者: table
```

### [三] 获取被拦截者中拦截者的索引
```lua
U.blocker_rank(store, 拦截者: table) -> 索引: int
```

### [四] 判断是否可被拦截
```lua
U.is_blocked_valid(store, 拦截者: table) -> 是否可被拦截: bool
```

### [五] 解除所有被拦截者的拦截者
```lua
U.unblock_all(store, 被拦截者: table)
```

### [六] 解除拦截者的拦截
```lua
U.unblock_target(store, 拦截者: table)
```

### [七] 拦截
```lua
U.block_enemy(store, 拦截者: table, 被拦截者: table)
```

### [八] 替换拦截者
```lua
U.replace_blocker(store, 原拦截者: table, 新拦截者: table)
```

### [九] 清除无效拦截
```lua
U.cleanup_blockers(store, 被拦截者: table)
```

# 动画
### [一] 协程等待
```lua
U.y_wait(store, 等待时间: num, 中断函数?: func) -> 是否被中断: bool
```
- 在指定时间内循环挂起协程
- 中断函数用于提前终止

### [二] 播放动画
```lua
U.animation_start(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 是否循环: bool, 精灵索引?: int, 强制重置时间戳: bool)
```
- 不指定精灵索引将会使所有精灵播放动画

### [三] 判断动画播放完成
```lua
U.animation_finished(实体: table, 精灵索引?: int, 播放次数?: int) -> 是否完成: bool
```
- 精灵索引默认为 1
- 播放次数默认为 1
- 循环动画将根据播放完成次数判断

### [四] 等待动画播放完成
```lua
U.y_animation_wait(实体: table, 精灵索引?: int, 播放次数?: int)
```
- 精灵索引默认为 1
- 播放次数默认为 1
- 若动画没有完成则循环挂起函数，直到动画播放完成
- 循环动画将根据播放完成次数判断

### [五] 播放并等待动画
```lua
U.y_animation_play(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数?: int, 精灵索引: int)
```
- 是 `animation_start` 与 `y_animation_wait` 的结合
- 播放次数默认值为 1

### [六] 播放动画组
```lua
U.animation_start_group(实体: table, 动画名: str, 是否水平翻转: bool, ts: num, 是否循环: bool, 组名: str)
```

### [七] 判断动画组播放完成
```lua
U.animation_finished_group(实体: table, 组名: str, 播放次数?: int) -> 是否完成: bool
```
- 播放次数默认值为 1

### [八] 等待动画组播放完成
```lua
U.y_animation_wait_group(实体: table, 组名: str, 播放次数?: int)
```
- 播放次数默认值为 1

### [九] 播放并等待动画组播放完成
```lua
U.y_animation_play_group(实体: table, 动画名: str, 是否水平翻转: bool, 时间戳: num, 播放次数?: int, 组: int)
```
- 是 `animation_start_group` 与 `y_animation_wait_group` 的结合
- 播放次数默认值为 1

### [十] 根据角度确定动画名称与翻转状态
```lua
U.animation_name_for_angle(实体: table, 组: int, 角度: num, 精灵索引?: int) -> 动画名: str, 是否水平翻转: bool, 象限索引: int
```
- 精灵索引默认值为 1

### [十一] 根据朝向目标点的角度确定动画
```lua
U.animation_name_facing_point(实体: table, 组名: str, 目标点: vec2, 精灵索引?: int, 偏移: vec2, 是否使用路径: bool) -> 动画名: str, 是否水平翻转: bool, 象限索引: int
```
- 精灵索引默认为 1

### [十二] 获取动画时间戳
```lua
U.get_animation_ts(实体: table, 组: int) -> 时间戳: num
```

### [十三] 隐藏指定范围的精灵
```lua
U.sprites_hide(实体: table, 起始索引: int, 结束索引: int, 是否计数: bool)
```
- 计数存入精灵 `hidden_count` 键

### [十四] 显示指定范围的精灵
```lua
U.sprites_show(实体: table, 起始索引: int, 结束索引: int, 是否计数: bool)
```