## 日志库
#### 1. 创建新日志实例
```lua
log:new(打印的日志前缀: str, 日志等级?: int) -> 日志实例: table
```
- 推荐在 `args` 修改全局日志等级


```lua
[22841.0227] image_db.DEBUG preload_atlas() - load atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000
```
- `[22841.0227]` 为时间信息
- `image_db` 为前缀
- `DEBUG` 为等级，调试五级
- `preload_atlas` 调用的函数
- `load atlas: _assets/kr1-desktop/images/fullhd,screen_settings-1.000000` 信息

#### 2. 打印 6 级完整信息
```lua
log.paranoid(信息: str, 用于格式化的参数: any...)
```

#### 3. 打印 5 级调试信息
```lua
log.debug(信息: str, 用于格式化的参数: any...)
```

#### 4. 打印 4 级待办信息
```lua
log.todo(信息: str, 用于格式化的参数: any...)
```

#### 5. 打印 3 级常规信息
```lua
log.info(信息: str, 用于格式化的参数: any...)
```

#### 6. 打印 2 级警告信息
```lua
log.warning(信息: str, 用于格式化的参数: any...)
```

#### 7. 打印 1 级错误信息
```lua
log.error(信息: str, 用于格式化的参数: any...)
```

#### 8. 断言检查
```lua
log.assert(条件: bool, 信息: str, 用于格式化的参数: any...)
```

#### 9. 调用栈跟踪
```lua
log.traceall(信息?: str)
```

#### 10. 完整的堆栈跟踪
```lua
log.traceall(显示的调用栈深度: int)
```

##  macros 宏指令库
#### 11. 常量

```lua
macros.pi = 3.1415926535898  -- 圆周率 π
macros.twopi = 6.2831853071796  -- 2π
macros.pi_2 = 1.5707963267949  -- π/2
macros.pi_4 = 0.78539816339745  -- π/4
```

#### 12. 弧度角归一化
```lua
macros.unroll(角度: num) -> 归一化后的角度: num
```
- 将任意弧度角归一化到 [0, 2π] 范围内

#### 13. 角度制归一化
```lua
macros.unroll_deg(角度: num) -> 归一化后的角度: num
```
- 将任意角度制角度归一化到 [0, 360] 范围内

#### 14. 带符号弧度角归一化
```lua
macros.signed_unroll(弧度: num) -> 归一化后的角度: num
```
- 使用 `macros.fmod` 进行归一化，保持符号信息

#### 15. 带符号角度制归一化
```lua
macros.signed_unroll_deg(角度: num) -> 归一化后的角度: num
```
- 使用 `math.fmod` 进行角度制归一化，保持符号信息

#### 16. 计算最短弧度差
```lua
macros.short_angle(起始角: num, 目标角: num) -> 最短角度差: num
```
- 计算从 `起始角` 到 `目标角` 的最短弧度差，结果在 [-π, π] 范围内

#### 17. 计算最短角度制差
```lua
macros.short_angle_deg(起始角: num, 目标角: num) -> 最短角度差: num
```
- 计算从 `起始角` 到 `目标角` 的最短角度差，结果在 [-180, 180] 范围内

#### 18. 有符号范围限制
```lua
macros.clamp_signed(最小值: num, 最大值: num, 数值: num) -> 限制后的值: num
```
- 将数值限制在指定范围内（要求最小值 ≤ 最大值）

#### 19. 通用范围限制
```lua
macros.clamp(边界1: num, 边界2: num, 数值: num) -> 限制后的值: num
```
- 使用 `macros.clamp_signed` 将数值限制在指定范围内，自动处理边界顺序

#### 20. 循环取模
```lua
macros.zmod(值: num, 模数: num) -> 取模结果: num
```
- 返回 `((值 - 1) % 模数) + 1`，常用于数组索引循环

#### 21. 四舍五入
```lua
macros.round(数值: num) -> 取整结果: num
```
- 返回 `math.floor(数值 + 0.5)` 的四舍五入结果

#### 22. 符号函数
```lua
macros.sign(数值: num) -> 符号: num
```
- 返回数值的符号：负数为 -1，非负数为 1

#### 23. 随机符号
```lua
macros.rand_sign(正号概率?: num) -> 符号: num
```
- 返回随机符号：-1 或 1。`正号概率` 默认为 0.5，表示返回 1 的概率

#### 24. 角度转弧度
```lua
macros.deg2rad(角度: num) -> 弧度: num
```

#### 25. 弧度转角度
```lua
macros.rad2deg(弧度: num) -> 角度: num
```

## vector 向量库

#### 26. 创建向量
```lua
V.v(x, y) -> 向量: vec2
```

#### 27. 创建对角线向量
```lua
V.vv(值: num) -> 向量: vec2
```

#### 28. 深拷贝向量
```lua
V.vclone(向量: vec2) -> 深拷贝的向量: vec2
```

#### 29. 判断向量相等
```lua
V.veq(向量1: vec2, 向量2: vec2) -> 是否相等: bool
```

#### 30. 向量分量取整（向上舍入）
```lua
V.v2c(向量: vec2) -> x: int, y: int
```

#### 31. 向量取整（创建新向量）
```lua
V.vsnap(向量: vec2) -> 取整后的向量: vec2
```

#### 32. 坐标分量取整（向上舍入）
```lua
V.csnap(x, y) -> x: int, y: int
```

#### 33. 创建矩形
```lua
V.r(x, y, 长: num, 高: h) -> 矩形: rect
```

#### 34. 深拷贝矩形
```lua
V.rclone(矩形: rect) -> 深拷贝的矩形: rect
```

#### 35. 点是否在矩形内
```lua
V.is_inside(点位: vec2, 矩形: rect) -> 是否在矩形内: bool
```
- 包含边界

#### 36. 判断矩形是否重叠
```lua
V.overlap(矩形: rect, 矩形: rect) -> 是否重叠: bool
```
- 包括边缘接触

## signal 信号库
### 常用
#### 1. 注册监听器到信号
```lua
signal:register(信号名: str, 监听器函数: func) -> 监听器函数: func
```

#### 2. 触发指定信号
```lua
signal:emit(信号名: str, 为监听器函数传递的参数: str...)
```

#### 3. 从信号中移除监听器
```lua
signal:remove(信号名: str, 监听器函数: func...)
```

#### 4. 清空信号的所有监听器
```lua
signal:clear(信号名: str...)
```

### 模式匹配

#### 1. 监听器注册到所有匹配的信号
```lua
signal:registerPattern(模式: str, 监听器函数: func) -> 监听器函数: func
```

#### 2. 按模式匹配触发信号
```lua
signal:emitPattern(模式: str, 信号名: str, 为监听器函数传递的参数: str...)
```

#### 3. 从所有匹配信号中移除监听器
```lua
signal:removePattern(模式: str, 监听器函数: func...)
```

#### 4. 清空所有匹配的信号
```lua
signal:clearPattern(模式: str)
```