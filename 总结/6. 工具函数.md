## 一、索敌

### [一] 搜索范围内所有敌人
```lua
U.find_enemies_in_range(e: table, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 范围内所有敌人: table
```
- `e` 参数通常为 `store.entities`
- 为过滤函数传递：实体、原点
- 过滤函数用于筛选目标，返回假的目标将会被筛选

### [二] 搜索第一个敌人
```lua
U.find_foremost_enemy(e: table, 原点: vec2, 最小半径: num, 最大半径: num, 预判时间: num, 标签: int, 禁止标签: int, 过滤函数?: func, 禁用最小半径的标签: int) -> 第一个敌人: table, 范围内所有敌人: table, 预判位置: vec2
```
- 禁用最小半径的标签：拥有此标签的目标不受搜索最小半径限制

### [三] 搜索最近敌人
```lua
U.find_nearest_enemy(e: table, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 最近敌人: table, 所有敌人: table
```

### [四] 搜索随机敌人
```lua
U.find_random_enemy(e: table, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 随机敌人: table
```

### [五] 搜索范围内所有士兵
```lua
U.find_soldiers_in_range(e: table, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 范围内所有士兵: table
```

### [六] 搜索最近士兵
```lua
U.find_nearest_soldier(e: table, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 最近士兵: table
```

### [七] 搜索范围内所有目标
```lua
U.find_targets_in_range(e: table, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 范围内所有目标: table
```
- 目标包含敌人与士兵

### [八] 搜索第一个目标
```lua
U.find_first_target(e: table, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 第一个目标: table
```

### [九] 搜索随机目标
```lua
U.find_random_target(e: table, 原点: vec2, 最小半径: num, 最大半径: num, 标签: int, 禁止标签: int, 过滤函数?: func) -> 随机目标: table
```

### [十] 搜索范围内所有防御塔
```lua
U.find_towers_in_range(e: table, 原点: vec2, 攻击参数: table, 过滤函数?: func) -> 范围内所有防御塔: table
```

### [十一] 搜索路径上的敌人
```lua
U.find_enemies_in_paths(e: table, 原点: vec2, 最小节点距离: int, 最大节点距离: int, 最大距离: num, 标签: int, 禁止标签: int, 是否仅上游: bool, 过滤函数?: func) -> 排序敌人表: table
```
- 返回根据到终点距离排序的表，表内的子表包含每个敌人与原点附近的节点
- 是否仅上游: 指定是否只筛选位于当前节点上游或下游的敌人

### [十二] 搜索有敌人的路径
```lua
U.find_paths_with_enemies(e: table, 标签: int, 禁止标签: int, 过滤函数?: func) -> 所有路径表: table
```

### [十三] 搜索坐标处的实体
```lua
U.find_entity_at_pos(e: table, x: num, y: num, 过滤函数?: func) -> 实体: table
```

### [十四] 获取实体指定效果
```lua
U.get_modifiers(store: table, 实体: table, 效果表: table) -> 拥有的效果实体: table
```
- 若不传递效果表则返回所有拥有的效果实体

### [十五] 判断是否拥有单个效果
```lua
U.has_modifiers(store: table, 实体: table, 效果模板名: str) -> 是否拥有: bool, 找到的效果实体: table
```
- 若不传递效果模板名称则返回所有效果

### [十六] 判断是否拥有表中效果
```lua
U.has_modifier_in_list(store: table, 实体: table, 效果表: table) -> 是否拥有: bool
```

### [十七] 判断是否拥有给定效果类型的效果
```lua
U.has_modifier_types(store: table, 实体: table, 效果类型: int...) -> 是否拥有: bool, 所有找到的效果实体: table
```
