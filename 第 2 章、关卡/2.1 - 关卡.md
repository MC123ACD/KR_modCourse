## 一、关卡数据
关卡中所有数据存储于 `kr/data/levels` 中

**其中**：
1. 无后缀为关卡相关函数
2. `_data` 为关卡参数
3. `_paths` 为路径数据
4. `_gird` 为网格数据

##### `_data` 结构

- 表：
	- `locked_hero` 是否锁定英雄
	- `max_upgrade_level` 防御塔最大等级
	- `entities_list` 进入关卡创建的实体
		- 实体 1：
			- `template` 创建的实体
			- `pos` 创建位置
			- 修改实体表...
		- 实体 2...
	- `level_mode_overrides` 不同模式的差异：
		- 战役模式
		- 英雄模式
		- 钢铁模式
	- `required_sounds` 加载的音效资源
	- `required_textures` 加载的贴图与动画资源

## 二、关卡操作函数

# 相关逻辑
## 一、关卡加载逻辑
### [一] 进入关卡
1. 点击开始战斗按钮
2. 调用 `screen_map:start_level` 函数
3. **回调 `director:item_done_callback` 函数：**
		1. 将 `director.next_item_name` 键赋值为 `"game"`
4. 调用 `director:update` 函数：
	1. 调用 `director:queue_load_item_named` 函数：
		1. 根据 `next_item_name` 键在 `kr-desktop/data/director_data.item_props` 的 `src` 决定进入的界面
			1. 进入 `game` 界面
			2. 加载模块 `game` 并存入 `director.queued_item` 内
	2. **调用 `director.queued_item.init` 函数（`game:init`）初始化**

### [二] 调用 `sys.level:init` 函数进行初始化
1. 调用 `GR:load`（`all/grid_db`）函数加载网格数据
2. 调用 `P:load`（`all/path_db`）函数加载路径数据
3. 调用 `W:load`（`all/wave_db`）函数加载波次数据
4. **若有 `level:init` 关卡初始化函数则调用进行初始化**
5. **若有关卡参数则调用 `LU.insert_entities` 创建关卡参数内的实体**
6. 根据波次数据设定初始金币
7. 根据模式设定初始生命

### [三] 在驱动函数调用关卡更新函数 `sys.level:on_update`
1. **若有 `store.level.update` 关卡更新函数则调用其**
2. **调用 `LU.insert_hero` 函数插入英雄**
3. **若生命小于 1 （失败）则：**
	1. 将结果、关卡索引、模式、难度存入 `store.game_outcome`
	2. 将存档 `last_victory` 键赋值为 `nil`
	3. 保存英雄经验（调用 `store_hero_xp` 函数）
	4. 无尽模式则将最高分数写入存档
4. **若关卡完成、所有波次已释放、敌人全部死亡（胜利）则：**
	1. 根据血量计算星星
	2. 将结果、模式、关卡索引、星星数量等存入 `store.game_outcome` 以及存档的 `last_victory` 表中
	3. 保存英雄经验

## 二、关卡退出逻辑
### [一] 退出：
1. 点击退出按钮：胜利和暂停界面的退出
2. 调用 `game_gui:go_to_map` 函数：
	1. 保存英雄经验
	2. 停止所有音效
	3. **回调 `director:item_done_callback` 函数：**
		1. 将 `director.next_item_name` 键赋值为 `"map"`
3. 调用 `director:update` 函数：
	1. 调用 `director:queue_load_item_named` 函数：
		1. 根据 `next_item_name` 键在 `kr-desktop/data/director_data.item_props` 的 `src` 决定进入的界面
			1. 进入 `screen_map` 界面
			2. 加载模块 `screen_map` 并存入 `director.queued_item` 内
	2. **调用 `director.queued_item.init` 函数（`screen_map:init`）重新初始化**

### [二] 调用 `screen_map:init` 函数初始化
1. **若存档中有 `last_victory` 键且存档没有对应关卡模式的通关数据（存档的 `levels` 键）则根据关卡模式进行：**
	1. **战役：调用 `U.find_next_level_in_ranges` 函数将 `ud.new_level` 赋值为下一个关卡的索引：**
		1. 遍历 `GS.level_ranges` 关卡范围，根据不同条件进行：
		2. 若一个范围内的 `list` 键为 `true` （表示这个范围是无序的）且通关的关卡索引包含在内则直接返回范围中的下一个关卡的索引
			1. 或通关的关卡索引等于最大范围，返回下一个范围表的第一个键
		3. 若通关的关卡索引在一个范围区间内则直接返回通关的关卡索引 + 1
			1. 或通关的关卡索引等于最大范围，返回下一个范围表的第一个键
	2. 将存档内所对应的关卡的键初始化（`= {}`）
	3. 将下一个关卡的索引存入将要解锁的关卡表
	4. 若存档有对应关卡的战役数据且通关获得的星星大于此前获得的星星则：
		1. 将 `ud.show_stars_level` 赋值为通关的关卡索引
		2. 将 `ud.star_count_before` 赋值为通关获得的星星
		3. 将通关获得的星星重新赋值给存档对应关卡数据的星星键
	5. **英雄与钢铁：分别将 `ud.heroic_level` 与 `ud.iron_level` 赋值为通关关卡索引**
	注：`screen.unlock_data` 缩写为 `ud`
2. 调用 `U.unlock_next_levels_in_ranges` 函数将将要解锁的关卡存起：
	1. 若存档有主线最后一关的关卡数据则：
		1. 将所有存档内没有的（没有通关过）支线关卡第一关存入将要解锁的关卡表
	2. 将所有存档内没有的关卡，根据关卡范围（逻辑同上）将下一关索引存入将要解锁的关卡表
		1. 同时将下一关索引存入 `ud.new_level`

### [三] 向地图增加关卡入口
1. 加载 `kr-desktop/data.map_points` 模块并将对应表分别存入：
	`screen_map.map_points.points / flags / endless_flags`
2. 调用 `self:show_flags` 函数（续承自父类 `MapView`）显示关卡旗帜：
	1. **调用 `self:load_level_decos` 函数加载并创建地图装饰 `kr-desktop/data.map_data.map_decos`**
	2. 将有 `trigger_level` 键的装饰返回到 `self.level_decos` 中
	3. 根据 `GS.last_level` 设定最大关卡数
	4. **遍历存档中通关的关卡**
		1. 根据 `screen_map.map_points.points` 表创建旗帜之间的连接点（续承自 `KImageView`）
		2. **创建已通关的关卡的旗帜（续承自 `LevelFlagView`）**
		3. 根据存档内战役、英雄、钢铁通关状态为旗帜设定不同样式
		4. 创建无尽模式旗帜（续承自 `EndlessLevelFlagView`）
		5. **若是首次创建的旗帜则根据不同情况播放动画**：
			1. 若关卡索引等于 `ud.show_stars_level` 则播放显示星星动画
			2. 若通过钢铁模式 `ud.iron_level` 则播放通过钢铁模式的动画
			3. 若通过英雄模式 `ud.heroic_level` 则播放通过英雄模式的动画
			4. 显示对应关卡的地图装饰（`trigger_level`）
			5. 播放连接新解锁（`ud.new_level`）的关卡的连接动画（旗帜之间的连接点）
			6. 播放所有将要解锁的关卡表的关卡（`ud.unlocked_levels`）的插入旗帜动画

