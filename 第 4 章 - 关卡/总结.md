# (一) 路径操作函数
以下是所有函数的表格，表头为“函数”，函数形式参数使用中文描述：

| <center>**作用（距离为节点距离）**</center>                       | <center>函数</center>                                           |
| ------------------------------------------------------ | ------------------------------------------------------------- |
| **返回路径宽度**                                             | `P:path_width(路径, 子路径, 节点)`                                   |
| **返回节点坐标**                                             | `P:node_pos(路径, 子路径, 节点, 是否返回引用)`                             |
| **返回偏移后节点坐标**                                          | `P:node_offset_pos(偏移量, 路径, 子路径, 节点)`                         |
| **返回起点的节点**                                            | `P:get_start_node(路径)`                                        |
| **返回可见终点的节点**                                          | `P:get_visible_end_node(路径)`                                  |
| **返回可见起点的节点**                                          | `P:get_visible_start_node(路径)`                                |
| **返回终点的节点**                                            | `P:get_end_node(路径)`                                          |
| **返回防守点的节点**                                           | `P:get_defend_point_node(路径)`                                 |
| **返回节点到起点距离**                                          | `P:nodes_from_start(路径, 子路径, 节点)`                             |
| **返回节点到终点距离**                                          | `P:nodes_to_goal(路径, 子路径, 节点)`                                |
| **返回节点到防守点距离**                                         | `P:nodes_to_defend_point(路径, 子路径, 节点)`                        |
| **判断一定距离是否存在节点**                                       | `P:point_within_distance(x, y, 距离)`                           |
| **返回一个根据距离排序的表：<br>子表包含附近所有节点的<br>所在路径、子路径、节点、<br>距离** | `P:nearest_nodes(x, y, 路径表, 子路径表, 是否仅有效节点, 标签, 过滤函数, 步长)`     |
| **返回地形类型**                                             | `P:path_terrain_types(路径)`                                    |
| **返回地形属性**                                             | `P:path_terrain_props(路径)`                                    |
| **判断路径是否激活**                                           | `P:is_path_active(路径)`                                        |
| **激活路径**                                               | `P:activate_path(路径)`                                         |
| **关闭路径**                                               | `P:deactivate_path(路径)`                                       |
| **增加无效节点范围**                                           | `P:add_invalid_range(路径, 从, 到, 标签)`                           |
| **移除无效节点范围**                                           | `P:remove_invalid_range(路径, 从, 到)`                            |
| **判断节点是否有效**                                           | `P:is_node_valid(路径, 节点, 标签)`                                 |
| **返回所有有效节点**                                           | `P:get_valid_nodes(路径, 标签)`                                   |
| **返回第一个找到的有效节点**                                       | `P:find_valid_node(路径, 开始节点, 步长, 标签)`                         |
| **判断附近有没有有效节点**                                        | `P:valid_node_nearby(x, y, 路径宽度乘数, 标签)`                       |
| **返回随机节点的坐标、<br>节点所在路径、子路径、<br>节点**                    | `P:get_random_position(边距, 地形标签, 标签, 边距是否相当于防御点)`             |
| **返回连接的下一路径**                                          | `P:get_next_pi(路径)`                                           |
| **返回所有连接的路径**                                          | `P:get_connected_paths(路径)`                                   |
| **查找首个有效节点**                                           | `P:get_all_valid_pos(x, y, 最小距离, 最大距离, 地形标签, 过滤函数, 标签, 子路径表)` |
| **获取路径宽度**                                             | `P:nodes_as_list(标签)`                                         |

# (二) 相关逻辑
## 一、关卡加载逻辑
### [一] 进入关卡
1. 点击开始战斗按钮
2. 调用 `screen_map:start_level` 函数
3. **回调 `director:item_done_callback` 函数：**
		1. 将 `director.next_item_name` 键赋值为 `"game"`
4. 调用 `director:update` 函数：
	1. 调用 `director:queue_load_item_named` 函数：
		1. 根据 `next_item_name` 键在 `kr-desktop/data/director_data.item_props` 的 `src` 决定进入的界面
			1. 进入 `game` 界面
			2. 加载模块 `game` 并存入 `director.queued_item` 内
	2. **调用 `director.queued_item.init` 函数（`game:init`）初始化**

### [二] 调用 `sys.level:init` 函数进行初始化
1. 调用 `GR:load`（`all/grid_db`）函数加载网格数据
2. 调用 `P:load`（`all/path_db`）函数加载路径数据
3. 调用 `W:load`（`all/wave_db`）函数加载波次数据
4. **若有 `level:init` 关卡初始化函数则调用进行初始化**
5. **若有关卡参数则调用 `LU.insert_entities` 创建关卡参数内的实体**
6. 根据波次数据设定初始金币
7. 根据模式设定初始生命

### [三] 在驱动函数调用关卡更新函数 `sys.level:on_update`
1. **若有 `store.level.update` 关卡更新函数则调用其**
2. **调用 `LU.insert_hero` 函数插入英雄**
3. **若生命小于 1 （失败）则：**
	1. 将结果、关卡索引、模式、难度存入 `store.game_outcome`
	2. 将存档 `last_victory` 键赋值为 `nil`
	3. 保存英雄经验（调用 `store_hero_xp` 函数）
	4. 无尽模式则将最高分数写入存档
4. **若关卡完成、所有波次已释放、敌人全部死亡（胜利）则：**
	1. 根据血量计算星星
	2. 将结果、模式、关卡索引、星星数量等存入 `store.game_outcome` 以及存档的 `last_victory` 表中
	3. 保存英雄经验

## 二、关卡退出逻辑
### [一] 退出：
1. 点击退出按钮：胜利和暂停界面的退出
2. 调用 `game_gui:go_to_map` 函数：
	1. 保存英雄经验
	2. 停止所有音效
	3. **回调 `director:item_done_callback` 函数：**
		1. 将 `director.next_item_name` 键赋值为 `"map"`
3. 调用 `director:update` 函数：
	1. 调用 `director:queue_load_item_named` 函数：
		1. 根据 `next_item_name` 键在 `kr-desktop/data/director_data.item_props` 的 `src` 决定进入的界面
			1. 进入 `screen_map` 界面
			2. 加载模块 `screen_map` 并存入 `director.queued_item` 内
	2. **调用 `director.queued_item.init` 函数（`screen_map:init`）重新初始化**

### [二] 调用 `screen_map:init` 函数初始化
1. **若存档中有 `last_victory` 键且存档没有对应关卡模式的通关数据（存档的 `levels` 键）则根据关卡模式进行：**
	1. **战役：调用 `U.find_next_level_in_ranges` 函数将 `ud.new_level` 赋值为下一个关卡的索引：**
		1. 遍历 `GS.level_ranges` 关卡范围，根据不同条件进行：
		2. 若一个范围内的 `list` 键为 `true` （表示这个范围是无序的）且通关的关卡索引包含在内则直接返回范围中的下一个关卡的索引
			1. 或通关的关卡索引等于最大范围，返回下一个范围表的第一个键
		3. 若通关的关卡索引在一个范围区间内则直接返回通关的关卡索引 + 1
			1. 或通关的关卡索引等于最大范围，返回下一个范围表的第一个键
	2. 将存档内所对应的关卡的键初始化（`= {}`）
	3. 将下一个关卡的索引存入将要解锁的关卡表
	4. 若存档有对应关卡的战役数据且通关获得的星星大于此前获得的星星则：
		1. 将 `ud.show_stars_level` 赋值为通关的关卡索引
		2. 将 `ud.star_count_before` 赋值为通关获得的星星
		3. 将通关获得的星星重新赋值给存档对应关卡数据的星星键
	5. **英雄与钢铁：分别将 `ud.heroic_level` 与 `ud.iron_level` 赋值为通关关卡索引**
	注：`screen.unlock_data` 缩写为 `ud`
2. 调用 `U.unlock_next_levels_in_ranges` 函数将将要解锁的关卡存起：
	1. 若存档有主线最后一关的关卡数据则：
		1. 将所有存档内没有的（没有通关过）支线关卡第一关存入将要解锁的关卡表
	2. 将所有存档内没有的关卡，根据关卡范围（逻辑同上）将下一关索引存入将要解锁的关卡表
		1. 同时将下一关索引存入 `ud.new_level`

### [三] 向地图增加关卡入口
1. 加载 `kr-desktop/data.map_points` 模块并将对应表分别存入：
	`screen_map.map_points.points / flags / endless_flags`
2. 调用 `self:show_flags` 函数（续承自父类 `MapView`）显示关卡旗帜：
	1. **调用 `self:load_level_decos` 函数加载并创建地图装饰 `kr-desktop/data.map_data.map_decos`**
	2. 将有 `trigger_level` 键的装饰返回到 `self.level_decos` 中
	3. 根据 `GS.last_level` 设定最大关卡数
	4. **遍历存档中通关的关卡**
		1. 根据 `screen_map.map_points.points` 表创建旗帜之间的连接点（续承自 `KImageView`）
		2. **创建已通关的关卡的旗帜（续承自 `LevelFlagView`）**
		3. 根据存档内战役、英雄、钢铁通关状态为旗帜设定不同样式
		4. 创建无尽模式旗帜（续承自 `EndlessLevelFlagView`）
		5. **若是首次创建的旗帜则根据不同情况播放动画**：
			1. 若关卡索引等于 `ud.show_stars_level` 则播放显示星星动画
			2. 若通过钢铁模式 `ud.iron_level` 则播放通过钢铁模式的动画
			3. 若通过英雄模式 `ud.heroic_level` 则播放通过英雄模式的动画
			4. 显示对应关卡的地图装饰（`trigger_level`）
			5. 播放连接新解锁（`ud.new_level`）的关卡的连接动画（旗帜之间的连接点）
			6. 播放所有将要解锁的关卡表的关卡（`ud.unlocked_levels`）的插入旗帜动画

## 三、生成怪物逻辑
### [一] 调用 `W:load` 函数加载波次数据
1. 将波次数据存入 `W.db`

### [二] 敌人生成初始化
1. 调用 `sys.wave_spawn:init` 函数
	1. 若游戏模式为无尽则最大波次 `store.wave_group_total` 赋值为 0
	2. 非无尽根据波次数据的波次数量决定（`W:groups_count`）
	3. **创建波次线协程 `store.wave_spawn_thread`**
		1. 调用 `W:get_group` 获得 `W.db.groups` 对应波次的数据
		2. 若为第一波则调用 `game_gui.wave_notification_handler` 函数显示消息
		3. **若没有主动释放第一波则循环挂起协程**
		4. 若下一波没有到来（`interval`），没有跳过这一波则循环挂起协程
		5. **若主动释放下一波则调用 `game_gui.early_wave_called_handler` 函数处理释放非第一波波次**
			 1. 无尽模式额外增加分数
			 2. 调用对应能力的 `early_wave_bonus` 函数给予玩家奖励（减冷却）
		6. **调用 `game_gui.next_wave_sent_handler` 函数处理释放波次**
			1. 隐藏释放波次按钮
			2. 调用 `game_gui.unlock_user_power_handler` 函数解锁对应技能
		7. 显示消息
		8. **创建协程，延迟 `delay` 一定时间，返回并调用生成敌人函数**
			1. 协程返回到 `store.waves_active`
			2. 生成敌人就是简单的遍历表生成敌人，不进行赘叙详细请查看 `sys.spawner` 函数
		9. **这一波敌人生成完毕后 `i += 1` 标志进入下一波**
路径中：
2. `ni` 为节点索引（**node index**），即一条路径中的位置
3. `pi` 为路径索引（**path index**），即不同路径
4. `spi` 为子路径索引（**subpath index**），即路径中的三个分支
![[Pasted image 20250812125430.png]]
如图所示一条路径有三条子路径，白点为节点

## 四、路径加载逻辑
### [一] 加载路径
1. 加载关卡路径数据并存入 `P:paths`
2. `P:set_start_node` 与 `P:set_end_node` 函数设定起点与终点节点，存入 `P:path_start_node` 与 `P:set_end_node`

### [二] 终点更新
1. 在驱动函数调用 `sys.goal_line:on_update` 函数
2. 若具有 `nav_path` 键的敌人到达终点（`nav_path.ni >= P:path_end_node`）则：
	1. 将生命减去敌人的 `enemy.lives_cost`，并移除这个敌人


## 五、网格加载逻辑
1. 加载关卡网格数据，并存入 `GR.grid`
2. `GR.ox` 网格中心点 x 轴
3. `GR.oy` 网格中心点 y 轴
4. `GR.grid_w` 所有网格总长度
5. `GR.grid_h` 所有网格总宽度

# 关卡编号
## 一代

| **<center>编号</center>** | <center>描述</center> |
| ----------------------- | ------------------- |
| **1-12**                | 主线                  |
| **13**                  | 蜘蛛支线                |
| **14**                  | 兽人支线                |
| **15**                  | 沼泽支线                |
| **16-17**               | 强盗支线                |
| **18-19**               | 巨魔支线                |
| **20-21**               | 恶魔支线                |
| **22**                  | 蘑菇人支线               |
| **23-26**               | 万圣节支线               |

## 二代

| **<center>编号</center>** | <center>描述</center> |
| ----------------------- | ------------------- |
| **1-15**                | 主线                  |
| **16-18**               | 海战支线                |
| **19-21**               | 万圣节支线               |
| **22**                  | 蜥蜴人支线               |
## 三代
 
| <center>编号</center> | <center>描述</center> |
| ------------------- | ------------------- |
| **1-15**            | 主线                  |
| **16-18**           | 食人魔支线               |
| **19-20**           | 暮光支线                |
| **21-22**           | 矮人支线                |

## 四代

|  编号   | 描述    |
| :---: | ----- |
|   **0**   | 教程关   |
| **1-16**  | 主线    |
| **17-19** | 青蛙支线  |
| **20-22** | 冰川支线  |
| **23-25** | 天朝支线  |
| **26-28** | 万圣节支线 |
| **29-31** | 原始支线  |
| **32-36** | 沙漠支线  |
| **37-41** | 海盗支线  |

## 五代

| <center>编号</center> | <center>描述</center> |
| ------------------- | ------------------- |
| **1-16**            | 主线                  |
| **17-19**           | 灵魂支线                |
| **20-22**           | 鳄鱼支线                |
| **23-27**           | 矮人支线                |
| **28-30**           | 蜘蛛支线                |
| **31-35**           | 悟空支线                |
