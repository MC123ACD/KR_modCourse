# 关卡数据
关卡中所有数据存储于 `kr/data/levels` 中

**其中**：
1. 无后缀为关卡的函数
2. `_data` 为关卡参数
3. `_paths` 为路径数据
4. `_gird` 为网格数据

## 结构：
- `locked_hero` 是否锁定英雄
- `max_upgrade_level` 防御塔最大等级
- `entities_list` 进入关卡创建的实体
	- 实体 1：
		- `template` 创建的实体
		- `pos` 创建位置
		- 修改实体表...
	- 实体 2...
- `level_mode_overrides` 不同模式的差异：
	- 战役模式
	- 英雄模式
	- 钢铁模式
- `required_sounds` 加载的音效资源
- `required_textures` 加载的贴图与动画资源

# 波次数据
波次的所有数据存储于 `kr/data/waves` 中

**其中**：
1. `_campaign` 为战役模式
2. `_heroic` 为英雄模式
3. `_iron` 为钢铁模式

## 结构：
注：时间单位为游戏帧
- `cash` 初始金币
- `live` 无尽模式生命
- `groups` 波次：
	- **第一波：**
		- `interval` 下一波到来时间
		- `waves`
			- **第一组出怪：**
				- `delay` 这组出怪延迟
				- `path_index` 出怪路径
				- `spawns` 出怪顺序数量等
					- **怪物 1：**
						- `interval` 出怪间隔
						- `creep` 怪物，填实体模板
						- `creep_aux` 交替的怪物，每次出一定怪后交替出这个怪
						- `max_same` 每次交替出怪数量
						- `max` 总数量
						- `fixed_sub_path` 出怪子路径，0 为随机
						- `path` 指定出怪子路径后将子路径索引修改为此键值
						- `interval_next` 下一个出怪的延迟
					- **怪物 2...**
			- **第二组出怪...**
	- **第二波...**

# 路径
路径中：
2. `ni` 为节点索引（**node index**），即一条路径中的位置
3. `pi` 为路径索引（**path index**），即不同路径
4. `spi` 为子路径索引（**subpath index**），即路径中的三个分支
![[Pasted image 20250812125430.png]]
如图所示一条路径有三条子路径，白点为节点

# 修改出怪
##### 1. 写出怪
由于出怪的表不易于查看修改，推荐使用附件的波次生成脚本修改
![[Pasted image 20250828164236.png|750]]
- 所有出怪组都是并发的，使用出怪组延迟控制
- 出怪组一般用于多个怪物组合进攻与进攻不同路径
- 交替出怪用于两个怪物轮流进攻
- 每个组的怪物只有前一个出完才会出下一个

##### 2. 修改完毕保存：
![[Pasted image 20250828164839.png|550]]
数字改成你修改的关卡编号，然后直接替换波次数据即可

##### 3 . 加载资源
没有加载对应怪的资源将会导致怪物透明

在关卡数据的 `required_textures` 键增加对应资源即可
```lua
required_textures = {
	"go_enemies...",
	...
}
```
图像资源基本都在 `_assets/kr-desktop/images/fullhd` 内

注：有些实体的资源在关卡资源内

# 随机在路径上召唤实体
在 `level_data` 的 `entities_list` 增加一个实体，在这个实体更新函数写召唤逻辑即可

##### 示例：
```lua
-- 模板
tt = RT("s_spawner_entities")
AC(tt, "main_script", "editor")
tt.main_script.update = scripts.s_spawner_entities.update
tt.ts = 0

tt.entity = "enemy_halloween_zombie"	-- 召唤实体
tt.spawn_margin = {
	["start"] = 30,	-- 距离起点边距
	["end"] = 60	-- 距离终点边距
}
tt.spawn_cooldown = 3	-- 召唤间隔
tt.spawn_count = 1	-- 召唤数量
tt.spawn_wave = 1	-- 开始召唤的波次
tt.spawn_path = {
	pi = {	-- 生成的路径
		1,
		2,
		5
	},
	spi = {	-- 生成的子路径
		1,
		2,
		3
	}
}
tt.ani = "raise"	-- 召唤后实体的动画，需要有相应动画，`idle` 为凭空出现
tt.enemy_gold = 0.5	-- 召唤的敌人赏金乘数

-- 函数
scripts.s_spawner_entities = {}
function scripts.s_spawner_entities.update(this, store)
	local pi, spi, ni
	local p_pi, p_spi = this.spawn_path["pi"], this.spawn_path["spi"]
	local margin = this.spawn_margin

	while true do
		if this.interrupt then
			break
		end

		-- 计算召唤间隔
		if store.wave_group_number >= this.spawn_wave and this.spawn_cooldown < store.tick_ts - this.ts then
			this.ts = store.tick_ts
			for i = 1, this.spawn_count do
				-- 取随机路径上随机节点
				pi, spi = p_pi[math.random(p_pi[1], #p_pi)], p_spi[math.random(p_spi[1], #p_spi)]
				ni = math.random(P:get_start_node(pi) + margin["start"], P:get_end_node(pi) - margin["end"])
				pos = P:node_pos(pi, spi, ni)

				-- 召唤实体
				local e = E:create_entity(this.entity)
				e.pos, e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = pos, pi, spi, ni
				e.render.sprites[1].name = this.ani
				e.enemy.gold = e.enemy.gold * this.enemy_gold
				queue_insert(store, e)
			end
		end
		
		coroutine.yield()
	end
	
	queue_remove(store, this)
end

-- 关卡数据
entities_list = {
	{
		template = "s_spawner_entities",	-- 关卡开始时召唤
		pos = {	-- 位置随便填
			x = 0,
			y = 0
		}
	},
	...
}
```

