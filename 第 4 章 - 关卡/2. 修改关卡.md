# 关卡数据
关卡中所有数据存储于 `kr/data/levels` 中

**其中**：
1. 无后缀为关卡的函数
2. `_data` 为关卡参数
3. `_paths` 为路径数据
4. `_gird` 为网格数据

## 结构：
```lua
locked_hero = bool,			-- 是否锁定英雄
max_upgrade_level = int,	-- 科技最大等级
locked_towers = {			-- 锁定的防御塔
	防御塔模板名 1: str,
	-- 防御塔模板名 2...
},
available_towers = {		-- 可用的防御塔（五代可用）
	防御塔模板名 1: str,
	-- 防御塔模板名 2...
},
locked_powers {				-- 锁定的能力
	是否锁定对应索引的能力: bool
},
entities_list = {			-- 进入关卡创建的实体
	{		-- 实体 1
		template = str,		-- 创建的实体模板名
		pos = vec2,			-- 实体位置
		
	},
	-- 实体 2...
},
level_mode_overrides = {	-- 不同模式覆盖的键（战役模式索引为 1、英雄为 2、钢铁为 3）
	{},		-- 战役模式
	{		-- 英雄模式
		max_upgrade_level = 2	-- 英雄模式下科技最大等级 2
	}
},
required_sounds = {			-- 加载的音效资源
	资源 1 名称: str,
	-- 资源 2 名称...
},
required_textures = {		-- 加载的美术资源
	资源 1 名称: str,
	-- 资源 2 名称...
}
required_exoskeletons = {	-- 加载的骨骼动画资源
	资源 1 名称: str,
	-- 资源 2 名称...
}
```

# 路径
路径中：
2. `ni` 为节点索引（**node index**），即一条路径中的位置
3. `pi` 为路径索引（**path index**），即不同路径
4. `spi` 为子路径索引（**subpath index**），即路径中的三个分支
![[Pasted image 20250812125430.png]]
如图所示一条路径有三条子路径，白点为节点

# 随机在路径上召唤实体
在 `level_data` 的 `entities_list` 增加一个实体，在这个实体更新函数写召唤逻辑即可

##### 示例：
```lua
-- 模板
tt = RT("s_spawner_entities")
AC(tt, "main_script", "editor")
tt.main_script.update = scripts.s_spawner_entities.update
tt.ts = 0

tt.entity = "enemy_halloween_zombie"	-- 召唤实体
tt.spawn_margin = {
	["start"] = 30,	-- 距离起点边距
	["end"] = 60	-- 距离终点边距
}
tt.spawn_cooldown = 3	-- 召唤间隔
tt.spawn_count = 1	-- 召唤数量
tt.spawn_wave = 1	-- 开始召唤的波次
tt.spawn_path = {
	pi = {	-- 生成的路径
		1,
		2,
		5
	},
	spi = {	-- 生成的子路径
		1,
		2,
		3
	}
}
tt.ani = "raise"	-- 召唤后实体的动画，需要有相应动画，`idle` 为凭空出现
tt.enemy_gold = 0.5	-- 召唤的敌人赏金乘数

-- 函数
scripts.s_spawner_entities = {}
function scripts.s_spawner_entities.update(this, store)
	local pi, spi, ni
	local p_pi, p_spi = this.spawn_path["pi"], this.spawn_path["spi"]
	local margin = this.spawn_margin

	while true do
		if this.interrupt then
			break
		end

		-- 计算召唤间隔
		if store.wave_group_number >= this.spawn_wave and this.spawn_cooldown < store.tick_ts - this.ts then
			this.ts = store.tick_ts
			for i = 1, this.spawn_count do
				-- 取随机路径上随机节点
				pi, spi = p_pi[math.random(p_pi[1], #p_pi)], p_spi[math.random(p_spi[1], #p_spi)]
				ni = math.random(P:get_start_node(pi) + margin["start"], P:get_end_node(pi) - margin["end"])
				pos = P:node_pos(pi, spi, ni)

				-- 召唤实体
				local e = E:create_entity(this.entity)
				e.pos, e.nav_path.pi, e.nav_path.spi, e.nav_path.ni = pos, pi, spi, ni
				e.render.sprites[1].name = this.ani
				e.enemy.gold = e.enemy.gold * this.enemy_gold
				queue_insert(store, e)
			end
		end
		
		coroutine.yield()
	end
	
	queue_remove(store, this)
end

-- 关卡数据
entities_list = {
	{
		template = "s_spawner_entities",	-- 关卡开始时召唤
		pos = {	-- 位置随便填
			x = 0,
			y = 0
		}
	},
	...
}
```

